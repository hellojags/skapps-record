/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/base32-encode/index.js":
/*!*********************************************!*\
  !*** ./node_modules/base32-encode/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toDataView = __webpack_require__(/*! to-data-view */ "./node_modules/to-data-view/index.js")

var RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
var RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
var CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

module.exports = function base32Encode (data, variant, options) {
  options = options || {}
  var alphabet, defaultPadding

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  var padding = (options.padding !== undefined ? options.padding : defaultPadding)
  var view = toDataView(data)

  var bits = 0
  var value = 0
  var output = ''

  for (var i = 0; i < view.byteLength; i++) {
    value = (value << 8) | view.getUint8(i)
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/blakejs/blake2b.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2b.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = __webpack_require__(/*! ./util */ "./node_modules/blakejs/util.js")

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  var o0 = v[a] + v[b]
  var o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  var o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  var o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return (arr[i] ^
  (arr[i + 1] << 8) ^
  (arr[i + 2] << 16) ^
  (arr[i + 3] << 24))
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  var x0 = m[ix]
  var x1 = m[ix + 1]
  var y0 = m[iy]
  var y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  var xor0 = v[d] ^ v[a]
  var xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,
  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,
  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,
  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19
])

var SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32)
var m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  var i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function blake2bInit (outlen, key) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }

  // state, 'param block'
  var ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize hash state
  for (var i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i]
  }
  var keylen = key ? key.length : 0
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2b (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2bInit(outlen, key)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2bHex (input, key, outlen) {
  var output = blake2b(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}


/***/ }),

/***/ "./node_modules/blakejs/blake2s.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2s.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// BLAKE2s hash function in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = __webpack_require__(/*! ./util */ "./node_modules/blakejs/util.js")

// Little-endian byte access.
// Expects a Uint8Array and an index
// Returns the little-endian uint32 at v[i..i+3]
function B2S_GET32 (v, i) {
  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
}

// Mixing function G.
function B2S_G (a, b, c, d, x, y) {
  v[a] = v[a] + v[b] + x
  v[d] = ROTR32(v[d] ^ v[a], 16)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 12)
  v[a] = v[a] + v[b] + y
  v[d] = ROTR32(v[d] ^ v[a], 8)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 7)
}

// 32-bit right rotation
// x should be a uint32
// y must be between 1 and 31, inclusive
function ROTR32 (x, y) {
  return (x >>> y) ^ (x << (32 - y))
}

// Initialization Vector.
var BLAKE2S_IV = new Uint32Array([
  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19])

var SIGMA = new Uint8Array([
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])

// Compression function. "last" flag indicates last block
var v = new Uint32Array(16)
var m = new Uint32Array(16)
function blake2sCompress (ctx, last) {
  var i = 0
  for (i = 0; i < 8; i++) { // init work variables
    v[i] = ctx.h[i]
    v[i + 8] = BLAKE2S_IV[i]
  }

  v[12] ^= ctx.t // low 32 bits of offset
  v[13] ^= (ctx.t / 0x100000000) // high 32 bits
  if (last) { // last block flag set ?
    v[14] = ~v[14]
  }

  for (i = 0; i < 16; i++) { // get little-endian words
    m[i] = B2S_GET32(ctx.b, 4 * i)
  }

  // ten rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 32)
  for (i = 0; i < 10; i++) {
    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])
    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])
    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])
    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])
    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])
    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])
    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])
    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])
  }
  // util.debugPrint('   (i=10) v[16]', v, 32)

  for (i = 0; i < 8; i++) {
    ctx.h[i] ^= v[i] ^ v[i + 8]
  }
  // util.debugPrint('h[8]', ctx.h, 32)
}

// Creates a BLAKE2s hashing context
// Requires an output length between 1 and 32 bytes
// Takes an optional Uint8Array key
function blake2sInit (outlen, key) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error('Incorrect output length, should be in [1, 32]')
  }
  var keylen = key ? key.length : 0
  if (key && !(keylen > 0 && keylen <= 32)) {
    throw new Error('Incorrect key length, should be in [1, 32]')
  }

  var ctx = {
    h: new Uint32Array(BLAKE2S_IV), // hash state
    b: new Uint32Array(64), // input block
    c: 0, // pointer within block
    t: 0, // input count
    outlen: outlen // output length in bytes
  }
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  if (keylen > 0) {
    blake2sUpdate(ctx, key)
    ctx.c = 64 // at the end
  }

  return ctx
}

// Updates a BLAKE2s streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2sUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 64) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2sCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2s streaming hash
// Returns a Uint8Array containing the message digest
function blake2sFinal (ctx) {
  ctx.t += ctx.c // mark last block offset
  while (ctx.c < 64) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2sCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xFF
  }
  return out
}

// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2s (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 32
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2sInit(outlen, key)
  blake2sUpdate(ctx, input)
  return blake2sFinal(ctx)
}

// Computes the BLAKE2S hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2sHex (input, key, outlen) {
  var output = blake2s(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2s: blake2s,
  blake2sHex: blake2sHex,
  blake2sInit: blake2sInit,
  blake2sUpdate: blake2sUpdate,
  blake2sFinal: blake2sFinal
}


/***/ }),

/***/ "./node_modules/blakejs/index.js":
/*!***************************************!*\
  !*** ./node_modules/blakejs/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var b2b = __webpack_require__(/*! ./blake2b */ "./node_modules/blakejs/blake2b.js")
var b2s = __webpack_require__(/*! ./blake2s */ "./node_modules/blakejs/blake2s.js")

module.exports = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
}


/***/ }),

/***/ "./node_modules/blakejs/util.js":
/*!**************************************!*\
  !*** ./node_modules/blakejs/util.js ***!
  \**************************************/
/***/ ((module) => {

var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  var ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (input instanceof Buffer) {
    ret = new Uint8Array(input)
  } else if (typeof (input) === 'string') {
    ret = new Uint8Array(Buffer.from(input, 'utf8'))
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map.call(bytes, function (n) {
    return (n < 16 ? '0' : '') + n.toString(16)
  }).join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  var msg = '\n' + label + ' = '
  for (var i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  var startMs = new Date().getTime()

  var input = new Uint8Array(N)
  for (var i = 0; i < N; i++) {
    input[i] = i % 256
  }
  var genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (i = 0; i < M; i++) {
    var hashHex = hashFn(input)
    var hashMs = new Date().getTime()
    var ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND')
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "./node_modules/post-me/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/post-me/dist/index.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ChildHandshake = ChildHandshake;
  _exports.DebugMessenger = DebugMessenger;
  _exports.ParentHandshake = ParentHandshake;
  _exports.debug = debug;
  _exports.WorkerMessenger = _exports.WindowMessenger = _exports.PortMessenger = _exports.ConcreteEmitter = _exports.BareMessenger = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var MARKER = '@post-me';

  function createUniqueIdFn() {
    var __id = 0;
    return function () {
      var id = __id;
      __id += 1;
      return id;
    };
  }
  /**
   * A concrete implementation of the {@link Emitter} interface
   *
   * @public
   */


  var ConcreteEmitter = /*#__PURE__*/function () {
    function ConcreteEmitter() {
      _classCallCheck(this, ConcreteEmitter);

      this._listeners = {};
    }
    /** {@inheritDoc Emitter.addEventListener} */


    _createClass(ConcreteEmitter, [{
      key: "addEventListener",
      value: function addEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          listeners = new Set();
          this._listeners[eventName] = listeners;
        }

        listeners.add(listener);
      }
      /** {@inheritDoc Emitter.removeEventListener} */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners["delete"](listener);
      }
      /** {@inheritDoc Emitter.once} */

    }, {
      key: "once",
      value: function once(eventName) {
        var _this = this;

        return new Promise(function (resolve) {
          var listener = function listener(data) {
            _this.removeEventListener(eventName, listener);

            resolve(data);
          };

          _this.addEventListener(eventName, listener);
        });
      }
      /** @internal */

    }, {
      key: "emit",
      value: function emit(eventName, data) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners.forEach(function (listener) {
          listener(data);
        });
      }
      /** @internal */

    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        Object.values(this._listeners).forEach(function (listeners) {
          if (listeners) {
            listeners.clear();
          }
        });
      }
    }]);

    return ConcreteEmitter;
  }();

  _exports.ConcreteEmitter = ConcreteEmitter;
  var MessageType;

  (function (MessageType) {
    MessageType["HandshakeRequest"] = "handshake-request";
    MessageType["HandshakeResponse"] = "handshake-response";
    MessageType["Call"] = "call";
    MessageType["Response"] = "response";
    MessageType["Error"] = "error";
    MessageType["Event"] = "event";
    MessageType["Callback"] = "callback";
  })(MessageType || (MessageType = {})); // Message Creators


  function createHandshakeRequestMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeRequest,
      sessionId: sessionId
    };
  }

  function createHandshakeResponseMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeResponse,
      sessionId: sessionId
    };
  }

  function createCallMessage(sessionId, requestId, methodName, args) {
    return {
      type: MARKER,
      action: MessageType.Call,
      sessionId: sessionId,
      requestId: requestId,
      methodName: methodName,
      args: args
    };
  }

  function createResponsMessage(sessionId, requestId, result, error) {
    var message = {
      type: MARKER,
      action: MessageType.Response,
      sessionId: sessionId,
      requestId: requestId
    };

    if (result !== undefined) {
      message.result = result;
    }

    if (error !== undefined) {
      message.error = error;
    }

    return message;
  }

  function createCallbackMessage(sessionId, requestId, callbackId, args) {
    return {
      type: MARKER,
      action: MessageType.Callback,
      sessionId: sessionId,
      requestId: requestId,
      callbackId: callbackId,
      args: args
    };
  }

  function createEventMessage(sessionId, eventName, payload) {
    return {
      type: MARKER,
      action: MessageType.Event,
      sessionId: sessionId,
      eventName: eventName,
      payload: payload
    };
  } // Type Guards


  function isMessage(m) {
    return m && m.type === MARKER;
  }

  function isHandshakeRequestMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeRequest;
  }

  function isHandshakeResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeResponse;
  }

  function isCallMessage(m) {
    return isMessage(m) && m.action === MessageType.Call;
  }

  function isResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.Response;
  }

  function isCallbackMessage(m) {
    return isMessage(m) && m.action === MessageType.Callback;
  }

  function isEventMessage(m) {
    return isMessage(m) && m.action === MessageType.Event;
  }

  function makeCallbackEvent(requestId) {
    return "callback_".concat(requestId);
  }

  function makeResponseEvent(requestId) {
    return "response_".concat(requestId);
  }

  var Dispatcher = /*#__PURE__*/function (_ConcreteEmitter) {
    _inherits(Dispatcher, _ConcreteEmitter);

    var _super = _createSuper(Dispatcher);

    function Dispatcher(messenger, sessionId) {
      var _this2;

      _classCallCheck(this, Dispatcher);

      _this2 = _super.call(this);
      _this2.uniqueId = createUniqueIdFn();
      _this2.messenger = messenger;
      _this2.sessionId = sessionId;
      _this2.removeMessengerListener = _this2.messenger.addMessageListener(_this2.messengerListener.bind(_assertThisInitialized(_this2)));
      return _this2;
    }

    _createClass(Dispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isCallMessage(data)) {
          this.emit(MessageType.Call, data);
        } else if (isResponseMessage(data)) {
          this.emit(makeResponseEvent(data.requestId), data);
        } else if (isEventMessage(data)) {
          this.emit(MessageType.Event, data);
        } else if (isCallbackMessage(data)) {
          this.emit(makeCallbackEvent(data.requestId), data);
        }
      }
    }, {
      key: "callOnRemote",
      value: function callOnRemote(methodName, args, transfer) {
        var requestId = this.uniqueId();
        var callbackEvent = makeCallbackEvent(requestId);
        var responseEvent = makeResponseEvent(requestId);
        var message = createCallMessage(this.sessionId, requestId, methodName, args);
        this.messenger.postMessage(message, transfer);
        return {
          callbackEvent: callbackEvent,
          responseEvent: responseEvent
        };
      }
    }, {
      key: "respondToRemote",
      value: function respondToRemote(requestId, value, error, transfer) {
        if (error instanceof Error) {
          error = {
            name: error.name,
            message: error.message
          };
        }

        var message = createResponsMessage(this.sessionId, requestId, value, error);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "callbackToRemote",
      value: function callbackToRemote(requestId, callbackId, args) {
        var message = createCallbackMessage(this.sessionId, requestId, callbackId, args);
        this.messenger.postMessage(message);
      }
    }, {
      key: "emitToRemote",
      value: function emitToRemote(eventName, payload, transfer) {
        var message = createEventMessage(this.sessionId, eventName, payload);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return Dispatcher;
  }(ConcreteEmitter);

  var ParentHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter2) {
    _inherits(ParentHandshakeDispatcher, _ConcreteEmitter2);

    var _super2 = _createSuper(ParentHandshakeDispatcher);

    function ParentHandshakeDispatcher(messenger, sessionId) {
      var _this3;

      _classCallCheck(this, ParentHandshakeDispatcher);

      _this3 = _super2.call(this);
      _this3.messenger = messenger;
      _this3.sessionId = sessionId;
      _this3.removeMessengerListener = _this3.messenger.addMessageListener(_this3.messengerListener.bind(_assertThisInitialized(_this3)));
      return _this3;
    }

    _createClass(ParentHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isHandshakeResponseMessage(data)) {
          this.emit(data.sessionId, data);
        }
      }
    }, {
      key: "initiateHandshake",
      value: function initiateHandshake() {
        var message = createHandshakeRequestMessage(this.sessionId);
        this.messenger.postMessage(message);
        return this.sessionId;
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ParentHandshakeDispatcher;
  }(ConcreteEmitter);

  var ChildHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter3) {
    _inherits(ChildHandshakeDispatcher, _ConcreteEmitter3);

    var _super3 = _createSuper(ChildHandshakeDispatcher);

    function ChildHandshakeDispatcher(messenger) {
      var _this4;

      _classCallCheck(this, ChildHandshakeDispatcher);

      _this4 = _super3.call(this);
      _this4.messenger = messenger;
      _this4.removeMessengerListener = _this4.messenger.addMessageListener(_this4.messengerListener.bind(_assertThisInitialized(_this4)));
      return _this4;
    }

    _createClass(ChildHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (isHandshakeRequestMessage(data)) {
          this.emit(MessageType.HandshakeRequest, data);
        }
      }
    }, {
      key: "acceptHandshake",
      value: function acceptHandshake(sessionId) {
        var message = createHandshakeResponseMessage(sessionId);
        this.messenger.postMessage(message);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ChildHandshakeDispatcher;
  }(ConcreteEmitter);

  var ProxyType;

  (function (ProxyType) {
    ProxyType["Callback"] = "callback";
  })(ProxyType || (ProxyType = {}));

  function createCallbackProxy(callbackId) {
    return {
      type: MARKER,
      proxy: ProxyType.Callback,
      callbackId: callbackId
    };
  }

  function isCallbackProxy(p) {
    return p && p.type === MARKER && p.proxy === ProxyType.Callback;
  }

  var ConcreteRemoteHandle = /*#__PURE__*/function (_ConcreteEmitter4) {
    _inherits(ConcreteRemoteHandle, _ConcreteEmitter4);

    var _super4 = _createSuper(ConcreteRemoteHandle);

    function ConcreteRemoteHandle(dispatcher) {
      var _this5;

      _classCallCheck(this, ConcreteRemoteHandle);

      _this5 = _super4.call(this);
      _this5._dispatcher = dispatcher;
      _this5._callTransfer = {};

      _this5._dispatcher.addEventListener(MessageType.Event, _this5._handleEvent.bind(_assertThisInitialized(_this5)));

      return _this5;
    }

    _createClass(ConcreteRemoteHandle, [{
      key: "close",
      value: function close() {
        this.removeAllListeners();
      }
    }, {
      key: "setCallTransfer",
      value: function setCallTransfer(methodName, transfer) {
        this._callTransfer[methodName] = transfer;
      }
    }, {
      key: "call",
      value: function call(methodName) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return this.customCall(methodName, args);
      }
    }, {
      key: "customCall",
      value: function customCall(methodName, args) {
        var _this6 = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return new Promise(function (resolve, reject) {
          var sanitizedArgs = [];
          var callbacks = [];
          var callbackId = 0;
          args.forEach(function (arg) {
            if (typeof arg === 'function') {
              callbacks.push(arg);
              sanitizedArgs.push(createCallbackProxy(callbackId));
              callbackId += 1;
            } else {
              sanitizedArgs.push(arg);
            }
          });
          var hasCallbacks = callbacks.length > 0;
          var callbackListener = undefined;

          if (hasCallbacks) {
            callbackListener = function callbackListener(data) {
              var callbackId = data.callbackId,
                  args = data.args;
              callbacks[callbackId].apply(callbacks, _toConsumableArray(args));
            };
          }

          var transfer = options.transfer;

          if (transfer === undefined && _this6._callTransfer[methodName]) {
            var _this6$_callTransfer;

            transfer = (_this6$_callTransfer = _this6._callTransfer)[methodName].apply(_this6$_callTransfer, sanitizedArgs);
          }

          var _this6$_dispatcher$ca = _this6._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer),
              callbackEvent = _this6$_dispatcher$ca.callbackEvent,
              responseEvent = _this6$_dispatcher$ca.responseEvent;

          if (hasCallbacks) {
            _this6._dispatcher.addEventListener(callbackEvent, callbackListener);
          }

          _this6._dispatcher.once(responseEvent).then(function (response) {
            if (callbackListener) {
              _this6._dispatcher.removeEventListener(callbackEvent, callbackListener);
            }

            var result = response.result,
                error = response.error;

            if (error !== undefined) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        });
      }
    }, {
      key: "_handleEvent",
      value: function _handleEvent(data) {
        var eventName = data.eventName,
            payload = data.payload;
        this.emit(eventName, payload);
      }
    }]);

    return ConcreteRemoteHandle;
  }(ConcreteEmitter);

  var ConcreteLocalHandle = /*#__PURE__*/function () {
    function ConcreteLocalHandle(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteLocalHandle);

      this._dispatcher = dispatcher;
      this._methods = localMethods;
      this._returnTransfer = {};
      this._emitTransfer = {};

      this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));
    }

    _createClass(ConcreteLocalHandle, [{
      key: "emit",
      value: function emit(eventName, payload) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var transfer = options.transfer;

        if (transfer === undefined && this._emitTransfer[eventName]) {
          transfer = this._emitTransfer[eventName](payload);
        }

        this._dispatcher.emitToRemote(eventName, payload, transfer);
      }
    }, {
      key: "setMethods",
      value: function setMethods(methods) {
        this._methods = methods;
      }
    }, {
      key: "setMethod",
      value: function setMethod(methodName, method) {
        this._methods[methodName] = method;
      }
    }, {
      key: "setReturnTransfer",
      value: function setReturnTransfer(methodName, transfer) {
        this._returnTransfer[methodName] = transfer;
      }
    }, {
      key: "setEmitTransfer",
      value: function setEmitTransfer(eventName, transfer) {
        this._emitTransfer[eventName] = transfer;
      }
    }, {
      key: "_handleCall",
      value: function _handleCall(data) {
        var _this7 = this;

        var requestId = data.requestId,
            methodName = data.methodName,
            args = data.args;
        var callMethod = new Promise(function (resolve, reject) {
          var _this7$_methods;

          var method = _this7._methods[methodName];

          if (typeof method !== 'function') {
            reject(new Error("The method \"".concat(methodName, "\" has not been implemented.")));
            return;
          }

          var desanitizedArgs = args.map(function (arg) {
            if (isCallbackProxy(arg)) {
              var callbackId = arg.callbackId;
              return function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this7._dispatcher.callbackToRemote(requestId, callbackId, args);
              };
            } else {
              return arg;
            }
          });
          Promise.resolve((_this7$_methods = _this7._methods)[methodName].apply(_this7$_methods, _toConsumableArray(desanitizedArgs))).then(resolve)["catch"](reject);
        });
        callMethod.then(function (result) {
          var transfer;

          if (_this7._returnTransfer[methodName]) {
            transfer = _this7._returnTransfer[methodName](result);
          }

          _this7._dispatcher.respondToRemote(requestId, result, undefined, transfer);
        })["catch"](function (error) {
          _this7._dispatcher.respondToRemote(requestId, undefined, error);
        });
      }
    }]);

    return ConcreteLocalHandle;
  }();

  var ConcreteConnection = /*#__PURE__*/function () {
    function ConcreteConnection(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteConnection);

      this._dispatcher = dispatcher;
      this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);
      this._remoteHandle = new ConcreteRemoteHandle(dispatcher);
    }

    _createClass(ConcreteConnection, [{
      key: "close",
      value: function close() {
        this._dispatcher.close();

        this.remoteHandle().close();
      }
    }, {
      key: "localHandle",
      value: function localHandle() {
        return this._localHandle;
      }
    }, {
      key: "remoteHandle",
      value: function remoteHandle() {
        return this._remoteHandle;
      }
    }]);

    return ConcreteConnection;
  }();

  var uniqueSessionId = createUniqueIdFn();

  var runUntil = function runUntil(worker, condition, unfulfilled, maxAttempts, attemptInterval) {
    var attempt = 0;

    var fn = function fn() {
      if (!condition() && (attempt < maxAttempts || maxAttempts < 1)) {
        worker();
        attempt += 1;
        setTimeout(fn, attemptInterval);
      } else if (!condition() && attempt >= maxAttempts && maxAttempts >= 1) {
        unfulfilled();
      }
    };

    fn();
  };
  /**
   * Initiate the handshake from the Parent side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @param maxAttempts - The maximum number of handshake attempts
   * @param attemptsInterval - The interval between handshake attempts
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ParentHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
    var attemptsInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
    var thisSessionId = uniqueSessionId();
    var connected = false;
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ParentHandshakeDispatcher(messenger, thisSessionId);
      handshakeDispatcher.once(thisSessionId).then(function (response) {
        connected = true;
        handshakeDispatcher.close();
        var sessionId = response.sessionId;
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
      runUntil(function () {
        return handshakeDispatcher.initiateHandshake();
      }, function () {
        return connected;
      }, function () {
        return reject(new Error("Handshake failed, reached maximum number of attempts"));
      }, maxAttempts, attemptsInterval);
    });
  }
  /**
   * Initiate the handshake from the Child side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ChildHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ChildHandshakeDispatcher(messenger);
      handshakeDispatcher.once(MessageType.HandshakeRequest).then(function (response) {
        var sessionId = response.sessionId;
        handshakeDispatcher.acceptHandshake(sessionId);
        handshakeDispatcher.close();
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
    });
  }

  var acceptableMessageEvent = function acceptableMessageEvent(event, remoteWindow, acceptedOrigin) {
    var source = event.source,
        origin = event.origin;

    if (source !== remoteWindow) {
      return false;
    }

    if (origin !== acceptedOrigin && acceptedOrigin !== '*') {
      return false;
    }

    return true;
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with another Window.
   *
   * @public
   *
   */


  var WindowMessenger = function WindowMessenger(_ref) {
    var localWindow = _ref.localWindow,
        remoteWindow = _ref.remoteWindow,
        remoteOrigin = _ref.remoteOrigin;

    _classCallCheck(this, WindowMessenger);

    localWindow = localWindow || window;

    this.postMessage = function (message, transfer) {
      remoteWindow.postMessage(message, remoteOrigin, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        if (acceptableMessageEvent(event, remoteWindow, remoteOrigin)) {
          listener(event);
        }
      };

      localWindow.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        localWindow.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /** @public */


  _exports.WindowMessenger = WindowMessenger;

  var BareMessenger = function BareMessenger(postable) {
    _classCallCheck(this, BareMessenger);

    this.postMessage = function (message) {
      var transfer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      postable.postMessage(message, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        listener(event);
      };

      postable.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        postable.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a Worker.
   *
   * Takes a {@link Postable} representing the `Worker` (when calling from
   * the parent context) or the `self` `DedicatedWorkerGlobalScope` object
   * (when calling from the child context).
   *
   * @public
   *
   */


  _exports.BareMessenger = BareMessenger;

  var WorkerMessenger = /*#__PURE__*/function (_BareMessenger) {
    _inherits(WorkerMessenger, _BareMessenger);

    var _super5 = _createSuper(WorkerMessenger);

    function WorkerMessenger(_ref2) {
      var worker = _ref2.worker;

      _classCallCheck(this, WorkerMessenger);

      return _super5.call(this, worker);
    }

    return WorkerMessenger;
  }(BareMessenger);
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a MessagePort.
   *
   * @public
   *
   */


  _exports.WorkerMessenger = WorkerMessenger;

  var PortMessenger = /*#__PURE__*/function (_BareMessenger2) {
    _inherits(PortMessenger, _BareMessenger2);

    var _super6 = _createSuper(PortMessenger);

    function PortMessenger(_ref3) {
      var port = _ref3.port;

      _classCallCheck(this, PortMessenger);

      port.start();
      return _super6.call(this, port);
    }

    return PortMessenger;
  }(BareMessenger);
  /**
   * Create a logger function with a specific namespace
   *
   * @param namespace - The namespace will be prepended to all the arguments passed to the logger function
   * @param log - The underlying logger (`console.log` by default)
   *
   * @public
   *
   */


  _exports.PortMessenger = PortMessenger;

  function debug(namespace, log) {
    log = log || console.debug || console.log || function () {};

    return function () {
      for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        data[_key3] = arguments[_key3];
      }

      log.apply(void 0, [namespace].concat(data));
    };
  }
  /**
   * Decorate a {@link Messenger} so that it will log any message exchanged
   * @param messenger - The Messenger that will be decorated
   * @param log - The logger function that will receive each message
   * @returns A decorated Messenger
   *
   * @public
   *
   */


  function DebugMessenger(messenger, log) {
    log = log || debug('post-me');

    var debugListener = function debugListener(event) {
      var data = event.data;
      log('⬅️ received message', data);
    };

    messenger.addMessageListener(debugListener);
    return {
      postMessage: function postMessage(message, transfer) {
        log('➡️ sending message', message);
        messenger.postMessage(message, transfer);
      },
      addMessageListener: function addMessageListener(listener) {
        return messenger.addMessageListener(listener);
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sjcl/sjcl.js":
/*!***********************************!*\
  !*** ./node_modules/sjcl/sjcl.js ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid("invalid aes key size");this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100>e;e++)k[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g<<1^g<<2^g<<3^g<<4,m=m>>8^m&255^99,c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][m]=p=p<<24^p>>>8;for(e=
0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid("invalid aes block size");var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],x=h[4];for(m=0;m<n;m++)h=a[e>>>24]^q[f>>16&255]^v[g>>8&255]^w[b&255]^d[p],k=a[f>>>24]^q[g>>16&255]^v[b>>8&255]^w[e&255]^d[p+1],l=a[g>>>24]^q[b>>16&255]^v[e>>8&255]^w[f&255]^d[p+2],b=a[b>>>24]^q[e>>16&255]^v[f>>8&255]^w[g&255]^d[p+3],p+=4,e=h,f=k,g=l;for(m=
0;4>m;m++)r[c?3&-m:m]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b=b&31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]},byteswapM:function(a){var b,c;for(b=0;b<a.length;++b)c=a[b],a[b]=c>>>24|c>>>8&0xff00|(c&0xff00)<<8|c<<24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>8>>>8>>>8),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a=a+"00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",X:"0123456789ABCDEFGHIJKLMNOPQRSTUV",BITS:32,BASE:5,REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f="",g=0,h=sjcl.codec.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&&(h=sjcl.codec.base32.X);for(c=0;f.length*d<l;)f+=h.charAt((k^a[c]>>>g)>>>e),g<d?(k=a[c]<<d-g,g+=e,c++):(k<<=d,g-=d);for(;f.length&7&&!b;)f+="=";return f},toBits:function(a,b){a=a.replace(/\s|=/g,"").toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m="base32";b&&(k=sjcl.codec.base32.X,m="base32hex");for(g=0;g<a.length;g++){n=k.indexOf(a.charAt(g));if(0>n){if(!b)try{return sjcl.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid("this isn't "+m+"!");}h>e?(h-=e,f.push(l^n>>>h),l=n<<c-h):(h+=d,l^=n<<c-h)}h&56&&f.push(sjcl.bitArray.partial(h&56,l,1));return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32.toBits(a,1)}};
sjcl.codec.base64={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&&(f=f.substr(0,62)+"-_");for(c=0;6*d.length<h;)d+=f.charAt((g^a[c]>>>e)>>>26),6>e?(g=a[c]<<6-e,e+=26,c++):(g<<=6,e-=6);for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&&(f=f.substr(0,62)+"-_");for(d=0;d<a.length;d++){h=f.indexOf(a.charAt(d));
if(0>h)throw new sjcl.exception.invalid("this isn't base64!");26<e?(e-=26,c.push(g^h>>>e),g=h<<32-e):(e+=6,g^=h<<32-e)}e&56&&c.push(sjcl.bitArray.partial(e&56,g,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff<a)throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");if("undefined"!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,c.splice(0,16));return this},finalize:function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64>b;c++){e=!0;for(d=2;d*d<=c;d++)if(0===c%d){e=
!1;break}e&&(8>b&&(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64>c;c++)16>c?d=b[c]:(d=b[c+1&15],e=b[c+14&15],d=b[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+b[c&15]+b[c+9&15]|0),d=d+q+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(r^m&(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&l^n&(k^l))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:"ccm",G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl.mode.ccm.G.indexOf(a);-1<a&&sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c<b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e||64;d=d||[];if(7>k)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(f=2;4>f&&l>>>8*f;f++);f<15-k&&(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7>g)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(b=2;4>b&&h>>>8*b;b++);b<15-g&&(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal(k.tag,a))throw new sjcl.exception.corrupt("ccm: tag doesn't match");
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2<<2|f-1)];d=h.concat(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279>=c?g=[h.partial(16,c)]:0xffffffff>=c&&(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b<g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4>e||16<e)throw new sjcl.exception.invalid("ccm: invalid tag length");
if(0xffffffff<d.length||0xffffffff<b.length)throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d<b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g<k;g+=4)g>n&&(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m,p=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l(n,l(c,h(c))));
d.length&&(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");e=e||64;var g=sjcl.mode.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4<r/32;c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&&(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice(b,r)))throw new sjcl.exception.corrupt("ocb: tag doesn't match");return q.concat(h.clamp(m,p))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128>e.bitLength(c)&&(h=f(h,d(h)),c=e.concat(c,[-2147483648,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^135*(a[0]>>>31)]}};
sjcl.mode.gcm={name:"gcm",encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||128;d=d||[];e<=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))throw new sjcl.exception.corrupt("gcm: tag doesn't match");return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128>c;c++){(d=0!==(a[Math.floor(c/32)]&1<<31-c%32))&&(e=h(e,f));g=0!==(f[3]&1);for(d=3;0<d;d--)f[d]=f[d]>>>1|(f[d-1]&1)<<31;f[0]>>>=1;g&&(f[0]^=-0x1f000000)}return e},j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d<e;d+=4)b[0]^=0xffffffff&c[d],b[1]^=0xffffffff&c[d+1],b[2]^=0xffffffff&c[d+2],b[3]^=0xffffffff&c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math.floor(h/0x100000000),h&0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c));for(l=0;l<m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&&(d=sjcl.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&0xffffffff,Math.floor(p/0x100000000),p&0xffffffff];d=sjcl.mode.gcm.j(g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid("encrypt on already updated hmac called!");this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0>d||0>c)throw new sjcl.exception.invalid("invalid params to pbkdf2");"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length<(d||1);k++){e=f=a.encrypt(n.concat(b,[k]));for(g=1;g<c;g++)for(f=a.encrypt(f),h=0;h<f.length;h++)e[h]^=f[h];l=l.concat(e)}d&&(l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady("generator isn't seeded");if(d&this.J){d=!(d&this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this.da;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.c.length&&(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&1<<g));g++);this.P>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f>this.o&&(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4>d&&(this.h[d]=this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.ca&&y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b)throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");this.M=a},addEntropy:function(a,
b,c){c=c||"user";var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&&(d=this.U[c]=this.ha++);void 0===g&&(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case "number":void 0===b&&(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else for("[object Array]"!==c&&(k=1),c=0;c<a.length&&!k;c++)"number"!==typeof a[c]&&
(k=1);if(!k){if(void 0===b)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,e=e>>>1;this.c[g].update([d,this.N++,2,b,f,a.length].concat(a))}break;case "string":void 0===b&&(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.m[g]+=b;this.f+=b;h===this.u&&(this.isReady()!==this.u&&A("seeded",Math.max(this.o,this.f)),A("progress",this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&&this.o>=a?this.m[0]>this.ba&&(new Date).valueOf()>this.Z?this.J|this.I:this.I:this.f>=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o>=a?1:this.f>a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window.addEventListener)window.addEventListener("load",
this.a.loadTimeCollector,!1),window.addEventListener("mousemove",this.a.mouseCollector,!1),window.addEventListener("keypress",this.a.keyboardCollector,!1),window.addEventListener("devicemotion",this.a.accelerometerCollector,!1),window.addEventListener("touchmove",this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector);else throw new sjcl.exception.bug("can't attach event");
this.D=!0}},stopCollectors:function(){this.D&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,!1),window.removeEventListener("mousemove",this.a.mouseCollector,!1),window.removeEventListener("keypress",this.a.keyboardCollector,!1),window.removeEventListener("devicemotion",this.a.accelerometerCollector,!1),window.removeEventListener("touchmove",this.a.touchCollector,!1)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",
this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.D=!1)},addEventListener:function(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&&e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&&0!=c&&this.addEntropy([b,c],2,"mouse");C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,"touch");C(this,0)},ma:function(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&this.addEntropy(b,1,"accelerometer")}a&&this.addEntropy(a,2,"accelerometer");C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function C(a,b){"undefined"!==typeof window&&window.performance&&"function"===typeof window.performance.now?a.addEntropy(window.performance.now(),b,"loadtime"):a.addEntropy((new Date).valueOf(),b,"loadtime")}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4>b&&(a.h[b]=a.h[b]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G= true&&module.exports){var H;try{H=__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))}catch(a){H=null}G=E=H}if(G&&E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy(D,1024,"crypto['randomBytes']");else if("undefined"!==typeof window&&"undefined"!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(F);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,"crypto['getRandomValues']")}}catch(a){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},ja:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;"string"===typeof f.salt&&(f.salt=sjcl.codec.base64.toBits(f.salt));"string"===typeof f.iv&&(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||"string"===typeof a&&100>=f.iter||64!==f.ts&&96!==f.ts&&128!==f.ts||128!==f.ks&&192!==f.ks&&0x100!==f.ks||2>f.iv.length||
4<f.iv.length)throw new sjcl.exception.invalid("json encrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.publicKey&&(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));"string"===typeof c&&(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);d.key=a;f.ct="ccm"===f.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;"string"===typeof b.salt&&(b.salt=sjcl.codec.base64.toBits(b.salt));"string"===typeof b.iv&&(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||"string"===
typeof a&&100>=b.iter||64!==b.ts&&96!==b.ts&&128!==b.ts||128!==b.ks&&192!==b.ks&&0x100!==b.ks||!b.iv||2>b.iv.length||4<b.iv.length)throw new sjcl.exception.invalid("json decrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.secretKey&&(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));"string"===typeof f&&(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f="ccm"===
b.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c="{",d="";for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid("json encode: invalid property name");c+=d+'"'+
b+'":';d=",";switch(typeof a[b]){case "number":case "boolean":c+=a[b];break;case "string":c+='"'+escape(a[b])+'"';break;case "object":c+='"'+sjcl.codec.base64.fromBits(a[b],0)+'"';break;default:throw new sjcl.exception.bug("json encode: unsupported type");}}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid("json decode: this isn't json!");a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++){if(!(d=a[c].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))throw new sjcl.exception.invalid("json decode: this isn't json!");
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4]):null!=d[5]&&(b[d[2]]="true"===d[5])}return b},g:function(a,b,c){void 0===a&&(a={});if(void 0===b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&&void 0!==a[d]&&a[d]!==b[d])throw new sjcl.exception.invalid("required parameter overridden");a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&&a[d]!==b[d]&&(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d<b.length;d++)void 0!==a[b[d]]&&(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
 true&&module.exports&&(module.exports=sjcl); true&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return sjcl}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/client.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkynetClient = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
const upload_1 = __webpack_require__(/*! ./upload */ "./node_modules/skynet-js/dist/cjs/upload.js");
const download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
const file_1 = __webpack_require__(/*! ./file */ "./node_modules/skynet-js/dist/cjs/file.js");
const skydb_1 = __webpack_require__(/*! ./skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const mysky_1 = __webpack_require__(/*! ./mysky */ "./node_modules/skynet-js/dist/cjs/mysky/index.js");
const utils_1 = __webpack_require__(/*! ./mysky/utils */ "./node_modules/skynet-js/dist/cjs/mysky/utils.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * The Skynet Client which can be used to access Skynet.
 */
class SkynetClient {
    /**
     * The Skynet Client which can be used to access Skynet.
     *
     * @class
     * @param [initialPortalUrl] The initial portal URL to use to access Skynet, if specified. A request will be made to this URL to get the actual portal URL. To use the default portal while passing custom options, pass "".
     * @param [customOptions] Configuration for the client.
     */
    constructor(initialPortalUrl = "", customOptions = {}) {
        // Set methods (defined in other files).
        // Upload
        this.uploadFile = upload_1.uploadFile;
        this.uploadFileRequest = upload_1.uploadFileRequest;
        this.uploadDirectory = upload_1.uploadDirectory;
        this.uploadDirectoryRequest = upload_1.uploadDirectoryRequest;
        // Download
        this.downloadFile = download_1.downloadFile;
        this.downloadFileHns = download_1.downloadFileHns;
        this.getSkylinkUrl = download_1.getSkylinkUrl;
        this.getHnsUrl = download_1.getHnsUrl;
        this.getHnsresUrl = download_1.getHnsresUrl;
        this.getMetadata = download_1.getMetadata;
        this.getFileContent = download_1.getFileContent;
        this.getFileContentHns = download_1.getFileContentHns;
        this.getFileContentRequest = download_1.getFileContentRequest;
        this.openFile = download_1.openFile;
        this.openFileHns = download_1.openFileHns;
        this.resolveHns = download_1.resolveHns;
        // MySky
        this.extractDomain = utils_1.extractDomain;
        this.getFullDomainUrl = utils_1.getFullDomainUrl;
        this.loadMySky = mysky_1.loadMySky;
        // File API
        this.file = {
            getJSON: file_1.getJSON.bind(this),
        };
        // SkyDB
        this.db = {
            getJSON: skydb_1.getJSON.bind(this),
            setJSON: skydb_1.setJSON.bind(this),
        };
        // SkyDB helpers
        this.registry = {
            getEntry: registry_1.getEntry.bind(this),
            getEntryUrl: registry_1.getEntryUrl.bind(this),
            getEntryLink: registry_1.getEntryLink.bind(this),
            setEntry: registry_1.setEntry.bind(this),
            postSignedEntry: registry_1.postSignedEntry.bind(this),
        };
        if (initialPortalUrl === "") {
            // Portal was not given, use the default portal URL. We'll still make a request for the resolved portal URL.
            initialPortalUrl = url_1.defaultPortalUrl();
        }
        else {
            // Portal was given, don't make the request for the resolved portal URL.
            this.givenPortalUrl = initialPortalUrl;
        }
        this.initialPortalUrl = initialPortalUrl;
        this.customOptions = customOptions;
    }
    /**
     * Make the request for the API portal URL.
     *
     * @returns - A promise that resolves when the request is complete.
     */
    /* istanbul ignore next */
    async initPortalUrl() {
        if (!SkynetClient.resolvedPortalUrl) {
            SkynetClient.resolvedPortalUrl = new Promise((resolve, reject) => {
                this.executeRequest({
                    ...this.customOptions,
                    method: "head",
                    url: this.initialPortalUrl,
                    endpointPath: "/",
                }).then((response) => {
                    if (typeof response.headers === "undefined") {
                        reject(new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists."));
                    }
                    const portalUrl = response.headers["skynet-portal-api"];
                    if (!portalUrl) {
                        reject(new Error("Could not get portal URL for the given portal"));
                    }
                    resolve(string_1.trimSuffix(portalUrl, "/"));
                });
            });
        }
        await SkynetClient.resolvedPortalUrl;
        return;
    }
    /**
     * Returns the API portal URL. Makes the request to get it if not done so already.
     *
     * @returns - the portal URL.
     */
    /* istanbul ignore next */
    async portalUrl() {
        if (this.givenPortalUrl) {
            return this.givenPortalUrl;
        }
        // Make the request if needed and not done so.
        this.initPortalUrl();
        return await SkynetClient.resolvedPortalUrl; // eslint-disable-line
    }
    /**
     * Creates and executes a request.
     *
     * @param config - Configuration for the request.
     * @returns - The response from axios.
     * @throws - Will throw if unimplemented options have been passed in.
     */
    async executeRequest(config) {
        var _a;
        // Build the URL.
        let url = config.url;
        if (!url) {
            const portalUrl = await this.portalUrl();
            url = url_1.makeUrl(portalUrl, config.endpointPath, (_a = config.extraPath) !== null && _a !== void 0 ? _a : "");
        }
        if (config.query) {
            url = url_1.addUrlQuery(url, config.query);
        }
        // Build headers.
        const headers = { ...config.headers };
        if (config.customUserAgent) {
            headers["User-Agent"] = config.customUserAgent;
        }
        if (config.customCookie) {
            headers["Cookie"] = config.customCookie;
        }
        const auth = config.APIKey ? { username: "", password: config.APIKey } : undefined;
        /* istanbul ignore next */
        const onUploadProgress = config.onUploadProgress &&
            function (event) {
                const progress = event.loaded / event.total;
                // Need the if-statement or TS complains.
                if (config.onUploadProgress)
                    config.onUploadProgress(progress, event);
            };
        return axios_1.default({
            url,
            method: config.method,
            data: config.data,
            headers,
            auth,
            onUploadProgress,
            transformRequest: config.transformRequest,
            transformResponse: config.transformResponse,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            // Allow cross-site cookies.
            withCredentials: true,
        });
    }
}
exports.SkynetClient = SkynetClient;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/crypto.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/crypto.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashRegistryEntry = exports.hashDataKey = exports.hashAll = exports.genKeyPairFromSeed = exports.genKeyPairAndSeed = exports.deriveChildSeed = void 0;
const sjcl_1 = __webpack_require__(/*! sjcl */ "./node_modules/sjcl/sjcl.js");
const blakejs_1 = __webpack_require__(/*! blakejs */ "./node_modules/blakejs/index.js");
const randombytes_1 = __importDefault(__webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js"));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const encoding_1 = __webpack_require__(/*! ./utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
/**
 * Returns a blake2b 256bit hasher. See `NewHash` in Sia.
 *
 * @returns - blake2b 256bit hasher.
 */
function newHash() {
    return blakejs_1.blake2bInit(32, null);
}
/**
 * Derives a child seed from the given master seed and sub seed.
 *
 * @param masterSeed - The master seed to derive from.
 * @param seed - The sub seed for the derivation.
 * @returns - The child seed derived from `masterSeed` using `seed`.
 * @throws - Will throw if the inputs are not strings.
 */
function deriveChildSeed(masterSeed, seed) {
    validation_1.validateString("masterSeed", masterSeed, "parameter");
    validation_1.validateString("seed", seed, "parameter");
    return string_1.toHexString(hashAll(encoding_1.encodeUtf8String(masterSeed), encoding_1.encodeUtf8String(seed)));
}
exports.deriveChildSeed = deriveChildSeed;
/**
 * Generates a master key pair and seed.
 *
 * @param [length=64] - The number of random bytes for the seed. Note that the string seed will be converted to hex representation, making it twice this length.
 * @returns - The generated key pair and seed.
 */
function genKeyPairAndSeed(length = 64) {
    validation_1.validateNumber("length", length, "parameter");
    const seed = makeSeed(length);
    return { ...genKeyPairFromSeed(seed), seed };
}
exports.genKeyPairAndSeed = genKeyPairAndSeed;
/**
 * Generates a public and private key from a provided, secure seed.
 *
 * @param seed - A secure seed.
 * @returns - The generated key pair.
 * @throws - Will throw if the input is not a string.
 */
function genKeyPairFromSeed(seed) {
    validation_1.validateString("seed", seed, "parameter");
    // Get a 32-byte key.
    const derivedKey = sjcl_1.misc.pbkdf2(seed, "", 1000, 32 * 8);
    const derivedKeyHex = sjcl_1.codec.hex.fromBits(derivedKey);
    const { publicKey, secretKey } = tweetnacl_1.sign.keyPair.fromSeed(string_1.hexToUint8Array(derivedKeyHex));
    return { publicKey: string_1.toHexString(publicKey), privateKey: string_1.toHexString(secretKey) };
}
exports.genKeyPairFromSeed = genKeyPairFromSeed;
/**
 * Takes all given arguments and hashes them.
 *
 * @param args - Byte arrays to hash.
 * @returns - The final hash as a byte array.
 */
function hashAll(...args) {
    const hasher = newHash();
    for (let i = 0; i < args.length; i++) {
        blakejs_1.blake2bUpdate(hasher, args[i]);
    }
    return blakejs_1.blake2bFinal(hasher);
}
exports.hashAll = hashAll;
/**
 * Hash the given data key.
 *
 * @param dataKey - Data key to hash.
 * @returns - Hash of the data key.
 */
function hashDataKey(dataKey) {
    return hashAll(encoding_1.encodeUtf8String(dataKey));
}
exports.hashDataKey = hashDataKey;
/**
 * Hashes the given registry entry.
 *
 * @param registryEntry - Registry entry to hash.
 * @param hashedDataKeyHex - Whether the data key is already hashed and in hex format. If not, we hash the data key.
 * @returns - Hash of the registry entry.
 */
function hashRegistryEntry(registryEntry, hashedDataKeyHex) {
    let dataKeyBytes;
    if (hashedDataKeyHex) {
        dataKeyBytes = string_1.hexToUint8Array(registryEntry.dataKey);
    }
    else {
        dataKeyBytes = hashDataKey(registryEntry.dataKey);
    }
    return hashAll(dataKeyBytes, encoding_1.encodeUtf8String(registryEntry.data), encoding_1.encodeBigintAsUint64(registryEntry.revision));
}
exports.hashRegistryEntry = hashRegistryEntry;
/**
 * Generates a random seed of the given length in bytes.
 *
 * @param length - Length of the seed in bytes.
 * @returns - The generated seed.
 */
function makeSeed(length) {
    // Cryptographically-secure random number generator. It should use the
    // built-in crypto.getRandomValues in the browser.
    const array = randombytes_1.default(length);
    return string_1.toHexString(array);
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/download.js":
/*!*****************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/download.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHns = exports.openFileHns = exports.openFile = exports.getFileContentRequest = exports.getFileContentHns = exports.getFileContent = exports.getMetadata = exports.getHnsresUrl = exports.getHnsUrl = exports.getSkylinkUrlForPortal = exports.getSkylinkUrl = exports.downloadFileHns = exports.downloadFile = exports.defaultDownloadOptions = void 0;
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
const parse_1 = __webpack_require__(/*! ./skylink/parse */ "./node_modules/skynet-js/dist/cjs/skylink/parse.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultDownloadOptions = {
    ...options_1.defaultBaseOptions,
    endpointDownload: "/",
    download: false,
    noResponseMetadata: false,
    path: undefined,
    query: undefined,
    subdomain: false,
};
const defaultDownloadHnsOptions = {
    ...exports.defaultDownloadOptions,
    endpointDownloadHns: "hns",
    hnsSubdomain: "hns",
};
const defaultResolveHnsOptions = {
    ...options_1.defaultBaseOptions,
    endpointDownloadHnsres: "hnsres",
};
/**
 * Initiates a download of the content of the skylink within the browser.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - 46-character skylink, or a valid skylink URL. Can be followed by a path. Note that the skylink will not be encoded, so if your path might contain special characters, consider using `customOptions.path`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function downloadFile(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions, download: true };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    // Download the url.
    window.location.assign(url);
    return url;
}
exports.downloadFile = downloadFile;
/**
 * Initiates a download of the content of the skylink at the Handshake domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the input domain is not a string.
 */
async function downloadFileHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions, download: true };
    const url = await this.getHnsUrl(domain, opts);
    // Download the url.
    window.location.assign(url);
    return url;
}
exports.downloadFileHns = downloadFileHns;
/**
 * Constructs the full URL for the given skylink.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getSkylinkUrl(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrlForPortal`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const portalUrl = await this.portalUrl();
    return getSkylinkUrlForPortal(portalUrl, skylinkUrl, opts);
}
exports.getSkylinkUrl = getSkylinkUrl;
/**
 * Gets the skylink URL without an initialized client.
 *
 * @param portalUrl - The portal URL.
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full URL for the skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
function getSkylinkUrlForPortal(portalUrl, skylinkUrl, customOptions) {
    var _a, _b;
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("skylinkUrl", skylinkUrl, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultDownloadOptions);
    const opts = { ...exports.defaultDownloadOptions, ...customOptions };
    const query = (_a = opts.query) !== null && _a !== void 0 ? _a : {};
    if (opts.download) {
        // Set the "attachment" parameter.
        query.attachment = true;
    }
    if (opts.noResponseMetadata) {
        // Set the "no-response-metadata" parameter.
        query["no-response-metadata"] = true;
    }
    // URL-encode the path.
    let path = "";
    if (opts.path) {
        if (typeof opts.path !== "string") {
            throw new Error(`opts.path has to be a string, ${typeof opts.path} provided`);
        }
        // Encode each element of the path separately and join them.
        //
        // Don't use encodeURI because it does not encode characters such as '?'
        // etc. These are allowed as filenames on Skynet and should be encoded so
        // they are not treated as URL separators.
        path = opts.path
            .split("/")
            .map((element) => encodeURIComponent(element))
            .join("/");
    }
    let url;
    if (opts.subdomain) {
        // Get the path from the skylink. Use the empty string if not found.
        const skylinkPath = (_b = parse_1.parseSkylink(skylinkUrl, { onlyPath: true })) !== null && _b !== void 0 ? _b : "";
        // Get just the skylink.
        let skylink = parse_1.parseSkylink(skylinkUrl);
        if (skylink === null) {
            throw new Error(`Could not get skylink out of input '${skylinkUrl}'`);
        }
        // Convert the skylink (without the path) to base32.
        skylink = format_1.convertSkylinkToBase32(skylink);
        url = url_1.addSubdomain(portalUrl, skylink);
        url = url_1.makeUrl(url, skylinkPath, path);
    }
    else {
        // Get the skylink including the path.
        const skylink = parse_1.parseSkylink(skylinkUrl, { includePath: true });
        if (skylink === null) {
            throw new Error(`Could not get skylink with path out of input '${skylinkUrl}'`);
        }
        // Add additional path if passed in.
        url = url_1.makeUrl(portalUrl, opts.endpointDownload, skylink, path);
    }
    return url_1.addUrlQuery(url, query);
}
exports.getSkylinkUrlForPortal = getSkylinkUrlForPortal;
/**
 * Constructs the full URL for the given HNS domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the HNS domain.
 * @throws - Will throw if the input domain is not a string.
 */
async function getHnsUrl(domain, customOptions) {
    var _a;
    validation_1.validateString("domain", domain, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultDownloadHnsOptions);
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const query = (_a = opts.query) !== null && _a !== void 0 ? _a : {};
    if (opts.download) {
        query.attachment = true;
    }
    if (opts.noResponseMetadata) {
        query["no-response-metadata"] = true;
    }
    domain = string_1.trimUriPrefix(domain, url_1.uriHandshakePrefix);
    const portalUrl = await this.portalUrl();
    const url = opts.subdomain
        ? url_1.addSubdomain(url_1.addSubdomain(portalUrl, opts.hnsSubdomain), domain)
        : url_1.makeUrl(portalUrl, opts.endpointDownloadHns, domain);
    return url_1.addUrlQuery(url, query);
}
exports.getHnsUrl = getHnsUrl;
/**
 * Constructs the full URL for the resolver for the given HNS domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/hnsres"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the resolver for the HNS domain.
 * @throws - Will throw if the input domain is not a string.
 */
async function getHnsresUrl(domain, customOptions) {
    validation_1.validateString("domain", domain, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultResolveHnsOptions);
    const opts = { ...defaultResolveHnsOptions, ...this.customOptions, ...customOptions };
    domain = string_1.trimUriPrefix(domain, url_1.uriHandshakeResolverPrefix);
    const portalUrl = await this.portalUrl();
    return url_1.makeUrl(portalUrl, opts.endpointDownloadHnsres, domain);
}
exports.getHnsresUrl = getHnsresUrl;
/**
 * Gets only the metadata for the given skylink without the contents.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFile` for the full list.
 * @param [customOptions.endpointPath="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The metadata in JSON format. Empty if no metadata was found.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getMetadata(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    var _a, _b;
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointDownload,
        method: "head",
        url,
    });
    if (typeof response.headers === "undefined") {
        throw new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    const contentType = (_a = response.headers["content-type"]) !== null && _a !== void 0 ? _a : "";
    const metadata = response.headers["skynet-file-metadata"] ? JSON.parse(response.headers["skynet-file-metadata"]) : {};
    const portalUrl = (_b = response.headers["skynet-portal-api"]) !== null && _b !== void 0 ? _b : "";
    const skylink = response.headers["skynet-skylink"] ? format_1.formatSkylink(response.headers["skynet-skylink"]) : "";
    return { contentType, metadata, portalUrl, skylink };
}
exports.getMetadata = getMetadata;
/**
 * Gets the contents of the file at the given skylink.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getFileContent(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    return this.getFileContentRequest(url, opts);
}
exports.getFileContent = getFileContent;
/**
 * Gets the contents of the file at the given Handshake domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the domain does not contain a skylink.
 */
async function getFileContentHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsUrl(domain, opts);
    return this.getFileContentRequest(url, opts);
}
exports.getFileContentHns = getFileContentHns;
/**
 * Does a GET request of the skylink, returning the data property of the response.
 *
 * @param this - SkynetClient
 * @param url - URL.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the request does not succeed or the response is missing data.
 */
async function getFileContentRequest(url, customOptions) {
    // Not publicly available, don't validate input.
    var _a, _b;
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    // GET request the data at the skylink.
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointDownload,
        method: "get",
        url,
    });
    if (typeof response.data === "undefined") {
        throw new Error("Did not get 'data' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    if (typeof response.headers === "undefined") {
        throw new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    const contentType = (_a = response.headers["content-type"]) !== null && _a !== void 0 ? _a : "";
    const metadata = response.headers["skynet-file-metadata"] ? JSON.parse(response.headers["skynet-file-metadata"]) : {};
    const portalUrl = (_b = response.headers["skynet-portal-api"]) !== null && _b !== void 0 ? _b : "";
    const skylink = response.headers["skynet-skylink"] ? format_1.formatSkylink(response.headers["skynet-skylink"]) : "";
    return { data: response.data, contentType, portalUrl, metadata, skylink };
}
exports.getFileContentRequest = getFileContentRequest;
/**
 * Opens the content of the skylink within the browser.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFile` for the full list.
 * @param [customOptions.endpointPath="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function openFile(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    window.open(url, "_blank");
    return url;
}
exports.openFile = openFile;
/**
 * Opens the content of the skylink from the given Handshake domain within the browser.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFileHns` for the full list.
 * @param [customOptions.endpointPath="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the input domain is not a string.
 */
async function openFileHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsUrl(domain, opts);
    // Open the url in a new tab.
    window.open(url, "_blank");
    return url;
}
exports.openFileHns = openFileHns;
/**
 * Resolves the given HNS domain to its TXT record and returns the data.
 *
 * @param this - SkynetClient
 * @param domain - Handshake resolver domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/hnsres"] - The relative URL path of the portal endpoint to contact.
 * @returns - The data for the TXT record.
 * @throws - Will throw if the input domain is not a string.
 */
async function resolveHns(domain, customOptions) {
    // Validation is done in `getHnsresUrl`.
    const opts = { ...defaultResolveHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsresUrl(domain, opts);
    // Get the txt record from the hnsres domain on the portal.
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointDownloadHnsres,
        method: "get",
        url,
    });
    validateResolveHnsResponse(response);
    return response.data;
}
exports.resolveHns = resolveHns;
function validateResolveHnsResponse(response) {
    try {
        if (!response.data) {
            throw new Error("response.data field missing");
        }
        validation_1.validateString("response.data.skylink", response.data.skylink, "upload response field");
    }
    catch (err) {
        throw new Error(`Did not get a complete resolve HNS response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/file.js":
/*!*************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/file.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJSON = void 0;
const tweak_1 = __webpack_require__(/*! ./mysky/tweak */ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js");
const skydb_1 = __webpack_require__(/*! ./skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
async function getJSON(userID, path, customOptions) {
    validation_1.validateString("userID", userID, "parameter");
    validation_1.validateString("path", path, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultGetJSONOptions);
    const opts = {
        ...skydb_1.defaultGetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const dataKey = tweak_1.deriveDiscoverableTweak(path);
    opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
    return await this.db.getJSON(userID, dataKey, opts);
}
exports.getJSON = getJSON;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermLegacySkyID = exports.PermDiscoverable = exports.PermHidden = exports.PermWrite = exports.PermRead = exports.PermType = exports.PermCategory = exports.Permission = exports.mySkyDevDomain = exports.mySkyDomain = exports.DacLibrary = exports.uriSkynetPrefix = exports.uriHandshakeResolverPrefix = exports.uriHandshakePrefix = exports.getFullDomainUrlForPortal = exports.extractDomainForPortal = exports.defaultSkynetPortalUrl = exports.defaultPortalUrl = exports.parseSkylink = exports.convertSkylinkToBase32 = exports.MAX_REVISION = exports.getRootDirectory = exports.getRelativeFilePath = exports.signEntry = exports.getEntryUrlForPortal = exports.getSkylinkUrlForPortal = exports.genKeyPairFromSeed = exports.genKeyPairAndSeed = exports.deriveChildSeed = exports.SkynetClient = void 0;
var client_1 = __webpack_require__(/*! ./client */ "./node_modules/skynet-js/dist/cjs/client.js");
Object.defineProperty(exports, "SkynetClient", ({ enumerable: true, get: function () { return client_1.SkynetClient; } }));
var crypto_1 = __webpack_require__(/*! ./crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
Object.defineProperty(exports, "deriveChildSeed", ({ enumerable: true, get: function () { return crypto_1.deriveChildSeed; } }));
Object.defineProperty(exports, "genKeyPairAndSeed", ({ enumerable: true, get: function () { return crypto_1.genKeyPairAndSeed; } }));
Object.defineProperty(exports, "genKeyPairFromSeed", ({ enumerable: true, get: function () { return crypto_1.genKeyPairFromSeed; } }));
var download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
Object.defineProperty(exports, "getSkylinkUrlForPortal", ({ enumerable: true, get: function () { return download_1.getSkylinkUrlForPortal; } }));
var registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
Object.defineProperty(exports, "getEntryUrlForPortal", ({ enumerable: true, get: function () { return registry_1.getEntryUrlForPortal; } }));
Object.defineProperty(exports, "signEntry", ({ enumerable: true, get: function () { return registry_1.signEntry; } }));
var file_1 = __webpack_require__(/*! ./utils/file */ "./node_modules/skynet-js/dist/cjs/utils/file.js");
Object.defineProperty(exports, "getRelativeFilePath", ({ enumerable: true, get: function () { return file_1.getRelativeFilePath; } }));
Object.defineProperty(exports, "getRootDirectory", ({ enumerable: true, get: function () { return file_1.getRootDirectory; } }));
var number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
Object.defineProperty(exports, "MAX_REVISION", ({ enumerable: true, get: function () { return number_1.MAX_REVISION; } }));
var format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
Object.defineProperty(exports, "convertSkylinkToBase32", ({ enumerable: true, get: function () { return format_1.convertSkylinkToBase32; } }));
var parse_1 = __webpack_require__(/*! ./skylink/parse */ "./node_modules/skynet-js/dist/cjs/skylink/parse.js");
Object.defineProperty(exports, "parseSkylink", ({ enumerable: true, get: function () { return parse_1.parseSkylink; } }));
var url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
Object.defineProperty(exports, "defaultPortalUrl", ({ enumerable: true, get: function () { return url_1.defaultPortalUrl; } }));
Object.defineProperty(exports, "defaultSkynetPortalUrl", ({ enumerable: true, get: function () { return url_1.defaultSkynetPortalUrl; } }));
Object.defineProperty(exports, "extractDomainForPortal", ({ enumerable: true, get: function () { return url_1.extractDomainForPortal; } }));
Object.defineProperty(exports, "getFullDomainUrlForPortal", ({ enumerable: true, get: function () { return url_1.getFullDomainUrlForPortal; } }));
Object.defineProperty(exports, "uriHandshakePrefix", ({ enumerable: true, get: function () { return url_1.uriHandshakePrefix; } }));
Object.defineProperty(exports, "uriHandshakeResolverPrefix", ({ enumerable: true, get: function () { return url_1.uriHandshakeResolverPrefix; } }));
Object.defineProperty(exports, "uriSkynetPrefix", ({ enumerable: true, get: function () { return url_1.uriSkynetPrefix; } }));
var mysky_1 = __webpack_require__(/*! ./mysky */ "./node_modules/skynet-js/dist/cjs/mysky/index.js");
Object.defineProperty(exports, "DacLibrary", ({ enumerable: true, get: function () { return mysky_1.DacLibrary; } }));
Object.defineProperty(exports, "mySkyDomain", ({ enumerable: true, get: function () { return mysky_1.mySkyDomain; } }));
Object.defineProperty(exports, "mySkyDevDomain", ({ enumerable: true, get: function () { return mysky_1.mySkyDevDomain; } }));
// Re-export Permissions.
var skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-mysky-utils/dist/index.js");
Object.defineProperty(exports, "Permission", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.Permission; } }));
Object.defineProperty(exports, "PermCategory", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermCategory; } }));
Object.defineProperty(exports, "PermType", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermType; } }));
Object.defineProperty(exports, "PermRead", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermRead; } }));
Object.defineProperty(exports, "PermWrite", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermWrite; } }));
Object.defineProperty(exports, "PermHidden", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermHidden; } }));
Object.defineProperty(exports, "PermDiscoverable", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermDiscoverable; } }));
Object.defineProperty(exports, "PermLegacySkyID", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermLegacySkyID; } }));


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/connector.js":
/*!************************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/connector.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Connector = exports.defaultConnectorOptions = void 0;
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/post-me/dist/index.js");
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-mysky-utils/dist/index.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
exports.defaultConnectorOptions = {
    dev: false,
    debug: false,
    alpha: false,
    handshakeMaxAttempts: skynet_mysky_utils_1.defaultHandshakeMaxAttempts,
    handshakeAttemptsInterval: skynet_mysky_utils_1.defaultHandshakeAttemptsInterval,
};
class Connector {
    constructor(url, client, childFrame, connection, options) {
        this.url = url;
        this.client = client;
        this.childFrame = childFrame;
        this.connection = connection;
        this.options = options;
    }
    // Static initializer
    static async init(client, domain, customOptions) {
        const opts = { ...exports.defaultConnectorOptions, ...customOptions };
        // Get the URL for the domain on the current portal.
        let domainUrl = await client.getFullDomainUrl(domain);
        if (opts.dev) {
            domainUrl = url_1.addUrlQuery(domainUrl, { dev: "true" });
        }
        if (opts.debug) {
            domainUrl = url_1.addUrlQuery(domainUrl, { debug: "true" });
        }
        if (opts.alpha) {
            domainUrl = url_1.addUrlQuery(domainUrl, { alpha: "true" });
        }
        // Create the iframe.
        const childFrame = skynet_mysky_utils_1.createIframe(domainUrl, domainUrl);
        const childWindow = childFrame.contentWindow;
        // Connect to the iframe.
        const messenger = new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: childWindow,
            remoteOrigin: "*",
        });
        const connection = await post_me_1.ParentHandshake(messenger, {}, opts.handshakeMaxAttempts, opts.handshakeAttemptsInterval);
        // Construct the component connector.
        return new Connector(domainUrl, client, childFrame, connection, opts);
    }
    async call(method, ...args) {
        return this.connection.remoteHandle().call(method, ...args);
    }
}
exports.Connector = Connector;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/dac.js":
/*!******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/dac.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DacLibrary = void 0;
const connector_1 = __webpack_require__(/*! ./connector */ "./node_modules/skynet-js/dist/cjs/mysky/connector.js");
class DacLibrary {
    constructor(dacDomain) {
        this.dacDomain = dacDomain;
    }
    async init(client, customOptions) {
        this.connector = await connector_1.Connector.init(client, this.dacDomain, customOptions);
        await this.connector.connection.remoteHandle().call("init");
    }
    onUserLogin() {
        if (!this.connector) {
            throw new Error("init was not called");
        }
        this.connector.connection.remoteHandle().call("onUserLogin");
    }
}
exports.DacLibrary = DacLibrary;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/index.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MySky = exports.loadMySky = exports.mySkyAlphaDomain = exports.mySkyDevDomain = exports.mySkyDomain = exports.DacLibrary = void 0;
var dac_1 = __webpack_require__(/*! ./dac */ "./node_modules/skynet-js/dist/cjs/mysky/dac.js");
Object.defineProperty(exports, "DacLibrary", ({ enumerable: true, get: function () { return dac_1.DacLibrary; } }));
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/post-me/dist/index.js");
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-mysky-utils/dist/index.js");
const connector_1 = __webpack_require__(/*! ./connector */ "./node_modules/skynet-js/dist/cjs/mysky/connector.js");
const registry_1 = __webpack_require__(/*! ../registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const skydb_1 = __webpack_require__(/*! ../skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const tweak_1 = __webpack_require__(/*! ./tweak */ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/dist/cjs/mysky/utils.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const options_1 = __webpack_require__(/*! ../utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
exports.mySkyDomain = "skynet-mysky.hns";
exports.mySkyDevDomain = "skynet-mysky-dev.hns";
exports.mySkyAlphaDomain = "sandbridge.hns";
const mySkyUiRelativeUrl = "ui.html";
const mySkyUiTitle = "MySky UI";
const [mySkyUiW, mySkyUiH] = [600, 600];
async function loadMySky(skappDomain, customOptions) {
    const mySky = await MySky.New(this, skappDomain, customOptions);
    return mySky;
}
exports.loadMySky = loadMySky;
class MySky {
    // ============
    // Constructors
    // ============
    constructor(connector, permissions, hostDomain) {
        this.connector = connector;
        this.hostDomain = hostDomain;
        this.dacs = [];
        this.grantedPermissions = [];
        this.pendingPermissions = permissions;
    }
    static async New(client, skappDomain, customOptions) {
        const opts = { ...connector_1.defaultConnectorOptions, ...customOptions };
        // Enforce singleton.
        if (MySky.instance) {
            return MySky.instance;
        }
        let domain = exports.mySkyDomain;
        if (opts.alpha) {
            domain = exports.mySkyAlphaDomain;
        }
        else if (opts.dev) {
            domain = exports.mySkyDevDomain;
        }
        const connector = await connector_1.Connector.init(client, domain, customOptions);
        const hostDomain = await client.extractDomain(window.location.hostname);
        const permissions = [];
        if (skappDomain) {
            // TODO: Are these permissions correct?
            const perm1 = new skynet_mysky_utils_1.Permission(hostDomain, skappDomain, skynet_mysky_utils_1.PermCategory.Hidden, skynet_mysky_utils_1.PermType.Read);
            const perm2 = new skynet_mysky_utils_1.Permission(hostDomain, skappDomain, skynet_mysky_utils_1.PermCategory.Hidden, skynet_mysky_utils_1.PermType.Write);
            permissions.push(perm1, perm2);
        }
        MySky.instance = new MySky(connector, permissions, hostDomain);
        return MySky.instance;
    }
    // ==========
    // Public API
    // ==========
    /**
     * Loads the given DACs.
     */
    async loadDacs(...dacs) {
        const promises = [];
        for (const dac of dacs) {
            promises.push(this.loadDac(dac));
        }
        this.dacs.push(...dacs);
        await Promise.all(promises);
    }
    async addPermissions(...permissions) {
        this.pendingPermissions.push(...permissions);
    }
    async checkLogin() {
        const [seedFound, permissionsResponse] = await this.connector.connection.remoteHandle().call("checkLogin", this.pendingPermissions);
        // Save granted and failed permissions.
        const { grantedPermissions, failedPermissions } = permissionsResponse;
        this.grantedPermissions = grantedPermissions;
        this.pendingPermissions = failedPermissions;
        const loggedIn = seedFound && failedPermissions.length === 0;
        this.handleLogin(loggedIn);
        return loggedIn;
    }
    /**
     * Destroys the mysky connection by:
     *
     * 1. Destroying the connected DACs,
     *
     * 2. Closing the connection,
     *
     * 3. Closing the child iframe
     */
    async destroy() {
        // TODO: For all connected dacs, send a destroy call.
        // TODO: Delete all connected dacs.
        // Close the connection.
        this.connector.connection.close();
        // Close the child iframe.
        if (this.connector.childFrame) {
            this.connector.childFrame.parentNode.removeChild(this.connector.childFrame);
        }
    }
    async logout() {
        return await this.connector.connection.remoteHandle().call("logout");
    }
    async requestLoginAccess() {
        let uiWindow;
        let uiConnection;
        let seedFound = false;
        // Add error listener.
        const { promise: promiseError, controller: controllerError } = skynet_mysky_utils_1.monitorWindowError();
        // eslint-disable-next-line no-async-promise-executor
        const promise = new Promise(async (resolve, reject) => {
            // Make this promise run in the background and reject on window close or any errors.
            promiseError.catch((err) => {
                if (err === skynet_mysky_utils_1.errorWindowClosed) {
                    // Resolve without updating the pending permissions.
                    resolve();
                    return;
                }
                reject(err);
            });
            try {
                // Launch the UI.
                uiWindow = await this.launchUI();
                uiConnection = await this.connectUi(uiWindow);
                // Send the UI the list of required permissions.
                // TODO: This should be a dual-promise that also calls ping() on an interval and rejects if no response was found in a given amount of time.
                const [seedFoundResponse, permissionsResponse] = await uiConnection.remoteHandle().call("requestLoginAccess", this.pendingPermissions);
                seedFound = seedFoundResponse;
                // Save failed permissions.
                const { grantedPermissions, failedPermissions } = permissionsResponse;
                this.grantedPermissions = grantedPermissions;
                this.pendingPermissions = failedPermissions;
                resolve();
            }
            catch (err) {
                reject(err);
            }
        });
        await promise
            .catch((err) => {
            throw err;
        })
            .finally(() => {
            // Close the window.
            if (uiWindow) {
                uiWindow.close();
            }
            // Close the connection.
            if (uiConnection) {
                uiConnection.close();
            }
            // Clean up the event listeners and promises.
            controllerError.cleanup();
        });
        const loggedIn = seedFound && this.pendingPermissions.length === 0;
        this.handleLogin(loggedIn);
        return loggedIn;
    }
    async userID(opts) {
        return await this.connector.connection.remoteHandle().call("userID", opts);
    }
    /**
     * Gets Discoverable JSON at the given path through MySky, if the user has given permissions to do so.
     *
     * @param path - The data path.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An object containing the json data as well as the skylink for the data.
     */
    async getJSON(path, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultGetJSONOptions);
        const opts = {
            ...skydb_1.defaultGetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        return await this.connector.client.db.getJSON(publicKey, dataKey, opts);
    }
    /**
     * Gets the entry link for the entry at the given path. This is a v2 skylink.
     * This link stays the same even if the content at the entry changes.
     *
     * @param path - The data path.
     * @returns - The entry link.
     */
    async getEntryLink(path) {
        validation_1.validateString("path", path, "parameter");
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        const opts = registry_1.defaultGetEntryOptions;
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        return await this.connector.client.registry.getEntryLink(publicKey, dataKey, opts);
    }
    /**
     * Sets Discoverable JSON at the given path through MySky, if the user has given permissions to do so.
     *
     * @param path - The data path.
     * @param json - The json to set.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An object containing the json data as well as the skylink for the data.
     */
    async setJSON(path, json, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateObject("json", json, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultSetJSONOptions);
        const opts = {
            ...skydb_1.defaultSetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const [entry, dataLink] = await skydb_1.getOrCreateRegistryEntry(this.connector.client, string_1.hexToUint8Array(publicKey), dataKey, json, opts);
        const signature = await this.signRegistryEntry(entry, path);
        const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
        await this.connector.client.registry.postSignedEntry(publicKey, entry, signature, setEntryOpts);
        return { data: json, dataLink };
    }
    // ================
    // Internal Methods
    // ================
    async catchError(errorMsg) {
        const event = new CustomEvent(skynet_mysky_utils_1.dispatchedErrorEvent, { detail: errorMsg });
        window.dispatchEvent(event);
    }
    async launchUI() {
        const mySkyUrl = new URL(this.connector.url);
        mySkyUrl.pathname = mySkyUiRelativeUrl;
        const uiUrl = mySkyUrl.toString();
        // Open the window.
        const childWindow = utils_1.popupCenter(uiUrl, mySkyUiTitle, mySkyUiW, mySkyUiH);
        if (!childWindow) {
            throw new Error(`Could not open window at '${uiUrl}'`);
        }
        return childWindow;
    }
    async connectUi(childWindow) {
        const options = this.connector.options;
        // Complete handshake with UI window.
        const messenger = new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: childWindow,
            remoteOrigin: "*",
        });
        const methods = {
            catchError: this.catchError,
        };
        const connection = await post_me_1.ParentHandshake(messenger, methods, options.handshakeMaxAttempts, options.handshakeAttemptsInterval);
        return connection;
    }
    async loadDac(dac) {
        // Initialize DAC.
        await dac.init(this.connector.client, this.connector.options);
        // Add DAC permissions.
        const perms = dac.getPermissions();
        this.addPermissions(...perms);
    }
    handleLogin(loggedIn) {
        if (loggedIn) {
            for (const dac of this.dacs) {
                dac.onUserLogin();
            }
        }
    }
    async signRegistryEntry(entry, path) {
        return await this.connector.connection.remoteHandle().call("signRegistryEntry", entry, path);
    }
}
exports.MySky = MySky;
MySky.instance = null;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/tweak.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deriveDiscoverableTweak = exports.hashPathComponent = exports.splitPath = exports.DiscoverableBucketTweak = void 0;
const crypto_1 = __webpack_require__(/*! ../crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const discoverableBucketTweakVersion = 1;
class DiscoverableBucketTweak {
    constructor(path) {
        const paths = splitPath(path);
        const pathHashes = paths.map(hashPathComponent);
        this.version = discoverableBucketTweakVersion;
        this.path = pathHashes;
    }
    encode() {
        const size = 1 + 32 * this.path.length;
        const buf = new Uint8Array(size);
        buf.set([this.version]);
        let offset = 1;
        for (const pathLevel of this.path) {
            buf.set(pathLevel, offset);
            offset += 32;
        }
        return buf;
    }
    getHash() {
        const encoding = this.encode();
        return crypto_1.hashAll(encoding);
    }
}
exports.DiscoverableBucketTweak = DiscoverableBucketTweak;
function splitPath(path) {
    return path.split("/");
}
exports.splitPath = splitPath;
function hashPathComponent(component) {
    return crypto_1.hashAll(string_1.stringToUint8ArrayUtf8(component));
}
exports.hashPathComponent = hashPathComponent;
function deriveDiscoverableTweak(path) {
    const dbt = new DiscoverableBucketTweak(path);
    const bytes = dbt.getHash();
    return string_1.toHexString(bytes);
}
exports.deriveDiscoverableTweak = deriveDiscoverableTweak;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.popupCenter = exports.extractDomain = exports.getFullDomainUrl = void 0;
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-mysky-utils/dist/index.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
/**
 * Constructs the full URL for the given component domain,
 * e.g. "dac.hns" => "https://dac.hns.siasky.net"
 *
 * @param this - SkynetClient
 * @param domain - Component domain.
 * @returns - The full URL for the component.
 */
async function getFullDomainUrl(domain) {
    const portalUrl = await this.portalUrl();
    return url_1.getFullDomainUrlForPortal(portalUrl, domain);
}
exports.getFullDomainUrl = getFullDomainUrl;
/**
 * Extracts the domain from the current portal URL,
 * e.g. ("dac.hns.siasky.net") => "dac.hns"
 *
 * @param this - SkynetClient
 * @param fullDomain - Full URL.
 * @returns - The extracted domain.
 */
async function extractDomain(fullDomain) {
    const portalUrl = await this.portalUrl();
    return url_1.extractDomainForPortal(portalUrl, fullDomain);
}
exports.extractDomain = extractDomain;
/**
 * Create a new popup window. From SkyID.
 */
function popupCenter(url, title, w, h) {
    url = skynet_mysky_utils_1.ensureUrl(url);
    // Fixes dual-screen position                             Most browsers      Firefox
    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
    const width = window.innerWidth
        ? window.innerWidth
        : document.documentElement.clientWidth
            ? document.documentElement.clientWidth
            : screen.width;
    const height = window.innerHeight
        ? window.innerHeight
        : document.documentElement.clientHeight
            ? document.documentElement.clientHeight
            : screen.height;
    const systemZoom = width / window.screen.availWidth;
    const left = (width - w) / 2 / systemZoom + dualScreenLeft;
    const top = (height - h) / 2 / systemZoom + dualScreenTop;
    const newWindow = window.open(url, title, `
scrollbars=yes,
width=${w / systemZoom},
height=${h / systemZoom},
top=${top},
left=${left}
`);
    if (!newWindow) {
        throw new Error("could not open window");
    }
    if (newWindow.focus) {
        newWindow.focus();
    }
    return newWindow;
}
exports.popupCenter = popupCenter;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/registry.js":
/*!*****************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/registry.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateRegistryEntry = exports.postSignedEntry = exports.signEntry = exports.setEntry = exports.getEntryLink = exports.getEntryUrlForPortal = exports.getEntryUrl = exports.getEntry = exports.regexRevisionNoQuotes = exports.DEFAULT_GET_ENTRY_TIMEOUT = exports.defaultSetEntryOptions = exports.defaultGetEntryOptions = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");
const number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const sia_1 = __webpack_require__(/*! ./skylink/sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
exports.defaultGetEntryOptions = {
    ...options_1.defaultBaseOptions,
    endpointGetEntry: "/skynet/registry",
    hashedDataKeyHex: false,
};
exports.defaultSetEntryOptions = {
    ...options_1.defaultBaseOptions,
    endpointSetEntry: "/skynet/registry",
    hashedDataKeyHex: false,
};
exports.DEFAULT_GET_ENTRY_TIMEOUT = 5; // 5 seconds
/**
 * Regex for JSON revision value without quotes.
 */
exports.regexRevisionNoQuotes = /"revision":\s*([0-9]+)/;
/**
 * Regex for JSON revision value with quotes.
 */
const regexRevisionWithQuotes = /"revision":\s*"([0-9]+)"/;
/**
 * Gets the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The signed registry entry.
 * @throws - Will throw if the returned signature does not match the returned entry or the provided timeout is invalid or the given key is not valid.
 */
async function getEntry(publicKey, dataKey, customOptions) {
    // Validation is done in `getEntryUrl`.
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const url = await this.registry.getEntryUrl(publicKey, dataKey, opts);
    let response;
    try {
        response = await this.executeRequest({
            ...opts,
            endpointPath: opts.endpointGetEntry,
            url,
            method: "get",
            // Transform the response to add quotes, since uint64 cannot be accurately
            // read by JS so the revision needs to be parsed as a string.
            transformResponse: function (data) {
                if (data === undefined) {
                    return {};
                }
                // Change the revision value from a JSON integer to a string.
                data = data.replace(exports.regexRevisionNoQuotes, '"revision":"$1"');
                // Try converting the JSON data to an object.
                try {
                    return JSON.parse(data);
                }
                catch {
                    // The data is not JSON, it's likely an HTML error response.
                    return data;
                }
            },
        });
    }
    catch (err) {
        return handleGetEntryErrResponse(err);
    }
    // Sanity check.
    try {
        validation_1.validateString("response.data.data", response.data.data, "entry response field");
        validation_1.validateString("response.data.revision", response.data.revision, "entry response field");
        validation_1.validateString("response.data.signature", response.data.signature, "entry response field");
    }
    catch (err) {
        throw new Error(`Did not get a complete entry response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
    // Use empty string if the data is empty.
    let data = "";
    if (response.data.data) {
        data = string_1.uint8ArrayToStringUtf8(string_1.hexToUint8Array(response.data.data));
    }
    const signedEntry = {
        entry: {
            dataKey,
            data,
            // Convert the revision from a string to bigint.
            revision: BigInt(response.data.revision),
        },
        signature: buffer_1.Buffer.from(string_1.hexToUint8Array(response.data.signature)),
    };
    if (signedEntry &&
        !tweetnacl_1.sign.detached.verify(crypto_1.hashRegistryEntry(signedEntry.entry, opts.hashedDataKeyHex), new Uint8Array(signedEntry.signature), string_1.hexToUint8Array(publicKey))) {
        throw new Error("could not verify signature from retrieved, signed registry entry -- possible corrupted entry");
    }
    return signedEntry;
}
exports.getEntry = getEntry;
/**
 * Gets the registry entry URL corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full get entry URL.
 * @throws - Will throw if the provided timeout is invalid or the given key is not valid.
 */
async function getEntryUrl(publicKey, dataKey, customOptions) {
    // Validation is done in `getEntryUrlForPortal`.
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const portalUrl = await this.portalUrl();
    return getEntryUrlForPortal(portalUrl, publicKey, dataKey, opts);
}
exports.getEntryUrl = getEntryUrl;
/**
 * Gets the registry entry URL without an initialized client.
 *
 * @param portalUrl - The portal URL.
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full get entry URL.
 * @throws - Will throw if the given key is not valid.
 */
function getEntryUrlForPortal(portalUrl, publicKey, dataKey, customOptions) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("publicKey", publicKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetEntryOptions);
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...customOptions,
    };
    // Trim the prefix if it was passed in.
    publicKey = string_1.trimPrefix(publicKey, "ed25519:");
    if (!string_1.isHexString(publicKey)) {
        throw new Error(`Given public key '${publicKey}' is not a valid hex-encoded string or contains an invalid prefix`);
    }
    // Hash and hex encode the given data key if it is not a hash already.
    let dataKeyHashHex = dataKey;
    if (!opts.hashedDataKeyHex) {
        dataKeyHashHex = string_1.toHexString(crypto_1.hashDataKey(dataKey));
    }
    const query = {
        publickey: `ed25519:${publicKey}`,
        datakey: dataKeyHashHex,
        timeout: exports.DEFAULT_GET_ENTRY_TIMEOUT,
    };
    let url = url_1.makeUrl(portalUrl, opts.endpointGetEntry);
    url = url_1.addUrlQuery(url, query);
    return url;
}
exports.getEntryUrlForPortal = getEntryUrlForPortal;
/**
 * Gets the entry link for the entry at the given public key and data key. This link stays the same even if the content at the entry changes.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The entry link.
 * @throws - Will throw if the given key is not valid.
 */
async function getEntryLink(publicKey, dataKey, customOptions) {
    validation_1.validateString("publicKey", publicKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetEntryOptions);
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...customOptions,
    };
    // Trim the prefix if it was passed in.
    publicKey = string_1.trimPrefix(publicKey, "ed25519:");
    if (!string_1.isHexString(publicKey)) {
        throw new Error(`Given public key '${publicKey}' is not a valid hex-encoded string or contains an invalid prefix`);
    }
    const siaPublicKey = sia_1.newEd25519PublicKey(publicKey);
    let tweak;
    if (opts.hashedDataKeyHex) {
        tweak = string_1.hexToUint8Array(dataKey);
    }
    else {
        tweak = crypto_1.hashDataKey(dataKey);
    }
    const skylink = sia_1.newSkylinkV2(siaPublicKey, tweak).toString();
    return format_1.formatSkylink(skylink);
}
exports.getEntryLink = getEntryLink;
/**
 * Sets the registry entry.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param entry - The entry to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An empty promise.
 * @throws - Will throw if the entry revision does not fit in 64 bits or the given key is not valid.
 */
async function setEntry(privateKey, entry, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validateRegistryEntry("entry", entry, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetEntryOptions);
    // Assert the input is 64 bits.
    number_1.assertUint64(entry.revision);
    const opts = {
        ...exports.defaultSetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const privateKeyArray = string_1.hexToUint8Array(privateKey);
    const signature = await signEntry(privateKey, entry, opts.hashedDataKeyHex);
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(privateKeyArray);
    return await this.registry.postSignedEntry(string_1.toHexString(publicKeyArray), entry, signature, opts);
}
exports.setEntry = setEntry;
async function signEntry(privateKey, entry, hashedDataKeyHex) {
    // TODO: Publicly available, validate input.
    const privateKeyArray = string_1.hexToUint8Array(privateKey);
    // Sign the entry.
    // TODO: signature type should be Signature?
    return tweetnacl_1.sign(crypto_1.hashRegistryEntry(entry, hashedDataKeyHex), privateKeyArray);
}
exports.signEntry = signEntry;
async function postSignedEntry(publicKey, entry, signature, customOptions) {
    validation_1.validateHexString("publicKey", publicKey, "parameter");
    // TODO: Validate entry and signature
    validation_1.validateString("entry.dataKey", entry.dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetEntryOptions);
    const opts = {
        ...exports.defaultSetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    // Hash and hex encode the given data key if it is not a hash already.
    let datakey = entry.dataKey;
    if (!opts.hashedDataKeyHex) {
        datakey = string_1.toHexString(crypto_1.hashDataKey(entry.dataKey));
    }
    const data = {
        publickey: {
            algorithm: "ed25519",
            key: Array.from(string_1.hexToUint8Array(publicKey)),
        },
        datakey,
        // Set the revision as a string here since the value may be up to 64 bits.
        // We remove the quotes later in transformRequest.
        revision: entry.revision.toString(),
        data: Array.from(buffer_1.Buffer.from(entry.data)),
        signature: Array.from(signature),
    };
    await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointSetEntry,
        method: "post",
        data,
        // Transform the request to remove quotes, since the revision needs to be
        // parsed as a uint64 on the Go side.
        transformRequest: function (data) {
            // Convert the object data to JSON.
            const json = JSON.stringify(data);
            // Change the revision value from a string to a JSON integer.
            return json.replace(regexRevisionWithQuotes, '"revision":$1');
        },
    });
}
exports.postSignedEntry = postSignedEntry;
function validateRegistryEntry(name, value, valueKind) {
    validation_1.validateObject(name, value, valueKind);
    validation_1.validateString(`${name}.dataKey`, value.dataKey, `${valueKind} field`);
    validation_1.validateString(`${name}.data`, value.data, `${valueKind} field`);
    validation_1.validateBigint(`${name}.revision`, value.revision, `${valueKind} field`);
}
exports.validateRegistryEntry = validateRegistryEntry;
/**
 * Handles error responses returned in getEntry.
 *
 * @param err - The Axios error.
 * @returns - An empty signed registry entry if the status code is 404.
 * @throws - Will throw if the status code is not 404.
 */
function handleGetEntryErrResponse(err) {
    /* istanbul ignore next */
    if (!err.response) {
        throw new Error(`Error response field not found, incomplete Axios error. Full error: ${err}`);
    }
    /* istanbul ignore next */
    if (!err.response.status) {
        throw new Error(`Error response did not contain expected field 'status'. Full error: ${err}`);
    }
    // Check if status was 404 "not found" and return null if so.
    if (err.response.status === 404) {
        return { entry: null, signature: null };
    }
    throw err;
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skydb.js":
/*!**************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skydb.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOrCreateRegistryEntry = exports.setJSON = exports.getJSON = exports.defaultSetJSONOptions = exports.defaultGetJSONOptions = exports.JSON_RESPONSE_VERSION = void 0;
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const upload_1 = __webpack_require__(/*! ./upload */ "./node_modules/skynet-js/dist/cjs/upload.js");
const download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
exports.JSON_RESPONSE_VERSION = 2;
exports.defaultGetJSONOptions = {
    ...options_1.defaultBaseOptions,
    ...registry_1.defaultGetEntryOptions,
    ...download_1.defaultDownloadOptions,
    cachedDataLink: undefined,
};
exports.defaultSetJSONOptions = {
    ...options_1.defaultBaseOptions,
    ...exports.defaultGetJSONOptions,
    ...registry_1.defaultSetEntryOptions,
    ...upload_1.defaultUploadOptions,
};
/**
 * Gets the JSON object corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The returned JSON and revision number.
 * @throws - Will throw if the returned signature does not match the returned entry, or if the skylink in the entry is invalid.
 */
async function getJSON(publicKey, dataKey, customOptions) {
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetJSONOptions);
    // Rest of validation is done in `getEntry`.
    const opts = {
        ...exports.defaultGetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    // Lookup the registry entry.
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const { entry } = await this.registry.getEntry(publicKey, dataKey, getEntryOpts);
    if (entry === null) {
        return { data: null, dataLink: null };
    }
    const dataLink = entry.data;
    // If a cached data link is provided and the data link hasn't changed, return.
    if (opts.cachedDataLink && dataLink === opts.cachedDataLink) {
        return { data: null, dataLink };
    }
    // Download the data in the returned data link.
    const downloadOpts = options_1.extractOptions(opts, download_1.defaultDownloadOptions);
    const { data } = await this.getFileContent(dataLink, downloadOpts);
    if (typeof data !== "object" || data === null) {
        throw new Error(`File data for the entry at data key '${dataKey}' is not JSON.`);
    }
    if (!(data["_data"] && data["_v"])) {
        // Legacy data prior to v4, return as-is.
        return { data, dataLink };
    }
    const actualData = data["_data"];
    if (typeof actualData !== "object" || data === null) {
        throw new Error(`File data '_data' for the entry at data key '${dataKey}' is not JSON.`);
    }
    return { data: actualData, dataLink };
}
exports.getJSON = getJSON;
/**
 * Sets a JSON object at the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param json - The JSON data to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @throws - Will throw if the input keys are not valid strings.
 */
async function setJSON(privateKey, dataKey, json, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateObject("json", json, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetJSONOptions);
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(string_1.hexToUint8Array(privateKey));
    const [entry, skylink] = await getOrCreateRegistryEntry(this, publicKeyArray, dataKey, json, opts);
    // Update the registry.
    const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
    await this.registry.setEntry(privateKey, entry, setEntryOpts);
    return { data: json, dataLink: skylink };
}
exports.setJSON = setJSON;
async function getOrCreateRegistryEntry(client, publicKeyArray, dataKey, json, customOptions) {
    // Not publicly available, don't validate input.
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...client.customOptions,
        ...customOptions,
    };
    // Set the hidden _data and _v fields.
    const data = { _data: json, _v: exports.JSON_RESPONSE_VERSION };
    // Create the data to upload to acquire its skylink.
    let dataKeyHex = dataKey;
    if (!opts.hashedDataKeyHex) {
        dataKeyHex = string_1.toHexString(string_1.stringToUint8ArrayUtf8(dataKey));
    }
    const file = new File([JSON.stringify(data)], `dk:${dataKeyHex}`, { type: "application/json" });
    // Start file upload, do not block.
    const uploadOpts = options_1.extractOptions(opts, upload_1.defaultUploadOptions);
    const skyfilePromise = client.uploadFile(file, uploadOpts);
    // Fetch the current value to find out the revision.
    //
    // Start getEntry, do not block.
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const entryPromise = client.registry.getEntry(string_1.toHexString(publicKeyArray), dataKey, getEntryOpts);
    // Block until both getEntry and uploadFile are finished.
    const [signedEntry, skyfile] = await Promise.all([
        entryPromise,
        skyfilePromise,
    ]);
    let revision;
    if (signedEntry.entry === null) {
        revision = BigInt(0);
    }
    else {
        revision = signedEntry.entry.revision + BigInt(1);
    }
    // Throw if the revision is already the maximum value.
    if (revision > number_1.MAX_REVISION) {
        throw new Error("Current entry already has maximum allowed revision, could not update the entry");
    }
    // Assert the input is 64 bits.
    number_1.assertUint64(revision);
    // Build the registry value.
    const dataLink = skyfile.skylink;
    const entry = {
        dataKey,
        data: string_1.trimUriPrefix(dataLink, url_1.uriSkynetPrefix),
        revision,
    };
    return [entry, dataLink];
}
exports.getOrCreateRegistryEntry = getOrCreateRegistryEntry;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/format.js":
/*!***********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/format.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatSkylink = exports.convertSkylinkToBase32 = void 0;
const base64_js_1 = __importDefault(__webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js"));
const base32_encode_1 = __importDefault(__webpack_require__(/*! base32-encode */ "./node_modules/base32-encode/index.js"));
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
/**
 * Converts the given base64 skylink to base32.
 *
 * @param skylink - The base64 skylink.
 * @returns - The converted base32 skylink.
 */
function convertSkylinkToBase32(skylink) {
    const decoded = base64_js_1.default.toByteArray(skylink.padEnd(skylink.length + 4 - (skylink.length % 4), "="));
    return base32_encode_1.default(decoded, "RFC4648-HEX", { padding: false }).toLowerCase();
}
exports.convertSkylinkToBase32 = convertSkylinkToBase32;
/**
 * Formats the skylink by adding the sia: prefix.
 *
 * @param skylink - The skylink.
 * @returns - The formatted skylink.
 */
function formatSkylink(skylink) {
    if (skylink == "") {
        return skylink;
    }
    if (!skylink.startsWith(url_1.uriSkynetPrefix)) {
        skylink = `${url_1.uriSkynetPrefix}${skylink}`;
    }
    return skylink;
}
exports.formatSkylink = formatSkylink;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/parse.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSkylinkBase32 = exports.parseSkylink = void 0;
const url_parse_1 = __importDefault(__webpack_require__(/*! url-parse */ "./node_modules/skynet-js/node_modules/url-parse/index.js"));
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const defaultParseSkylinkOptions = {
    fromSubdomain: false,
    includePath: false,
    onlyPath: false,
};
const SKYLINK_MATCHER = "([a-zA-Z0-9_-]{46})";
const SKYLINK_MATCHER_SUBDOMAIN = "([a-z0-9_-]{55})";
const SKYLINK_DIRECT_REGEX = new RegExp(`^${SKYLINK_MATCHER}$`);
const SKYLINK_PATHNAME_REGEX = new RegExp(`^/?${SKYLINK_MATCHER}((/.*)?)$`);
const SKYLINK_SUBDOMAIN_REGEX = new RegExp(`^${SKYLINK_MATCHER_SUBDOMAIN}(\\..*)?$`);
const SKYLINK_DIRECT_MATCH_POSITION = 1;
const SKYLINK_PATH_MATCH_POSITION = 2;
/**
 * Parses the given string for a base64 skylink, or base32 if opts.fromSubdomain is given. If the given string is prefixed with sia:, sia://, or a portal URL, those will be removed and the raw skylink returned.
 *
 * @param skylinkUrl - Plain skylink, skylink with URI prefix, or URL with skylink as the first path element.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The base64 (or base32) skylink, optionally with the path included.
 * @throws - Will throw on invalid combination of options.
 */
function parseSkylink(skylinkUrl, customOptions) {
    validation_1.validateString("skylinkUrl", skylinkUrl, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultParseSkylinkOptions);
    const opts = { ...defaultParseSkylinkOptions, ...customOptions };
    if (opts.includePath && opts.onlyPath) {
        throw new Error("The includePath and onlyPath options cannot both be set");
    }
    if (opts.includePath && opts.fromSubdomain) {
        throw new Error("The includePath and fromSubdomain options cannot both be set");
    }
    if (opts.fromSubdomain) {
        return parseSkylinkBase32(skylinkUrl, opts);
    }
    // Check for skylink prefixed with sia: or sia:// and extract it.
    // Example: sia:XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    // Example: sia://XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    skylinkUrl = string_1.trimUriPrefix(skylinkUrl, url_1.uriSkynetPrefix);
    // Check for direct base64 skylink match.
    const matchDirect = skylinkUrl.match(SKYLINK_DIRECT_REGEX);
    if (matchDirect) {
        if (opts.onlyPath) {
            return "";
        }
        return matchDirect[SKYLINK_DIRECT_MATCH_POSITION];
    }
    // Check for skylink passed in an url and extract it.
    // Example: https://siasky.net/XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    // Example: https://bg06v2tidkir84hg0s1s4t97jaeoaa1jse1svrad657u070c9calq4g.siasky.net (if opts.fromSubdomain = true)
    // Pass empty object as second param to disable using location as base url
    // when parsing in browser.
    const parsed = url_parse_1.default(skylinkUrl, {});
    const skylinkAndPath = string_1.trimSuffix(parsed.pathname, "/");
    const matchPathname = skylinkAndPath.match(SKYLINK_PATHNAME_REGEX);
    if (!matchPathname)
        return null;
    const path = matchPathname[SKYLINK_PATH_MATCH_POSITION];
    if (opts.includePath)
        return string_1.trimForwardSlash(skylinkAndPath);
    else if (opts.onlyPath)
        return path;
    else
        return matchPathname[SKYLINK_DIRECT_MATCH_POSITION];
}
exports.parseSkylink = parseSkylink;
/**
 * Helper function that parses the given string for a base32 skylink.
 *
 * @param skylinkUrl - Base32 skylink.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The base32 skylink.
 */
function parseSkylinkBase32(skylinkUrl, customOptions) {
    // Do not validate, this helper function should only be called from parseSkylink.
    const opts = { ...defaultParseSkylinkOptions, ...customOptions };
    // Pass empty object as second param to disable using location as base url
    // when parsing in browser.
    const parsed = url_parse_1.default(skylinkUrl, {});
    // Check if the hostname contains a skylink subdomain.
    const matchHostname = parsed.hostname.match(SKYLINK_SUBDOMAIN_REGEX);
    if (matchHostname) {
        if (opts.onlyPath) {
            return string_1.trimSuffix(parsed.pathname, "/");
        }
        return matchHostname[SKYLINK_DIRECT_MATCH_POSITION];
    }
    return null;
}
exports.parseSkylinkBase32 = parseSkylinkBase32;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/sia.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/sia.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.newSkylinkV2 = exports.newEd25519PublicKey = exports.newSpecifier = exports.SiaSkylink = void 0;
const base64_js_1 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const encoding_1 = __webpack_require__(/*! ../utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
// The raw size of the data that gets put into a link.
const RAW_SKYLINK_SIZE = 34;
class SiaSkylink {
    constructor(bitfield, merkleRoot) {
        this.bitfield = bitfield;
        this.merkleRoot = merkleRoot;
        validation_1.validateNumber("bitfield", bitfield, "constructor parameter");
        validation_1.validateUint8ArrayLen("merkleRoot", merkleRoot, "constructor parameter", 32);
    }
    toBytes() {
        const buf = new ArrayBuffer(RAW_SKYLINK_SIZE);
        const view = new DataView(buf);
        view.setUint16(0, this.bitfield, true);
        const uint8Bytes = new Uint8Array(buf);
        uint8Bytes.set(this.merkleRoot, 2);
        return uint8Bytes;
    }
    toString() {
        let base64 = base64_js_1.fromByteArray(this.toBytes());
        // Change to URL encoding.
        base64 = base64.replace(/\+/g, "-").replace(/\//g, "_");
        // Remove padding characters.
        return string_1.trimSuffix(base64, "=");
    }
}
exports.SiaSkylink = SiaSkylink;
const SPECIFIER_LEN = 16;
/**
 * Returns a specifier for given name, a specifier can only be 16 bytes so we
 * panic if the given name is too long.
 *
 * @param name - The name.
 * @returns - The specifier, if valid.
 */
function newSpecifier(name) {
    validateSpecifier(name);
    const specifier = new Uint8Array(SPECIFIER_LEN);
    specifier.set(string_1.stringToUint8ArrayUtf8(name));
    return specifier;
}
exports.newSpecifier = newSpecifier;
const PUBLIC_KEY_SIZE = 32;
class SiaPublicKey {
    constructor(algorithm, key) {
        this.algorithm = algorithm;
        this.key = key;
    }
    marshalSia() {
        const bytes = new Uint8Array(SPECIFIER_LEN + 8 + PUBLIC_KEY_SIZE);
        bytes.set(this.algorithm);
        bytes.set(encoding_1.encodePrefixedBytes(this.key), SPECIFIER_LEN);
        return bytes;
    }
}
/**
 * Creates a new sia public key. Matches Ed25519PublicKey in sia.
 *
 * @param publicKey - The hex-encoded public key.
 * @returns - The SiaPublicKey.
 */
function newEd25519PublicKey(publicKey) {
    validation_1.validateHexString("publicKey", publicKey, "parameter");
    const algorithm = newSpecifier("ed25519");
    const publicKeyBytes = string_1.hexToUint8Array(publicKey);
    validation_1.validateUint8ArrayLen("publicKeyBytes", publicKeyBytes, "converted publicKey", PUBLIC_KEY_SIZE);
    return new SiaPublicKey(algorithm, publicKeyBytes);
}
exports.newEd25519PublicKey = newEd25519PublicKey;
/**
 * Creates a new v2 skylink. Matches NewSkylinkV2 in skyd.
 *
 * @param siaPublicKey - The public key as a SiaPublicKey.
 * @param tweak - The hashed tweak.
 * @returns - The v2 skylink.
 */
function newSkylinkV2(siaPublicKey, tweak) {
    const version = 2;
    const bitfield = version - 1;
    const merkleRoot = deriveRegistryEntryID(siaPublicKey, tweak);
    return new SiaSkylink(bitfield, merkleRoot);
}
exports.newSkylinkV2 = newSkylinkV2;
/**
 * A helper to derive an entry id for a registry key value pair. Matches `DeriveRegistryEntryID` in sia.
 *
 * @param pubKey - The sia public key.
 * @param tweak - The tweak.
 * @returns - The entry ID as a hash of the inputs.
 */
function deriveRegistryEntryID(pubKey, tweak) {
    return crypto_1.hashAll(pubKey.marshalSia(), tweak);
}
/**
 * Performs validation checks on the specifier name, it panics when the input is
 * invalid seeing we want to catch this on runtime.
 * Matches `validateSpecifier` in sia.
 *
 * @param name - The specifier name.
 * @throws - Will throw if the specifier name is not valid.
 */
function validateSpecifier(name) {
    if (!string_1.isASCIIString(name)) {
        throw new Error("specifier has to be ASCII");
    }
    if (name.length > SPECIFIER_LEN) {
        throw new Error("specifier max length exceeded");
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/upload.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/upload.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uploadDirectoryRequest = exports.uploadDirectory = exports.uploadFileRequest = exports.uploadFile = exports.defaultUploadOptions = void 0;
const file_1 = __webpack_require__(/*! ./utils/file */ "./node_modules/skynet-js/dist/cjs/utils/file.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultUploadOptions = {
    ...options_1.defaultBaseOptions,
    endpointUpload: "/skynet/skyfile",
    portalFileFieldname: "file",
    portalDirectoryFileFieldname: "files[]",
    customFilename: "",
    query: undefined,
};
/**
 * Uploads a file to Skynet.
 *
 * @param this - SkynetClient
 * @param file - The file to upload.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The returned skylink.
 * @throws - Will throw if the request is successful but the upload response does not contain a complete response.
 */
async function uploadFile(file, customOptions) {
    // Validation is done in `uploadDirectoryRequest`.
    const response = await this.uploadFileRequest(file, customOptions);
    // Sanity check.
    validateUploadResponse(response);
    const skylink = format_1.formatSkylink(response.data.skylink);
    const merkleroot = response.data.merkleroot;
    const bitfield = response.data.bitfield;
    return { skylink, merkleroot, bitfield };
}
exports.uploadFile = uploadFile;
/**
 * Makes a request to upload a file to Skynet.
 *
 * @param this - SkynetClient
 * @param file - The file to upload.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The upload response.
 */
async function uploadFileRequest(file, customOptions) {
    validateFile("file", file, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultUploadOptions);
    const opts = { ...exports.defaultUploadOptions, ...this.customOptions, ...customOptions };
    const formData = new FormData();
    file = ensureFileObjectConsistency(file);
    if (opts.customFilename) {
        formData.append(opts.portalFileFieldname, file, opts.customFilename);
    }
    else {
        formData.append(opts.portalFileFieldname, file);
    }
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointUpload,
        method: "post",
        data: formData,
    });
    return response;
}
exports.uploadFileRequest = uploadFileRequest;
/**
 * Uploads a directory to Skynet.
 *
 * @param this - SkynetClient
 * @param directory - File objects to upload, indexed by their path strings.
 * @param filename - The name of the directory.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The returned skylink.
 * @throws - Will throw if the request is successful but the upload response does not contain a complete response.
 */
async function uploadDirectory(directory, filename, customOptions) {
    // Validation is done in `uploadDirectoryRequest`.
    const response = await this.uploadDirectoryRequest(directory, filename, customOptions);
    // Sanity check.
    validateUploadResponse(response);
    const skylink = format_1.formatSkylink(response.data.skylink);
    const merkleroot = response.data.merkleroot;
    const bitfield = response.data.bitfield;
    return { skylink, merkleroot, bitfield };
}
exports.uploadDirectory = uploadDirectory;
/**
 * Makes a request to upload a directory to Skynet.
 *
 * @param this - SkynetClient
 * @param directory - File objects to upload, indexed by their path strings.
 * @param filename - The name of the directory.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The upload response.
 * @throws - Will throw if the input filename is not a string.
 */
async function uploadDirectoryRequest(directory, filename, customOptions) {
    validation_1.validateObject("directory", directory, "parameter");
    validation_1.validateString("filename", filename, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultUploadOptions);
    const opts = { ...exports.defaultUploadOptions, ...this.customOptions, ...customOptions };
    const formData = new FormData();
    Object.entries(directory).forEach(([path, file]) => {
        file = ensureFileObjectConsistency(file);
        formData.append(opts.portalDirectoryFileFieldname, file, path);
    });
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointUpload,
        method: "post",
        data: formData,
        query: { filename },
    });
    return response;
}
exports.uploadDirectoryRequest = uploadDirectoryRequest;
/**
 * Sometimes file object might have had the type property defined manually with
 * Object.defineProperty and some browsers (namely firefox) can have problems
 * reading it after the file has been appended to form data. To overcome this,
 * we recreate the file object using native File constructor with a type defined
 * as a constructor argument.
 *
 * @param file - The input file.
 * @returns - The processed file.
 * @see {@link https://github.com/NebulousLabs/skynet-webportal/issues/290| Related Issue}
 */
function ensureFileObjectConsistency(file) {
    return new File([file], file.name, { type: file_1.getFileMimeType(file) });
}
/**
 * Validates the given value as a file.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid file.
 */
function validateFile(name, value, valueKind) {
    if (!(value instanceof File)) {
        validation_1.throwValidationError(name, value, valueKind, "'File'");
    }
}
/**
 * Validates the upload response.
 *
 * @param response - The upload response.
 * @throws - Will throw if not a valid upload response.
 */
function validateUploadResponse(response) {
    try {
        if (!response.data) {
            throw new Error("response.data field missing");
        }
        validation_1.validateString("skylink", response.data.skylink, "upload response field");
        validation_1.validateString("merkleroot", response.data.merkleroot, "upload response field");
        validation_1.validateNumber("bitfield", response.data.bitfield, "upload response field");
    }
    catch (err) {
        throw new Error(`Did not get a complete upload response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/encoding.js":
/*!***********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/encoding.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeUtf8String = exports.encodePrefixedBytes = exports.encodeBigintAsUint64 = exports.encodeNumber = void 0;
const number_1 = __webpack_require__(/*! ./number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * Converts the given number into a uint8 array
 *
 * @param num - Number to encode.
 * @returns - Number encoded as a byte array.
 */
function encodeNumber(num) {
    const encoded = new Uint8Array(8);
    for (let index = 0; index < encoded.length; index++) {
        const byte = num & 0xff;
        encoded[index] = byte;
        num = num >> 8;
    }
    return encoded;
}
exports.encodeNumber = encodeNumber;
/**
 * Encodes the given bigint into a uint8 array.
 *
 * @param int - Bigint to encode.
 * @returns - Bigint encoded as a byte array.
 * @throws - Will throw if the int does not fit in 64 bits.
 */
function encodeBigintAsUint64(int) {
    // Assert the input is 64 bits.
    number_1.assertUint64(int);
    const encoded = new Uint8Array(8);
    for (let index = 0; index < encoded.length; index++) {
        const byte = int & BigInt(0xff);
        encoded[index] = Number(byte);
        int = int >> BigInt(8);
    }
    return encoded;
}
exports.encodeBigintAsUint64 = encodeBigintAsUint64;
/**
 * Encodes the uint8array, prefixed by its length.
 *
 * @param bytes - The input array.
 * @returns - The encoded byte array.
 */
function encodePrefixedBytes(bytes) {
    const len = bytes.length;
    const buf = new ArrayBuffer(8 + len);
    const view = new DataView(buf);
    // Sia uses setUint64 which is unavailable in JS.
    view.setUint32(0, len, true);
    const uint8Bytes = new Uint8Array(buf);
    uint8Bytes.set(bytes, 8);
    return uint8Bytes;
}
exports.encodePrefixedBytes = encodePrefixedBytes;
/**
 * Encodes the given UTF-8 string into a uint8 array containing the string length and the string.
 *
 * @param str - String to encode.
 * @returns - String encoded as a byte array.
 */
function encodeUtf8String(str) {
    const byteArray = string_1.stringToUint8ArrayUtf8(str);
    const encoded = new Uint8Array(8 + byteArray.length);
    encoded.set(encodeNumber(byteArray.length));
    encoded.set(byteArray, 8);
    return encoded;
}
exports.encodeUtf8String = encodeUtf8String;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/file.js":
/*!*******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/file.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFileMimeType = exports.getRootDirectory = exports.getRelativeFilePath = void 0;
const lite_1 = __importDefault(__webpack_require__(/*! mime/lite */ "./node_modules/skynet-js/node_modules/mime/lite.js"));
const path_browserify_1 = __importDefault(__webpack_require__(/*! path-browserify */ "./node_modules/path-browserify/index.js"));
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * Gets the path for the file.
 *
 * @param file - The file.
 * @returns - The path.
 */
function getFilePath(file) {
    /* istanbul ignore next */
    return file.webkitRelativePath || file.path || file.name;
}
/**
 * Gets the file path relative to the root directory of the path, e.g. `bar` in `/foo/bar`.
 *
 * @param file - The input file.
 * @returns - The relative file path.
 */
function getRelativeFilePath(file) {
    const filePath = getFilePath(file);
    const { root, dir, base } = path_browserify_1.default.parse(filePath);
    const relative = path_browserify_1.default.normalize(dir).slice(root.length).split(path_browserify_1.default.sep).slice(1);
    return path_browserify_1.default.join(...relative, base);
}
exports.getRelativeFilePath = getRelativeFilePath;
/**
 * Gets the root directory of the file path, e.g. `foo` in `/foo/bar`.
 *
 * @param file - The input file.
 * @returns - The root directory.
 */
function getRootDirectory(file) {
    const filePath = getFilePath(file);
    const { root, dir } = path_browserify_1.default.parse(filePath);
    return path_browserify_1.default.normalize(dir).slice(root.length).split(path_browserify_1.default.sep)[0];
}
exports.getRootDirectory = getRootDirectory;
/**
 * Get the file mime type. In case the type is not provided, use mime-db and try
 * to guess the file type based on the extension.
 *
 * @param file - The file.
 * @returns - The mime type.
 */
function getFileMimeType(file) {
    if (file.type)
        return file.type;
    let { ext } = path_browserify_1.default.parse(file.name);
    ext = string_1.trimPrefix(ext, ".");
    if (ext !== "") {
        const mimeType = lite_1.default.getType(ext);
        if (mimeType) {
            return mimeType;
        }
    }
    return "";
}
exports.getFileMimeType = getFileMimeType;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/number.js":
/*!*********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/number.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertUint64 = exports.MAX_REVISION = void 0;
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * The maximum allowed value for an entry revision. Setting an entry revision to this value prevents it from being updated further.
 */
exports.MAX_REVISION = BigInt("18446744073709551615"); // max uint64
/**
 * Checks if the provided bigint can fit in a 64-bit unsigned integer.
 *
 * @param int - The provided integer.
 * @throws - Will throw if the int does not fit in 64 bits.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN | MDN Demo}
 */
function assertUint64(int) {
    validation_1.validateBigint("int", int, "parameter");
    if (int < BigInt(0)) {
        throw new Error(`Argument ${int} must be an unsigned 64-bit integer; was negative`);
    }
    if (int > exports.MAX_REVISION) {
        throw new Error(`Argument ${int} does not fit in a 64-bit unsigned integer; exceeds 2^64-1`);
    }
}
exports.assertUint64 = assertUint64;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/options.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/options.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractOptions = exports.defaultBaseOptions = void 0;
/**
 * The default base custom options.
 */
exports.defaultBaseOptions = {
    APIKey: "",
    customUserAgent: "",
    customCookie: "",
    onUploadProgress: undefined,
};
/**
 * Extract only the model's custom options from the given options.
 *
 * @param opts - The given options.
 * @param model - The model options.
 * @returns - The extracted custom options.
 */
function extractOptions(opts, model) {
    const result = {};
    for (const property in model) {
        if (Object.prototype.hasOwnProperty.call(model, property)) {
            result[property] = opts[property];
        }
    }
    return result;
}
exports.extractOptions = extractOptions;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/string.js":
/*!*********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHexString = exports.isHexString = exports.hexToUint8Array = exports.uint8ArrayToStringUtf8 = exports.stringToUint8ArrayUtf8 = exports.trimUriPrefix = exports.trimSuffix = exports.trimPrefix = exports.trimForwardSlash = exports.isASCIIString = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * Returns a boolean indicating whether the String contains only ASCII bytes.
 * From https://stackoverflow.com/a/14313213/6085242.
 *
 * @param str - The input string.
 * @returns - Whether the string is ASCII.
 */
function isASCIIString(str) {
    // eslint-disable-next-line
    return /^[\x00-\x7F]*$/.test(str);
}
exports.isASCIIString = isASCIIString;
/**
 * Removes slashes from the beginning and end of the string.
 *
 * @param str - The string to process.
 * @returns - The processed string.
 */
function trimForwardSlash(str) {
    return trimPrefix(trimSuffix(str, "/"), "/");
}
exports.trimForwardSlash = trimForwardSlash;
// TODO: Move to mysky-utils
/**
 * Removes a prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimPrefix(str, prefix, limit) {
    while (str.startsWith(prefix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.slice(prefix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimPrefix = trimPrefix;
// TODO: Move to mysky-utils
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimSuffix(str, suffix, limit) {
    while (str.endsWith(suffix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.substring(0, str.length - suffix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimSuffix = trimSuffix;
/**
 * Removes a URI prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @returns - The processed string.
 */
function trimUriPrefix(str, prefix) {
    const longPrefix = `${prefix}//`;
    if (str.startsWith(longPrefix)) {
        // longPrefix is exactly at the beginning
        return str.slice(longPrefix.length);
    }
    if (str.startsWith(prefix)) {
        // else prefix is exactly at the beginning
        return str.slice(prefix.length);
    }
    return str;
}
exports.trimUriPrefix = trimUriPrefix;
/**
 * Converts a UTF-8 string to a uint8 array containing valid UTF-8 bytes.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a string.
 */
function stringToUint8ArrayUtf8(str) {
    validation_1.validateString("str", str, "parameter");
    return Uint8Array.from(buffer_1.Buffer.from(str, "utf-8"));
}
exports.stringToUint8ArrayUtf8 = stringToUint8ArrayUtf8;
/**
 * Converts a uint8 array containing valid utf-8 bytes to a string.
 *
 * @param array - The uint8 array to convert.
 * @returns - The string.
 */
function uint8ArrayToStringUtf8(array) {
    return buffer_1.Buffer.from(array).toString("utf-8");
}
exports.uint8ArrayToStringUtf8 = uint8ArrayToStringUtf8;
/**
 * Converts a hex encoded string to a uint8 array.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a valid hex-encoded string or is an empty string.
 */
function hexToUint8Array(str) {
    validation_1.validateHexString("str", str, "parameter");
    const matches = str.match(/.{1,2}/g);
    if (matches === null) {
        throw validation_1.throwValidationError("str", str, "parameter", "a hex-encoded string");
    }
    return new Uint8Array(matches.map((byte) => parseInt(byte, 16)));
}
exports.hexToUint8Array = hexToUint8Array;
/**
 * Returns true if the input is a valid hex-encoded string.
 *
 * @param str - The input string.
 * @returns - True if the input is hex-encoded.
 * @throws - Will throw if the input is not a string.
 */
function isHexString(str) {
    validation_1.validateString("str", str, "parameter");
    return /^[0-9A-Fa-f]*$/g.test(str);
}
exports.isHexString = isHexString;
/**
 * Convert a byte array to a hex string.
 *
 * @param byteArray - The byte array to convert.
 * @returns - The hex string.
 * @see {@link https://stackoverflow.com/a/44608819|Stack Overflow}
 */
function toHexString(byteArray) {
    let s = "";
    byteArray.forEach(function (byte) {
        s += ("0" + (byte & 0xff).toString(16)).slice(-2);
    });
    return s;
}
exports.toHexString = toHexString;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/url.js":
/*!******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/url.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractDomainForPortal = exports.getFullDomainUrlForPortal = exports.makeUrl = exports.addUrlQuery = exports.addSubdomain = exports.addPath = exports.defaultPortalUrl = exports.uriSkynetPrefix = exports.uriHandshakeResolverPrefix = exports.uriHandshakePrefix = exports.defaultSkynetPortalUrl = void 0;
const url_parse_1 = __importDefault(__webpack_require__(/*! url-parse */ "./node_modules/skynet-js/node_modules/url-parse/index.js"));
const url_join_1 = __importDefault(__webpack_require__(/*! url-join */ "./node_modules/url-join/lib/url-join.js"));
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultSkynetPortalUrl = "https://siasky.net";
exports.uriHandshakePrefix = "hns:";
exports.uriHandshakeResolverPrefix = "hnsres:";
exports.uriSkynetPrefix = "sia:";
// TODO: This will be smarter. See
// https://github.com/NebulousLabs/skynet-docs/issues/21.
/**
 * Returns the default portal URL.
 *
 * @returns - The portal URL.
 */
function defaultPortalUrl() {
    /* istanbul ignore next */
    if (typeof window === "undefined")
        return "/"; // default to path root on ssr
    return window.location.origin;
}
exports.defaultPortalUrl = defaultPortalUrl;
/**
 * Adds a path to the given URL.
 *
 * @param url - The URL.
 * @param path - The given path.
 * @returns - The final URL.
 */
function addPath(url, path) {
    if (!path) {
        return url;
    }
    path = string_1.trimForwardSlash(path);
    let str;
    if (url === "localhost") {
        // Special handling for localhost.
        str = `localhost/${path}`;
    }
    else {
        // Construct a URL object and set the pathname property.
        const urlObj = new URL(url);
        urlObj.pathname = path;
        str = urlObj.toString();
    }
    return string_1.trimSuffix(str, "/");
}
exports.addPath = addPath;
/**
 * Adds a subdomain to the given URL.
 *
 * @param url - The URL.
 * @param subdomain - The subdomain to add.
 * @returns - The final URL.
 */
function addSubdomain(url, subdomain) {
    const urlObj = new URL(url);
    urlObj.hostname = `${subdomain}.${urlObj.hostname}`;
    const str = urlObj.toString();
    return string_1.trimSuffix(str, "/");
}
exports.addSubdomain = addSubdomain;
/**
 * Adds a query to the given URL.
 *
 * @param url - The URL.
 * @param query - The query parameters.
 * @returns - The final URL.
 */
function addUrlQuery(url, query) {
    const parsed = url_parse_1.default(url, true);
    // Combine the desired query params with the already existing ones.
    query = { ...parsed.query, ...query };
    parsed.set("query", query);
    return parsed.toString();
}
exports.addUrlQuery = addUrlQuery;
/**
 * Properly joins paths together to create a URL. Takes a variable number of
 * arguments.
 *
 * @param args - Array of URL parts to join.
 * @returns - Final URL constructed from the input parts.
 */
function makeUrl(...args) {
    if (args.length === 0) {
        validation_1.throwValidationError("args", args, "parameter", "non-empty");
    }
    return args.reduce((acc, cur) => url_join_1.default(acc, cur));
}
exports.makeUrl = makeUrl;
/**
 * Constructs the full URL for the given domain,
 * e.g. ("https://siasky.net", "dac.hns/path/file") => "https://dac.hns.siasky.net/path/file"
 *
 * @param portalUrl - The portal URL.
 * @param domain - Domain.
 * @returns - The full URL for the given domain.
 */
function getFullDomainUrlForPortal(portalUrl, domain) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("domain", domain, "parameter");
    domain = string_1.trimUriPrefix(domain, exports.uriSkynetPrefix);
    domain = string_1.trimForwardSlash(domain);
    // Split on first / to get the path.
    let path;
    [domain, path] = domain.split(/\/(.+)/);
    // Add to subdomain.
    let url;
    if (domain === "localhost") {
        // Special handling for localhost.
        url = "localhost";
    }
    else {
        url = addSubdomain(portalUrl, domain);
    }
    // Add back the path if there was one.
    if (path) {
        url = addPath(url, path);
    }
    return url;
}
exports.getFullDomainUrlForPortal = getFullDomainUrlForPortal;
/**
 * Extracts the domain from the given portal URL,
 * e.g. ("https://siasky.net", "dac.hns.siasky.net/path/file") => "dac.hns/path/file"
 *
 * @param portalUrl - The portal URL.
 * @param fullDomain - Full URL.
 * @returns - The extracted domain.
 */
function extractDomainForPortal(portalUrl, fullDomain) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("fullDomain", fullDomain, "parameter");
    let path;
    try {
        // Try to extract the domain from the fullDomain.
        const fullDomainObj = new URL(fullDomain);
        fullDomain = fullDomainObj.hostname;
        path = fullDomainObj.pathname;
        path = string_1.trimForwardSlash(path);
    }
    catch {
        // If fullDomain is not a URL, ignore the error and use it as-is.
        //
        // Trim any slashes from the input URL.
        fullDomain = string_1.trimForwardSlash(fullDomain);
        // Split on first / to get the path.
        [fullDomain, path] = fullDomain.split(/\/(.+)/);
    }
    // Get the portal domain.
    const portalUrlObj = new URL(portalUrl);
    const portalDomain = string_1.trimForwardSlash(portalUrlObj.hostname);
    // Remove the portal domain from the domain.
    let domain = string_1.trimSuffix(fullDomain, portalDomain, 1);
    domain = string_1.trimSuffix(domain, ".");
    // Add back the path if there is one.
    if (path && path !== "") {
        path = string_1.trimForwardSlash(path);
        domain = `${domain}/${path}`;
    }
    return domain;
}
exports.extractDomainForPortal = extractDomainForPortal;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/validation.js":
/*!*************************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/validation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwValidationError = exports.validateUint8ArrayLen = exports.validateUint8Array = exports.validateHexString = exports.validateString = exports.validateNumber = exports.validateOptionalObject = exports.validateObject = exports.validateBigint = void 0;
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * Validates the given value as a bigint.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid bigint.
 */
function validateBigint(name, value, valueKind) {
    if (typeof value !== "bigint") {
        throwValidationError(name, value, valueKind, "type 'bigint'");
    }
}
exports.validateBigint = validateBigint;
/**
 * Validates the given value as an object.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid object.
 */
function validateObject(name, value, valueKind) {
    if (typeof value !== "object") {
        throwValidationError(name, value, valueKind, "type 'object'");
    }
    if (value === null) {
        throwValidationError(name, value, valueKind, "non-null");
    }
}
exports.validateObject = validateObject;
/**
 * Validates the given value as an optional object.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param model - A model object that contains all possible fields. 'value' does not need to have all fields, but it may not have any fields not contained in 'model'.
 * @throws - Will throw if not a valid optional object.
 */
function validateOptionalObject(name, value, valueKind, model) {
    if (!value) {
        // This is okay, the object is optional.
        return;
    }
    validateObject(name, value, valueKind);
    // Check if all given properties of value also exist in the model.
    for (const property in value) {
        if (!(property in model)) {
            throw new Error(`Object ${valueKind} '${name}' contains unexpected property '${property}'`);
        }
    }
}
exports.validateOptionalObject = validateOptionalObject;
/**
 * Validates the given value as a number.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid number.
 */
function validateNumber(name, value, valueKind) {
    if (typeof value !== "number") {
        throwValidationError(name, value, valueKind, "type 'number'");
    }
}
exports.validateNumber = validateNumber;
/**
 * Validates the given value as a string.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid string.
 */
function validateString(name, value, valueKind) {
    if (typeof value !== "string") {
        throwValidationError(name, value, valueKind, "type 'string'");
    }
}
exports.validateString = validateString;
/**
 * Validates the given value as a hex-encoded string.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid hex-encoded string.
 */
function validateHexString(name, value, valueKind) {
    validateString(name, value, valueKind);
    if (!string_1.isHexString(value)) {
        throwValidationError(name, value, valueKind, "a hex-encoded string");
    }
}
exports.validateHexString = validateHexString;
/**
 * Validates the given value as a uint8array.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid uint8array.
 */
function validateUint8Array(name, value, valueKind) {
    if (!(value instanceof Uint8Array)) {
        throwValidationError(name, value, valueKind, "'Uint8Array'");
    }
}
exports.validateUint8Array = validateUint8Array;
/**
 * Validates the given value as a uint8array of the given length.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param len - The length to check.
 * @throws - Will throw if not a valid uint8array of the given length.
 */
function validateUint8ArrayLen(name, value, valueKind, len) {
    validateUint8Array(name, value, valueKind);
    const actualLen = value.length;
    if (actualLen !== len) {
        throwValidationError(name, value, valueKind, `'Uint8Array' of length ${len}, was length ${actualLen}`);
    }
}
exports.validateUint8ArrayLen = validateUint8ArrayLen;
/**
 * Throws an error for the given value
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param expected - The expected aspect of the value that could not be validated (e.g. "type 'string'" or "non-null").
 * @throws - Will always throw.
 */
function throwValidationError(name, value, valueKind, expected) {
    throw new Error(`Expected ${valueKind} '${name}' to be ${expected}, was '${value}'`);
}
exports.throwValidationError = throwValidationError;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/Mime.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/Mime.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/lite.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/lite.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Mime = __webpack_require__(/*! ./Mime */ "./node_modules/skynet-js/node_modules/mime/Mime.js");
module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "./node_modules/skynet-js/node_modules/mime/types/standard.js"));


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/types/standard.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/types/standard.js ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/url-parse/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/url-parse/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/skynet-mysky-utils/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/skynet-mysky-utils/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
exports.__esModule = true;
exports.defaultHandshakeAttemptsInterval = exports.defaultHandshakeMaxAttempts = exports.monitorWindowError = exports.errorWindowClosed = exports.dispatchedErrorEvent = exports.trimSuffix = exports.ensureUrl = exports.createIframe = exports.createFullScreenIframe = exports.PermWrite = exports.PermRead = exports.PermLegacySkyID = exports.PermHidden = exports.PermDiscoverable = exports.permTypeToString = exports.permCategoryToString = exports.PermType = exports.PermCategory = exports.Permission = exports.sanitizePath = exports.getParentPath = exports.getPathDomain = void 0;
var paths_1 = __webpack_require__(/*! ./paths */ "./node_modules/skynet-mysky-utils/dist/paths.js");
__createBinding(exports, paths_1, "getPathDomain");
__createBinding(exports, paths_1, "getParentPath");
__createBinding(exports, paths_1, "sanitizePath");
var permissions_1 = __webpack_require__(/*! ./permissions */ "./node_modules/skynet-mysky-utils/dist/permissions.js");
__createBinding(exports, permissions_1, "Permission");
__createBinding(exports, permissions_1, "PermCategory");
__createBinding(exports, permissions_1, "PermType");
__createBinding(exports, permissions_1, "permCategoryToString");
__createBinding(exports, permissions_1, "permTypeToString");
// Constants
__createBinding(exports, permissions_1, "PermDiscoverable");
__createBinding(exports, permissions_1, "PermHidden");
__createBinding(exports, permissions_1, "PermLegacySkyID");
__createBinding(exports, permissions_1, "PermRead");
__createBinding(exports, permissions_1, "PermWrite");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-mysky-utils/dist/utils.js");
__createBinding(exports, utils_1, "createFullScreenIframe");
__createBinding(exports, utils_1, "createIframe");
__createBinding(exports, utils_1, "ensureUrl");
__createBinding(exports, utils_1, "trimSuffix");
var window_listener_1 = __webpack_require__(/*! ./window-listener */ "./node_modules/skynet-mysky-utils/dist/window-listener.js");
__createBinding(exports, window_listener_1, "dispatchedErrorEvent");
__createBinding(exports, window_listener_1, "errorWindowClosed");
__createBinding(exports, window_listener_1, "monitorWindowError");
exports.defaultHandshakeMaxAttempts = 150;
exports.defaultHandshakeAttemptsInterval = 100;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/skynet-mysky-utils/dist/paths.js":
/*!*******************************************************!*\
  !*** ./node_modules/skynet-mysky-utils/dist/paths.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.sanitizePath = exports.getParentPath = exports.getPathDomain = void 0;
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-mysky-utils/dist/utils.js");
/**
 * Gets the root path domain for the given path.
 *
 * @param path - The given path.
 * @returns - The path domain.
 */
function getPathDomain(path) {
    return path.split("/")[0];
}
exports.getPathDomain = getPathDomain;
/**
 * Gets the parent path for the given path.
 *
 * @param path - The given path.
 * @returns - The parent path, or null if no parent.
 */
function getParentPath(path) {
    path = sanitizePath(path);
    var pathArray = path.split("/");
    if (pathArray.length <= 1) {
        return null;
    }
    pathArray.pop();
    path = pathArray.join("/");
    return path;
}
exports.getParentPath = getParentPath;
/**
 * Sanitizes the path by removing trailing slashes and removing repeating adjacent slashes.
 *
 * @param path - The given path
 * @returns - The sanitized path.
 */
function sanitizePath(path) {
    // Remove trailing slashes.
    path = utils_1.trimSuffix(path, "/");
    // Remove duplicate adjacent slashes.
    var pathArray = Array.from(path);
    for (var i = 0; i < pathArray.length - 1;) {
        if (pathArray[i] === "/" && pathArray[i + 1] === "/") {
            pathArray.splice(i, 1);
        }
        else {
            i++;
        }
    }
    path = pathArray.join("");
    return path;
}
exports.sanitizePath = sanitizePath;
//# sourceMappingURL=paths.js.map

/***/ }),

/***/ "./node_modules/skynet-mysky-utils/dist/permissions.js":
/*!*************************************************************!*\
  !*** ./node_modules/skynet-mysky-utils/dist/permissions.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.permTypeToString = exports.permCategoryToString = exports.PermType = exports.PermWrite = exports.PermRead = exports.PermCategory = exports.PermLegacySkyID = exports.PermHidden = exports.PermDiscoverable = exports.Permission = void 0;
var Permission = /** @class */ (function () {
    function Permission(requestor, path, category, permType) {
        this.requestor = requestor;
        this.path = path;
        this.category = category;
        this.permType = permType;
        if (typeof category !== "number" || !(category in PermCategory)) {
            throw new Error("Invalid 'category' enum value " + category);
        }
        if (typeof permType !== "number" || !(permType in PermType)) {
            throw new Error("Invalid 'permType' enum value " + permType);
        }
    }
    return Permission;
}());
exports.Permission = Permission;
// Define category constants for non-TS users.
exports.PermDiscoverable = 1;
exports.PermHidden = 2;
exports.PermLegacySkyID = 3;
/**
 * Defines what type of file is being requested. Discoverable files are visible
 * to the entire world, hidden files are only visible to the user (unless
 * shared), and LegacySkyID files are supported files from the legacy SkyID
 * login system.
 */
var PermCategory;
(function (PermCategory) {
    PermCategory[PermCategory["Discoverable"] = exports.PermDiscoverable] = "Discoverable";
    PermCategory[PermCategory["Hidden"] = exports.PermHidden] = "Hidden";
    PermCategory[PermCategory["LegacySkyID"] = exports.PermLegacySkyID] = "LegacySkyID";
})(PermCategory = exports.PermCategory || (exports.PermCategory = {}));
// Define type constants for non-TS users.
exports.PermRead = 4;
exports.PermWrite = 5;
var PermType;
(function (PermType) {
    PermType[PermType["Read"] = exports.PermRead] = "Read";
    PermType[PermType["Write"] = exports.PermWrite] = "Write";
})(PermType = exports.PermType || (exports.PermType = {}));
/**
 * Converts the given permission category to a human-readable string.
 *
 * @param category - The given category.
 * @returns - The string.
 * @throws - Will throw if the category is not valid.
 */
function permCategoryToString(category) {
    if (category === PermCategory.Discoverable) {
        return "Discoverable";
    }
    else if (category === PermCategory.Hidden) {
        return "Hidden";
    }
    else if (category === PermCategory.LegacySkyID) {
        return "LegacySkyID";
    }
    else {
        throw new Error("Invalid permission category " + category);
    }
}
exports.permCategoryToString = permCategoryToString;
/**
 * Converts the given permission type to a human-readable string.
 *
 * @param permType - The given type.
 * @returns - The string.
 * @throws - Will throw if the type is not valid.
 */
function permTypeToString(permType) {
    if (permType === PermType.Read) {
        return "Read";
    }
    else if (permType === PermType.Write) {
        return "Write";
    }
    else {
        throw new Error("Invalid permission type " + permType);
    }
}
exports.permTypeToString = permTypeToString;
//# sourceMappingURL=permissions.js.map

/***/ }),

/***/ "./node_modules/skynet-mysky-utils/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/skynet-mysky-utils/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.trimSuffix = exports.ensureUrl = exports.createFullScreenIframe = exports.createIframe = void 0;
/**
 * Creates an invisible iframe with the given src and adds it to the page.
 */
function createIframe(srcUrl, name) {
    srcUrl = ensureUrl(srcUrl);
    var childFrame = document.createElement("iframe");
    childFrame.src = srcUrl;
    childFrame.name = name;
    childFrame.style.display = "none";
    // Set sandbox permissions.
    // TODO: Enable sandboxing?
    // childFrame.sandbox.add("allow-same-origin");
    // childFrame.sandbox.add("allow-scripts");
    document.body.appendChild(childFrame);
    return childFrame;
}
exports.createIframe = createIframe;
/**
 * Creates a full-screen iframe with the given src and adds it to the page.
 */
function createFullScreenIframe(srcUrl, name) {
    srcUrl = ensureUrl(srcUrl);
    var childFrame = document.createElement("iframe");
    childFrame.src = srcUrl;
    childFrame.name = name;
    // Set properties to make the iframe full-screen.
    childFrame.style.position = "fixed";
    childFrame.style.top = "0";
    childFrame.style.left = "0";
    childFrame.style.bottom = "0";
    childFrame.style.right = "0";
    childFrame.style.width = "100%";
    childFrame.style.height = "100%";
    childFrame.style.border = "none";
    childFrame.style.margin = "0";
    childFrame.style.padding = "0";
    childFrame.style.overflow = "hidden";
    childFrame.style.zIndex = "999999";
    // Set sandbox permissions.
    // TODO: Enable sandboxing?
    // childFrame.sandbox.add("allow-same-origin");
    // childFrame.sandbox.add("allow-scripts");
    document.body.appendChild(childFrame);
    return childFrame;
}
exports.createFullScreenIframe = createFullScreenIframe;
function ensureUrl(url) {
    return ensurePrefix(url, "https://");
}
exports.ensureUrl = ensureUrl;
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimSuffix(str, suffix, limit) {
    while (str.endsWith(suffix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.substring(0, str.length - suffix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimSuffix = trimSuffix;
function ensurePrefix(s, prefix) {
    if (!s.startsWith(prefix)) {
        s = "" + prefix + s;
    }
    return s;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/skynet-mysky-utils/dist/window-listener.js":
/*!*****************************************************************!*\
  !*** ./node_modules/skynet-mysky-utils/dist/window-listener.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.monitorWindowError = exports.PromiseController = exports.dispatchedErrorEvent = exports.errorWindowClosed = void 0;
exports.errorWindowClosed = "window-closed";
exports.dispatchedErrorEvent = "catchError";
var PromiseController = /** @class */ (function () {
    function PromiseController() {
    }
    PromiseController.prototype.cleanup = function () {
        // Empty until implemented in monitorWindowError.
    };
    return PromiseController;
}());
exports.PromiseController = PromiseController;
/**
 * Checks if there has been an error from the window on an interval.
 */
function monitorWindowError() {
    var controller = new PromiseController();
    var abortController = new AbortController();
    var promise = new Promise(function (resolve, reject) {
        var handleEvent = function (e) {
            window.removeEventListener(exports.dispatchedErrorEvent, handleEvent);
            var err = e.detail;
            reject(err);
        };
        // @ts-expect-error doesn't recognize signal option.
        window.addEventListener(exports.dispatchedErrorEvent, handleEvent, {
            signal: abortController.signal
        });
        // Initialize cleanup function.
        controller.cleanup = function () {
            // Abort the event listener.
            abortController.abort();
            // Cleanup the promise.
            resolve();
        };
    });
    return { promise: promise, controller: controller };
}
exports.monitorWindowError = monitorWindowError;
//# sourceMappingURL=window-listener.js.map

/***/ }),

/***/ "./node_modules/to-data-view/index.js":
/*!********************************************!*\
  !*** ./node_modules/to-data-view/index.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = function toDataView (data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength)
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data)
  }

  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
}


/***/ }),

/***/ "./src/dac.ts":
/*!********************!*\
  !*** ./src/dac.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const skynet_js_1 = __webpack_require__(/*! skynet-js */ "./node_modules/skynet-js/dist/cjs/index.js");
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/post-me/dist/index.js");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
// DAC consts
const DATA_DOMAIN = "skapps.hns";
//const urlParams = new URLSearchParams(window.location.search);
const DEBUG_ENABLED = true;
const DEV_ENABLED = true;
// page consts
const ENTRY_MAX_SIZE = 1 << 12; // 4kib
const PAGE_REF = '[NUM]';
// index consts
const INDEX_DEFAULT_PAGE_SIZE = 1000;
const INDEX_VERSION = 1;
// ContentRecordDAC is a DAC that allows recording user interactions with pieces
// of content. There are two types of interactions which are:
// - content creation
// - content interaction (can be anything)
//
// The DAC will store these interactions across a fanout data structure that
// consists of an index file that points to multiple page files.
class SkappDAC {
    constructor() {
        this.skappDict = {};
        // create client
        this.client = new skynet_js_1.SkynetClient();
        // define API
        const methods = {
            init: this.init.bind(this),
            onUserLogin: this.onUserLogin.bind(this),
            skappAction: this.skappAction.bind(this),
            getPublishedApps: this.getPublishedApps.bind(this),
            getSkappsInfo: this.getSkappsInfo.bind(this),
            getSkappStats: this.getSkappStats.bind(this),
            getSkappComments: this.getSkappComments.bind(this),
            getDeployedApps: this.getDeployedApps.bind(this),
            getPublishedAppsCount: this.getPublishedAppsCount.bind(this)
        };
        // create connection
        this.connection = post_me_1.ChildHandshake(new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: window.parent,
            remoteOrigin: "*",
        }), methods);
    }
    async skappAction(action, appId, data) {
        let result = {
            submitted: false,
        };
        try {
            switch (action) {
                case types_1.skappActionType.DEPLOY:
                case types_1.skappActionType.REDEPLOY:
                    await this.setDeployedAppInfo(appId, data);
                    await this.updateDeployedIndex(appId);
                    result.submitted = true;
                    break;
                case types_1.skappActionType.PUBLISH:
                    let appstats = {
                        id: appId,
                        version: '1',
                        prevSkylink: '',
                        ts: (new Date()).toUTCString(),
                        content: {
                            favorite: 0,
                            viewed: 0,
                            liked: 0,
                            accessed: 0
                        }
                    };
                    await this.setPublishedAppStats(appId, appstats);
                    let appcomments = {
                        id: appId,
                        version: '1',
                        prevSkylink: '',
                        ts: (new Date()).toUTCString(),
                        content: {
                            comments: []
                        }
                    };
                    await this.setPublishedAppComments(appId, appcomments);
                case types_1.skappActionType.REPUBLISH:
                    await this.setPublishedAppInfo(appId, data);
                    await this.updatePublisedIndex(appId);
                    result.submitted = true;
                    break;
                case types_1.skappActionType.LIKED:
                case types_1.skappActionType.UNLIKED:
                    if (await this.checkPublishedApp(appId)) {
                        let like = await this.getPublishedAppStats(appId);
                        like.ts = (new Date()).toUTCString();
                        like.content.liked = action == types_1.skappActionType.LIKED ? 1 : 0;
                        await this.setPublishedAppStats(appId, like);
                    }
                    break;
                case types_1.skappActionType.FAVORITE:
                case types_1.skappActionType.UNFAVORITE:
                    if (await this.checkPublishedApp(appId)) {
                        let fav = await this.getPublishedAppStats(appId);
                        fav.ts = (new Date()).toUTCString();
                        fav.content.favorite = action == types_1.skappActionType.FAVORITE ? 1 : 0;
                        await this.setPublishedAppStats(appId, fav);
                    }
                    break;
                case types_1.skappActionType.VIEWED:
                    if (await this.checkPublishedApp(appId)) {
                        let view = await this.getPublishedAppStats(appId);
                        view.ts = (new Date()).toUTCString();
                        view.content.viewed += 1;
                        await this.setPublishedAppStats(appId, view);
                    }
                    break;
                case types_1.skappActionType.ACCESSED:
                    if (await this.checkPublishedApp(appId)) {
                        let access = await this.getPublishedAppStats(appId);
                        access.ts = (new Date()).toUTCString();
                        access.content.accessed += 1;
                        await this.setPublishedAppStats(appId, access);
                    }
                    break;
                case types_1.skappActionType.ADD_COMMENT:
                    if (await this.checkPublishedApp(appId)) {
                        let comment = await this.getPublishedAppComments(appId);
                        comment.ts = (new Date()).toUTCString();
                        comment.content.comments.push({ timestamp: (new Date()).toUTCString(), comment: data.comment });
                        await this.setPublishedAppComments(appId, comment);
                    }
                    break;
                default:
                    this.log('No such Implementation');
            }
        }
        catch (error) {
            result.error = error;
        }
        return result;
    }
    async checkPublishedApp(appId) {
        let indexData = {};
        try {
            indexData = await this.downloadFile(this.paths.PUBLISHED_INDEX_PATH);
        }
        catch (error) {
            throw Error('NO Index present');
        }
        if (indexData.published.includes(appId)) {
            return true;
        }
        else {
            return false;
        }
    }
    async updatePublisedIndex(appId) {
        let indexData = {};
        try {
            indexData = await this.downloadFile(this.paths.PUBLISHED_INDEX_PATH);
        }
        catch (error) {
            indexData['published'] = [];
        }
        if (indexData == null || indexData == undefined || indexData.published == null || indexData.published == undefined) {
            indexData = {};
            indexData['published'] = [];
        }
        if (!indexData.published.includes(appId)) {
            indexData.published.push(appId);
            this.mySky.setJSON(this.paths.PUBLISHED_INDEX_PATH, indexData);
        }
    }
    async updateDeployedIndex(appId) {
        let indexData = {};
        try {
            indexData = await this.downloadFile(this.paths.DEPLOYED_INDEX_PATH);
        }
        catch (error) {
            indexData['deployed'] = [];
        }
        if (indexData == null || indexData == undefined || indexData.deployed == null || indexData.deployed == undefined) {
            indexData = {};
            indexData['deployed'] = [];
        }
        if (!indexData.deployed.includes(appId)) {
            indexData.deployed.push(appId);
            this.mySky.setJSON(this.paths.DEPLOYED_INDEX_PATH, indexData);
        }
    }
    async init() {
        try {
            // extract the skappname and use it to set the filepaths
            const hostname = new URL(document.referrer).hostname;
            const skapp = await this.client.extractDomain(hostname);
            this.log("loaded from skapp", skapp);
            this.skapp = skapp;
            this.paths = {
                SKAPPS_DICT_PATH: `${DATA_DOMAIN}/skapp-dict.json`,
                PUBLISHED_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/published/index.json`,
                ///JSON Data: [appId1, AppId2....]
                //PATH_Example: /skyapps.hns/skapp.hns/published/index.json, /skyapps.hns/anotherAppStore.hns/published/index.json..etc
                PUBLISHED_APP_INFO_PATH: `${DATA_DOMAIN}/${skapp}/published/`,
                PUBLISHED_APP_COMMENT_PATH: `${DATA_DOMAIN}/${skapp}/published/`,
                PUBLISHED_APP_STATS_PATH: `${DATA_DOMAIN}/${skapp}/published/`,
                DEPLOYED_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/deployed/index.json`,
                //JSON Data: [appId1, AppId2....]
                DEPLOYED_APP_INFO_PATH: `${DATA_DOMAIN}/${skapp}/deployed/`,
            };
            // load mysky
            const opts = { dev: DEV_ENABLED };
            this.mySky = await this.client.loadMySky(DATA_DOMAIN, opts);
        }
        catch (error) {
            this.log('Failed to load MySky, err: ', error);
            throw error;
        }
        try {
            //this.skappDict= await this.downloadFile(this.paths.SKAPPS_DICT_PATH)
        }
        catch (error) {
            this.log('Failed to load skappDict, err: ', error);
            this.skappDict[this.skapp] = true;
            //this.mySky.setJSON(this.paths.SKAPPS_DICT_PATH,this.skappDict);
            this.log('updated current skapp to skapp dict');
        }
    }
    async getPublishedApps(appIds) {
        let indexData = {};
        let results = [];
        if (appIds == null || appIds.length == 0) {
            try {
                indexData = await this.downloadFile(this.paths.PUBLISHED_INDEX_PATH);
            }
            catch (error) {
                throw new Error("NO PUBLISHED APP");
            }
            appIds = indexData.published;
        }
        for (let appid of appIds) {
            let appData;
            try {
                appData = await this.getPublishedAppInfo(appid);
                results.push(appData);
            }
            catch (error) {
                this.log('missing json for appid :', appid);
            }
        }
        return results;
    }
    async getPublishedAppsCount(appIds) {
        let indexData = {};
        //let results:any[] = [];
        if (appIds == null || appIds.length == 0) {
            try {
                indexData = await this.downloadFile(this.paths.PUBLISHED_INDEX_PATH);
            }
            catch (error) {
                throw new Error("NO PUBLISHED APP");
            }
            appIds = indexData.published;
        }
        return appIds.length;
    }
    async getSkappsInfo(appIds) {
        let indexData = {};
        let results = [];
        if (appIds == null || appIds.length == 0) {
            try {
                indexData = await this.downloadFile(this.paths.PUBLISHED_INDEX_PATH);
            }
            catch (error) {
                throw new Error("NO PUBLISHED APP");
            }
            appIds = indexData.published;
        }
        for (let appid of appIds) {
            let appMaster = {};
            let appData;
            let appStats;
            let appComments;
            try {
                appData = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appid + '/' + 'appInfo.json');
                appStats = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appid + '/' + 'appStats.json');
                appComments = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appid + '/' + 'appComments.json');
                appMaster = {
                    appdata: appData,
                    appstats: appStats,
                    appcomments: appComments
                };
                results.push(appMaster);
            }
            catch (error) {
                this.log('missing json for appid :', appid);
            }
        }
        return results;
    }
    async getSkappStats(appId) {
        let appData;
        try {
            appData = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appStats.json');
        }
        catch (error) {
            this.log('missing json for appid :', appId);
            throw new Error("missing json for appid :" + appId);
        }
        return appData;
    }
    async getSkappComments(appId) {
        let appData;
        try {
            appData = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appComments.json');
        }
        catch (error) {
            this.log('missing json for appid :', appId);
            throw new Error("missing json for appid :" + appId);
        }
        return appData;
    }
    async getDeployedApps(appIds) {
        let indexData = {};
        let results = [];
        if (appIds == null || appIds.length == 0) {
            try {
                indexData = await this.downloadFile(this.paths.DEPLOYED_INDEX_PATH);
            }
            catch (error) {
                throw new Error("NO DEPLOYED APP");
            }
            appIds = indexData.deployed;
        }
        for (let appid of appIds) {
            let appData;
            try {
                appData = await this.getDeployedAppInfo(appid);
                results.push(appData);
            }
            catch (error) {
                this.log('missing json for appid :', appid);
            }
        }
        return results;
    }
    async getPublishedAppInfo(appId) {
        return await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appInfo.json');
    }
    async getPublishedAppStats(appId) {
        return (await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appStats.json'));
    }
    async setPublishedAppStats(appId, data) {
        return await this.mySky.setJSON(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appStats.json', data);
    }
    async getPublishedAppComments(appId) {
        return await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appComments.json');
    }
    async setPublishedAppComments(appId, data) {
        return await this.mySky.setJSON(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appComments.json', data);
    }
    async setPublishedAppInfo(appId, appData) {
        return await this.mySky.setJSON(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appInfo.json', appData);
    }
    async getDeployedAppInfo(appId) {
        return await this.downloadFile(this.paths.DEPLOYED_APP_INFO_PATH + appId + '/' + 'appInfo.json');
    }
    async setDeployedAppInfo(appId, appData) {
        return await this.mySky.setJSON(this.paths.DEPLOYED_APP_INFO_PATH + appId + '/' + 'appInfo.json', appData);
    }
    // onUserLogin is called by MySky when the user has logged in successfully
    async onUserLogin() {
        // Register the skapp name in the dictionary
    }
    // registerSkappName is called on init and ensures this skapp name is
    // registered in the skapp name dictionary.
    async registerSkappName() {
        const { SKAPPS_DICT_PATH } = this.paths;
        let skapps = await this.downloadFile(SKAPPS_DICT_PATH);
        if (!skapps) {
            skapps = {};
        }
        skapps[this.skapp] = true;
        await this.updateFile(SKAPPS_DICT_PATH, skapps);
    }
    // downloadFile merely wraps getJSON but is typed in a way that avoids
    // repeating the awkward "as unknown as T" everywhere
    async downloadFile(path) {
        this.log('### Skapp-Record ### :: downloading file at path', path);
        const { data } = await this.mySky.getJSON(path);
        if (!data) {
            this.log('no data found at path', path);
            return null;
        }
        this.log('data found at path', path, data);
        return data;
    }
    // updateFile merely wraps setJSON but is typed in a way that avoids repeating
    // the awkwars "as unknown as JsonData" everywhere
    async updateFile(path, data) {
        this.log('updating file at path', path, data);
        await this.mySky.setJSON(path, data);
    }
    // toPersistence turns content info into a content persistence object
    toPersistence(data) {
        const persistence = {
            timestamp: Math.floor(Date.now() / 1000),
            ...data,
        };
        if (persistence.metadata === undefined) {
            persistence.metadata = {};
        }
        // validate the given data does not exceed max size
        const size = buffer_1.Buffer.from(JSON.stringify(persistence)).length;
        if (size > ENTRY_MAX_SIZE) {
            throw new Error(`Entry exceeds max size, ${length}>${ENTRY_MAX_SIZE}`);
        }
        return persistence;
    }
    // log prints to stdout only if DEBUG_ENABLED flag is set
    log(message, ...optionalContext) {
        if (DEBUG_ENABLED) {
            console.log(message, ...optionalContext);
        }
    }
}
exports.default = SkappDAC;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dac_1 = __importDefault(__webpack_require__(/*! ./dac */ "./src/dac.ts"));
(async () => {
    new dac_1.default();
})();


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EntryType = exports.skappActionType = void 0;
var skappActionType;
(function (skappActionType) {
    skappActionType[skappActionType["PUBLISH"] = 0] = "PUBLISH";
    skappActionType[skappActionType["REPUBLISH"] = 1] = "REPUBLISH";
    skappActionType[skappActionType["DEPLOY"] = 2] = "DEPLOY";
    skappActionType[skappActionType["REDEPLOY"] = 3] = "REDEPLOY";
    skappActionType[skappActionType["VIEWED"] = 4] = "VIEWED";
    skappActionType[skappActionType["ACCESSED"] = 5] = "ACCESSED";
    skappActionType[skappActionType["FAVORITE"] = 6] = "FAVORITE";
    skappActionType[skappActionType["UNFAVORITE"] = 7] = "UNFAVORITE";
    skappActionType[skappActionType["LIKED"] = 8] = "LIKED";
    skappActionType[skappActionType["UNLIKED"] = 9] = "UNLIKED";
    skappActionType[skappActionType["ADD_COMMENT"] = 10] = "ADD_COMMENT";
    skappActionType[skappActionType["EDIT_COMMENT"] = 11] = "EDIT_COMMENT";
    skappActionType[skappActionType["REMOVE_COMMENT"] = 12] = "REMOVE_COMMENT";
})(skappActionType = exports.skappActionType || (exports.skappActionType = {}));
var EntryType;
(function (EntryType) {
    EntryType[EntryType["NEWCONTENT"] = 0] = "NEWCONTENT";
    EntryType[EntryType["INTERACTIONS"] = 1] = "INTERACTIONS";
})(EntryType = exports.EntryType || (exports.EntryType = {}));


/***/ }),

/***/ "./node_modules/tweetnacl/nacl-fast.js":
/*!*********************************************!*\
  !*** ./node_modules/tweetnacl/nacl-fast.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "?dba7");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "./node_modules/url-join/lib/url-join.js":
/*!***********************************************!*\
  !*** ./node_modules/url-join/lib/url-join.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {
  if ( true && module.exports) module.exports = definition();
  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  else {}
})('urljoin', this, function () {

  function normalize (strArray) {
    var resultArray = [];
    if (strArray.length === 0) { return ''; }

    if (typeof strArray[0] !== 'string') {
      throw new TypeError('Url must be a string. Received ' + strArray[0]);
    }

    // If the first part is a plain protocol, we combine it with the next part.
    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
      var first = strArray.shift();
      strArray[0] = first + strArray[0];
    }

    // There must be two or three slashes in the file protocol, two slashes in anything else.
    if (strArray[0].match(/^file:\/\/\//)) {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
    } else {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
    }

    for (var i = 0; i < strArray.length; i++) {
      var component = strArray[i];

      if (typeof component !== 'string') {
        throw new TypeError('Url must be a string. Received ' + component);
      }

      if (component === '') { continue; }

      if (i > 0) {
        // Removing the starting slashes for each component but the first.
        component = component.replace(/^[\/]+/, '');
      }
      if (i < strArray.length - 1) {
        // Removing the ending slashes for each component but the last.
        component = component.replace(/[\/]+$/, '');
      } else {
        // For the last component we will combine multiple slashes to a single one.
        component = component.replace(/[\/]+$/, '/');
      }

      resultArray.push(component);

    }

    var str = resultArray.join('/');
    // Each input component is now separated by a single slash except the possible first plain protocol part.

    // remove trailing slash before parameters or hash
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

    // replace ? in parameters with &
    var parts = str.split('?');
    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

    return str;
  }

  return function () {
    var input;

    if (typeof arguments[0] === 'object') {
      input = arguments[0];
    } else {
      input = [].slice.call(arguments);
    }

    return normalize(input);
  };

});


/***/ }),

/***/ "?dba7":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2Jhc2UzMi1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2JsYWtlanMvYmxha2UyYi5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9ibGFrZWpzL2JsYWtlMnMuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9ibGFrZWpzL3V0aWwuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3Bvc3QtbWUvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2pjbC9zamNsLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL2NyeXB0by5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvZG93bmxvYWQuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9teXNreS9jb25uZWN0b3IuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL215c2t5L2RhYy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvbXlza3kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL215c2t5L3R3ZWFrLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9teXNreS91dGlscy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3NreWRiLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9za3lsaW5rL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvc2t5bGluay9wYXJzZS5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvc2t5bGluay9zaWEuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3VwbG9hZC5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL251bWJlci5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvc3RyaW5nLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy91dGlscy91cmwuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9taW1lL01pbWUuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9taW1lL2xpdGUuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9taW1lL3R5cGVzL3N0YW5kYXJkLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1teXNreS11dGlscy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1teXNreS11dGlscy9kaXN0L3BhdGhzLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1teXNreS11dGlscy9kaXN0L3Blcm1pc3Npb25zLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1teXNreS11dGlscy9kaXN0L3V0aWxzLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1teXNreS11dGlscy9kaXN0L3dpbmRvdy1saXN0ZW5lci5qcyIsIndlYnBhY2s6Ly9za2FwcHMtcmVjb3JkLWRhYy8uL25vZGVfbW9kdWxlcy90by1kYXRhLXZpZXcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9zcmMvZGFjLnRzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vc3JjL3R5cGVzLnRzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjLy4vbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanMiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvLi9ub2RlX21vZHVsZXMvdXJsLWpvaW4vbGliL3VybC1qb2luLmpzIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjL2lnbm9yZWR8RjpcXEZJUVxcQ29udGVudFxcc2thcHBzLXJlY29yZFxcbm9kZV9tb2R1bGVzXFx0d2VldG5hY2x8Y3J5cHRvIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3NrYXBwcy1yZWNvcmQtZGFjL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vc2thcHBzLXJlY29yZC1kYWMvd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDRGQUF1QyxDOzs7Ozs7Ozs7OztBQ0ExQjs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMseUVBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDbExhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0VBQWtCOztBQUV6QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdGQUF3Qjs7QUFFckQ7O0FBRUE7QUFDQSxzQkFBc0I7Ozs7Ozs7Ozs7OztBQ3ZEVDs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2xCYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsMkRBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDeERhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7O0FDOUZhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbkRhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLG1GQUEwQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBd0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkJhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHVFQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMseURBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzlFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RGYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hCYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25CYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsa0RBQVM7QUFDN0IsMEJBQTBCLG1CQUFPLENBQUMsOEZBQStCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdEMsR0FBRztBQUNIO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGlFQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7OztBQ2pHYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUMsU0FBUzs7QUFFVDtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsK0JBQStCLGFBQWEsRUFBRTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMOzs7Ozs7Ozs7Ozs7QUNwRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNWYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7Ozs7Ozs7Ozs7QUNuRWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1EQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQ1hhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7QUNwRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlWQSxpQkFBaUIsbUJBQU8sQ0FBQywwREFBYzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hEWTs7QUFFWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsOENBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHFCQUFxQixVQUFVLElBQUksSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLEdBQUc7OztBQUd4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFD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TyxDQUFDLHFCQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsRUFBRSxLQUE2QixrRUFBa0U7Ozs7Ozs7Ozs7O0FDdDFFbEc7QUFDQSxNQUFNLEtBQTZCO0FBQ25DLFdBQVcsSUFBMEMsRUFBRSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDekUsT0FBTyxFQUE2QjtBQUNwQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7OztBQzdFRCxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztVQ1BEO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcih0aW1lb3V0RXJyb3JNZXNzYWdlLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCJ2YXIgdG9EYXRhVmlldyA9IHJlcXVpcmUoJ3RvLWRhdGEtdmlldycpXG5cbnZhciBSRkM0NjQ4ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J1xudmFyIFJGQzQ2NDhfSEVYID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ1xudmFyIENST0NLRk9SRCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWidcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzJFbmNvZGUgKGRhdGEsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGFscGhhYmV0LCBkZWZhdWx0UGFkZGluZ1xuXG4gIHN3aXRjaCAodmFyaWFudCkge1xuICAgIGNhc2UgJ1JGQzM1NDgnOlxuICAgIGNhc2UgJ1JGQzQ2NDgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4XG4gICAgICBkZWZhdWx0UGFkZGluZyA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnUkZDNDY0OC1IRVgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4X0hFWFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0Nyb2NrZm9yZCc6XG4gICAgICBhbHBoYWJldCA9IENST0NLRk9SRFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UzMiB2YXJpYW50OiAnICsgdmFyaWFudClcbiAgfVxuXG4gIHZhciBwYWRkaW5nID0gKG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogZGVmYXVsdFBhZGRpbmcpXG4gIHZhciB2aWV3ID0gdG9EYXRhVmlldyhkYXRhKVxuXG4gIHZhciBiaXRzID0gMFxuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBvdXRwdXQgPSAnJ1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA4KSB8IHZpZXcuZ2V0VWludDgoaSlcbiAgICBiaXRzICs9IDhcblxuICAgIHdoaWxlIChiaXRzID49IDUpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFsodmFsdWUgPj4+IChiaXRzIC0gNSkpICYgMzFdXG4gICAgICBiaXRzIC09IDVcbiAgICB9XG4gIH1cblxuICBpZiAoYml0cyA+IDApIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlIDw8ICg1IC0gYml0cykpICYgMzFdXG4gIH1cblxuICBpZiAocGFkZGluZykge1xuICAgIHdoaWxlICgob3V0cHV0Lmxlbmd0aCAlIDgpICE9PSAwKSB7XG4gICAgICBvdXRwdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvLyBCbGFrZTJCIGluIHB1cmUgSmF2YXNjcmlwdFxuLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuLy8gUG9ydGVkIHRvIEphdmFzY3JpcHQgYnkgREMgLSBodHRwczovL2dpdGh1Yi5jb20vZGNwb3NjaFxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSB2W2IsYisxXVxuLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuZnVuY3Rpb24gQURENjRBQSAodiwgYSwgYikge1xuICB2YXIgbzAgPSB2W2FdICsgdltiXVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gYlxuLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuZnVuY3Rpb24gQURENjRBQyAodiwgYSwgYjAsIGIxKSB7XG4gIHZhciBvMCA9IHZbYV0gKyBiMFxuICBpZiAoYjAgPCAwKSB7XG4gICAgbzAgKz0gMHgxMDAwMDAwMDBcbiAgfVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzXG5mdW5jdGlvbiBCMkJfR0VUMzIgKGFyciwgaSkge1xuICByZXR1cm4gKGFycltpXSBeXG4gIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgKGFycltpICsgM10gPDwgMjQpKVxufVxuXG4vLyBHIE1peGluZyBmdW5jdGlvblxuLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuZnVuY3Rpb24gQjJCX0cgKGEsIGIsIGMsIGQsIGl4LCBpeSkge1xuICB2YXIgeDAgPSBtW2l4XVxuICB2YXIgeDEgPSBtW2l4ICsgMV1cbiAgdmFyIHkwID0gbVtpeV1cbiAgdmFyIHkxID0gbVtpeSArIDFdXG5cbiAgQURENjRBQSh2LCBhLCBiKSAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICBBREQ2NEFDKHYsIGEsIHgwLCB4MSkgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHRvIHRoZSByaWdodCBieSAzMiBiaXRzXG4gIHZhciB4b3IwID0gdltkXSBeIHZbYV1cbiAgdmFyIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSB4b3IxXG4gIHZbZCArIDFdID0geG9yMFxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KVxuICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KVxuXG4gIEFERDY0QUEodiwgYSwgYilcbiAgQURENjRBQyh2LCBhLCB5MCwgeTEpXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpXG4gIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KVxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgNjMgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IxID4+PiAzMSkgXiAoeG9yMCA8PCAxKVxuICB2W2IgKyAxXSA9ICh4b3IwID4+PiAzMSkgXiAoeG9yMSA8PCAxKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweEYzQkNDOTA4LCAweDZBMDlFNjY3LCAweDg0Q0FBNzNCLCAweEJCNjdBRTg1LFxuICAweEZFOTRGODJCLCAweDNDNkVGMzcyLCAweDVGMUQzNkYxLCAweEE1NEZGNTNBLFxuICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAweEZCNDFCRDZCLCAweDFGODNEOUFCLCAweDEzN0UyMTc5LCAweDVCRTBDRDE5XG5dKVxuXG52YXIgU0lHTUE4ID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0LFxuICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5LFxuICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICA2LCAxNSwgMTQsIDksIDExLCAzLCAwLCA4LCAxMiwgMiwgMTMsIDcsIDEsIDQsIDEwLCA1LFxuICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzXG5dXG5cbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqIDIgfSkpXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgzMilcbmZ1bmN0aW9uIGJsYWtlMmJDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuXG4gIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuXG4gIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICB2WzI0XSA9IHZbMjRdIF4gY3R4LnRcbiAgdlsyNV0gPSB2WzI1XSBeIChjdHgudCAvIDB4MTAwMDAwMDAwKVxuICAvLyBoaWdoIDY0IGJpdHMgbm90IHN1cHBvcnRlZCwgb2Zmc2V0IG1heSBub3QgYmUgaGlnaGVyIHRoYW4gMioqNTMtMVxuXG4gIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICBpZiAobGFzdCkge1xuICAgIHZbMjhdID0gfnZbMjhdXG4gICAgdlsyOV0gPSB+dlsyOV1cbiAgfVxuXG4gIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgbVtpXSA9IEIyQl9HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICAvLyB1bmNvbW1lbnQgdGhlIERlYnVnUHJpbnQgY2FsbHMgdG8gbG9nIHRoZSBjb21wdXRhdGlvblxuICAvLyBhbmQgbWF0Y2ggdGhlIFJGQyBzYW1wbGUgZG9jdW1lbnRhdGlvblxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgICAgICAgICBtWzE2XScsIG0sIDY0KVxuICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9JyArIChpIDwgMTAgPyAnICcgOiAnJykgKyBpICsgJykgdlsxNl0nLCB2LCA2NClcbiAgICBCMkJfRygwLCA4LCAxNiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMF0sIFNJR01BODJbaSAqIDE2ICsgMV0pXG4gICAgQjJCX0coMiwgMTAsIDE4LCAyNiwgU0lHTUE4MltpICogMTYgKyAyXSwgU0lHTUE4MltpICogMTYgKyAzXSlcbiAgICBCMkJfRyg0LCAxMiwgMjAsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDRdLCBTSUdNQTgyW2kgKiAxNiArIDVdKVxuICAgIEIyQl9HKDYsIDE0LCAyMiwgMzAsIFNJR01BODJbaSAqIDE2ICsgNl0sIFNJR01BODJbaSAqIDE2ICsgN10pXG4gICAgQjJCX0coMCwgMTAsIDIwLCAzMCwgU0lHTUE4MltpICogMTYgKyA4XSwgU0lHTUE4MltpICogMTYgKyA5XSlcbiAgICBCMkJfRygyLCAxMiwgMjIsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDEwXSwgU0lHTUE4MltpICogMTYgKyAxMV0pXG4gICAgQjJCX0coNCwgMTQsIDE2LCAyNiwgU0lHTUE4MltpICogMTYgKyAxMl0sIFNJR01BODJbaSAqIDE2ICsgMTNdKVxuICAgIEIyQl9HKDYsIDgsIDE4LCAyOCwgU0lHTUE4MltpICogMTYgKyAxNF0sIFNJR01BODJbaSAqIDE2ICsgMTVdKVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9MTIpIHZbMTZdJywgdiwgNjQpXG5cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjdHguaFtpXSA9IGN0eC5oW2ldIF4gdltpXSBeIHZbaSArIDE2XVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnaFs4XScsIGN0eC5oLCA2NClcbn1cblxuLy8gQ3JlYXRlcyBhIEJMQUtFMmIgaGFzaGluZyBjb250ZXh0XG4vLyBSZXF1aXJlcyBhbiBvdXRwdXQgbGVuZ3RoIGJldHdlZW4gMSBhbmQgNjQgYnl0ZXNcbi8vIFRha2VzIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkga2V5XG5mdW5jdGlvbiBibGFrZTJiSW5pdCAob3V0bGVuLCBrZXkpIHtcbiAgaWYgKG91dGxlbiA9PT0gMCB8fCBvdXRsZW4gPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvdXRwdXQgbGVuZ3RoLCBleHBlY3RlZCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuICBpZiAoa2V5ICYmIGtleS5sZW5ndGggPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBrZXksIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuXG4gIC8vIHN0YXRlLCAncGFyYW0gYmxvY2snXG4gIHZhciBjdHggPSB7XG4gICAgYjogbmV3IFVpbnQ4QXJyYXkoMTI4KSxcbiAgICBoOiBuZXcgVWludDMyQXJyYXkoMTYpLFxuICAgIHQ6IDAsIC8vIGlucHV0IGNvdW50XG4gICAgYzogMCwgLy8gcG9pbnRlciB3aXRoaW4gYnVmZmVyXG4gICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gQkxBS0UyQl9JVjMyW2ldXG4gIH1cbiAgdmFyIGtleWxlbiA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIGN0eC5oWzBdIF49IDB4MDEwMTAwMDAgXiAoa2V5bGVuIDw8IDgpIF4gb3V0bGVuXG5cbiAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gIGlmIChrZXkpIHtcbiAgICBibGFrZTJiVXBkYXRlKGN0eCwga2V5KVxuICAgIC8vIGF0IHRoZSBlbmRcbiAgICBjdHguYyA9IDEyOFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2UyYlVwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSAxMjgpIHsgLy8gYnVmZmVyIGZ1bGwgP1xuICAgICAgY3R4LnQgKz0gY3R4LmMgLy8gYWRkIGNvdW50ZXJzXG4gICAgICBibGFrZTJiQ29tcHJlc3MoY3R4LCBmYWxzZSkgLy8gY29tcHJlc3MgKG5vdCBsYXN0KVxuICAgICAgY3R4LmMgPSAwIC8vIGNvdW50ZXIgdG8gemVyb1xuICAgIH1cbiAgICBjdHguYltjdHguYysrXSA9IGlucHV0W2ldXG4gIH1cbn1cblxuLy8gQ29tcGxldGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgbWVzc2FnZSBkaWdlc3RcbmZ1bmN0aW9uIGJsYWtlMmJGaW5hbCAoY3R4KSB7XG4gIGN0eC50ICs9IGN0eC5jIC8vIG1hcmsgbGFzdCBibG9jayBvZmZzZXRcblxuICB3aGlsZSAoY3R4LmMgPCAxMjgpIHsgLy8gZmlsbCB1cCB3aXRoIHplcm9zXG4gICAgY3R4LmJbY3R4LmMrK10gPSAwXG4gIH1cbiAgYmxha2UyYkNvbXByZXNzKGN0eCwgdHJ1ZSkgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICAvLyBsaXR0bGUgZW5kaWFuIGNvbnZlcnQgYW5kIHN0b3JlXG4gIHZhciBvdXQgPSBuZXcgVWludDhBcnJheShjdHgub3V0bGVuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIEJMQUtFMkIgaGFzaCBvZiBhIHN0cmluZyBvciBieXRlIGFycmF5LCBhbmQgcmV0dXJucyBhIFVpbnQ4QXJyYXlcbi8vXG4vLyBSZXR1cm5zIGEgbi1ieXRlIFVpbnQ4QXJyYXlcbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBpbnB1dCAtIHRoZSBpbnB1dCBieXRlcywgYXMgYSBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byA2NCBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG5mdW5jdGlvbiBibGFrZTJiIChpbnB1dCwga2V5LCBvdXRsZW4pIHtcbiAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgb3V0bGVuID0gb3V0bGVuIHx8IDY0XG4gIGlucHV0ID0gdXRpbC5ub3JtYWxpemVJbnB1dChpbnB1dClcblxuICAvLyBkbyB0aGUgbWF0aFxuICB2YXIgY3R4ID0gYmxha2UyYkluaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMmJVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMmJGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJCIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMmJIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICB2YXIgb3V0cHV0ID0gYmxha2UyYihpbnB1dCwga2V5LCBvdXRsZW4pXG4gIHJldHVybiB1dGlsLnRvSGV4KG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMmI6IGJsYWtlMmIsXG4gIGJsYWtlMmJIZXg6IGJsYWtlMmJIZXgsXG4gIGJsYWtlMmJJbml0OiBibGFrZTJiSW5pdCxcbiAgYmxha2UyYlVwZGF0ZTogYmxha2UyYlVwZGF0ZSxcbiAgYmxha2UyYkZpbmFsOiBibGFrZTJiRmluYWxcbn1cbiIsIi8vIEJMQUtFMnMgaGFzaCBmdW5jdGlvbiBpbiBwdXJlIEphdmFzY3JpcHRcbi8vIEFkYXB0ZWQgZnJvbSB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGluIFJGQzc2OTNcbi8vIFBvcnRlZCB0byBKYXZhc2NyaXB0IGJ5IERDIC0gaHR0cHM6Ly9naXRodWIuY29tL2RjcG9zY2hcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzLlxuLy8gRXhwZWN0cyBhIFVpbnQ4QXJyYXkgYW5kIGFuIGluZGV4XG4vLyBSZXR1cm5zIHRoZSBsaXR0bGUtZW5kaWFuIHVpbnQzMiBhdCB2W2kuLmkrM11cbmZ1bmN0aW9uIEIyU19HRVQzMiAodiwgaSkge1xuICByZXR1cm4gdltpXSBeICh2W2kgKyAxXSA8PCA4KSBeICh2W2kgKyAyXSA8PCAxNikgXiAodltpICsgM10gPDwgMjQpXG59XG5cbi8vIE1peGluZyBmdW5jdGlvbiBHLlxuZnVuY3Rpb24gQjJTX0cgKGEsIGIsIGMsIGQsIHgsIHkpIHtcbiAgdlthXSA9IHZbYV0gKyB2W2JdICsgeFxuICB2W2RdID0gUk9UUjMyKHZbZF0gXiB2W2FdLCAxNilcbiAgdltjXSA9IHZbY10gKyB2W2RdXG4gIHZbYl0gPSBST1RSMzIodltiXSBeIHZbY10sIDEyKVxuICB2W2FdID0gdlthXSArIHZbYl0gKyB5XG4gIHZbZF0gPSBST1RSMzIodltkXSBeIHZbYV0sIDgpXG4gIHZbY10gPSB2W2NdICsgdltkXVxuICB2W2JdID0gUk9UUjMyKHZbYl0gXiB2W2NdLCA3KVxufVxuXG4vLyAzMi1iaXQgcmlnaHQgcm90YXRpb25cbi8vIHggc2hvdWxkIGJlIGEgdWludDMyXG4vLyB5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzMSwgaW5jbHVzaXZlXG5mdW5jdGlvbiBST1RSMzIgKHgsIHkpIHtcbiAgcmV0dXJuICh4ID4+PiB5KSBeICh4IDw8ICgzMiAtIHkpKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3IuXG52YXIgQkxBS0UyU19JViA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsXG4gIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTldKVxuXG52YXIgU0lHTUEgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDBdKVxuXG4vLyBDb21wcmVzc2lvbiBmdW5jdGlvbi4gXCJsYXN0XCIgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9ja1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMTYpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgxNilcbmZ1bmN0aW9uIGJsYWtlMnNDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7IC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyA4XSA9IEJMQUtFMlNfSVZbaV1cbiAgfVxuXG4gIHZbMTJdIF49IGN0eC50IC8vIGxvdyAzMiBiaXRzIG9mIG9mZnNldFxuICB2WzEzXSBePSAoY3R4LnQgLyAweDEwMDAwMDAwMCkgLy8gaGlnaCAzMiBiaXRzXG4gIGlmIChsYXN0KSB7IC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICAgIHZbMTRdID0gfnZbMTRdXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeyAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgIG1baV0gPSBCMlNfR0VUMzIoY3R4LmIsIDQgKiBpKVxuICB9XG5cbiAgLy8gdGVuIHJvdW5kcyBvZiBtaXhpbmdcbiAgLy8gdW5jb21tZW50IHRoZSBEZWJ1Z1ByaW50IGNhbGxzIHRvIGxvZyB0aGUgY29tcHV0YXRpb25cbiAgLy8gYW5kIG1hdGNoIHRoZSBSRkMgc2FtcGxlIGRvY3VtZW50YXRpb25cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAgICAgICAgbVsxNl0nLCBtLCAzMilcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPScgKyBpICsgJykgIHZbMTZdJywgdiwgMzIpXG4gICAgQjJTX0coMCwgNCwgOCwgMTIsIG1bU0lHTUFbaSAqIDE2ICsgMF1dLCBtW1NJR01BW2kgKiAxNiArIDFdXSlcbiAgICBCMlNfRygxLCA1LCA5LCAxMywgbVtTSUdNQVtpICogMTYgKyAyXV0sIG1bU0lHTUFbaSAqIDE2ICsgM11dKVxuICAgIEIyU19HKDIsIDYsIDEwLCAxNCwgbVtTSUdNQVtpICogMTYgKyA0XV0sIG1bU0lHTUFbaSAqIDE2ICsgNV1dKVxuICAgIEIyU19HKDMsIDcsIDExLCAxNSwgbVtTSUdNQVtpICogMTYgKyA2XV0sIG1bU0lHTUFbaSAqIDE2ICsgN11dKVxuICAgIEIyU19HKDAsIDUsIDEwLCAxNSwgbVtTSUdNQVtpICogMTYgKyA4XV0sIG1bU0lHTUFbaSAqIDE2ICsgOV1dKVxuICAgIEIyU19HKDEsIDYsIDExLCAxMiwgbVtTSUdNQVtpICogMTYgKyAxMF1dLCBtW1NJR01BW2kgKiAxNiArIDExXV0pXG4gICAgQjJTX0coMiwgNywgOCwgMTMsIG1bU0lHTUFbaSAqIDE2ICsgMTJdXSwgbVtTSUdNQVtpICogMTYgKyAxM11dKVxuICAgIEIyU19HKDMsIDQsIDksIDE0LCBtW1NJR01BW2kgKiAxNiArIDE0XV0sIG1bU0lHTUFbaSAqIDE2ICsgMTVdXSlcbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPTEwKSB2WzE2XScsIHYsIDMyKVxuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBjdHguaFtpXSBePSB2W2ldIF4gdltpICsgOF1cbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJ2hbOF0nLCBjdHguaCwgMzIpXG59XG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJzIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDMyIGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gYmxha2Uyc0luaXQgKG91dGxlbiwga2V5KSB7XG4gIGlmICghKG91dGxlbiA+IDAgJiYgb3V0bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG91dHB1dCBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuICB2YXIga2V5bGVuID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgaWYgKGtleSAmJiAhKGtleWxlbiA+IDAgJiYga2V5bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGtleSBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuXG4gIHZhciBjdHggPSB7XG4gICAgaDogbmV3IFVpbnQzMkFycmF5KEJMQUtFMlNfSVYpLCAvLyBoYXNoIHN0YXRlXG4gICAgYjogbmV3IFVpbnQzMkFycmF5KDY0KSwgLy8gaW5wdXQgYmxvY2tcbiAgICBjOiAwLCAvLyBwb2ludGVyIHdpdGhpbiBibG9ja1xuICAgIHQ6IDAsIC8vIGlucHV0IGNvdW50XG4gICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICB9XG4gIGN0eC5oWzBdIF49IDB4MDEwMTAwMDAgXiAoa2V5bGVuIDw8IDgpIF4gb3V0bGVuXG5cbiAgaWYgKGtleWxlbiA+IDApIHtcbiAgICBibGFrZTJzVXBkYXRlKGN0eCwga2V5KVxuICAgIGN0eC5jID0gNjQgLy8gYXQgdGhlIGVuZFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UycyBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2Uyc1VwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSA2NCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMnNDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJzIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2Uyc0ZpbmFsIChjdHgpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuICB3aGlsZSAoY3R4LmMgPCA2NCkgeyAvLyBmaWxsIHVwIHdpdGggemVyb3NcbiAgICBjdHguYltjdHguYysrXSA9IDBcbiAgfVxuICBibGFrZTJzQ29tcHJlc3MoY3R4LCB0cnVlKSAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuXG4gIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGN0eC5vdXRsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gKGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKSkgJiAweEZGXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyUyBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyLCBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byAzMiBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG5mdW5jdGlvbiBibGFrZTJzIChpbnB1dCwga2V5LCBvdXRsZW4pIHtcbiAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgb3V0bGVuID0gb3V0bGVuIHx8IDMyXG4gIGlucHV0ID0gdXRpbC5ub3JtYWxpemVJbnB1dChpbnB1dClcblxuICAvLyBkbyB0aGUgbWF0aFxuICB2YXIgY3R4ID0gYmxha2Uyc0luaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMnNVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMnNGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJTIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDMyIGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMnNIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICB2YXIgb3V0cHV0ID0gYmxha2UycyhpbnB1dCwga2V5LCBvdXRsZW4pXG4gIHJldHVybiB1dGlsLnRvSGV4KG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMnM6IGJsYWtlMnMsXG4gIGJsYWtlMnNIZXg6IGJsYWtlMnNIZXgsXG4gIGJsYWtlMnNJbml0OiBibGFrZTJzSW5pdCxcbiAgYmxha2Uyc1VwZGF0ZTogYmxha2Uyc1VwZGF0ZSxcbiAgYmxha2Uyc0ZpbmFsOiBibGFrZTJzRmluYWxcbn1cbiIsInZhciBiMmIgPSByZXF1aXJlKCcuL2JsYWtlMmInKVxudmFyIGIycyA9IHJlcXVpcmUoJy4vYmxha2UycycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBibGFrZTJiOiBiMmIuYmxha2UyYixcbiAgYmxha2UyYkhleDogYjJiLmJsYWtlMmJIZXgsXG4gIGJsYWtlMmJJbml0OiBiMmIuYmxha2UyYkluaXQsXG4gIGJsYWtlMmJVcGRhdGU6IGIyYi5ibGFrZTJiVXBkYXRlLFxuICBibGFrZTJiRmluYWw6IGIyYi5ibGFrZTJiRmluYWwsXG4gIGJsYWtlMnM6IGIycy5ibGFrZTJzLFxuICBibGFrZTJzSGV4OiBiMnMuYmxha2Uyc0hleCxcbiAgYmxha2Uyc0luaXQ6IGIycy5ibGFrZTJzSW5pdCxcbiAgYmxha2Uyc1VwZGF0ZTogYjJzLmJsYWtlMnNVcGRhdGUsXG4gIGJsYWtlMnNGaW5hbDogYjJzLmJsYWtlMnNGaW5hbFxufVxuIiwidmFyIEVSUk9SX01TR19JTlBVVCA9ICdJbnB1dCBtdXN0IGJlIGFuIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG5cbi8vIEZvciBjb252ZW5pZW5jZSwgbGV0IHBlb3BsZSBoYXNoIGEgc3RyaW5nLCBub3QganVzdCBhIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0IChpbnB1dCkge1xuICB2YXIgcmV0XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXQgPSBpbnB1dFxuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIChpbnB1dCkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oaW5wdXQsICd1dGY4JykpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19JTlBVVClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleGFkZWNpbWFsIHN0cmluZ1xuLy8gRm9yIGV4YW1wbGUsIHRvSGV4KFsyNTUsIDAsIDI1NV0pIHJldHVybnMgXCJmZjAwZmZcIlxuZnVuY3Rpb24gdG9IZXggKGJ5dGVzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIDwgMTYgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KVxuICB9KS5qb2luKCcnKVxufVxuXG4vLyBDb252ZXJ0cyBhbnkgdmFsdWUgaW4gWzAuLi4yXjMyLTFdIHRvIGFuIDgtY2hhcmFjdGVyIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHVpbnQzMlRvSGV4ICh2YWwpIHtcbiAgcmV0dXJuICgweDEwMDAwMDAwMCArIHZhbCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKVxufVxuXG4vLyBGb3IgZGVidWdnaW5nOiBwcmludHMgb3V0IGhhc2ggc3RhdGUgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBSRkNcbi8vIHNhbXBsZSBjb21wdXRhdGlvbiBleGFjdGx5LCBzbyB0aGF0IHlvdSBjYW4gZGlmZlxuZnVuY3Rpb24gZGVidWdQcmludCAobGFiZWwsIGFyciwgc2l6ZSkge1xuICB2YXIgbXNnID0gJ1xcbicgKyBsYWJlbCArICcgPSAnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKHNpemUgPT09IDMyKSB7XG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gJyAnXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2kgKyAxXSkudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gNjQpIHtcbiAgICAgIG1zZyArPSB1aW50MzJUb0hleChhcnJbaSArIDFdKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplICcgKyBzaXplKVxuICAgIGlmIChpICUgNiA9PT0gNCkge1xuICAgICAgbXNnICs9ICdcXG4nICsgbmV3IEFycmF5KGxhYmVsLmxlbmd0aCArIDQpLmpvaW4oJyAnKVxuICAgIH0gZWxzZSBpZiAoaSA8IGFyci5sZW5ndGggLSAyKSB7XG4gICAgICBtc2cgKz0gJyAnXG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKG1zZylcbn1cblxuLy8gRm9yIHBlcmZvcm1hbmNlIHRlc3Rpbmc6IGdlbmVyYXRlcyBOIGJ5dGVzIG9mIGlucHV0LCBoYXNoZXMgTSB0aW1lc1xuLy8gTWVhc3VyZXMgYW5kIHByaW50cyBNQi9zZWNvbmQgaGFzaCBwZXJmb3JtYW5jZSBlYWNoIHRpbWVcbmZ1bmN0aW9uIHRlc3RTcGVlZCAoaGFzaEZuLCBOLCBNKSB7XG4gIHZhciBzdGFydE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICB2YXIgaW5wdXQgPSBuZXcgVWludDhBcnJheShOKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIGlucHV0W2ldID0gaSAlIDI1NlxuICB9XG4gIHZhciBnZW5NcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgcmFuZG9tIGlucHV0IGluICcgKyAoZ2VuTXMgLSBzdGFydE1zKSArICdtcycpXG4gIHN0YXJ0TXMgPSBnZW5Nc1xuXG4gIGZvciAoaSA9IDA7IGkgPCBNOyBpKyspIHtcbiAgICB2YXIgaGFzaEhleCA9IGhhc2hGbihpbnB1dClcbiAgICB2YXIgaGFzaE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB2YXIgbXMgPSBoYXNoTXMgLSBzdGFydE1zXG4gICAgc3RhcnRNcyA9IGhhc2hNc1xuICAgIGNvbnNvbGUubG9nKCdIYXNoZWQgaW4gJyArIG1zICsgJ21zOiAnICsgaGFzaEhleC5zdWJzdHJpbmcoMCwgMjApICsgJy4uLicpXG4gICAgY29uc29sZS5sb2coTWF0aC5yb3VuZChOIC8gKDEgPDwgMjApIC8gKG1zIC8gMTAwMCkgKiAxMDApIC8gMTAwICsgJyBNQiBQRVIgU0VDT05EJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9ybWFsaXplSW5wdXQ6IG5vcm1hbGl6ZUlucHV0LFxuICB0b0hleDogdG9IZXgsXG4gIGRlYnVnUHJpbnQ6IGRlYnVnUHJpbnQsXG4gIHRlc3RTcGVlZDogdGVzdFNwZWVkXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvLyAncGF0aCcgbW9kdWxlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSAob25seSB0aGUgcG9zaXggcGFydClcbi8vIHRyYW5zcGxpdGVkIHdpdGggQmFiZWxcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gIH1cbn1cblxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCBhbGxvd0Fib3ZlUm9vdCkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIHZhciBsYXN0U2xhc2ggPSAtMTtcbiAgdmFyIGRvdHMgPSAwO1xuICB2YXIgY29kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgY29kZSA9IDQ3IC8qLyovO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAvLyBOT09QXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiAvKi4qLyB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMgPSAnLi4nO1xuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJlcyArPSAnLycgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2IC8qLiovICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgdmFyIGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgKHBhdGhPYmplY3QubmFtZSB8fCAnJykgKyAocGF0aE9iamVjdC5leHQgfHwgJycpO1xuICBpZiAoIWRpcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChkaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG4gIHJldHVybiBkaXIgKyBzZXAgKyBiYXNlO1xufVxuXG52YXIgcG9zaXggPSB7XG4gIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgY3dkO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3dkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgcGF0aCA9IGN3ZDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcblxuICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3IC8qLyovO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsICFpc0Fic29sdXRlKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkgcGF0aCA9ICcuJztcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKSBwYXRoICs9ICcvJztcblxuICAgIGlmIChpc0Fic29sdXRlKSByZXR1cm4gJy8nICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICcuJztcbiAgICB2YXIgam9pbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBqb2luZWQgKz0gJy8nICsgYXJnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcblxuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBhc3NlcnRQYXRoKGZyb20pO1xuICAgIGFzc2VydFBhdGgodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICB0byA9IHBvc2l4LnJlc29sdmUodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIGZyb21TdGFydCA9IDE7XG4gICAgZm9yICg7IGZyb21TdGFydCA8IGZyb20ubGVuZ3RoOyArK2Zyb21TdGFydCkge1xuICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciB0b1N0YXJ0ID0gMTtcbiAgICBmb3IgKDsgdG9TdGFydCA8IHRvLmxlbmd0aDsgKyt0b1N0YXJ0KSB7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgdG9FbmQgPSB0by5sZW5ndGg7XG4gICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuXG4gICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgdmFyIGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vJzsgdG89Jy8nXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICB2YXIgdG9Db2RlID0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSk7XG4gICAgICBpZiAoZnJvbUNvZGUgIT09IHRvQ29kZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gNDcgLyovKi8pXG4gICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgIC8vIGFuZCBgZnJvbWBcbiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgb3V0ICs9ICcuLic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXQgKz0gJy8uLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gb3V0ICsgdG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApO1xuICAgIGVsc2Uge1xuICAgICAgdG9TdGFydCArPSBsYXN0Q29tbW9uU2VwO1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IDQ3IC8qLyovKVxuICAgICAgICArK3RvU3RhcnQ7XG4gICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCk7XG4gICAgfVxuICB9LFxuXG4gIF9tYWtlTG9uZzogZnVuY3Rpb24gX21ha2VMb25nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSByZXR1cm4gJy8vJztcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICB9LFxuXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aC5sZW5ndGggJiYgZXh0ID09PSBwYXRoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7ZWxzZSBpZiAoZW5kID09PSAtMSkgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcblxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChwYXRoT2JqZWN0KSB7XG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHBhdGhPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdCgnLycsIHBhdGhPYmplY3QpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgc3RhcnQ7XG4gICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgIHJldC5yb290ID0gJy8nO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcblxuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG5cbiAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSBzdGFydERvdCA9IGk7ZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHByZURvdFN0YXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIGVuZCk7ZWxzZSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhcnQgPiAwKSByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtlbHNlIGlmIChpc0Fic29sdXRlKSByZXQuZGlyID0gJy8nO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIHdpbjMyOiBudWxsLFxuICBwb3NpeDogbnVsbFxufTtcblxucG9zaXgucG9zaXggPSBwb3NpeDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpeDtcbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwiUG9zdE1lXCIsIFtcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kLmV4cG9ydHMpO1xuICAgIGdsb2JhbC5Qb3N0TWUgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgX2V4cG9ydHMuQ2hpbGRIYW5kc2hha2UgPSBDaGlsZEhhbmRzaGFrZTtcbiAgX2V4cG9ydHMuRGVidWdNZXNzZW5nZXIgPSBEZWJ1Z01lc3NlbmdlcjtcbiAgX2V4cG9ydHMuUGFyZW50SGFuZHNoYWtlID0gUGFyZW50SGFuZHNoYWtlO1xuICBfZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnO1xuICBfZXhwb3J0cy5Xb3JrZXJNZXNzZW5nZXIgPSBfZXhwb3J0cy5XaW5kb3dNZXNzZW5nZXIgPSBfZXhwb3J0cy5Qb3J0TWVzc2VuZ2VyID0gX2V4cG9ydHMuQ29uY3JldGVFbWl0dGVyID0gX2V4cG9ydHMuQmFyZU1lc3NlbmdlciA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbiAgdmFyIE1BUktFUiA9ICdAcG9zdC1tZSc7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pcXVlSWRGbigpIHtcbiAgICB2YXIgX19pZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZCA9IF9faWQ7XG4gICAgICBfX2lkICs9IDE7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEVtaXR0ZXJ9IGludGVyZmFjZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgdmFyIENvbmNyZXRlRW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVFbWl0dGVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNyZXRlRW1pdHRlcik7XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0RG9jIEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcn0gKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbmNyZXRlRW1pdHRlciwgW3tcbiAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgLyoqIHtAaW5oZXJpdERvYyBFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXJ9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnNbXCJkZWxldGVcIl0obGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgLyoqIHtAaW5oZXJpdERvYyBFbWl0dGVyLm9uY2V9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKiogQGludGVybmFsICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW1pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbGxMaXN0ZW5lcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fbGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25jcmV0ZUVtaXR0ZXI7XG4gIH0oKTtcblxuICBfZXhwb3J0cy5Db25jcmV0ZUVtaXR0ZXIgPSBDb25jcmV0ZUVtaXR0ZXI7XG4gIHZhciBNZXNzYWdlVHlwZTtcblxuICAoZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbXCJIYW5kc2hha2VSZXF1ZXN0XCJdID0gXCJoYW5kc2hha2UtcmVxdWVzdFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiSGFuZHNoYWtlUmVzcG9uc2VcIl0gPSBcImhhbmRzaGFrZS1yZXNwb25zZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ2FsbFwiXSA9IFwiY2FsbFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiUmVzcG9uc2VcIl0gPSBcInJlc3BvbnNlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkV2ZW50XCJdID0gXCJldmVudFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ2FsbGJhY2tcIl0gPSBcImNhbGxiYWNrXCI7XG4gIH0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7IC8vIE1lc3NhZ2UgQ3JlYXRvcnNcblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhbmRzaGFrZVJlcXVlc3RNZXNzYWdlKHNlc3Npb25JZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkhhbmRzaGFrZVJlcXVlc3QsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIYW5kc2hha2VSZXNwb25zZU1lc3NhZ2Uoc2Vzc2lvbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVzcG9uc2UsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDYWxsTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkNhbGwsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc01lc3NhZ2Uoc2Vzc2lvbklkLCByZXF1ZXN0SWQsIHJlc3VsdCwgZXJyb3IpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuUmVzcG9uc2UsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkXG4gICAgfTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lc3NhZ2UuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkNhbGxiYWNrLFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcbiAgICAgIGNhbGxiYWNrSWQ6IGNhbGxiYWNrSWQsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50TWVzc2FnZShzZXNzaW9uSWQsIGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkV2ZW50LFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9O1xuICB9IC8vIFR5cGUgR3VhcmRzXG5cblxuICBmdW5jdGlvbiBpc01lc3NhZ2UobSkge1xuICAgIHJldHVybiBtICYmIG0udHlwZSA9PT0gTUFSS0VSO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYW5kc2hha2VSZXF1ZXN0TWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFuZHNoYWtlUmVzcG9uc2VNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXNwb25zZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FsbE1lc3NhZ2UobSkge1xuICAgIHJldHVybiBpc01lc3NhZ2UobSkgJiYgbS5hY3Rpb24gPT09IE1lc3NhZ2VUeXBlLkNhbGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jlc3BvbnNlTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuUmVzcG9uc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NhbGxiYWNrTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuQ2FsbGJhY2s7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V2ZW50TWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2tFdmVudChyZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gXCJjYWxsYmFja19cIi5jb25jYXQocmVxdWVzdElkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZXNwb25zZUV2ZW50KHJlcXVlc3RJZCkge1xuICAgIHJldHVybiBcInJlc3BvbnNlX1wiLmNvbmNhdChyZXF1ZXN0SWQpO1xuICB9XG5cbiAgdmFyIERpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERpc3BhdGNoZXIpO1xuXG4gICAgZnVuY3Rpb24gRGlzcGF0Y2hlcihtZXNzZW5nZXIsIHNlc3Npb25JZCkge1xuICAgICAgdmFyIF90aGlzMjtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgICBfdGhpczIgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzMi51bmlxdWVJZCA9IGNyZWF0ZVVuaXF1ZUlkRm4oKTtcbiAgICAgIF90aGlzMi5tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICBfdGhpczIuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgX3RoaXMyLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXMyLm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXMyLm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKSk7XG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEaXNwYXRjaGVyLCBbe1xuICAgICAga2V5OiBcIm1lc3Nlbmdlckxpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2VuZ2VyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmICghaXNNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkICE9PSBkYXRhLnNlc3Npb25JZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhbGxNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KE1lc3NhZ2VUeXBlLkNhbGwsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVzcG9uc2VNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KG1ha2VSZXNwb25zZUV2ZW50KGRhdGEucmVxdWVzdElkKSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudE1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVR5cGUuRXZlbnQsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsbGJhY2tNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KG1ha2VDYWxsYmFja0V2ZW50KGRhdGEucmVxdWVzdElkKSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsbE9uUmVtb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbE9uUmVtb3RlKG1ldGhvZE5hbWUsIGFyZ3MsIHRyYW5zZmVyKSB7XG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSB0aGlzLnVuaXF1ZUlkKCk7XG4gICAgICAgIHZhciBjYWxsYmFja0V2ZW50ID0gbWFrZUNhbGxiYWNrRXZlbnQocmVxdWVzdElkKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlRXZlbnQgPSBtYWtlUmVzcG9uc2VFdmVudChyZXF1ZXN0SWQpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUNhbGxNZXNzYWdlKHRoaXMuc2Vzc2lvbklkLCByZXF1ZXN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FsbGJhY2tFdmVudDogY2FsbGJhY2tFdmVudCxcbiAgICAgICAgICByZXNwb25zZUV2ZW50OiByZXNwb25zZUV2ZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc3BvbmRUb1JlbW90ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3BvbmRUb1JlbW90ZShyZXF1ZXN0SWQsIHZhbHVlLCBlcnJvciwgdHJhbnNmZXIpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXNzYWdlID0gY3JlYXRlUmVzcG9uc01lc3NhZ2UodGhpcy5zZXNzaW9uSWQsIHJlcXVlc3RJZCwgdmFsdWUsIGVycm9yKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxsYmFja1RvUmVtb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbGJhY2tUb1JlbW90ZShyZXF1ZXN0SWQsIGNhbGxiYWNrSWQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjcmVhdGVDYWxsYmFja01lc3NhZ2UodGhpcy5zZXNzaW9uSWQsIHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncyk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbWl0VG9SZW1vdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0VG9SZW1vdGUoZXZlbnROYW1lLCBwYXlsb2FkLCB0cmFuc2Zlcikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUV2ZW50TWVzc2FnZSh0aGlzLnNlc3Npb25JZCwgZXZlbnROYW1lLCBwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERpc3BhdGNoZXI7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbmNyZXRlRW1pdHRlcjIpIHtcbiAgICBfaW5oZXJpdHMoUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcjIpO1xuXG4gICAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcik7XG5cbiAgICBmdW5jdGlvbiBQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyKG1lc3Nlbmdlciwgc2Vzc2lvbklkKSB7XG4gICAgICB2YXIgX3RoaXMzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcik7XG5cbiAgICAgIF90aGlzMyA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzMy5tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICBfdGhpczMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgX3RoaXMzLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXMzLm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXMzLm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSk7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyLCBbe1xuICAgICAga2V5OiBcIm1lc3Nlbmdlckxpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2VuZ2VyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmICghaXNNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkICE9PSBkYXRhLnNlc3Npb25JZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hhbmRzaGFrZVJlc3BvbnNlTWVzc2FnZShkYXRhKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChkYXRhLnNlc3Npb25JZCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdGlhdGVIYW5kc2hha2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWF0ZUhhbmRzaGFrZSgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjcmVhdGVIYW5kc2hha2VSZXF1ZXN0TWVzc2FnZSh0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uSWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcjtcbiAgfShDb25jcmV0ZUVtaXR0ZXIpO1xuXG4gIHZhciBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXIzKSB7XG4gICAgX2luaGVyaXRzKENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcjMpO1xuXG4gICAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyKTtcblxuICAgIGZ1bmN0aW9uIENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlcihtZXNzZW5nZXIpIHtcbiAgICAgIHZhciBfdGhpczQ7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIpO1xuXG4gICAgICBfdGhpczQgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgICBfdGhpczQubWVzc2VuZ2VyID0gbWVzc2VuZ2VyO1xuICAgICAgX3RoaXM0LnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXM0Lm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXM0Lm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczQpKSk7XG4gICAgICByZXR1cm4gX3RoaXM0O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIsIFt7XG4gICAgICBrZXk6IFwibWVzc2VuZ2VyTGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXNzZW5nZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKGlzSGFuZHNoYWtlUmVxdWVzdE1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWNjZXB0SGFuZHNoYWtlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0SGFuZHNoYWtlKHNlc3Npb25JZCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUhhbmRzaGFrZVJlc3BvbnNlTWVzc2FnZShzZXNzaW9uSWQpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNZXNzZW5nZXJMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXI7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgUHJveHlUeXBlO1xuXG4gIChmdW5jdGlvbiAoUHJveHlUeXBlKSB7XG4gICAgUHJveHlUeXBlW1wiQ2FsbGJhY2tcIl0gPSBcImNhbGxiYWNrXCI7XG4gIH0pKFByb3h5VHlwZSB8fCAoUHJveHlUeXBlID0ge30pKTtcblxuICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja1Byb3h5KGNhbGxiYWNrSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogTUFSS0VSLFxuICAgICAgcHJveHk6IFByb3h5VHlwZS5DYWxsYmFjayxcbiAgICAgIGNhbGxiYWNrSWQ6IGNhbGxiYWNrSWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWxsYmFja1Byb3h5KHApIHtcbiAgICByZXR1cm4gcCAmJiBwLnR5cGUgPT09IE1BUktFUiAmJiBwLnByb3h5ID09PSBQcm94eVR5cGUuQ2FsbGJhY2s7XG4gIH1cblxuICB2YXIgQ29uY3JldGVSZW1vdGVIYW5kbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXI0KSB7XG4gICAgX2luaGVyaXRzKENvbmNyZXRlUmVtb3RlSGFuZGxlLCBfQ29uY3JldGVFbWl0dGVyNCk7XG5cbiAgICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihDb25jcmV0ZVJlbW90ZUhhbmRsZSk7XG5cbiAgICBmdW5jdGlvbiBDb25jcmV0ZVJlbW90ZUhhbmRsZShkaXNwYXRjaGVyKSB7XG4gICAgICB2YXIgX3RoaXM1O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uY3JldGVSZW1vdGVIYW5kbGUpO1xuXG4gICAgICBfdGhpczUgPSBfc3VwZXI0LmNhbGwodGhpcyk7XG4gICAgICBfdGhpczUuX2Rpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgX3RoaXM1Ll9jYWxsVHJhbnNmZXIgPSB7fTtcblxuICAgICAgX3RoaXM1Ll9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoTWVzc2FnZVR5cGUuRXZlbnQsIF90aGlzNS5faGFuZGxlRXZlbnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNSkpKTtcblxuICAgICAgcmV0dXJuIF90aGlzNTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uY3JldGVSZW1vdGVIYW5kbGUsIFt7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q2FsbFRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FsbFRyYW5zZmVyKG1ldGhvZE5hbWUsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuX2NhbGxUcmFuc2ZlclttZXRob2ROYW1lXSA9IHRyYW5zZmVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbChtZXRob2ROYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUNhbGwobWV0aG9kTmFtZSwgYXJncyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImN1c3RvbUNhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21DYWxsKG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBzYW5pdGl6ZWRBcmdzID0gW107XG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gMDtcbiAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgc2FuaXRpemVkQXJncy5wdXNoKGNyZWF0ZUNhbGxiYWNrUHJveHkoY2FsbGJhY2tJZCkpO1xuICAgICAgICAgICAgICBjYWxsYmFja0lkICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYW5pdGl6ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaGFzQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3RlbmVyID0gZnVuY3Rpb24gY2FsbGJhY2tMaXN0ZW5lcihkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgICAgICAgYXJncyA9IGRhdGEuYXJncztcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW2NhbGxiYWNrSWRdLmFwcGx5KGNhbGxiYWNrcywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRyYW5zZmVyID0gb3B0aW9ucy50cmFuc2ZlcjtcblxuICAgICAgICAgIGlmICh0cmFuc2ZlciA9PT0gdW5kZWZpbmVkICYmIF90aGlzNi5fY2FsbFRyYW5zZmVyW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2JF9jYWxsVHJhbnNmZXI7XG5cbiAgICAgICAgICAgIHRyYW5zZmVyID0gKF90aGlzNiRfY2FsbFRyYW5zZmVyID0gX3RoaXM2Ll9jYWxsVHJhbnNmZXIpW21ldGhvZE5hbWVdLmFwcGx5KF90aGlzNiRfY2FsbFRyYW5zZmVyLCBzYW5pdGl6ZWRBcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RoaXM2JF9kaXNwYXRjaGVyJGNhID0gX3RoaXM2Ll9kaXNwYXRjaGVyLmNhbGxPblJlbW90ZShtZXRob2ROYW1lLCBzYW5pdGl6ZWRBcmdzLCB0cmFuc2ZlciksXG4gICAgICAgICAgICAgIGNhbGxiYWNrRXZlbnQgPSBfdGhpczYkX2Rpc3BhdGNoZXIkY2EuY2FsbGJhY2tFdmVudCxcbiAgICAgICAgICAgICAgcmVzcG9uc2VFdmVudCA9IF90aGlzNiRfZGlzcGF0Y2hlciRjYS5yZXNwb25zZUV2ZW50O1xuXG4gICAgICAgICAgaWYgKGhhc0NhbGxiYWNrcykge1xuICAgICAgICAgICAgX3RoaXM2Ll9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoY2FsbGJhY2tFdmVudCwgY2FsbGJhY2tMaXN0ZW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM2Ll9kaXNwYXRjaGVyLm9uY2UocmVzcG9uc2VFdmVudCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5fZGlzcGF0Y2hlci5yZW1vdmVFdmVudExpc3RlbmVyKGNhbGxiYWNrRXZlbnQsIGNhbGxiYWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0LFxuICAgICAgICAgICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cbiAgICAgICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRXZlbnQoZGF0YSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZGF0YS5ldmVudE5hbWUsXG4gICAgICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uY3JldGVSZW1vdGVIYW5kbGU7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgQ29uY3JldGVMb2NhbEhhbmRsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVMb2NhbEhhbmRsZShkaXNwYXRjaGVyLCBsb2NhbE1ldGhvZHMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25jcmV0ZUxvY2FsSGFuZGxlKTtcblxuICAgICAgdGhpcy5fZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICB0aGlzLl9tZXRob2RzID0gbG9jYWxNZXRob2RzO1xuICAgICAgdGhpcy5fcmV0dXJuVHJhbnNmZXIgPSB7fTtcbiAgICAgIHRoaXMuX2VtaXRUcmFuc2ZlciA9IHt9O1xuXG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoTWVzc2FnZVR5cGUuQ2FsbCwgdGhpcy5faGFuZGxlQ2FsbC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uY3JldGVMb2NhbEhhbmRsZSwgW3tcbiAgICAgIGtleTogXCJlbWl0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICB2YXIgdHJhbnNmZXIgPSBvcHRpb25zLnRyYW5zZmVyO1xuXG4gICAgICAgIGlmICh0cmFuc2ZlciA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2VtaXRUcmFuc2ZlcltldmVudE5hbWVdKSB7XG4gICAgICAgICAgdHJhbnNmZXIgPSB0aGlzLl9lbWl0VHJhbnNmZXJbZXZlbnROYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZW1pdFRvUmVtb3RlKGV2ZW50TmFtZSwgcGF5bG9hZCwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRNZXRob2RzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRNZXRob2RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNZXRob2QobWV0aG9kTmFtZSwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZHNbbWV0aG9kTmFtZV0gPSBtZXRob2Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFJldHVyblRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmV0dXJuVHJhbnNmZXIobWV0aG9kTmFtZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5fcmV0dXJuVHJhbnNmZXJbbWV0aG9kTmFtZV0gPSB0cmFuc2ZlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RW1pdFRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RW1pdFRyYW5zZmVyKGV2ZW50TmFtZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRyYW5zZmVyW2V2ZW50TmFtZV0gPSB0cmFuc2ZlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2FsbChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSBkYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSBkYXRhLm1ldGhvZE5hbWUsXG4gICAgICAgICAgICBhcmdzID0gZGF0YS5hcmdzO1xuICAgICAgICB2YXIgY2FsbE1ldGhvZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgX3RoaXM3JF9tZXRob2RzO1xuXG4gICAgICAgICAgdmFyIG1ldGhvZCA9IF90aGlzNy5fbWV0aG9kc1ttZXRob2ROYW1lXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGhlIG1ldGhvZCBcXFwiXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiXFxcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQuXCIpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlc2FuaXRpemVkQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxiYWNrUHJveHkoYXJnKSkge1xuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tJZCA9IGFyZy5jYWxsYmFja0lkO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzNy5fZGlzcGF0Y2hlci5jYWxsYmFja1RvUmVtb3RlKHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgoX3RoaXM3JF9tZXRob2RzID0gX3RoaXM3Ll9tZXRob2RzKVttZXRob2ROYW1lXS5hcHBseShfdGhpczckX21ldGhvZHMsIF90b0NvbnN1bWFibGVBcnJheShkZXNhbml0aXplZEFyZ3MpKSkudGhlbihyZXNvbHZlKVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsTWV0aG9kLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHZhciB0cmFuc2ZlcjtcblxuICAgICAgICAgIGlmIChfdGhpczcuX3JldHVyblRyYW5zZmVyW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICB0cmFuc2ZlciA9IF90aGlzNy5fcmV0dXJuVHJhbnNmZXJbbWV0aG9kTmFtZV0ocmVzdWx0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczcuX2Rpc3BhdGNoZXIucmVzcG9uZFRvUmVtb3RlKHJlcXVlc3RJZCwgcmVzdWx0LCB1bmRlZmluZWQsIHRyYW5zZmVyKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczcuX2Rpc3BhdGNoZXIucmVzcG9uZFRvUmVtb3RlKHJlcXVlc3RJZCwgdW5kZWZpbmVkLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25jcmV0ZUxvY2FsSGFuZGxlO1xuICB9KCk7XG5cbiAgdmFyIENvbmNyZXRlQ29ubmVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVDb25uZWN0aW9uKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNyZXRlQ29ubmVjdGlvbik7XG5cbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgdGhpcy5fbG9jYWxIYW5kbGUgPSBuZXcgQ29uY3JldGVMb2NhbEhhbmRsZShkaXNwYXRjaGVyLCBsb2NhbE1ldGhvZHMpO1xuICAgICAgdGhpcy5fcmVtb3RlSGFuZGxlID0gbmV3IENvbmNyZXRlUmVtb3RlSGFuZGxlKGRpc3BhdGNoZXIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb25jcmV0ZUNvbm5lY3Rpb24sIFt7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMucmVtb3RlSGFuZGxlKCkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibG9jYWxIYW5kbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbEhhbmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsSGFuZGxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdGVIYW5kbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdGVIYW5kbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVIYW5kbGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbmNyZXRlQ29ubmVjdGlvbjtcbiAgfSgpO1xuXG4gIHZhciB1bmlxdWVTZXNzaW9uSWQgPSBjcmVhdGVVbmlxdWVJZEZuKCk7XG5cbiAgdmFyIHJ1blVudGlsID0gZnVuY3Rpb24gcnVuVW50aWwod29ya2VyLCBjb25kaXRpb24sIHVuZnVsZmlsbGVkLCBtYXhBdHRlbXB0cywgYXR0ZW1wdEludGVydmFsKSB7XG4gICAgdmFyIGF0dGVtcHQgPSAwO1xuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbigpICYmIChhdHRlbXB0IDwgbWF4QXR0ZW1wdHMgfHwgbWF4QXR0ZW1wdHMgPCAxKSkge1xuICAgICAgICB3b3JrZXIoKTtcbiAgICAgICAgYXR0ZW1wdCArPSAxO1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCBhdHRlbXB0SW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIGlmICghY29uZGl0aW9uKCkgJiYgYXR0ZW1wdCA+PSBtYXhBdHRlbXB0cyAmJiBtYXhBdHRlbXB0cyA+PSAxKSB7XG4gICAgICAgIHVuZnVsZmlsbGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZuKCk7XG4gIH07XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgaGFuZHNoYWtlIGZyb20gdGhlIFBhcmVudCBzaWRlXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzZW5nZXIgLSBUaGUgTWVzc2VuZ2VyIHVzZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvdGhlciBlbmRcbiAgICogQHBhcmFtIGxvY2FsTWV0aG9kcyAtIFRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBleHBvc2VkIHRvIHRoZSBvdGhlciBlbmRcbiAgICogQHBhcmFtIG1heEF0dGVtcHRzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGhhbmRzaGFrZSBhdHRlbXB0c1xuICAgKiBAcGFyYW0gYXR0ZW1wdHNJbnRlcnZhbCAtIFRoZSBpbnRlcnZhbCBiZXR3ZWVuIGhhbmRzaGFrZSBhdHRlbXB0c1xuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdG8gYW4gYWN0aXZlIHtAbGluayBDb25uZWN0aW9ufSB0byB0aGUgb3RoZXIgZW5kXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBmdW5jdGlvbiBQYXJlbnRIYW5kc2hha2UobWVzc2VuZ2VyKSB7XG4gICAgdmFyIGxvY2FsTWV0aG9kcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIG1heEF0dGVtcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1O1xuICAgIHZhciBhdHRlbXB0c0ludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxMDA7XG4gICAgdmFyIHRoaXNTZXNzaW9uSWQgPSB1bmlxdWVTZXNzaW9uSWQoKTtcbiAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBoYW5kc2hha2VEaXNwYXRjaGVyID0gbmV3IFBhcmVudEhhbmRzaGFrZURpc3BhdGNoZXIobWVzc2VuZ2VyLCB0aGlzU2Vzc2lvbklkKTtcbiAgICAgIGhhbmRzaGFrZURpc3BhdGNoZXIub25jZSh0aGlzU2Vzc2lvbklkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLmNsb3NlKCk7XG4gICAgICAgIHZhciBzZXNzaW9uSWQgPSByZXNwb25zZS5zZXNzaW9uSWQ7XG4gICAgICAgIHZhciBkaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIobWVzc2VuZ2VyLCBzZXNzaW9uSWQpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBDb25jcmV0ZUNvbm5lY3Rpb24oZGlzcGF0Y2hlciwgbG9jYWxNZXRob2RzKTtcbiAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcnVuVW50aWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFuZHNoYWtlRGlzcGF0Y2hlci5pbml0aWF0ZUhhbmRzaGFrZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGVkO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkhhbmRzaGFrZSBmYWlsZWQsIHJlYWNoZWQgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHNcIikpO1xuICAgICAgfSwgbWF4QXR0ZW1wdHMsIGF0dGVtcHRzSW50ZXJ2YWwpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgaGFuZHNoYWtlIGZyb20gdGhlIENoaWxkIHNpZGVcbiAgICpcbiAgICogQHBhcmFtIG1lc3NlbmdlciAtIFRoZSBNZXNzZW5nZXIgdXNlZCB0byBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIGZyb20gdGhlIG90aGVyIGVuZFxuICAgKiBAcGFyYW0gbG9jYWxNZXRob2RzIC0gVGhlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIG90aGVyIGVuZFxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdG8gYW4gYWN0aXZlIHtAbGluayBDb25uZWN0aW9ufSB0byB0aGUgb3RoZXIgZW5kXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBmdW5jdGlvbiBDaGlsZEhhbmRzaGFrZShtZXNzZW5nZXIpIHtcbiAgICB2YXIgbG9jYWxNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGhhbmRzaGFrZURpc3BhdGNoZXIgPSBuZXcgQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyKG1lc3Nlbmdlcik7XG4gICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLm9uY2UoTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHNlc3Npb25JZCA9IHJlc3BvbnNlLnNlc3Npb25JZDtcbiAgICAgICAgaGFuZHNoYWtlRGlzcGF0Y2hlci5hY2NlcHRIYW5kc2hha2Uoc2Vzc2lvbklkKTtcbiAgICAgICAgaGFuZHNoYWtlRGlzcGF0Y2hlci5jbG9zZSgpO1xuICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKG1lc3Nlbmdlciwgc2Vzc2lvbklkKTtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgQ29uY3JldGVDb25uZWN0aW9uKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcyk7XG4gICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhY2NlcHRhYmxlTWVzc2FnZUV2ZW50ID0gZnVuY3Rpb24gYWNjZXB0YWJsZU1lc3NhZ2VFdmVudChldmVudCwgcmVtb3RlV2luZG93LCBhY2NlcHRlZE9yaWdpbikge1xuICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UsXG4gICAgICAgIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbjtcblxuICAgIGlmIChzb3VyY2UgIT09IHJlbW90ZVdpbmRvdykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGFjY2VwdGVkT3JpZ2luICYmIGFjY2VwdGVkT3JpZ2luICE9PSAnKicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIE1lc3Nlbmdlcn0gdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIGFub3RoZXIgV2luZG93LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIFdpbmRvd01lc3NlbmdlciA9IGZ1bmN0aW9uIFdpbmRvd01lc3NlbmdlcihfcmVmKSB7XG4gICAgdmFyIGxvY2FsV2luZG93ID0gX3JlZi5sb2NhbFdpbmRvdyxcbiAgICAgICAgcmVtb3RlV2luZG93ID0gX3JlZi5yZW1vdGVXaW5kb3csXG4gICAgICAgIHJlbW90ZU9yaWdpbiA9IF9yZWYucmVtb3RlT3JpZ2luO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpbmRvd01lc3Nlbmdlcik7XG5cbiAgICBsb2NhbFdpbmRvdyA9IGxvY2FsV2luZG93IHx8IHdpbmRvdztcblxuICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXIpIHtcbiAgICAgIHJlbW90ZVdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCByZW1vdGVPcmlnaW4sIHRyYW5zZmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHZhciBvdXRlckxpc3RlbmVyID0gZnVuY3Rpb24gb3V0ZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoYWNjZXB0YWJsZU1lc3NhZ2VFdmVudChldmVudCwgcmVtb3RlV2luZG93LCByZW1vdGVPcmlnaW4pKSB7XG4gICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsb2NhbFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG5cbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBsb2NhbFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gICAgfTtcbiAgfTtcbiAgLyoqIEBwdWJsaWMgKi9cblxuXG4gIF9leHBvcnRzLldpbmRvd01lc3NlbmdlciA9IFdpbmRvd01lc3NlbmdlcjtcblxuICB2YXIgQmFyZU1lc3NlbmdlciA9IGZ1bmN0aW9uIEJhcmVNZXNzZW5nZXIocG9zdGFibGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyZU1lc3Nlbmdlcik7XG5cbiAgICB0aGlzLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciB0cmFuc2ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICBwb3N0YWJsZS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgb3V0ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIG91dGVyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgcG9zdGFibGUuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG91dGVyTGlzdGVuZXIpO1xuXG4gICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgcG9zdGFibGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG91dGVyTGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBNZXNzZW5nZXJ9IHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCBhIFdvcmtlci5cbiAgICpcbiAgICogVGFrZXMgYSB7QGxpbmsgUG9zdGFibGV9IHJlcHJlc2VudGluZyB0aGUgYFdvcmtlcmAgKHdoZW4gY2FsbGluZyBmcm9tXG4gICAqIHRoZSBwYXJlbnQgY29udGV4dCkgb3IgdGhlIGBzZWxmYCBgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVgIG9iamVjdFxuICAgKiAod2hlbiBjYWxsaW5nIGZyb20gdGhlIGNoaWxkIGNvbnRleHQpLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgX2V4cG9ydHMuQmFyZU1lc3NlbmdlciA9IEJhcmVNZXNzZW5nZXI7XG5cbiAgdmFyIFdvcmtlck1lc3NlbmdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JhcmVNZXNzZW5nZXIpIHtcbiAgICBfaW5oZXJpdHMoV29ya2VyTWVzc2VuZ2VyLCBfQmFyZU1lc3Nlbmdlcik7XG5cbiAgICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihXb3JrZXJNZXNzZW5nZXIpO1xuXG4gICAgZnVuY3Rpb24gV29ya2VyTWVzc2VuZ2VyKF9yZWYyKSB7XG4gICAgICB2YXIgd29ya2VyID0gX3JlZjIud29ya2VyO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV29ya2VyTWVzc2VuZ2VyKTtcblxuICAgICAgcmV0dXJuIF9zdXBlcjUuY2FsbCh0aGlzLCB3b3JrZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBXb3JrZXJNZXNzZW5nZXI7XG4gIH0oQmFyZU1lc3Nlbmdlcik7XG4gIC8qKlxuICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBNZXNzZW5nZXJ9IHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCBhIE1lc3NhZ2VQb3J0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgX2V4cG9ydHMuV29ya2VyTWVzc2VuZ2VyID0gV29ya2VyTWVzc2VuZ2VyO1xuXG4gIHZhciBQb3J0TWVzc2VuZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyZU1lc3NlbmdlcjIpIHtcbiAgICBfaW5oZXJpdHMoUG9ydE1lc3NlbmdlciwgX0JhcmVNZXNzZW5nZXIyKTtcblxuICAgIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKFBvcnRNZXNzZW5nZXIpO1xuXG4gICAgZnVuY3Rpb24gUG9ydE1lc3NlbmdlcihfcmVmMykge1xuICAgICAgdmFyIHBvcnQgPSBfcmVmMy5wb3J0O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9ydE1lc3Nlbmdlcik7XG5cbiAgICAgIHBvcnQuc3RhcnQoKTtcbiAgICAgIHJldHVybiBfc3VwZXI2LmNhbGwodGhpcywgcG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBvcnRNZXNzZW5nZXI7XG4gIH0oQmFyZU1lc3Nlbmdlcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2dnZXIgZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSB3aWxsIGJlIHByZXBlbmRlZCB0byBhbGwgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGxvZ2dlciBmdW5jdGlvblxuICAgKiBAcGFyYW0gbG9nIC0gVGhlIHVuZGVybHlpbmcgbG9nZ2VyIChgY29uc29sZS5sb2dgIGJ5IGRlZmF1bHQpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICovXG5cblxuICBfZXhwb3J0cy5Qb3J0TWVzc2VuZ2VyID0gUG9ydE1lc3NlbmdlcjtcblxuICBmdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UsIGxvZykge1xuICAgIGxvZyA9IGxvZyB8fCBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBkYXRhW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIGxvZy5hcHBseSh2b2lkIDAsIFtuYW1lc3BhY2VdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVjb3JhdGUgYSB7QGxpbmsgTWVzc2VuZ2VyfSBzbyB0aGF0IGl0IHdpbGwgbG9nIGFueSBtZXNzYWdlIGV4Y2hhbmdlZFxuICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIE1lc3NlbmdlciB0aGF0IHdpbGwgYmUgZGVjb3JhdGVkXG4gICAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nZ2VyIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWNlaXZlIGVhY2ggbWVzc2FnZVxuICAgKiBAcmV0dXJucyBBIGRlY29yYXRlZCBNZXNzZW5nZXJcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIERlYnVnTWVzc2VuZ2VyKG1lc3NlbmdlciwgbG9nKSB7XG4gICAgbG9nID0gbG9nIHx8IGRlYnVnKCdwb3N0LW1lJyk7XG5cbiAgICB2YXIgZGVidWdMaXN0ZW5lciA9IGZ1bmN0aW9uIGRlYnVnTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIGxvZygn4qyF77iPIHJlY2VpdmVkIG1lc3NhZ2UnLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgbWVzc2VuZ2VyLmFkZE1lc3NhZ2VMaXN0ZW5lcihkZWJ1Z0xpc3RlbmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKSB7XG4gICAgICAgIGxvZygn4p6h77iPIHNlbmRpbmcgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICBtZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfSxcbiAgICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBtZXNzZW5nZXIuYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIlwidXNlIHN0cmljdFwiO3ZhciBzamNsPXtjaXBoZXI6e30saGFzaDp7fSxrZXlleGNoYW5nZTp7fSxtb2RlOnt9LG1pc2M6e30sY29kZWM6e30sZXhjZXB0aW9uOntjb3JydXB0OmZ1bmN0aW9uKGEpe3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkNPUlJVUFQ6IFwiK3RoaXMubWVzc2FnZX07dGhpcy5tZXNzYWdlPWF9LGludmFsaWQ6ZnVuY3Rpb24oYSl7dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiSU5WQUxJRDogXCIrdGhpcy5tZXNzYWdlfTt0aGlzLm1lc3NhZ2U9YX0sYnVnOmZ1bmN0aW9uKGEpe3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkJVRzogXCIrdGhpcy5tZXNzYWdlfTt0aGlzLm1lc3NhZ2U9YX0sbm90UmVhZHk6ZnVuY3Rpb24oYSl7dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTk9UIFJFQURZOiBcIit0aGlzLm1lc3NhZ2V9O3RoaXMubWVzc2FnZT1hfX19O1xuc2pjbC5jaXBoZXIuYWVzPWZ1bmN0aW9uKGEpe3RoaXMuc1swXVswXVswXXx8dGhpcy5PKCk7dmFyIGIsYyxkLGUsZj10aGlzLnNbMF1bNF0sZz10aGlzLnNbMV07Yj1hLmxlbmd0aDt2YXIgaD0xO2lmKDQhPT1iJiY2IT09YiYmOCE9PWIpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJpbnZhbGlkIGFlcyBrZXkgc2l6ZVwiKTt0aGlzLmI9W2Q9YS5zbGljZSgwKSxlPVtdXTtmb3IoYT1iO2E8NCpiKzI4O2ErKyl7Yz1kW2EtMV07aWYoMD09PWElYnx8OD09PWImJjQ9PT1hJWIpYz1mW2M+Pj4yNF08PDI0XmZbYz4+MTYmMjU1XTw8MTZeZltjPj44JjI1NV08PDheZltjJjI1NV0sMD09PWElYiYmKGM9Yzw8OF5jPj4+MjReaDw8MjQsaD1oPDwxXjI4MyooaD4+NykpO2RbYV09ZFthLWJdXmN9Zm9yKGI9MDthO2IrKyxhLS0pYz1kW2ImMz9hOmEtNF0sZVtiXT00Pj1hfHw0PmI/YzpnWzBdW2ZbYz4+PjI0XV1eZ1sxXVtmW2M+PjE2JjI1NV1dXmdbMl1bZltjPj44JjI1NV1dXmdbM11bZltjJlxuMjU1XV19O1xuc2pjbC5jaXBoZXIuYWVzLnByb3RvdHlwZT17ZW5jcnlwdDpmdW5jdGlvbihhKXtyZXR1cm4gdCh0aGlzLGEsMCl9LGRlY3J5cHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHQodGhpcyxhLDEpfSxzOltbW10sW10sW10sW10sW11dLFtbXSxbXSxbXSxbXSxbXV1dLE86ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNbMF0sYj10aGlzLnNbMV0sYz1hWzRdLGQ9Yls0XSxlLGYsZyxoPVtdLGs9W10sbCxuLG0scDtmb3IoZT0wOzB4MTAwPmU7ZSsrKWtbKGhbZV09ZTw8MV4yODMqKGU+PjcpKV5lXT1lO2ZvcihmPWc9MDshY1tmXTtmXj1sfHwxLGc9a1tnXXx8MSlmb3IobT1nXmc8PDFeZzw8Ml5nPDwzXmc8PDQsbT1tPj44Xm0mMjU1Xjk5LGNbZl09bSxkW21dPWYsbj1oW2U9aFtsPWhbZl1dXSxwPTB4MTAxMDEwMSpuXjB4MTAwMDEqZV4weDEwMSpsXjB4MTAxMDEwMCpmLG49MHgxMDEqaFttXV4weDEwMTAxMDAqbSxlPTA7ND5lO2UrKylhW2VdW2ZdPW49bjw8MjRebj4+PjgsYltlXVttXT1wPXA8PDI0XnA+Pj44O2ZvcihlPVxuMDs1PmU7ZSsrKWFbZV09YVtlXS5zbGljZSgwKSxiW2VdPWJbZV0uc2xpY2UoMCl9fTtcbmZ1bmN0aW9uIHQoYSxiLGMpe2lmKDQhPT1iLmxlbmd0aCl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImludmFsaWQgYWVzIGJsb2NrIHNpemVcIik7dmFyIGQ9YS5iW2NdLGU9YlswXV5kWzBdLGY9YltjPzM6MV1eZFsxXSxnPWJbMl1eZFsyXTtiPWJbYz8xOjNdXmRbM107dmFyIGgsayxsLG49ZC5sZW5ndGgvNC0yLG0scD00LHI9WzAsMCwwLDBdO2g9YS5zW2NdO2E9aFswXTt2YXIgcT1oWzFdLHY9aFsyXSx3PWhbM10seD1oWzRdO2ZvcihtPTA7bTxuO20rKyloPWFbZT4+PjI0XV5xW2Y+PjE2JjI1NV1edltnPj44JjI1NV1ed1tiJjI1NV1eZFtwXSxrPWFbZj4+PjI0XV5xW2c+PjE2JjI1NV1edltiPj44JjI1NV1ed1tlJjI1NV1eZFtwKzFdLGw9YVtnPj4+MjRdXnFbYj4+MTYmMjU1XV52W2U+PjgmMjU1XV53W2YmMjU1XV5kW3ArMl0sYj1hW2I+Pj4yNF1ecVtlPj4xNiYyNTVdXnZbZj4+OCYyNTVdXndbZyYyNTVdXmRbcCszXSxwKz00LGU9aCxmPWssZz1sO2ZvcihtPVxuMDs0Pm07bSsrKXJbYz8zJi1tOm1dPXhbZT4+PjI0XTw8MjReeFtmPj4xNiYyNTVdPDwxNl54W2c+PjgmMjU1XTw8OF54W2ImMjU1XV5kW3ArK10saD1lLGU9ZixmPWcsZz1iLGI9aDtyZXR1cm4gcn1cbnNqY2wuYml0QXJyYXk9e2JpdFNsaWNlOmZ1bmN0aW9uKGEsYixjKXthPXNqY2wuYml0QXJyYXkuJChhLnNsaWNlKGIvMzIpLDMyLShiJjMxKSkuc2xpY2UoMSk7cmV0dXJuIHZvaWQgMD09PWM/YTpzamNsLmJpdEFycmF5LmNsYW1wKGEsYy1iKX0sZXh0cmFjdDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9TWF0aC5mbG9vcigtYi1jJjMxKTtyZXR1cm4oKGIrYy0xXmIpJi0zMj9hW2IvMzJ8MF08PDMyLWReYVtiLzMyKzF8MF0+Pj5kOmFbYi8zMnwwXT4+PmQpJigxPDxjKS0xfSxjb25jYXQ6ZnVuY3Rpb24oYSxiKXtpZigwPT09YS5sZW5ndGh8fDA9PT1iLmxlbmd0aClyZXR1cm4gYS5jb25jYXQoYik7dmFyIGM9YVthLmxlbmd0aC0xXSxkPXNqY2wuYml0QXJyYXkuZ2V0UGFydGlhbChjKTtyZXR1cm4gMzI9PT1kP2EuY29uY2F0KGIpOnNqY2wuYml0QXJyYXkuJChiLGQsY3wwLGEuc2xpY2UoMCxhLmxlbmd0aC0xKSl9LGJpdExlbmd0aDpmdW5jdGlvbihhKXt2YXIgYj1hLmxlbmd0aDtyZXR1cm4gMD09PVxuYj8wOjMyKihiLTEpK3NqY2wuYml0QXJyYXkuZ2V0UGFydGlhbChhW2ItMV0pfSxjbGFtcDpmdW5jdGlvbihhLGIpe2lmKDMyKmEubGVuZ3RoPGIpcmV0dXJuIGE7YT1hLnNsaWNlKDAsTWF0aC5jZWlsKGIvMzIpKTt2YXIgYz1hLmxlbmd0aDtiPWImMzE7MDxjJiZiJiYoYVtjLTFdPXNqY2wuYml0QXJyYXkucGFydGlhbChiLGFbYy0xXSYyMTQ3NDgzNjQ4Pj5iLTEsMSkpO3JldHVybiBhfSxwYXJ0aWFsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gMzI9PT1hP2I6KGM/YnwwOmI8PDMyLWEpKzB4MTAwMDAwMDAwMDAqYX0sZ2V0UGFydGlhbDpmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZChhLzB4MTAwMDAwMDAwMDApfHwzMn0sZXF1YWw6ZnVuY3Rpb24oYSxiKXtpZihzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKSE9PXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGIpKXJldHVybiExO3ZhciBjPTAsZDtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWN8PWFbZF1eYltkXTtyZXR1cm4gMD09PVxuY30sJDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZTtlPTA7Zm9yKHZvaWQgMD09PWQmJihkPVtdKTszMjw9YjtiLT0zMilkLnB1c2goYyksYz0wO2lmKDA9PT1iKXJldHVybiBkLmNvbmNhdChhKTtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKWQucHVzaChjfGFbZV0+Pj5iKSxjPWFbZV08PDMyLWI7ZT1hLmxlbmd0aD9hW2EubGVuZ3RoLTFdOjA7YT1zamNsLmJpdEFycmF5LmdldFBhcnRpYWwoZSk7ZC5wdXNoKHNqY2wuYml0QXJyYXkucGFydGlhbChiK2EmMzEsMzI8YithP2M6ZC5wb3AoKSwxKSk7cmV0dXJuIGR9LGk6ZnVuY3Rpb24oYSxiKXtyZXR1cm5bYVswXV5iWzBdLGFbMV1eYlsxXSxhWzJdXmJbMl0sYVszXV5iWzNdXX0sYnl0ZXN3YXBNOmZ1bmN0aW9uKGEpe3ZhciBiLGM7Zm9yKGI9MDtiPGEubGVuZ3RoOysrYiljPWFbYl0sYVtiXT1jPj4+MjR8Yz4+PjgmMHhmZjAwfChjJjB4ZmYwMCk8PDh8Yzw8MjQ7cmV0dXJuIGF9fTtcbnNqY2wuY29kZWMudXRmOFN0cmluZz17ZnJvbUJpdHM6ZnVuY3Rpb24oYSl7dmFyIGI9XCJcIixjPXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGEpLGQsZTtmb3IoZD0wO2Q8Yy84O2QrKykwPT09KGQmMykmJihlPWFbZC80XSksYis9U3RyaW5nLmZyb21DaGFyQ29kZShlPj4+OD4+Pjg+Pj44KSxlPDw9ODtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShiKSl9LHRvQml0czpmdW5jdGlvbihhKXthPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhKSk7dmFyIGI9W10sYyxkPTA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKylkPWQ8PDh8YS5jaGFyQ29kZUF0KGMpLDM9PT0oYyYzKSYmKGIucHVzaChkKSxkPTApO2MmMyYmYi5wdXNoKHNqY2wuYml0QXJyYXkucGFydGlhbCg4KihjJjMpLGQpKTtyZXR1cm4gYn19O1xuc2pjbC5jb2RlYy5oZXg9e2Zyb21CaXRzOmZ1bmN0aW9uKGEpe3ZhciBiPVwiXCIsYztmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWIrPSgoYVtjXXwwKSsweGYwMDAwMDAwMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cig0KTtyZXR1cm4gYi5zdWJzdHIoMCxzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKS80KX0sdG9CaXRzOmZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZDthPWEucmVwbGFjZSgvXFxzfDB4L2csXCJcIik7ZD1hLmxlbmd0aDthPWErXCIwMDAwMDAwMFwiO2ZvcihiPTA7YjxhLmxlbmd0aDtiKz04KWMucHVzaChwYXJzZUludChhLnN1YnN0cihiLDgpLDE2KV4wKTtyZXR1cm4gc2pjbC5iaXRBcnJheS5jbGFtcChjLDQqZCl9fTtcbnNqY2wuY29kZWMuYmFzZTMyPXtCOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIixYOlwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIixCSVRTOjMyLEJBU0U6NSxSRU1BSU5JTkc6MjcsZnJvbUJpdHM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXNqY2wuY29kZWMuYmFzZTMyLkJBU0UsZT1zamNsLmNvZGVjLmJhc2UzMi5SRU1BSU5JTkcsZj1cIlwiLGc9MCxoPXNqY2wuY29kZWMuYmFzZTMyLkIsaz0wLGw9c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYSk7YyYmKGg9c2pjbC5jb2RlYy5iYXNlMzIuWCk7Zm9yKGM9MDtmLmxlbmd0aCpkPGw7KWYrPWguY2hhckF0KChrXmFbY10+Pj5nKT4+PmUpLGc8ZD8oaz1hW2NdPDxkLWcsZys9ZSxjKyspOihrPDw9ZCxnLT1kKTtmb3IoO2YubGVuZ3RoJjcmJiFiOylmKz1cIj1cIjtyZXR1cm4gZn0sdG9CaXRzOmZ1bmN0aW9uKGEsYil7YT1hLnJlcGxhY2UoL1xcc3w9L2csXCJcIikudG9VcHBlckNhc2UoKTt2YXIgYz1zamNsLmNvZGVjLmJhc2UzMi5CSVRTLFxuZD1zamNsLmNvZGVjLmJhc2UzMi5CQVNFLGU9c2pjbC5jb2RlYy5iYXNlMzIuUkVNQUlOSU5HLGY9W10sZyxoPTAsaz1zamNsLmNvZGVjLmJhc2UzMi5CLGw9MCxuLG09XCJiYXNlMzJcIjtiJiYoaz1zamNsLmNvZGVjLmJhc2UzMi5YLG09XCJiYXNlMzJoZXhcIik7Zm9yKGc9MDtnPGEubGVuZ3RoO2crKyl7bj1rLmluZGV4T2YoYS5jaGFyQXQoZykpO2lmKDA+bil7aWYoIWIpdHJ5e3JldHVybiBzamNsLmNvZGVjLmJhc2UzMmhleC50b0JpdHMoYSl9Y2F0Y2gocCl7fXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwidGhpcyBpc24ndCBcIittK1wiIVwiKTt9aD5lPyhoLT1lLGYucHVzaChsXm4+Pj5oKSxsPW48PGMtaCk6KGgrPWQsbF49bjw8Yy1oKX1oJjU2JiZmLnB1c2goc2pjbC5iaXRBcnJheS5wYXJ0aWFsKGgmNTYsbCwxKSk7cmV0dXJuIGZ9fTtcbnNqY2wuY29kZWMuYmFzZTMyaGV4PXtmcm9tQml0czpmdW5jdGlvbihhLGIpe3JldHVybiBzamNsLmNvZGVjLmJhc2UzMi5mcm9tQml0cyhhLGIsMSl9LHRvQml0czpmdW5jdGlvbihhKXtyZXR1cm4gc2pjbC5jb2RlYy5iYXNlMzIudG9CaXRzKGEsMSl9fTtcbnNqY2wuY29kZWMuYmFzZTY0PXtCOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLGZyb21CaXRzOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1cIlwiLGU9MCxmPXNqY2wuY29kZWMuYmFzZTY0LkIsZz0wLGg9c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYSk7YyYmKGY9Zi5zdWJzdHIoMCw2MikrXCItX1wiKTtmb3IoYz0wOzYqZC5sZW5ndGg8aDspZCs9Zi5jaGFyQXQoKGdeYVtjXT4+PmUpPj4+MjYpLDY+ZT8oZz1hW2NdPDw2LWUsZSs9MjYsYysrKTooZzw8PTYsZS09Nik7Zm9yKDtkLmxlbmd0aCYzJiYhYjspZCs9XCI9XCI7cmV0dXJuIGR9LHRvQml0czpmdW5jdGlvbihhLGIpe2E9YS5yZXBsYWNlKC9cXHN8PS9nLFwiXCIpO3ZhciBjPVtdLGQsZT0wLGY9c2pjbC5jb2RlYy5iYXNlNjQuQixnPTAsaDtiJiYoZj1mLnN1YnN0cigwLDYyKStcIi1fXCIpO2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspe2g9Zi5pbmRleE9mKGEuY2hhckF0KGQpKTtcbmlmKDA+aCl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcInRoaXMgaXNuJ3QgYmFzZTY0IVwiKTsyNjxlPyhlLT0yNixjLnB1c2goZ15oPj4+ZSksZz1oPDwzMi1lKTooZSs9NixnXj1oPDwzMi1lKX1lJjU2JiZjLnB1c2goc2pjbC5iaXRBcnJheS5wYXJ0aWFsKGUmNTYsZywxKSk7cmV0dXJuIGN9fTtzamNsLmNvZGVjLmJhc2U2NHVybD17ZnJvbUJpdHM6ZnVuY3Rpb24oYSl7cmV0dXJuIHNqY2wuY29kZWMuYmFzZTY0LmZyb21CaXRzKGEsMSwxKX0sdG9CaXRzOmZ1bmN0aW9uKGEpe3JldHVybiBzamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoYSwxKX19O3NqY2wuaGFzaC5zaGEyNTY9ZnVuY3Rpb24oYSl7dGhpcy5iWzBdfHx0aGlzLk8oKTthPyh0aGlzLkY9YS5GLnNsaWNlKDApLHRoaXMuQT1hLkEuc2xpY2UoMCksdGhpcy5sPWEubCk6dGhpcy5yZXNldCgpfTtzamNsLmhhc2guc2hhMjU2Lmhhc2g9ZnVuY3Rpb24oYSl7cmV0dXJuKG5ldyBzamNsLmhhc2guc2hhMjU2KS51cGRhdGUoYSkuZmluYWxpemUoKX07XG5zamNsLmhhc2guc2hhMjU2LnByb3RvdHlwZT17YmxvY2tTaXplOjUxMixyZXNldDpmdW5jdGlvbigpe3RoaXMuRj10aGlzLlkuc2xpY2UoMCk7dGhpcy5BPVtdO3RoaXMubD0wO3JldHVybiB0aGlzfSx1cGRhdGU6ZnVuY3Rpb24oYSl7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1zamNsLmNvZGVjLnV0ZjhTdHJpbmcudG9CaXRzKGEpKTt2YXIgYixjPXRoaXMuQT1zamNsLmJpdEFycmF5LmNvbmNhdCh0aGlzLkEsYSk7Yj10aGlzLmw7YT10aGlzLmw9YitzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKTtpZigweDFmZmZmZmZmZmZmZmZmPGEpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJDYW5ub3QgaGFzaCBtb3JlIHRoYW4gMl41MyAtIDEgYml0c1wiKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5KXt2YXIgZD1uZXcgVWludDMyQXJyYXkoYyksZT0wO2ZvcihiPTUxMitiLSg1MTIrYiYweDFmZik7Yjw9YTtiKz01MTIpdSh0aGlzLGQuc3ViYXJyYXkoMTYqZSxcbjE2KihlKzEpKSksZSs9MTtjLnNwbGljZSgwLDE2KmUpfWVsc2UgZm9yKGI9NTEyK2ItKDUxMitiJjB4MWZmKTtiPD1hO2IrPTUxMil1KHRoaXMsYy5zcGxpY2UoMCwxNikpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBhLGI9dGhpcy5BLGM9dGhpcy5GLGI9c2pjbC5iaXRBcnJheS5jb25jYXQoYixbc2pjbC5iaXRBcnJheS5wYXJ0aWFsKDEsMSldKTtmb3IoYT1iLmxlbmd0aCsyO2EmMTU7YSsrKWIucHVzaCgwKTtiLnB1c2goTWF0aC5mbG9vcih0aGlzLmwvMHgxMDAwMDAwMDApKTtmb3IoYi5wdXNoKHRoaXMubHwwKTtiLmxlbmd0aDspdSh0aGlzLGIuc3BsaWNlKDAsMTYpKTt0aGlzLnJlc2V0KCk7cmV0dXJuIGN9LFk6W10sYjpbXSxPOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4gMHgxMDAwMDAwMDAqKGEtTWF0aC5mbG9vcihhKSl8MH1mb3IodmFyIGI9MCxjPTIsZCxlOzY0PmI7YysrKXtlPSEwO2ZvcihkPTI7ZCpkPD1jO2QrKylpZigwPT09YyVkKXtlPVxuITE7YnJlYWt9ZSYmKDg+YiYmKHRoaXMuWVtiXT1hKE1hdGgucG93KGMsLjUpKSksdGhpcy5iW2JdPWEoTWF0aC5wb3coYywxLzMpKSxiKyspfX19O1xuZnVuY3Rpb24gdShhLGIpe3ZhciBjLGQsZSxmPWEuRixnPWEuYixoPWZbMF0saz1mWzFdLGw9ZlsyXSxuPWZbM10sbT1mWzRdLHA9Zls1XSxyPWZbNl0scT1mWzddO2ZvcihjPTA7NjQ+YztjKyspMTY+Yz9kPWJbY106KGQ9YltjKzEmMTVdLGU9YltjKzE0JjE1XSxkPWJbYyYxNV09KGQ+Pj43XmQ+Pj4xOF5kPj4+M15kPDwyNV5kPDwxNCkrKGU+Pj4xN15lPj4+MTleZT4+PjEwXmU8PDE1XmU8PDEzKStiW2MmMTVdK2JbYys5JjE1XXwwKSxkPWQrcSsobT4+PjZebT4+PjExXm0+Pj4yNV5tPDwyNl5tPDwyMV5tPDw3KSsocl5tJihwXnIpKStnW2NdLHE9cixyPXAscD1tLG09bitkfDAsbj1sLGw9ayxrPWgsaD1kKyhrJmxebiYoa15sKSkrKGs+Pj4yXms+Pj4xM15rPj4+MjJeazw8MzBeazw8MTleazw8MTApfDA7ZlswXT1mWzBdK2h8MDtmWzFdPWZbMV0ra3wwO2ZbMl09ZlsyXStsfDA7ZlszXT1mWzNdK258MDtmWzRdPWZbNF0rbXwwO2ZbNV09Zls1XStwfDA7Zls2XT1mWzZdK3J8MDtmWzddPVxuZls3XStxfDB9XG5zamNsLm1vZGUuY2NtPXtuYW1lOlwiY2NtXCIsRzpbXSxsaXN0ZW5Qcm9ncmVzczpmdW5jdGlvbihhKXtzamNsLm1vZGUuY2NtLkcucHVzaChhKX0sdW5MaXN0ZW5Qcm9ncmVzczpmdW5jdGlvbihhKXthPXNqY2wubW9kZS5jY20uRy5pbmRleE9mKGEpOy0xPGEmJnNqY2wubW9kZS5jY20uRy5zcGxpY2UoYSwxKX0sZmE6ZnVuY3Rpb24oYSl7dmFyIGI9c2pjbC5tb2RlLmNjbS5HLnNsaWNlKCksYztmb3IoYz0wO2M8Yi5sZW5ndGg7Yys9MSliW2NdKGEpfSxlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZz1iLnNsaWNlKDApLGg9c2pjbC5iaXRBcnJheSxrPWguYml0TGVuZ3RoKGMpLzgsbD1oLmJpdExlbmd0aChnKS84O2U9ZXx8NjQ7ZD1kfHxbXTtpZig3PmspdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJjY206IGl2IG11c3QgYmUgYXQgbGVhc3QgNyBieXRlc1wiKTtmb3IoZj0yOzQ+ZiYmbD4+PjgqZjtmKyspO2Y8MTUtayYmKGY9MTUtayk7Yz1oLmNsYW1wKGMsXG44KigxNS1mKSk7Yj1zamNsLm1vZGUuY2NtLlYoYSxiLGMsZCxlLGYpO2c9c2pjbC5tb2RlLmNjbS5DKGEsZyxjLGIsZSxmKTtyZXR1cm4gaC5jb25jYXQoZy5kYXRhLGcudGFnKX0sZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkLGUpe2U9ZXx8NjQ7ZD1kfHxbXTt2YXIgZj1zamNsLmJpdEFycmF5LGc9Zi5iaXRMZW5ndGgoYykvOCxoPWYuYml0TGVuZ3RoKGIpLGs9Zi5jbGFtcChiLGgtZSksbD1mLmJpdFNsaWNlKGIsaC1lKSxoPShoLWUpLzg7aWYoNz5nKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiY2NtOiBpdiBtdXN0IGJlIGF0IGxlYXN0IDcgYnl0ZXNcIik7Zm9yKGI9Mjs0PmImJmg+Pj44KmI7YisrKTtiPDE1LWcmJihiPTE1LWcpO2M9Zi5jbGFtcChjLDgqKDE1LWIpKTtrPXNqY2wubW9kZS5jY20uQyhhLGssYyxsLGUsYik7YT1zamNsLm1vZGUuY2NtLlYoYSxrLmRhdGEsYyxkLGUsYik7aWYoIWYuZXF1YWwoay50YWcsYSkpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmNvcnJ1cHQoXCJjY206IHRhZyBkb2Vzbid0IG1hdGNoXCIpO1xucmV0dXJuIGsuZGF0YX0sbmE6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPVtdLGg9c2pjbC5iaXRBcnJheSxrPWguaTtkPVtoLnBhcnRpYWwoOCwoYi5sZW5ndGg/NjQ6MCl8ZC0yPDwyfGYtMSldO2Q9aC5jb25jYXQoZCxjKTtkWzNdfD1lO2Q9YS5lbmNyeXB0KGQpO2lmKGIubGVuZ3RoKWZvcihjPWguYml0TGVuZ3RoKGIpLzgsNjUyNzk+PWM/Zz1baC5wYXJ0aWFsKDE2LGMpXToweGZmZmZmZmZmPj1jJiYoZz1oLmNvbmNhdChbaC5wYXJ0aWFsKDE2LDY1NTM0KV0sW2NdKSksZz1oLmNvbmNhdChnLGIpLGI9MDtiPGcubGVuZ3RoO2IrPTQpZD1hLmVuY3J5cHQoayhkLGcuc2xpY2UoYixiKzQpLmNvbmNhdChbMCwwLDBdKSkpO3JldHVybiBkfSxWOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1zamNsLmJpdEFycmF5LGg9Zy5pO2UvPTg7aWYoZSUyfHw0PmV8fDE2PGUpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJjY206IGludmFsaWQgdGFnIGxlbmd0aFwiKTtcbmlmKDB4ZmZmZmZmZmY8ZC5sZW5ndGh8fDB4ZmZmZmZmZmY8Yi5sZW5ndGgpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmJ1ZyhcImNjbTogY2FuJ3QgZGVhbCB3aXRoIDRHaUIgb3IgbW9yZSBkYXRhXCIpO2M9c2pjbC5tb2RlLmNjbS5uYShhLGQsYyxlLGcuYml0TGVuZ3RoKGIpLzgsZik7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrPTQpYz1hLmVuY3J5cHQoaChjLGIuc2xpY2UoZCxkKzQpLmNvbmNhdChbMCwwLDBdKSkpO3JldHVybiBnLmNsYW1wKGMsOCplKX0sQzpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaD1zamNsLmJpdEFycmF5O2c9aC5pO3ZhciBrPWIubGVuZ3RoLGw9aC5iaXRMZW5ndGgoYiksbj1rLzUwLG09bjtjPWguY29uY2F0KFtoLnBhcnRpYWwoOCxmLTEpXSxjKS5jb25jYXQoWzAsMCwwXSkuc2xpY2UoMCw0KTtkPWguYml0U2xpY2UoZyhkLGEuZW5jcnlwdChjKSksMCxlKTtpZighaylyZXR1cm57dGFnOmQsZGF0YTpbXX07Zm9yKGc9MDtnPGs7Zys9NClnPm4mJihzamNsLm1vZGUuY2NtLmZhKGcvXG5rKSxuKz1tKSxjWzNdKyssZT1hLmVuY3J5cHQoYyksYltnXV49ZVswXSxiW2crMV1ePWVbMV0sYltnKzJdXj1lWzJdLGJbZyszXV49ZVszXTtyZXR1cm57dGFnOmQsZGF0YTpoLmNsYW1wKGIsbCl9fX07XG5zamNsLm1vZGUub2NiMj17bmFtZTpcIm9jYjJcIixlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZigxMjghPT1zamNsLmJpdEFycmF5LmJpdExlbmd0aChjKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcIm9jYiBpdiBtdXN0IGJlIDEyOCBiaXRzXCIpO3ZhciBnLGg9c2pjbC5tb2RlLm9jYjIuUyxrPXNqY2wuYml0QXJyYXksbD1rLmksbj1bMCwwLDAsMF07Yz1oKGEuZW5jcnlwdChjKSk7dmFyIG0scD1bXTtkPWR8fFtdO2U9ZXx8NjQ7Zm9yKGc9MDtnKzQ8Yi5sZW5ndGg7Zys9NCltPWIuc2xpY2UoZyxnKzQpLG49bChuLG0pLHA9cC5jb25jYXQobChjLGEuZW5jcnlwdChsKGMsbSkpKSksYz1oKGMpO209Yi5zbGljZShnKTtiPWsuYml0TGVuZ3RoKG0pO2c9YS5lbmNyeXB0KGwoYyxbMCwwLDAsYl0pKTttPWsuY2xhbXAobChtLmNvbmNhdChbMCwwLDBdKSxnKSxiKTtuPWwobixsKG0uY29uY2F0KFswLDAsMF0pLGcpKTtuPWEuZW5jcnlwdChsKG4sbChjLGgoYykpKSk7XG5kLmxlbmd0aCYmKG49bChuLGY/ZDpzamNsLm1vZGUub2NiMi5wbWFjKGEsZCkpKTtyZXR1cm4gcC5jb25jYXQoay5jb25jYXQobSxrLmNsYW1wKG4sZSkpKX0sZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7aWYoMTI4IT09c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYykpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJvY2IgaXYgbXVzdCBiZSAxMjggYml0c1wiKTtlPWV8fDY0O3ZhciBnPXNqY2wubW9kZS5vY2IyLlMsaD1zamNsLmJpdEFycmF5LGs9aC5pLGw9WzAsMCwwLDBdLG49ZyhhLmVuY3J5cHQoYykpLG0scCxyPXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGIpLWUscT1bXTtkPWR8fFtdO2ZvcihjPTA7Yys0PHIvMzI7Yys9NCltPWsobixhLmRlY3J5cHQoayhuLGIuc2xpY2UoYyxjKzQpKSkpLGw9ayhsLG0pLHE9cS5jb25jYXQobSksbj1nKG4pO3A9ci0zMipjO209YS5lbmNyeXB0KGsobixbMCwwLDAscF0pKTttPWsobSxoLmNsYW1wKGIuc2xpY2UoYykscCkuY29uY2F0KFswLFxuMCwwXSkpO2w9ayhsLG0pO2w9YS5lbmNyeXB0KGsobCxrKG4sZyhuKSkpKTtkLmxlbmd0aCYmKGw9ayhsLGY/ZDpzamNsLm1vZGUub2NiMi5wbWFjKGEsZCkpKTtpZighaC5lcXVhbChoLmNsYW1wKGwsZSksaC5iaXRTbGljZShiLHIpKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uY29ycnVwdChcIm9jYjogdGFnIGRvZXNuJ3QgbWF0Y2hcIik7cmV0dXJuIHEuY29uY2F0KGguY2xhbXAobSxwKSl9LHBtYWM6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXNqY2wubW9kZS5vY2IyLlMsZT1zamNsLmJpdEFycmF5LGY9ZS5pLGc9WzAsMCwwLDBdLGg9YS5lbmNyeXB0KFswLDAsMCwwXSksaD1mKGgsZChkKGgpKSk7Zm9yKGM9MDtjKzQ8Yi5sZW5ndGg7Yys9NCloPWQoaCksZz1mKGcsYS5lbmNyeXB0KGYoaCxiLnNsaWNlKGMsYys0KSkpKTtjPWIuc2xpY2UoYyk7MTI4PmUuYml0TGVuZ3RoKGMpJiYoaD1mKGgsZChoKSksYz1lLmNvbmNhdChjLFstMjE0NzQ4MzY0OCwwLDAsMF0pKTtnPWYoZyxjKTtcbnJldHVybiBhLmVuY3J5cHQoZihkKGYoaCxkKGgpKSksZykpfSxTOmZ1bmN0aW9uKGEpe3JldHVyblthWzBdPDwxXmFbMV0+Pj4zMSxhWzFdPDwxXmFbMl0+Pj4zMSxhWzJdPDwxXmFbM10+Pj4zMSxhWzNdPDwxXjEzNSooYVswXT4+PjMxKV19fTtcbnNqY2wubW9kZS5nY209e25hbWU6XCJnY21cIixlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9Yi5zbGljZSgwKTtiPXNqY2wuYml0QXJyYXk7ZD1kfHxbXTthPXNqY2wubW9kZS5nY20uQyghMCxhLGYsZCxjLGV8fDEyOCk7cmV0dXJuIGIuY29uY2F0KGEuZGF0YSxhLnRhZyl9LGRlY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1iLnNsaWNlKDApLGc9c2pjbC5iaXRBcnJheSxoPWcuYml0TGVuZ3RoKGYpO2U9ZXx8MTI4O2Q9ZHx8W107ZTw9aD8oYj1nLmJpdFNsaWNlKGYsaC1lKSxmPWcuYml0U2xpY2UoZiwwLGgtZSkpOihiPWYsZj1bXSk7YT1zamNsLm1vZGUuZ2NtLkMoITEsYSxmLGQsYyxlKTtpZighZy5lcXVhbChhLnRhZyxiKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uY29ycnVwdChcImdjbTogdGFnIGRvZXNuJ3QgbWF0Y2hcIik7cmV0dXJuIGEuZGF0YX0sa2E6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg9c2pjbC5iaXRBcnJheS5pO2U9WzAsMCxcbjAsMF07Zj1iLnNsaWNlKDApO2ZvcihjPTA7MTI4PmM7YysrKXsoZD0wIT09KGFbTWF0aC5mbG9vcihjLzMyKV0mMTw8MzEtYyUzMikpJiYoZT1oKGUsZikpO2c9MCE9PShmWzNdJjEpO2ZvcihkPTM7MDxkO2QtLSlmW2RdPWZbZF0+Pj4xfChmW2QtMV0mMSk8PDMxO2ZbMF0+Pj49MTtnJiYoZlswXV49LTB4MWYwMDAwMDApfXJldHVybiBlfSxqOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPWMubGVuZ3RoO2I9Yi5zbGljZSgwKTtmb3IoZD0wO2Q8ZTtkKz00KWJbMF1ePTB4ZmZmZmZmZmYmY1tkXSxiWzFdXj0weGZmZmZmZmZmJmNbZCsxXSxiWzJdXj0weGZmZmZmZmZmJmNbZCsyXSxiWzNdXj0weGZmZmZmZmZmJmNbZCszXSxiPXNqY2wubW9kZS5nY20ua2EoYixhKTtyZXR1cm4gYn0sQzpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaCxrLGwsbixtLHAscixxPXNqY2wuYml0QXJyYXk7bT1jLmxlbmd0aDtwPXEuYml0TGVuZ3RoKGMpO3I9cS5iaXRMZW5ndGgoZCk7aD1xLmJpdExlbmd0aChlKTtcbmc9Yi5lbmNyeXB0KFswLDAsMCwwXSk7OTY9PT1oPyhlPWUuc2xpY2UoMCksZT1xLmNvbmNhdChlLFsxXSkpOihlPXNqY2wubW9kZS5nY20uaihnLFswLDAsMCwwXSxlKSxlPXNqY2wubW9kZS5nY20uaihnLGUsWzAsMCxNYXRoLmZsb29yKGgvMHgxMDAwMDAwMDApLGgmMHhmZmZmZmZmZl0pKTtoPXNqY2wubW9kZS5nY20uaihnLFswLDAsMCwwXSxkKTtuPWUuc2xpY2UoMCk7ZD1oLnNsaWNlKDApO2F8fChkPXNqY2wubW9kZS5nY20uaihnLGgsYykpO2ZvcihsPTA7bDxtO2wrPTQpblszXSsrLGs9Yi5lbmNyeXB0KG4pLGNbbF1ePWtbMF0sY1tsKzFdXj1rWzFdLGNbbCsyXV49a1syXSxjW2wrM11ePWtbM107Yz1xLmNsYW1wKGMscCk7YSYmKGQ9c2pjbC5tb2RlLmdjbS5qKGcsaCxjKSk7YT1bTWF0aC5mbG9vcihyLzB4MTAwMDAwMDAwKSxyJjB4ZmZmZmZmZmYsTWF0aC5mbG9vcihwLzB4MTAwMDAwMDAwKSxwJjB4ZmZmZmZmZmZdO2Q9c2pjbC5tb2RlLmdjbS5qKGcsZCxhKTtrPWIuZW5jcnlwdChlKTtcbmRbMF1ePWtbMF07ZFsxXV49a1sxXTtkWzJdXj1rWzJdO2RbM11ePWtbM107cmV0dXJue3RhZzpxLmJpdFNsaWNlKGQsMCxmKSxkYXRhOmN9fX07c2pjbC5taXNjLmhtYWM9ZnVuY3Rpb24oYSxiKXt0aGlzLlc9Yj1ifHxzamNsLmhhc2guc2hhMjU2O3ZhciBjPVtbXSxbXV0sZCxlPWIucHJvdG90eXBlLmJsb2NrU2l6ZS8zMjt0aGlzLnc9W25ldyBiLG5ldyBiXTthLmxlbmd0aD5lJiYoYT1iLmhhc2goYSkpO2ZvcihkPTA7ZDxlO2QrKyljWzBdW2RdPWFbZF1eOTA5NTIyNDg2LGNbMV1bZF09YVtkXV4xNTQ5NTU2ODI4O3RoaXMud1swXS51cGRhdGUoY1swXSk7dGhpcy53WzFdLnVwZGF0ZShjWzFdKTt0aGlzLlI9bmV3IGIodGhpcy53WzBdKX07XG5zamNsLm1pc2MuaG1hYy5wcm90b3R5cGUuZW5jcnlwdD1zamNsLm1pc2MuaG1hYy5wcm90b3R5cGUubWFjPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYWEpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJlbmNyeXB0IG9uIGFscmVhZHkgdXBkYXRlZCBobWFjIGNhbGxlZCFcIik7dGhpcy51cGRhdGUoYSk7cmV0dXJuIHRoaXMuZGlnZXN0KGEpfTtzamNsLm1pc2MuaG1hYy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLlI9bmV3IHRoaXMuVyh0aGlzLndbMF0pO3RoaXMuYWE9ITF9O3NqY2wubWlzYy5obWFjLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy5hYT0hMDt0aGlzLlIudXBkYXRlKGEpfTtzamNsLm1pc2MuaG1hYy5wcm90b3R5cGUuZGlnZXN0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5SLmZpbmFsaXplKCksYT0obmV3IHRoaXMuVyh0aGlzLndbMV0pKS51cGRhdGUoYSkuZmluYWxpemUoKTt0aGlzLnJlc2V0KCk7cmV0dXJuIGF9O1xuc2pjbC5taXNjLnBia2RmMj1mdW5jdGlvbihhLGIsYyxkLGUpe2M9Y3x8MUU0O2lmKDA+ZHx8MD5jKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiaW52YWxpZCBwYXJhbXMgdG8gcGJrZGYyXCIpO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhhKSk7XCJzdHJpbmdcIj09PXR5cGVvZiBiJiYoYj1zamNsLmNvZGVjLnV0ZjhTdHJpbmcudG9CaXRzKGIpKTtlPWV8fHNqY2wubWlzYy5obWFjO2E9bmV3IGUoYSk7dmFyIGYsZyxoLGssbD1bXSxuPXNqY2wuYml0QXJyYXk7Zm9yKGs9MTszMipsLmxlbmd0aDwoZHx8MSk7aysrKXtlPWY9YS5lbmNyeXB0KG4uY29uY2F0KGIsW2tdKSk7Zm9yKGc9MTtnPGM7ZysrKWZvcihmPWEuZW5jcnlwdChmKSxoPTA7aDxmLmxlbmd0aDtoKyspZVtoXV49ZltoXTtsPWwuY29uY2F0KGUpfWQmJihsPW4uY2xhbXAobCxkKSk7cmV0dXJuIGx9O1xuc2pjbC5wcm5nPWZ1bmN0aW9uKGEpe3RoaXMuYz1bbmV3IHNqY2wuaGFzaC5zaGEyNTZdO3RoaXMubT1bMF07dGhpcy5QPTA7dGhpcy5IPXt9O3RoaXMuTj0wO3RoaXMuVT17fTt0aGlzLlo9dGhpcy5mPXRoaXMubz10aGlzLmhhPTA7dGhpcy5iPVswLDAsMCwwLDAsMCwwLDBdO3RoaXMuaD1bMCwwLDAsMF07dGhpcy5MPXZvaWQgMDt0aGlzLk09YTt0aGlzLkQ9ITE7dGhpcy5LPXtwcm9ncmVzczp7fSxzZWVkZWQ6e319O3RoaXMudT10aGlzLmdhPTA7dGhpcy5JPTE7dGhpcy5KPTI7dGhpcy5jYT0weDEwMDAwO3RoaXMuVD1bMCw0OCw2NCw5NiwxMjgsMTkyLDB4MTAwLDM4NCw1MTIsNzY4LDEwMjRdO3RoaXMuZGE9M0U0O3RoaXMuYmE9ODB9O1xuc2pjbC5wcm5nLnByb3RvdHlwZT17cmFuZG9tV29yZHM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkO2Q9dGhpcy5pc1JlYWR5KGIpO3ZhciBlO2lmKGQ9PT10aGlzLnUpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLm5vdFJlYWR5KFwiZ2VuZXJhdG9yIGlzbid0IHNlZWRlZFwiKTtpZihkJnRoaXMuSil7ZD0hKGQmdGhpcy5JKTtlPVtdO3ZhciBmPTAsZzt0aGlzLlo9ZVswXT0obmV3IERhdGUpLnZhbHVlT2YoKSt0aGlzLmRhO2ZvcihnPTA7MTY+ZztnKyspZS5wdXNoKDB4MTAwMDAwMDAwKk1hdGgucmFuZG9tKCl8MCk7Zm9yKGc9MDtnPHRoaXMuYy5sZW5ndGgmJihlPWUuY29uY2F0KHRoaXMuY1tnXS5maW5hbGl6ZSgpKSxmKz10aGlzLm1bZ10sdGhpcy5tW2ddPTAsZHx8ISh0aGlzLlAmMTw8ZykpO2crKyk7dGhpcy5QPj0xPDx0aGlzLmMubGVuZ3RoJiYodGhpcy5jLnB1c2gobmV3IHNqY2wuaGFzaC5zaGEyNTYpLHRoaXMubS5wdXNoKDApKTt0aGlzLmYtPWY7Zj50aGlzLm8mJih0aGlzLm89XG5mKTt0aGlzLlArKzt0aGlzLmI9c2pjbC5oYXNoLnNoYTI1Ni5oYXNoKHRoaXMuYi5jb25jYXQoZSkpO3RoaXMuTD1uZXcgc2pjbC5jaXBoZXIuYWVzKHRoaXMuYik7Zm9yKGQ9MDs0PmQmJih0aGlzLmhbZF09dGhpcy5oW2RdKzF8MCwhdGhpcy5oW2RdKTtkKyspO31mb3IoZD0wO2Q8YTtkKz00KTA9PT0oZCsxKSV0aGlzLmNhJiZ5KHRoaXMpLGU9eih0aGlzKSxjLnB1c2goZVswXSxlWzFdLGVbMl0sZVszXSk7eSh0aGlzKTtyZXR1cm4gYy5zbGljZSgwLGEpfSxzZXREZWZhdWx0UGFyYW5vaWE6ZnVuY3Rpb24oYSxiKXtpZigwPT09YSYmXCJTZXR0aW5nIHBhcmFub2lhPTAgd2lsbCBydWluIHlvdXIgc2VjdXJpdHk7IHVzZSBpdCBvbmx5IGZvciB0ZXN0aW5nXCIhPT1iKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiU2V0dGluZyBwYXJhbm9pYT0wIHdpbGwgcnVpbiB5b3VyIHNlY3VyaXR5OyB1c2UgaXQgb25seSBmb3IgdGVzdGluZ1wiKTt0aGlzLk09YX0sYWRkRW50cm9weTpmdW5jdGlvbihhLFxuYixjKXtjPWN8fFwidXNlclwiO3ZhciBkLGUsZj0obmV3IERhdGUpLnZhbHVlT2YoKSxnPXRoaXMuSFtjXSxoPXRoaXMuaXNSZWFkeSgpLGs9MDtkPXRoaXMuVVtjXTt2b2lkIDA9PT1kJiYoZD10aGlzLlVbY109dGhpcy5oYSsrKTt2b2lkIDA9PT1nJiYoZz10aGlzLkhbY109MCk7dGhpcy5IW2NdPSh0aGlzLkhbY10rMSkldGhpcy5jLmxlbmd0aDtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJudW1iZXJcIjp2b2lkIDA9PT1iJiYoYj0xKTt0aGlzLmNbZ10udXBkYXRlKFtkLHRoaXMuTisrLDEsYixmLDEsYXwwXSk7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOmM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBVaW50MzJBcnJheV1cIj09PWMpe2U9W107Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllLnB1c2goYVtjXSk7YT1lfWVsc2UgZm9yKFwiW29iamVjdCBBcnJheV1cIiE9PWMmJihrPTEpLGM9MDtjPGEubGVuZ3RoJiYhaztjKyspXCJudW1iZXJcIiE9PXR5cGVvZiBhW2NdJiZcbihrPTEpO2lmKCFrKXtpZih2b2lkIDA9PT1iKWZvcihjPWI9MDtjPGEubGVuZ3RoO2MrKylmb3IoZT1hW2NdOzA8ZTspYisrLGU9ZT4+PjE7dGhpcy5jW2ddLnVwZGF0ZShbZCx0aGlzLk4rKywyLGIsZixhLmxlbmd0aF0uY29uY2F0KGEpKX1icmVhaztjYXNlIFwic3RyaW5nXCI6dm9pZCAwPT09YiYmKGI9YS5sZW5ndGgpO3RoaXMuY1tnXS51cGRhdGUoW2QsdGhpcy5OKyssMyxiLGYsYS5sZW5ndGhdKTt0aGlzLmNbZ10udXBkYXRlKGEpO2JyZWFrO2RlZmF1bHQ6az0xfWlmKGspdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmJ1ZyhcInJhbmRvbTogYWRkRW50cm9weSBvbmx5IHN1cHBvcnRzIG51bWJlciwgYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdcIik7dGhpcy5tW2ddKz1iO3RoaXMuZis9YjtoPT09dGhpcy51JiYodGhpcy5pc1JlYWR5KCkhPT10aGlzLnUmJkEoXCJzZWVkZWRcIixNYXRoLm1heCh0aGlzLm8sdGhpcy5mKSksQShcInByb2dyZXNzXCIsdGhpcy5nZXRQcm9ncmVzcygpKSl9LFxuaXNSZWFkeTpmdW5jdGlvbihhKXthPXRoaXMuVFt2b2lkIDAhPT1hP2E6dGhpcy5NXTtyZXR1cm4gdGhpcy5vJiZ0aGlzLm8+PWE/dGhpcy5tWzBdPnRoaXMuYmEmJihuZXcgRGF0ZSkudmFsdWVPZigpPnRoaXMuWj90aGlzLkp8dGhpcy5JOnRoaXMuSTp0aGlzLmY+PWE/dGhpcy5KfHRoaXMudTp0aGlzLnV9LGdldFByb2dyZXNzOmZ1bmN0aW9uKGEpe2E9dGhpcy5UW2E/YTp0aGlzLk1dO3JldHVybiB0aGlzLm8+PWE/MTp0aGlzLmY+YT8xOnRoaXMuZi9hfSxzdGFydENvbGxlY3RvcnM6ZnVuY3Rpb24oKXtpZighdGhpcy5EKXt0aGlzLmE9e2xvYWRUaW1lQ29sbGVjdG9yOkIodGhpcyx0aGlzLm1hKSxtb3VzZUNvbGxlY3RvcjpCKHRoaXMsdGhpcy5vYSksa2V5Ym9hcmRDb2xsZWN0b3I6Qih0aGlzLHRoaXMubGEpLGFjY2VsZXJvbWV0ZXJDb2xsZWN0b3I6Qih0aGlzLHRoaXMuZWEpLHRvdWNoQ29sbGVjdG9yOkIodGhpcyx0aGlzLnFhKX07aWYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsXG50aGlzLmEubG9hZFRpbWVDb2xsZWN0b3IsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5hLm1vdXNlQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsdGhpcy5hLmtleWJvYXJkQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLHRoaXMuYS5hY2NlbGVyb21ldGVyQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuYS50b3VjaENvbGxlY3RvciwhMSk7ZWxzZSBpZihkb2N1bWVudC5hdHRhY2hFdmVudClkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ubG9hZFwiLHRoaXMuYS5sb2FkVGltZUNvbGxlY3RvciksZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbm1vdXNlbW92ZVwiLHRoaXMuYS5tb3VzZUNvbGxlY3RvciksZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJrZXlwcmVzc1wiLHRoaXMuYS5rZXlib2FyZENvbGxlY3Rvcik7ZWxzZSB0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uYnVnKFwiY2FuJ3QgYXR0YWNoIGV2ZW50XCIpO1xudGhpcy5EPSEwfX0sc3RvcENvbGxlY3RvcnM6ZnVuY3Rpb24oKXt0aGlzLkQmJih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcj8od2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdGhpcy5hLmxvYWRUaW1lQ29sbGVjdG9yLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuYS5tb3VzZUNvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLHRoaXMuYS5rZXlib2FyZENvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIix0aGlzLmEuYWNjZWxlcm9tZXRlckNvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLmEudG91Y2hDb2xsZWN0b3IsITEpKTpkb2N1bWVudC5kZXRhY2hFdmVudCYmKGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25sb2FkXCIsdGhpcy5hLmxvYWRUaW1lQ29sbGVjdG9yKSxkb2N1bWVudC5kZXRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsXG50aGlzLmEubW91c2VDb2xsZWN0b3IpLGRvY3VtZW50LmRldGFjaEV2ZW50KFwia2V5cHJlc3NcIix0aGlzLmEua2V5Ym9hcmRDb2xsZWN0b3IpKSx0aGlzLkQ9ITEpfSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKGEsYil7dGhpcy5LW2FdW3RoaXMuZ2ErK109Yn0scmVtb3ZlRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT10aGlzLktbYV0sZj1bXTtmb3IoZCBpbiBlKWUuaGFzT3duUHJvcGVydHkoZCkmJmVbZF09PT1iJiZmLnB1c2goZCk7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylkPWZbY10sZGVsZXRlIGVbZF19LGxhOmZ1bmN0aW9uKCl7Qyh0aGlzLDEpfSxvYTpmdW5jdGlvbihhKXt2YXIgYixjO3RyeXtiPWEueHx8YS5jbGllbnRYfHxhLm9mZnNldFh8fDAsYz1hLnl8fGEuY2xpZW50WXx8YS5vZmZzZXRZfHwwfWNhdGNoKGQpe2M9Yj0wfTAhPWImJjAhPWMmJnRoaXMuYWRkRW50cm9weShbYixjXSwyLFwibW91c2VcIik7Qyh0aGlzLDApfSxxYTpmdW5jdGlvbihhKXthPVxuYS50b3VjaGVzWzBdfHxhLmNoYW5nZWRUb3VjaGVzWzBdO3RoaXMuYWRkRW50cm9weShbYS5wYWdlWHx8YS5jbGllbnRYLGEucGFnZVl8fGEuY2xpZW50WV0sMSxcInRvdWNoXCIpO0ModGhpcywwKX0sbWE6ZnVuY3Rpb24oKXtDKHRoaXMsMil9LGVhOmZ1bmN0aW9uKGEpe2E9YS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Lnh8fGEuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS55fHxhLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuejtpZih3aW5kb3cub3JpZW50YXRpb24pe3ZhciBiPXdpbmRvdy5vcmllbnRhdGlvbjtcIm51bWJlclwiPT09dHlwZW9mIGImJnRoaXMuYWRkRW50cm9weShiLDEsXCJhY2NlbGVyb21ldGVyXCIpfWEmJnRoaXMuYWRkRW50cm9weShhLDIsXCJhY2NlbGVyb21ldGVyXCIpO0ModGhpcywwKX19O1xuZnVuY3Rpb24gQShhLGIpe3ZhciBjLGQ9c2pjbC5yYW5kb20uS1thXSxlPVtdO2ZvcihjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmZS5wdXNoKGRbY10pO2ZvcihjPTA7YzxlLmxlbmd0aDtjKyspZVtjXShiKX1mdW5jdGlvbiBDKGEsYil7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3c/YS5hZGRFbnRyb3B5KHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSxiLFwibG9hZHRpbWVcIik6YS5hZGRFbnRyb3B5KChuZXcgRGF0ZSkudmFsdWVPZigpLGIsXCJsb2FkdGltZVwiKX1mdW5jdGlvbiB5KGEpe2EuYj16KGEpLmNvbmNhdCh6KGEpKTthLkw9bmV3IHNqY2wuY2lwaGVyLmFlcyhhLmIpfWZ1bmN0aW9uIHooYSl7Zm9yKHZhciBiPTA7ND5iJiYoYS5oW2JdPWEuaFtiXSsxfDAsIWEuaFtiXSk7YisrKTtyZXR1cm4gYS5MLmVuY3J5cHQoYS5oKX1cbmZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtiLmFwcGx5KGEsYXJndW1lbnRzKX19c2pjbC5yYW5kb209bmV3IHNqY2wucHJuZyg2KTtcbmE6dHJ5e3ZhciBELEUsRixHO2lmKEc9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzKXt2YXIgSDt0cnl7SD1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKGEpe0g9bnVsbH1HPUU9SH1pZihHJiZFLnJhbmRvbUJ5dGVzKUQ9RS5yYW5kb21CeXRlcygxMjgpLEQ9bmV3IFVpbnQzMkFycmF5KChuZXcgVWludDhBcnJheShEKSkuYnVmZmVyKSxzamNsLnJhbmRvbS5hZGRFbnRyb3B5KEQsMTAyNCxcImNyeXB0b1sncmFuZG9tQnl0ZXMnXVwiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5KXtGPW5ldyBVaW50MzJBcnJheSgzMik7aWYod2luZG93LmNyeXB0byYmd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoRik7ZWxzZSBpZih3aW5kb3cubXNDcnlwdG8mJndpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhGKTtcbmVsc2UgYnJlYWsgYTtzamNsLnJhbmRvbS5hZGRFbnRyb3B5KEYsMTAyNCxcImNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ11cIil9fWNhdGNoKGEpe1widW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKGNvbnNvbGUubG9nKFwiVGhlcmUgd2FzIGFuIGVycm9yIGNvbGxlY3RpbmcgZW50cm9weSBmcm9tIHRoZSBicm93c2VyOlwiKSxjb25zb2xlLmxvZyhhKSl9XG5zamNsLmpzb249e2RlZmF1bHRzOnt2OjEsaXRlcjoxRTQsa3M6MTI4LHRzOjY0LG1vZGU6XCJjY21cIixhZGF0YTpcIlwiLGNpcGhlcjpcImFlc1wifSxqYTpmdW5jdGlvbihhLGIsYyxkKXtjPWN8fHt9O2Q9ZHx8e307dmFyIGU9c2pjbC5qc29uLGY9ZS5nKHtpdjpzamNsLnJhbmRvbS5yYW5kb21Xb3Jkcyg0LDApfSxlLmRlZmF1bHRzKSxnO2UuZyhmLGMpO2M9Zi5hZGF0YTtcInN0cmluZ1wiPT09dHlwZW9mIGYuc2FsdCYmKGYuc2FsdD1zamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoZi5zYWx0KSk7XCJzdHJpbmdcIj09PXR5cGVvZiBmLml2JiYoZi5pdj1zamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoZi5pdikpO2lmKCFzamNsLm1vZGVbZi5tb2RlXXx8IXNqY2wuY2lwaGVyW2YuY2lwaGVyXXx8XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYxMDA+PWYuaXRlcnx8NjQhPT1mLnRzJiY5NiE9PWYudHMmJjEyOCE9PWYudHN8fDEyOCE9PWYua3MmJjE5MiE9PWYua3MmJjB4MTAwIT09Zi5rc3x8Mj5mLml2Lmxlbmd0aHx8XG40PGYuaXYubGVuZ3RoKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwianNvbiBlbmNyeXB0OiBpbnZhbGlkIHBhcmFtZXRlcnNcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBhPyhnPXNqY2wubWlzYy5jYWNoZWRQYmtkZjIoYSxmKSxhPWcua2V5LnNsaWNlKDAsZi5rcy8zMiksZi5zYWx0PWcuc2FsdCk6c2pjbC5lY2MmJmEgaW5zdGFuY2VvZiBzamNsLmVjYy5lbEdhbWFsLnB1YmxpY0tleSYmKGc9YS5rZW0oKSxmLmtlbXRhZz1nLnRhZyxhPWcua2V5LnNsaWNlKDAsZi5rcy8zMikpO1wic3RyaW5nXCI9PT10eXBlb2YgYiYmKGI9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhiKSk7XCJzdHJpbmdcIj09PXR5cGVvZiBjJiYoZi5hZGF0YT1jPXNqY2wuY29kZWMudXRmOFN0cmluZy50b0JpdHMoYykpO2c9bmV3IHNqY2wuY2lwaGVyW2YuY2lwaGVyXShhKTtlLmcoZCxmKTtkLmtleT1hO2YuY3Q9XCJjY21cIj09PWYubW9kZSYmc2pjbC5hcnJheUJ1ZmZlciYmc2pjbC5hcnJheUJ1ZmZlci5jY20mJlxuYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP3NqY2wuYXJyYXlCdWZmZXIuY2NtLmVuY3J5cHQoZyxiLGYuaXYsYyxmLnRzKTpzamNsLm1vZGVbZi5tb2RlXS5lbmNyeXB0KGcsYixmLml2LGMsZi50cyk7cmV0dXJuIGZ9LGVuY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9c2pjbC5qc29uLGY9ZS5qYS5hcHBseShlLGFyZ3VtZW50cyk7cmV0dXJuIGUuZW5jb2RlKGYpfSxpYTpmdW5jdGlvbihhLGIsYyxkKXtjPWN8fHt9O2Q9ZHx8e307dmFyIGU9c2pjbC5qc29uO2I9ZS5nKGUuZyhlLmcoe30sZS5kZWZhdWx0cyksYiksYywhMCk7dmFyIGYsZztmPWIuYWRhdGE7XCJzdHJpbmdcIj09PXR5cGVvZiBiLnNhbHQmJihiLnNhbHQ9c2pjbC5jb2RlYy5iYXNlNjQudG9CaXRzKGIuc2FsdCkpO1wic3RyaW5nXCI9PT10eXBlb2YgYi5pdiYmKGIuaXY9c2pjbC5jb2RlYy5iYXNlNjQudG9CaXRzKGIuaXYpKTtpZighc2pjbC5tb2RlW2IubW9kZV18fCFzamNsLmNpcGhlcltiLmNpcGhlcl18fFwic3RyaW5nXCI9PT1cbnR5cGVvZiBhJiYxMDA+PWIuaXRlcnx8NjQhPT1iLnRzJiY5NiE9PWIudHMmJjEyOCE9PWIudHN8fDEyOCE9PWIua3MmJjE5MiE9PWIua3MmJjB4MTAwIT09Yi5rc3x8IWIuaXZ8fDI+Yi5pdi5sZW5ndGh8fDQ8Yi5pdi5sZW5ndGgpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJqc29uIGRlY3J5cHQ6IGludmFsaWQgcGFyYW1ldGVyc1wiKTtcInN0cmluZ1wiPT09dHlwZW9mIGE/KGc9c2pjbC5taXNjLmNhY2hlZFBia2RmMihhLGIpLGE9Zy5rZXkuc2xpY2UoMCxiLmtzLzMyKSxiLnNhbHQ9Zy5zYWx0KTpzamNsLmVjYyYmYSBpbnN0YW5jZW9mIHNqY2wuZWNjLmVsR2FtYWwuc2VjcmV0S2V5JiYoYT1hLnVua2VtKHNqY2wuY29kZWMuYmFzZTY0LnRvQml0cyhiLmtlbXRhZykpLnNsaWNlKDAsYi5rcy8zMikpO1wic3RyaW5nXCI9PT10eXBlb2YgZiYmKGY9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhmKSk7Zz1uZXcgc2pjbC5jaXBoZXJbYi5jaXBoZXJdKGEpO2Y9XCJjY21cIj09PVxuYi5tb2RlJiZzamNsLmFycmF5QnVmZmVyJiZzamNsLmFycmF5QnVmZmVyLmNjbSYmYi5jdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP3NqY2wuYXJyYXlCdWZmZXIuY2NtLmRlY3J5cHQoZyxiLmN0LGIuaXYsYi50YWcsZixiLnRzKTpzamNsLm1vZGVbYi5tb2RlXS5kZWNyeXB0KGcsYi5jdCxiLml2LGYsYi50cyk7ZS5nKGQsYik7ZC5rZXk9YTtyZXR1cm4gMT09PWMucmF3P2Y6c2pjbC5jb2RlYy51dGY4U3RyaW5nLmZyb21CaXRzKGYpfSxkZWNyeXB0OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXNqY2wuanNvbjtyZXR1cm4gZS5pYShhLGUuZGVjb2RlKGIpLGMsZCl9LGVuY29kZTpmdW5jdGlvbihhKXt2YXIgYixjPVwie1wiLGQ9XCJcIjtmb3IoYiBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYikpe2lmKCFiLm1hdGNoKC9eW2EtejAtOV0rJC9pKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImpzb24gZW5jb2RlOiBpbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7Yys9ZCsnXCInK1xuYisnXCI6JztkPVwiLFwiO3N3aXRjaCh0eXBlb2YgYVtiXSl7Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJib29sZWFuXCI6Yys9YVtiXTticmVhaztjYXNlIFwic3RyaW5nXCI6Yys9J1wiJytlc2NhcGUoYVtiXSkrJ1wiJzticmVhaztjYXNlIFwib2JqZWN0XCI6Yys9J1wiJytzamNsLmNvZGVjLmJhc2U2NC5mcm9tQml0cyhhW2JdLDApKydcIic7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uYnVnKFwianNvbiBlbmNvZGU6IHVuc3VwcG9ydGVkIHR5cGVcIik7fX1yZXR1cm4gYytcIn1cIn0sZGVjb2RlOmZ1bmN0aW9uKGEpe2E9YS5yZXBsYWNlKC9cXHMvZyxcIlwiKTtpZighYS5tYXRjaCgvXlxcey4qXFx9JC8pKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwianNvbiBkZWNvZGU6IHRoaXMgaXNuJ3QganNvbiFcIik7YT1hLnJlcGxhY2UoL15cXHt8XFx9JC9nLFwiXCIpLnNwbGl0KC8sLyk7dmFyIGI9e30sYyxkO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspe2lmKCEoZD1hW2NdLm1hdGNoKC9eXFxzKig/OihbXCInXT8pKFthLXpdW2EtejAtOV0qKVxcMSlcXHMqOlxccyooPzooLT9cXGQrKXxcIihbYS16MC05K1xcLyUqXy5APVxcLV0qKVwifCh0cnVlfGZhbHNlKSkkL2kpKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImpzb24gZGVjb2RlOiB0aGlzIGlzbid0IGpzb24hXCIpO1xubnVsbCE9ZFszXT9iW2RbMl1dPXBhcnNlSW50KGRbM10sMTApOm51bGwhPWRbNF0/YltkWzJdXT1kWzJdLm1hdGNoKC9eKGN0fGFkYXRhfHNhbHR8aXYpJC8pP3NqY2wuY29kZWMuYmFzZTY0LnRvQml0cyhkWzRdKTp1bmVzY2FwZShkWzRdKTpudWxsIT1kWzVdJiYoYltkWzJdXT1cInRydWVcIj09PWRbNV0pfXJldHVybiBifSxnOmZ1bmN0aW9uKGEsYixjKXt2b2lkIDA9PT1hJiYoYT17fSk7aWYodm9pZCAwPT09YilyZXR1cm4gYTtmb3IodmFyIGQgaW4gYilpZihiLmhhc093blByb3BlcnR5KGQpKXtpZihjJiZ2b2lkIDAhPT1hW2RdJiZhW2RdIT09YltkXSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcInJlcXVpcmVkIHBhcmFtZXRlciBvdmVycmlkZGVuXCIpO2FbZF09YltkXX1yZXR1cm4gYX0sc2E6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fSxkO2ZvcihkIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShkKSYmYVtkXSE9PWJbZF0mJihjW2RdPWFbZF0pO3JldHVybiBjfSxyYTpmdW5jdGlvbihhLFxuYil7dmFyIGM9e30sZDtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKXZvaWQgMCE9PWFbYltkXV0mJihjW2JbZF1dPWFbYltkXV0pO3JldHVybiBjfX07c2pjbC5lbmNyeXB0PXNqY2wuanNvbi5lbmNyeXB0O3NqY2wuZGVjcnlwdD1zamNsLmpzb24uZGVjcnlwdDtzamNsLm1pc2MucGE9e307c2pjbC5taXNjLmNhY2hlZFBia2RmMj1mdW5jdGlvbihhLGIpe3ZhciBjPXNqY2wubWlzYy5wYSxkO2I9Ynx8e307ZD1iLml0ZXJ8fDFFMztjPWNbYV09Y1thXXx8e307ZD1jW2RdPWNbZF18fHtmaXJzdFNhbHQ6Yi5zYWx0JiZiLnNhbHQubGVuZ3RoP2Iuc2FsdC5zbGljZSgwKTpzamNsLnJhbmRvbS5yYW5kb21Xb3JkcygyLDApfTtjPXZvaWQgMD09PWIuc2FsdD9kLmZpcnN0U2FsdDpiLnNhbHQ7ZFtjXT1kW2NdfHxzamNsLm1pc2MucGJrZGYyKGEsYyxiLml0ZXIpO3JldHVybntrZXk6ZFtjXS5zbGljZSgwKSxzYWx0OmMuc2xpY2UoMCl9fTtcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPXNqY2wpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZShbXSxmdW5jdGlvbigpe3JldHVybiBzamNsfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2t5bmV0Q2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuY29uc3QgdXBsb2FkXzEgPSByZXF1aXJlKFwiLi91cGxvYWRcIik7XG5jb25zdCBkb3dubG9hZF8xID0gcmVxdWlyZShcIi4vZG93bmxvYWRcIik7XG5jb25zdCBmaWxlXzEgPSByZXF1aXJlKFwiLi9maWxlXCIpO1xuY29uc3Qgc2t5ZGJfMSA9IHJlcXVpcmUoXCIuL3NreWRiXCIpO1xuY29uc3QgcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JlZ2lzdHJ5XCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwiLi91dGlscy91cmxcIik7XG5jb25zdCBteXNreV8xID0gcmVxdWlyZShcIi4vbXlza3lcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vbXlza3kvdXRpbHNcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ1wiKTtcbi8qKlxuICogVGhlIFNreW5ldCBDbGllbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYWNjZXNzIFNreW5ldC5cbiAqL1xuY2xhc3MgU2t5bmV0Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgU2t5bmV0IENsaWVudCB3aGljaCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgU2t5bmV0LlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIFtpbml0aWFsUG9ydGFsVXJsXSBUaGUgaW5pdGlhbCBwb3J0YWwgVVJMIHRvIHVzZSB0byBhY2Nlc3MgU2t5bmV0LCBpZiBzcGVjaWZpZWQuIEEgcmVxdWVzdCB3aWxsIGJlIG1hZGUgdG8gdGhpcyBVUkwgdG8gZ2V0IHRoZSBhY3R1YWwgcG9ydGFsIFVSTC4gVG8gdXNlIHRoZSBkZWZhdWx0IHBvcnRhbCB3aGlsZSBwYXNzaW5nIGN1c3RvbSBvcHRpb25zLCBwYXNzIFwiXCIuXG4gICAgICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSBDb25maWd1cmF0aW9uIGZvciB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQb3J0YWxVcmwgPSBcIlwiLCBjdXN0b21PcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gU2V0IG1ldGhvZHMgKGRlZmluZWQgaW4gb3RoZXIgZmlsZXMpLlxuICAgICAgICAvLyBVcGxvYWRcbiAgICAgICAgdGhpcy51cGxvYWRGaWxlID0gdXBsb2FkXzEudXBsb2FkRmlsZTtcbiAgICAgICAgdGhpcy51cGxvYWRGaWxlUmVxdWVzdCA9IHVwbG9hZF8xLnVwbG9hZEZpbGVSZXF1ZXN0O1xuICAgICAgICB0aGlzLnVwbG9hZERpcmVjdG9yeSA9IHVwbG9hZF8xLnVwbG9hZERpcmVjdG9yeTtcbiAgICAgICAgdGhpcy51cGxvYWREaXJlY3RvcnlSZXF1ZXN0ID0gdXBsb2FkXzEudXBsb2FkRGlyZWN0b3J5UmVxdWVzdDtcbiAgICAgICAgLy8gRG93bmxvYWRcbiAgICAgICAgdGhpcy5kb3dubG9hZEZpbGUgPSBkb3dubG9hZF8xLmRvd25sb2FkRmlsZTtcbiAgICAgICAgdGhpcy5kb3dubG9hZEZpbGVIbnMgPSBkb3dubG9hZF8xLmRvd25sb2FkRmlsZUhucztcbiAgICAgICAgdGhpcy5nZXRTa3lsaW5rVXJsID0gZG93bmxvYWRfMS5nZXRTa3lsaW5rVXJsO1xuICAgICAgICB0aGlzLmdldEhuc1VybCA9IGRvd25sb2FkXzEuZ2V0SG5zVXJsO1xuICAgICAgICB0aGlzLmdldEhuc3Jlc1VybCA9IGRvd25sb2FkXzEuZ2V0SG5zcmVzVXJsO1xuICAgICAgICB0aGlzLmdldE1ldGFkYXRhID0gZG93bmxvYWRfMS5nZXRNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5nZXRGaWxlQ29udGVudCA9IGRvd25sb2FkXzEuZ2V0RmlsZUNvbnRlbnQ7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUNvbnRlbnRIbnMgPSBkb3dubG9hZF8xLmdldEZpbGVDb250ZW50SG5zO1xuICAgICAgICB0aGlzLmdldEZpbGVDb250ZW50UmVxdWVzdCA9IGRvd25sb2FkXzEuZ2V0RmlsZUNvbnRlbnRSZXF1ZXN0O1xuICAgICAgICB0aGlzLm9wZW5GaWxlID0gZG93bmxvYWRfMS5vcGVuRmlsZTtcbiAgICAgICAgdGhpcy5vcGVuRmlsZUhucyA9IGRvd25sb2FkXzEub3BlbkZpbGVIbnM7XG4gICAgICAgIHRoaXMucmVzb2x2ZUhucyA9IGRvd25sb2FkXzEucmVzb2x2ZUhucztcbiAgICAgICAgLy8gTXlTa3lcbiAgICAgICAgdGhpcy5leHRyYWN0RG9tYWluID0gdXRpbHNfMS5leHRyYWN0RG9tYWluO1xuICAgICAgICB0aGlzLmdldEZ1bGxEb21haW5VcmwgPSB1dGlsc18xLmdldEZ1bGxEb21haW5Vcmw7XG4gICAgICAgIHRoaXMubG9hZE15U2t5ID0gbXlza3lfMS5sb2FkTXlTa3k7XG4gICAgICAgIC8vIEZpbGUgQVBJXG4gICAgICAgIHRoaXMuZmlsZSA9IHtcbiAgICAgICAgICAgIGdldEpTT046IGZpbGVfMS5nZXRKU09OLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNreURCXG4gICAgICAgIHRoaXMuZGIgPSB7XG4gICAgICAgICAgICBnZXRKU09OOiBza3lkYl8xLmdldEpTT04uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldEpTT046IHNreWRiXzEuc2V0SlNPTi5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBTa3lEQiBoZWxwZXJzXG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSB7XG4gICAgICAgICAgICBnZXRFbnRyeTogcmVnaXN0cnlfMS5nZXRFbnRyeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RW50cnlVcmw6IHJlZ2lzdHJ5XzEuZ2V0RW50cnlVcmwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEVudHJ5TGluazogcmVnaXN0cnlfMS5nZXRFbnRyeUxpbmsuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldEVudHJ5OiByZWdpc3RyeV8xLnNldEVudHJ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBwb3N0U2lnbmVkRW50cnk6IHJlZ2lzdHJ5XzEucG9zdFNpZ25lZEVudHJ5LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbml0aWFsUG9ydGFsVXJsID09PSBcIlwiKSB7XG4gICAgICAgICAgICAvLyBQb3J0YWwgd2FzIG5vdCBnaXZlbiwgdXNlIHRoZSBkZWZhdWx0IHBvcnRhbCBVUkwuIFdlJ2xsIHN0aWxsIG1ha2UgYSByZXF1ZXN0IGZvciB0aGUgcmVzb2x2ZWQgcG9ydGFsIFVSTC5cbiAgICAgICAgICAgIGluaXRpYWxQb3J0YWxVcmwgPSB1cmxfMS5kZWZhdWx0UG9ydGFsVXJsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQb3J0YWwgd2FzIGdpdmVuLCBkb24ndCBtYWtlIHRoZSByZXF1ZXN0IGZvciB0aGUgcmVzb2x2ZWQgcG9ydGFsIFVSTC5cbiAgICAgICAgICAgIHRoaXMuZ2l2ZW5Qb3J0YWxVcmwgPSBpbml0aWFsUG9ydGFsVXJsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbFBvcnRhbFVybCA9IGluaXRpYWxQb3J0YWxVcmw7XG4gICAgICAgIHRoaXMuY3VzdG9tT3B0aW9ucyA9IGN1c3RvbU9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIHJlcXVlc3QgZm9yIHRoZSBBUEkgcG9ydGFsIFVSTC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGFzeW5jIGluaXRQb3J0YWxVcmwoKSB7XG4gICAgICAgIGlmICghU2t5bmV0Q2xpZW50LnJlc29sdmVkUG9ydGFsVXJsKSB7XG4gICAgICAgICAgICBTa3luZXRDbGllbnQucmVzb2x2ZWRQb3J0YWxVcmwgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImhlYWRcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmluaXRpYWxQb3J0YWxVcmwsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50UGF0aDogXCIvXCIsXG4gICAgICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRGlkIG5vdCBnZXQgJ2hlYWRlcnMnIGluIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9ydGFsVXJsID0gcmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1wb3J0YWwtYXBpXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcnRhbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgcG9ydGFsIFVSTCBmb3IgdGhlIGdpdmVuIHBvcnRhbFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdHJpbmdfMS50cmltU3VmZml4KHBvcnRhbFVybCwgXCIvXCIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFNreW5ldENsaWVudC5yZXNvbHZlZFBvcnRhbFVybDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBUEkgcG9ydGFsIFVSTC4gTWFrZXMgdGhlIHJlcXVlc3QgdG8gZ2V0IGl0IGlmIG5vdCBkb25lIHNvIGFscmVhZHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBwb3J0YWwgVVJMLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgYXN5bmMgcG9ydGFsVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5naXZlblBvcnRhbFVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2l2ZW5Qb3J0YWxVcmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdCBpZiBuZWVkZWQgYW5kIG5vdCBkb25lIHNvLlxuICAgICAgICB0aGlzLmluaXRQb3J0YWxVcmwoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFNreW5ldENsaWVudC5yZXNvbHZlZFBvcnRhbFVybDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBleGVjdXRlcyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgLSBUaGUgcmVzcG9uc2UgZnJvbSBheGlvcy5cbiAgICAgKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB1bmltcGxlbWVudGVkIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlUmVxdWVzdChjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBCdWlsZCB0aGUgVVJMLlxuICAgICAgICBsZXQgdXJsID0gY29uZmlnLnVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgICAgICAgICB1cmwgPSB1cmxfMS5tYWtlVXJsKHBvcnRhbFVybCwgY29uZmlnLmVuZHBvaW50UGF0aCwgKF9hID0gY29uZmlnLmV4dHJhUGF0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5xdWVyeSkge1xuICAgICAgICAgICAgdXJsID0gdXJsXzEuYWRkVXJsUXVlcnkodXJsLCBjb25maWcucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGhlYWRlcnMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLmNvbmZpZy5oZWFkZXJzIH07XG4gICAgICAgIGlmIChjb25maWcuY3VzdG9tVXNlckFnZW50KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiVXNlci1BZ2VudFwiXSA9IGNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jdXN0b21Db29raWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb29raWVcIl0gPSBjb25maWcuY3VzdG9tQ29va2llO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGggPSBjb25maWcuQVBJS2V5ID8geyB1c2VybmFtZTogXCJcIiwgcGFzc3dvcmQ6IGNvbmZpZy5BUElLZXkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgY29uc3Qgb25VcGxvYWRQcm9ncmVzcyA9IGNvbmZpZy5vblVwbG9hZFByb2dyZXNzICYmXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdGhlIGlmLXN0YXRlbWVudCBvciBUUyBjb21wbGFpbnMuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICBjb25maWcub25VcGxvYWRQcm9ncmVzcyhwcm9ncmVzcywgZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF4aW9zXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QsXG4gICAgICAgICAgICBkYXRhOiBjb25maWcuZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0LFxuICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICAgIG1heENvbnRlbnRMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICAgICAgbWF4Qm9keUxlbmd0aDogSW5maW5pdHksXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcy1zaXRlIGNvb2tpZXMuXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2t5bmV0Q2xpZW50ID0gU2t5bmV0Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hSZWdpc3RyeUVudHJ5ID0gZXhwb3J0cy5oYXNoRGF0YUtleSA9IGV4cG9ydHMuaGFzaEFsbCA9IGV4cG9ydHMuZ2VuS2V5UGFpckZyb21TZWVkID0gZXhwb3J0cy5nZW5LZXlQYWlyQW5kU2VlZCA9IGV4cG9ydHMuZGVyaXZlQ2hpbGRTZWVkID0gdm9pZCAwO1xuY29uc3Qgc2pjbF8xID0gcmVxdWlyZShcInNqY2xcIik7XG5jb25zdCBibGFrZWpzXzEgPSByZXF1aXJlKFwiYmxha2Vqc1wiKTtcbmNvbnN0IHJhbmRvbWJ5dGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJhbmRvbWJ5dGVzXCIpKTtcbmNvbnN0IHR3ZWV0bmFjbF8xID0gcmVxdWlyZShcInR3ZWV0bmFjbFwiKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvc3RyaW5nXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9lbmNvZGluZ1wiKTtcbi8qKlxuICogUmV0dXJucyBhIGJsYWtlMmIgMjU2Yml0IGhhc2hlci4gU2VlIGBOZXdIYXNoYCBpbiBTaWEuXG4gKlxuICogQHJldHVybnMgLSBibGFrZTJiIDI1NmJpdCBoYXNoZXIuXG4gKi9cbmZ1bmN0aW9uIG5ld0hhc2goKSB7XG4gICAgcmV0dXJuIGJsYWtlanNfMS5ibGFrZTJiSW5pdCgzMiwgbnVsbCk7XG59XG4vKipcbiAqIERlcml2ZXMgYSBjaGlsZCBzZWVkIGZyb20gdGhlIGdpdmVuIG1hc3RlciBzZWVkIGFuZCBzdWIgc2VlZC5cbiAqXG4gKiBAcGFyYW0gbWFzdGVyU2VlZCAtIFRoZSBtYXN0ZXIgc2VlZCB0byBkZXJpdmUgZnJvbS5cbiAqIEBwYXJhbSBzZWVkIC0gVGhlIHN1YiBzZWVkIGZvciB0aGUgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIC0gVGhlIGNoaWxkIHNlZWQgZGVyaXZlZCBmcm9tIGBtYXN0ZXJTZWVkYCB1c2luZyBgc2VlZGAuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXRzIGFyZSBub3Qgc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGVyaXZlQ2hpbGRTZWVkKG1hc3RlclNlZWQsIHNlZWQpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJtYXN0ZXJTZWVkXCIsIG1hc3RlclNlZWQsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInNlZWRcIiwgc2VlZCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgcmV0dXJuIHN0cmluZ18xLnRvSGV4U3RyaW5nKGhhc2hBbGwoZW5jb2RpbmdfMS5lbmNvZGVVdGY4U3RyaW5nKG1hc3RlclNlZWQpLCBlbmNvZGluZ18xLmVuY29kZVV0ZjhTdHJpbmcoc2VlZCkpKTtcbn1cbmV4cG9ydHMuZGVyaXZlQ2hpbGRTZWVkID0gZGVyaXZlQ2hpbGRTZWVkO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXN0ZXIga2V5IHBhaXIgYW5kIHNlZWQuXG4gKlxuICogQHBhcmFtIFtsZW5ndGg9NjRdIC0gVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgZm9yIHRoZSBzZWVkLiBOb3RlIHRoYXQgdGhlIHN0cmluZyBzZWVkIHdpbGwgYmUgY29udmVydGVkIHRvIGhleCByZXByZXNlbnRhdGlvbiwgbWFraW5nIGl0IHR3aWNlIHRoaXMgbGVuZ3RoLlxuICogQHJldHVybnMgLSBUaGUgZ2VuZXJhdGVkIGtleSBwYWlyIGFuZCBzZWVkLlxuICovXG5mdW5jdGlvbiBnZW5LZXlQYWlyQW5kU2VlZChsZW5ndGggPSA2NCkge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU51bWJlcihcImxlbmd0aFwiLCBsZW5ndGgsIFwicGFyYW1ldGVyXCIpO1xuICAgIGNvbnN0IHNlZWQgPSBtYWtlU2VlZChsZW5ndGgpO1xuICAgIHJldHVybiB7IC4uLmdlbktleVBhaXJGcm9tU2VlZChzZWVkKSwgc2VlZCB9O1xufVxuZXhwb3J0cy5nZW5LZXlQYWlyQW5kU2VlZCA9IGdlbktleVBhaXJBbmRTZWVkO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwdWJsaWMgYW5kIHByaXZhdGUga2V5IGZyb20gYSBwcm92aWRlZCwgc2VjdXJlIHNlZWQuXG4gKlxuICogQHBhcmFtIHNlZWQgLSBBIHNlY3VyZSBzZWVkLlxuICogQHJldHVybnMgLSBUaGUgZ2VuZXJhdGVkIGtleSBwYWlyLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2VuS2V5UGFpckZyb21TZWVkKHNlZWQpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJzZWVkXCIsIHNlZWQsIFwicGFyYW1ldGVyXCIpO1xuICAgIC8vIEdldCBhIDMyLWJ5dGUga2V5LlxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBzamNsXzEubWlzYy5wYmtkZjIoc2VlZCwgXCJcIiwgMTAwMCwgMzIgKiA4KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5SGV4ID0gc2pjbF8xLmNvZGVjLmhleC5mcm9tQml0cyhkZXJpdmVkS2V5KTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgc2VjcmV0S2V5IH0gPSB0d2VldG5hY2xfMS5zaWduLmtleVBhaXIuZnJvbVNlZWQoc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KGRlcml2ZWRLZXlIZXgpKTtcbiAgICByZXR1cm4geyBwdWJsaWNLZXk6IHN0cmluZ18xLnRvSGV4U3RyaW5nKHB1YmxpY0tleSksIHByaXZhdGVLZXk6IHN0cmluZ18xLnRvSGV4U3RyaW5nKHNlY3JldEtleSkgfTtcbn1cbmV4cG9ydHMuZ2VuS2V5UGFpckZyb21TZWVkID0gZ2VuS2V5UGFpckZyb21TZWVkO1xuLyoqXG4gKiBUYWtlcyBhbGwgZ2l2ZW4gYXJndW1lbnRzIGFuZCBoYXNoZXMgdGhlbS5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIEJ5dGUgYXJyYXlzIHRvIGhhc2guXG4gKiBAcmV0dXJucyAtIFRoZSBmaW5hbCBoYXNoIGFzIGEgYnl0ZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaGFzaEFsbCguLi5hcmdzKSB7XG4gICAgY29uc3QgaGFzaGVyID0gbmV3SGFzaCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBibGFrZWpzXzEuYmxha2UyYlVwZGF0ZShoYXNoZXIsIGFyZ3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYmxha2Vqc18xLmJsYWtlMmJGaW5hbChoYXNoZXIpO1xufVxuZXhwb3J0cy5oYXNoQWxsID0gaGFzaEFsbDtcbi8qKlxuICogSGFzaCB0aGUgZ2l2ZW4gZGF0YSBrZXkuXG4gKlxuICogQHBhcmFtIGRhdGFLZXkgLSBEYXRhIGtleSB0byBoYXNoLlxuICogQHJldHVybnMgLSBIYXNoIG9mIHRoZSBkYXRhIGtleS5cbiAqL1xuZnVuY3Rpb24gaGFzaERhdGFLZXkoZGF0YUtleSkge1xuICAgIHJldHVybiBoYXNoQWxsKGVuY29kaW5nXzEuZW5jb2RlVXRmOFN0cmluZyhkYXRhS2V5KSk7XG59XG5leHBvcnRzLmhhc2hEYXRhS2V5ID0gaGFzaERhdGFLZXk7XG4vKipcbiAqIEhhc2hlcyB0aGUgZ2l2ZW4gcmVnaXN0cnkgZW50cnkuXG4gKlxuICogQHBhcmFtIHJlZ2lzdHJ5RW50cnkgLSBSZWdpc3RyeSBlbnRyeSB0byBoYXNoLlxuICogQHBhcmFtIGhhc2hlZERhdGFLZXlIZXggLSBXaGV0aGVyIHRoZSBkYXRhIGtleSBpcyBhbHJlYWR5IGhhc2hlZCBhbmQgaW4gaGV4IGZvcm1hdC4gSWYgbm90LCB3ZSBoYXNoIHRoZSBkYXRhIGtleS5cbiAqIEByZXR1cm5zIC0gSGFzaCBvZiB0aGUgcmVnaXN0cnkgZW50cnkuXG4gKi9cbmZ1bmN0aW9uIGhhc2hSZWdpc3RyeUVudHJ5KHJlZ2lzdHJ5RW50cnksIGhhc2hlZERhdGFLZXlIZXgpIHtcbiAgICBsZXQgZGF0YUtleUJ5dGVzO1xuICAgIGlmIChoYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgICAgIGRhdGFLZXlCeXRlcyA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShyZWdpc3RyeUVudHJ5LmRhdGFLZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YUtleUJ5dGVzID0gaGFzaERhdGFLZXkocmVnaXN0cnlFbnRyeS5kYXRhS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hBbGwoZGF0YUtleUJ5dGVzLCBlbmNvZGluZ18xLmVuY29kZVV0ZjhTdHJpbmcocmVnaXN0cnlFbnRyeS5kYXRhKSwgZW5jb2RpbmdfMS5lbmNvZGVCaWdpbnRBc1VpbnQ2NChyZWdpc3RyeUVudHJ5LnJldmlzaW9uKSk7XG59XG5leHBvcnRzLmhhc2hSZWdpc3RyeUVudHJ5ID0gaGFzaFJlZ2lzdHJ5RW50cnk7XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZWVkIG9mIHRoZSBnaXZlbiBsZW5ndGggaW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgc2VlZCBpbiBieXRlcy5cbiAqIEByZXR1cm5zIC0gVGhlIGdlbmVyYXRlZCBzZWVkLlxuICovXG5mdW5jdGlvbiBtYWtlU2VlZChsZW5ndGgpIHtcbiAgICAvLyBDcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIEl0IHNob3VsZCB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpbiB0aGUgYnJvd3Nlci5cbiAgICBjb25zdCBhcnJheSA9IHJhbmRvbWJ5dGVzXzEuZGVmYXVsdChsZW5ndGgpO1xuICAgIHJldHVybiBzdHJpbmdfMS50b0hleFN0cmluZyhhcnJheSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZUhucyA9IGV4cG9ydHMub3BlbkZpbGVIbnMgPSBleHBvcnRzLm9wZW5GaWxlID0gZXhwb3J0cy5nZXRGaWxlQ29udGVudFJlcXVlc3QgPSBleHBvcnRzLmdldEZpbGVDb250ZW50SG5zID0gZXhwb3J0cy5nZXRGaWxlQ29udGVudCA9IGV4cG9ydHMuZ2V0TWV0YWRhdGEgPSBleHBvcnRzLmdldEhuc3Jlc1VybCA9IGV4cG9ydHMuZ2V0SG5zVXJsID0gZXhwb3J0cy5nZXRTa3lsaW5rVXJsRm9yUG9ydGFsID0gZXhwb3J0cy5nZXRTa3lsaW5rVXJsID0gZXhwb3J0cy5kb3dubG9hZEZpbGVIbnMgPSBleHBvcnRzLmRvd25sb2FkRmlsZSA9IGV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL3NreWxpbmsvZm9ybWF0XCIpO1xuY29uc3QgcGFyc2VfMSA9IHJlcXVpcmUoXCIuL3NreWxpbmsvcGFyc2VcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbmV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAuLi5vcHRpb25zXzEuZGVmYXVsdEJhc2VPcHRpb25zLFxuICAgIGVuZHBvaW50RG93bmxvYWQ6IFwiL1wiLFxuICAgIGRvd25sb2FkOiBmYWxzZSxcbiAgICBub1Jlc3BvbnNlTWV0YWRhdGE6IGZhbHNlLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIHN1YmRvbWFpbjogZmFsc2UsXG59O1xuY29uc3QgZGVmYXVsdERvd25sb2FkSG5zT3B0aW9ucyA9IHtcbiAgICAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsXG4gICAgZW5kcG9pbnREb3dubG9hZEhuczogXCJobnNcIixcbiAgICBobnNTdWJkb21haW46IFwiaG5zXCIsXG59O1xuY29uc3QgZGVmYXVsdFJlc29sdmVIbnNPcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnNfMS5kZWZhdWx0QmFzZU9wdGlvbnMsXG4gICAgZW5kcG9pbnREb3dubG9hZEhuc3JlczogXCJobnNyZXNcIixcbn07XG4vKipcbiAqIEluaXRpYXRlcyBhIGRvd25sb2FkIG9mIHRoZSBjb250ZW50IG9mIHRoZSBza3lsaW5rIHdpdGhpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHNreWxpbmtVcmwgLSA0Ni1jaGFyYWN0ZXIgc2t5bGluaywgb3IgYSB2YWxpZCBza3lsaW5rIFVSTC4gQ2FuIGJlIGZvbGxvd2VkIGJ5IGEgcGF0aC4gTm90ZSB0aGF0IHRoZSBza3lsaW5rIHdpbGwgbm90IGJlIGVuY29kZWQsIHNvIGlmIHlvdXIgcGF0aCBtaWdodCBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycywgY29uc2lkZXIgdXNpbmcgYGN1c3RvbU9wdGlvbnMucGF0aGAuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIHRoYXQgd2FzIHVzZWQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoc2t5bGlua1VybCwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0U2t5bGlua1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMsIGRvd25sb2FkOiB0cnVlIH07XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRTa3lsaW5rVXJsKHNreWxpbmtVcmwsIG9wdHMpO1xuICAgIC8vIERvd25sb2FkIHRoZSB1cmwuXG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLmRvd25sb2FkRmlsZSA9IGRvd25sb2FkRmlsZTtcbi8qKlxuICogSW5pdGlhdGVzIGEgZG93bmxvYWQgb2YgdGhlIGNvbnRlbnQgb2YgdGhlIHNreWxpbmsgYXQgdGhlIEhhbmRzaGFrZSBkb21haW4uXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBkb21haW4gLSBIYW5kc2hha2UgZG9tYWluLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL2huc1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIFVSTCB0aGF0IHdhcyB1c2VkLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGRvbWFpbiBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZUhucyhkb21haW4sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldEhuc1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdERvd25sb2FkSG5zT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zLCBkb3dubG9hZDogdHJ1ZSB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0SG5zVXJsKGRvbWFpbiwgb3B0cyk7XG4gICAgLy8gRG93bmxvYWQgdGhlIHVybC5cbiAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMuZG93bmxvYWRGaWxlSG5zID0gZG93bmxvYWRGaWxlSG5zO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBmdWxsIFVSTCBmb3IgdGhlIGdpdmVuIHNreWxpbmsuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gU2t5bGluayBzdHJpbmcuIFNlZSBgZG93bmxvYWRGaWxlYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UGF0aD1cIi9cIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgZm9yIHRoZSBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHNreWxpbmtVcmwgZG9lcyBub3QgY29udGFpbiBhIHNreWxpbmsgb3IgaWYgdGhlIHBhdGggb3B0aW9uIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0U2t5bGlua1VybChza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRTa3lsaW5rVXJsRm9yUG9ydGFsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgcmV0dXJuIGdldFNreWxpbmtVcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBza3lsaW5rVXJsLCBvcHRzKTtcbn1cbmV4cG9ydHMuZ2V0U2t5bGlua1VybCA9IGdldFNreWxpbmtVcmw7XG4vKipcbiAqIEdldHMgdGhlIHNreWxpbmsgVVJMIHdpdGhvdXQgYW4gaW5pdGlhbGl6ZWQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBwb3J0YWxVcmwgLSBUaGUgcG9ydGFsIFVSTC5cbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gU2t5bGluayBzdHJpbmcuIFNlZSBgZG93bmxvYWRGaWxlYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgZm9yIHRoZSBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHNreWxpbmtVcmwgZG9lcyBub3QgY29udGFpbiBhIHNreWxpbmsgb3IgaWYgdGhlIHBhdGggb3B0aW9uIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2t5bGlua1VybEZvclBvcnRhbChwb3J0YWxVcmwsIHNreWxpbmtVcmwsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBvcnRhbFVybFwiLCBwb3J0YWxVcmwsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInNreWxpbmtVcmxcIiwgc2t5bGlua1VybCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgcXVlcnkgPSAoX2EgPSBvcHRzLnF1ZXJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBpZiAob3B0cy5kb3dubG9hZCkge1xuICAgICAgICAvLyBTZXQgdGhlIFwiYXR0YWNobWVudFwiIHBhcmFtZXRlci5cbiAgICAgICAgcXVlcnkuYXR0YWNobWVudCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLm5vUmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICAvLyBTZXQgdGhlIFwibm8tcmVzcG9uc2UtbWV0YWRhdGFcIiBwYXJhbWV0ZXIuXG4gICAgICAgIHF1ZXJ5W1wibm8tcmVzcG9uc2UtbWV0YWRhdGFcIl0gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBVUkwtZW5jb2RlIHRoZSBwYXRoLlxuICAgIGxldCBwYXRoID0gXCJcIjtcbiAgICBpZiAob3B0cy5wYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wdHMucGF0aCBoYXMgdG8gYmUgYSBzdHJpbmcsICR7dHlwZW9mIG9wdHMucGF0aH0gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmNvZGUgZWFjaCBlbGVtZW50IG9mIHRoZSBwYXRoIHNlcGFyYXRlbHkgYW5kIGpvaW4gdGhlbS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRG9uJ3QgdXNlIGVuY29kZVVSSSBiZWNhdXNlIGl0IGRvZXMgbm90IGVuY29kZSBjaGFyYWN0ZXJzIHN1Y2ggYXMgJz8nXG4gICAgICAgIC8vIGV0Yy4gVGhlc2UgYXJlIGFsbG93ZWQgYXMgZmlsZW5hbWVzIG9uIFNreW5ldCBhbmQgc2hvdWxkIGJlIGVuY29kZWQgc29cbiAgICAgICAgLy8gdGhleSBhcmUgbm90IHRyZWF0ZWQgYXMgVVJMIHNlcGFyYXRvcnMuXG4gICAgICAgIHBhdGggPSBvcHRzLnBhdGhcbiAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgIC5tYXAoKGVsZW1lbnQpID0+IGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KSlcbiAgICAgICAgICAgIC5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHVybDtcbiAgICBpZiAob3B0cy5zdWJkb21haW4pIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwYXRoIGZyb20gdGhlIHNreWxpbmsuIFVzZSB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgY29uc3Qgc2t5bGlua1BhdGggPSAoX2IgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsLCB7IG9ubHlQYXRoOiB0cnVlIH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICAvLyBHZXQganVzdCB0aGUgc2t5bGluay5cbiAgICAgICAgbGV0IHNreWxpbmsgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsKTtcbiAgICAgICAgaWYgKHNreWxpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBza3lsaW5rIG91dCBvZiBpbnB1dCAnJHtza3lsaW5rVXJsfSdgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBza3lsaW5rICh3aXRob3V0IHRoZSBwYXRoKSB0byBiYXNlMzIuXG4gICAgICAgIHNreWxpbmsgPSBmb3JtYXRfMS5jb252ZXJ0U2t5bGlua1RvQmFzZTMyKHNreWxpbmspO1xuICAgICAgICB1cmwgPSB1cmxfMS5hZGRTdWJkb21haW4ocG9ydGFsVXJsLCBza3lsaW5rKTtcbiAgICAgICAgdXJsID0gdXJsXzEubWFrZVVybCh1cmwsIHNreWxpbmtQYXRoLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgc2t5bGluayBpbmNsdWRpbmcgdGhlIHBhdGguXG4gICAgICAgIGNvbnN0IHNreWxpbmsgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsLCB7IGluY2x1ZGVQYXRoOiB0cnVlIH0pO1xuICAgICAgICBpZiAoc2t5bGluayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IHNreWxpbmsgd2l0aCBwYXRoIG91dCBvZiBpbnB1dCAnJHtza3lsaW5rVXJsfSdgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYWRkaXRpb25hbCBwYXRoIGlmIHBhc3NlZCBpbi5cbiAgICAgICAgdXJsID0gdXJsXzEubWFrZVVybChwb3J0YWxVcmwsIG9wdHMuZW5kcG9pbnREb3dubG9hZCwgc2t5bGluaywgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB1cmxfMS5hZGRVcmxRdWVyeSh1cmwsIHF1ZXJ5KTtcbn1cbmV4cG9ydHMuZ2V0U2t5bGlua1VybEZvclBvcnRhbCA9IGdldFNreWxpbmtVcmxGb3JQb3J0YWw7XG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gSE5TIGRvbWFpbi5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRvbWFpbiAtIEhhbmRzaGFrZSBkb21haW4uXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnM9e31dIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvaG5zXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIGZvciB0aGUgSE5TIGRvbWFpbi5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBkb21haW4gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRIbnNVcmwoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRvbWFpblwiLCBkb21haW4sIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBkZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCBxdWVyeSA9IChfYSA9IG9wdHMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRzLmRvd25sb2FkKSB7XG4gICAgICAgIHF1ZXJ5LmF0dGFjaG1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5ub1Jlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgcXVlcnlbXCJuby1yZXNwb25zZS1tZXRhZGF0YVwiXSA9IHRydWU7XG4gICAgfVxuICAgIGRvbWFpbiA9IHN0cmluZ18xLnRyaW1VcmlQcmVmaXgoZG9tYWluLCB1cmxfMS51cmlIYW5kc2hha2VQcmVmaXgpO1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgY29uc3QgdXJsID0gb3B0cy5zdWJkb21haW5cbiAgICAgICAgPyB1cmxfMS5hZGRTdWJkb21haW4odXJsXzEuYWRkU3ViZG9tYWluKHBvcnRhbFVybCwgb3B0cy5obnNTdWJkb21haW4pLCBkb21haW4pXG4gICAgICAgIDogdXJsXzEubWFrZVVybChwb3J0YWxVcmwsIG9wdHMuZW5kcG9pbnREb3dubG9hZEhucywgZG9tYWluKTtcbiAgICByZXR1cm4gdXJsXzEuYWRkVXJsUXVlcnkodXJsLCBxdWVyeSk7XG59XG5leHBvcnRzLmdldEhuc1VybCA9IGdldEhuc1VybDtcbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZnVsbCBVUkwgZm9yIHRoZSByZXNvbHZlciBmb3IgdGhlIGdpdmVuIEhOUyBkb21haW4uXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBkb21haW4gLSBIYW5kc2hha2UgZG9tYWluLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zPXt9XSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL2huc3Jlc1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIFVSTCBmb3IgdGhlIHJlc29sdmVyIGZvciB0aGUgSE5TIGRvbWFpbi5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBkb21haW4gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRIbnNyZXNVcmwoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZG9tYWluXCIsIGRvbWFpbiwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGRlZmF1bHRSZXNvbHZlSG5zT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdFJlc29sdmVIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBkb21haW4gPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KGRvbWFpbiwgdXJsXzEudXJpSGFuZHNoYWtlUmVzb2x2ZXJQcmVmaXgpO1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgcmV0dXJuIHVybF8xLm1ha2VVcmwocG9ydGFsVXJsLCBvcHRzLmVuZHBvaW50RG93bmxvYWRIbnNyZXMsIGRvbWFpbik7XG59XG5leHBvcnRzLmdldEhuc3Jlc1VybCA9IGdldEhuc3Jlc1VybDtcbi8qKlxuICogR2V0cyBvbmx5IHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIHNreWxpbmsgd2l0aG91dCB0aGUgY29udGVudHMuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gU2t5bGluayBzdHJpbmcuIFNlZSBgZG93bmxvYWRGaWxlYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LiBTZWUgYGRvd25sb2FkRmlsZWAgZm9yIHRoZSBmdWxsIGxpc3QuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSBtZXRhZGF0YSBpbiBKU09OIGZvcm1hdC4gRW1wdHkgaWYgbm8gbWV0YWRhdGEgd2FzIGZvdW5kLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHNreWxpbmtVcmwgZG9lcyBub3QgY29udGFpbiBhIHNreWxpbmsgb3IgaWYgdGhlIHBhdGggb3B0aW9uIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TWV0YWRhdGEoc2t5bGlua1VybCwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0U2t5bGlua1VybGAuXG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0U2t5bGlua1VybChza3lsaW5rVXJsLCBvcHRzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBlbmRwb2ludFBhdGg6IG9wdHMuZW5kcG9pbnREb3dubG9hZCxcbiAgICAgICAgbWV0aG9kOiBcImhlYWRcIixcbiAgICAgICAgdXJsLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuaGVhZGVycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGdldCAnaGVhZGVycycgaW4gcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IChfYSA9IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgY29uc3QgbWV0YWRhdGEgPSByZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LWZpbGUtbWV0YWRhdGFcIl0gPyBKU09OLnBhcnNlKHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtZmlsZS1tZXRhZGF0YVwiXSkgOiB7fTtcbiAgICBjb25zdCBwb3J0YWxVcmwgPSAoX2IgPSByZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LXBvcnRhbC1hcGlcIl0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgY29uc3Qgc2t5bGluayA9IHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtc2t5bGlua1wiXSA/IGZvcm1hdF8xLmZvcm1hdFNreWxpbmsocmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1za3lsaW5rXCJdKSA6IFwiXCI7XG4gICAgcmV0dXJuIHsgY29udGVudFR5cGUsIG1ldGFkYXRhLCBwb3J0YWxVcmwsIHNreWxpbmsgfTtcbn1cbmV4cG9ydHMuZ2V0TWV0YWRhdGEgPSBnZXRNZXRhZGF0YTtcbi8qKlxuICogR2V0cyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYXQgdGhlIGdpdmVuIHNreWxpbmsuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gU2t5bGluayBzdHJpbmcuIFNlZSBgZG93bmxvYWRGaWxlYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UGF0aD1cIi9cIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgZmlsZSwgdGhlIGNvbnRlbnQtdHlwZSwgbWV0YWRhdGEsIGFuZCB0aGUgZmlsZSdzIHNreWxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlQ29udGVudChza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRTa3lsaW5rVXJsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0U2t5bGlua1VybChza3lsaW5rVXJsLCBvcHRzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRGaWxlQ29udGVudFJlcXVlc3QodXJsLCBvcHRzKTtcbn1cbmV4cG9ydHMuZ2V0RmlsZUNvbnRlbnQgPSBnZXRGaWxlQ29udGVudDtcbi8qKlxuICogR2V0cyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYXQgdGhlIGdpdmVuIEhhbmRzaGFrZSBkb21haW4uXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBkb21haW4gLSBIYW5kc2hha2UgZG9tYWluLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL2huc1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIG9mIHRoZSBmaWxlLCB0aGUgY29udGVudC10eXBlLCBtZXRhZGF0YSwgYW5kIHRoZSBmaWxlJ3Mgc2t5bGluay5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBkb21haW4gZG9lcyBub3QgY29udGFpbiBhIHNreWxpbmsuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbGVDb250ZW50SG5zKGRvbWFpbiwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0SG5zVXJsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldEhuc1VybChkb21haW4sIG9wdHMpO1xuICAgIHJldHVybiB0aGlzLmdldEZpbGVDb250ZW50UmVxdWVzdCh1cmwsIG9wdHMpO1xufVxuZXhwb3J0cy5nZXRGaWxlQ29udGVudEhucyA9IGdldEZpbGVDb250ZW50SG5zO1xuLyoqXG4gKiBEb2VzIGEgR0VUIHJlcXVlc3Qgb2YgdGhlIHNreWxpbmssIHJldHVybmluZyB0aGUgZGF0YSBwcm9wZXJ0eSBvZiB0aGUgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSB1cmwgLSBVUkwuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIGZpbGUsIHRoZSBjb250ZW50LXR5cGUsIG1ldGFkYXRhLCBhbmQgdGhlIGZpbGUncyBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJlcXVlc3QgZG9lcyBub3Qgc3VjY2VlZCBvciB0aGUgcmVzcG9uc2UgaXMgbWlzc2luZyBkYXRhLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlQ29udGVudFJlcXVlc3QodXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gTm90IHB1YmxpY2x5IGF2YWlsYWJsZSwgZG9uJ3QgdmFsaWRhdGUgaW5wdXQuXG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIC8vIEdFVCByZXF1ZXN0IHRoZSBkYXRhIGF0IHRoZSBza3lsaW5rLlxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGVuZHBvaW50UGF0aDogb3B0cy5lbmRwb2ludERvd25sb2FkLFxuICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBnZXQgJ2RhdGEnIGluIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZ2V0ICdoZWFkZXJzJyBpbiByZXNwb25zZSBkZXNwaXRlIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LiBQbGVhc2UgdHJ5IGFnYWluIGFuZCByZXBvcnQgdGhpcyBpc3N1ZSB0byB0aGUgZGV2cyBpZiBpdCBwZXJzaXN0cy5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gKF9hID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtZmlsZS1tZXRhZGF0YVwiXSA/IEpTT04ucGFyc2UocmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1maWxlLW1ldGFkYXRhXCJdKSA6IHt9O1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IChfYiA9IHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtcG9ydGFsLWFwaVwiXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICBjb25zdCBza3lsaW5rID0gcmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1za3lsaW5rXCJdID8gZm9ybWF0XzEuZm9ybWF0U2t5bGluayhyZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LXNreWxpbmtcIl0pIDogXCJcIjtcbiAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5kYXRhLCBjb250ZW50VHlwZSwgcG9ydGFsVXJsLCBtZXRhZGF0YSwgc2t5bGluayB9O1xufVxuZXhwb3J0cy5nZXRGaWxlQ29udGVudFJlcXVlc3QgPSBnZXRGaWxlQ29udGVudFJlcXVlc3Q7XG4vKipcbiAqIE9wZW5zIHRoZSBjb250ZW50IG9mIHRoZSBza3lsaW5rIHdpdGhpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHNreWxpbmtVcmwgLSBTa3lsaW5rIHN0cmluZy4gU2VlIGBkb3dubG9hZEZpbGVgLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuIFNlZSBgZG93bmxvYWRGaWxlYCBmb3IgdGhlIGZ1bGwgbGlzdC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIHRoYXQgd2FzIHVzZWQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBvcGVuRmlsZShza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRTa3lsaW5rVXJsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0U2t5bGlua1VybChza3lsaW5rVXJsLCBvcHRzKTtcbiAgICB3aW5kb3cub3Blbih1cmwsIFwiX2JsYW5rXCIpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLm9wZW5GaWxlID0gb3BlbkZpbGU7XG4vKipcbiAqIE9wZW5zIHRoZSBjb250ZW50IG9mIHRoZSBza3lsaW5rIGZyb20gdGhlIGdpdmVuIEhhbmRzaGFrZSBkb21haW4gd2l0aGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gSGFuZHNoYWtlIGRvbWFpbi5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LiBTZWUgYGRvd25sb2FkRmlsZUhuc2AgZm9yIHRoZSBmdWxsIGxpc3QuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL2huc1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIFVSTCB0aGF0IHdhcyB1c2VkLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGRvbWFpbiBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9wZW5GaWxlSG5zKGRvbWFpbiwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0SG5zVXJsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldEhuc1VybChkb21haW4sIG9wdHMpO1xuICAgIC8vIE9wZW4gdGhlIHVybCBpbiBhIG5ldyB0YWIuXG4gICAgd2luZG93Lm9wZW4odXJsLCBcIl9ibGFua1wiKTtcbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy5vcGVuRmlsZUhucyA9IG9wZW5GaWxlSG5zO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSE5TIGRvbWFpbiB0byBpdHMgVFhUIHJlY29yZCBhbmQgcmV0dXJucyB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRvbWFpbiAtIEhhbmRzaGFrZSByZXNvbHZlciBkb21haW4uXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnM9e31dIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvaG5zcmVzXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGRhdGEgZm9yIHRoZSBUWFQgcmVjb3JkLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGRvbWFpbiBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVIbnMoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRIbnNyZXNVcmxgLlxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmRlZmF1bHRSZXNvbHZlSG5zT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRIbnNyZXNVcmwoZG9tYWluLCBvcHRzKTtcbiAgICAvLyBHZXQgdGhlIHR4dCByZWNvcmQgZnJvbSB0aGUgaG5zcmVzIGRvbWFpbiBvbiB0aGUgcG9ydGFsLlxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGVuZHBvaW50UGF0aDogb3B0cy5lbmRwb2ludERvd25sb2FkSG5zcmVzLFxuICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVJlc29sdmVIbnNSZXNwb25zZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59XG5leHBvcnRzLnJlc29sdmVIbnMgPSByZXNvbHZlSG5zO1xuZnVuY3Rpb24gdmFsaWRhdGVSZXNvbHZlSG5zUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc3BvbnNlLmRhdGEgZmllbGQgbWlzc2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJyZXNwb25zZS5kYXRhLnNreWxpbmtcIiwgcmVzcG9uc2UuZGF0YS5za3lsaW5rLCBcInVwbG9hZCByZXNwb25zZSBmaWVsZFwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCBub3QgZ2V0IGEgY29tcGxldGUgcmVzb2x2ZSBITlMgcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuIEVycm9yOiAke2Vycn1gKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SlNPTiA9IHZvaWQgMDtcbmNvbnN0IHR3ZWFrXzEgPSByZXF1aXJlKFwiLi9teXNreS90d2Vha1wiKTtcbmNvbnN0IHNreWRiXzEgPSByZXF1aXJlKFwiLi9za3lkYlwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRpb25cIik7XG5hc3luYyBmdW5jdGlvbiBnZXRKU09OKHVzZXJJRCwgcGF0aCwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInVzZXJJRFwiLCB1c2VySUQsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBhdGhcIiwgcGF0aCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIHNreWRiXzEuZGVmYXVsdEdldEpTT05PcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5za3lkYl8xLmRlZmF1bHRHZXRKU09OT3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgZGF0YUtleSA9IHR3ZWFrXzEuZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsocGF0aCk7XG4gICAgb3B0cy5oYXNoZWREYXRhS2V5SGV4ID0gdHJ1ZTsgLy8gRG8gbm90IGhhc2ggdGhlIHR3ZWFrIGFueW1vcmUuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0SlNPTih1c2VySUQsIGRhdGFLZXksIG9wdHMpO1xufVxuZXhwb3J0cy5nZXRKU09OID0gZ2V0SlNPTjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJtTGVnYWN5U2t5SUQgPSBleHBvcnRzLlBlcm1EaXNjb3ZlcmFibGUgPSBleHBvcnRzLlBlcm1IaWRkZW4gPSBleHBvcnRzLlBlcm1Xcml0ZSA9IGV4cG9ydHMuUGVybVJlYWQgPSBleHBvcnRzLlBlcm1UeXBlID0gZXhwb3J0cy5QZXJtQ2F0ZWdvcnkgPSBleHBvcnRzLlBlcm1pc3Npb24gPSBleHBvcnRzLm15U2t5RGV2RG9tYWluID0gZXhwb3J0cy5teVNreURvbWFpbiA9IGV4cG9ydHMuRGFjTGlicmFyeSA9IGV4cG9ydHMudXJpU2t5bmV0UHJlZml4ID0gZXhwb3J0cy51cmlIYW5kc2hha2VSZXNvbHZlclByZWZpeCA9IGV4cG9ydHMudXJpSGFuZHNoYWtlUHJlZml4ID0gZXhwb3J0cy5nZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsID0gZXhwb3J0cy5leHRyYWN0RG9tYWluRm9yUG9ydGFsID0gZXhwb3J0cy5kZWZhdWx0U2t5bmV0UG9ydGFsVXJsID0gZXhwb3J0cy5kZWZhdWx0UG9ydGFsVXJsID0gZXhwb3J0cy5wYXJzZVNreWxpbmsgPSBleHBvcnRzLmNvbnZlcnRTa3lsaW5rVG9CYXNlMzIgPSBleHBvcnRzLk1BWF9SRVZJU0lPTiA9IGV4cG9ydHMuZ2V0Um9vdERpcmVjdG9yeSA9IGV4cG9ydHMuZ2V0UmVsYXRpdmVGaWxlUGF0aCA9IGV4cG9ydHMuc2lnbkVudHJ5ID0gZXhwb3J0cy5nZXRFbnRyeVVybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0U2t5bGlua1VybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2VuS2V5UGFpckZyb21TZWVkID0gZXhwb3J0cy5nZW5LZXlQYWlyQW5kU2VlZCA9IGV4cG9ydHMuZGVyaXZlQ2hpbGRTZWVkID0gZXhwb3J0cy5Ta3luZXRDbGllbnQgPSB2b2lkIDA7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTa3luZXRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLlNreW5ldENsaWVudDsgfSB9KTtcbnZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL2NyeXB0b1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlcml2ZUNoaWxkU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEuZGVyaXZlQ2hpbGRTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuS2V5UGFpckFuZFNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLmdlbktleVBhaXJBbmRTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuS2V5UGFpckZyb21TZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcnlwdG9fMS5nZW5LZXlQYWlyRnJvbVNlZWQ7IH0gfSk7XG52YXIgZG93bmxvYWRfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U2t5bGlua1VybEZvclBvcnRhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG93bmxvYWRfMS5nZXRTa3lsaW5rVXJsRm9yUG9ydGFsOyB9IH0pO1xudmFyIHJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yZWdpc3RyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEVudHJ5VXJsRm9yUG9ydGFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeV8xLmdldEVudHJ5VXJsRm9yUG9ydGFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2lnbkVudHJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeV8xLnNpZ25FbnRyeTsgfSB9KTtcbnZhciBmaWxlXzEgPSByZXF1aXJlKFwiLi91dGlscy9maWxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UmVsYXRpdmVGaWxlUGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsZV8xLmdldFJlbGF0aXZlRmlsZVBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb290RGlyZWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWxlXzEuZ2V0Um9vdERpcmVjdG9yeTsgfSB9KTtcbnZhciBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1BWF9SRVZJU0lPTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyXzEuTUFYX1JFVklTSU9OOyB9IH0pO1xudmFyIGZvcm1hdF8xID0gcmVxdWlyZShcIi4vc2t5bGluay9mb3JtYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0U2t5bGlua1RvQmFzZTMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXRfMS5jb252ZXJ0U2t5bGlua1RvQmFzZTMyOyB9IH0pO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL3BhcnNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VTa3lsaW5rXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZV8xLnBhcnNlU2t5bGluazsgfSB9KTtcbnZhciB1cmxfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3VybFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQb3J0YWxVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF8xLmRlZmF1bHRQb3J0YWxVcmw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0U2t5bmV0UG9ydGFsVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfMS5kZWZhdWx0U2t5bmV0UG9ydGFsVXJsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXh0cmFjdERvbWFpbkZvclBvcnRhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsXzEuZXh0cmFjdERvbWFpbkZvclBvcnRhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF8xLmdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1cmlIYW5kc2hha2VQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF8xLnVyaUhhbmRzaGFrZVByZWZpeDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaUhhbmRzaGFrZVJlc29sdmVyUHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfMS51cmlIYW5kc2hha2VSZXNvbHZlclByZWZpeDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaVNreW5ldFByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsXzEudXJpU2t5bmV0UHJlZml4OyB9IH0pO1xudmFyIG15c2t5XzEgPSByZXF1aXJlKFwiLi9teXNreVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhY0xpYnJhcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG15c2t5XzEuRGFjTGlicmFyeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm15U2t5RG9tYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBteXNreV8xLm15U2t5RG9tYWluOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibXlTa3lEZXZEb21haW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG15c2t5XzEubXlTa3lEZXZEb21haW47IH0gfSk7XG4vLyBSZS1leHBvcnQgUGVybWlzc2lvbnMuXG52YXIgc2t5bmV0X215c2t5X3V0aWxzXzEgPSByZXF1aXJlKFwic2t5bmV0LW15c2t5LXV0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybWlzc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybWlzc2lvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcm1DYXRlZ29yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybUNhdGVnb3J5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybVJlYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1SZWFkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybVdyaXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtV3JpdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtSGlkZGVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtSGlkZGVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybURpc2NvdmVyYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybURpc2NvdmVyYWJsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcm1MZWdhY3lTa3lJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybUxlZ2FjeVNreUlEOyB9IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3RvciA9IGV4cG9ydHMuZGVmYXVsdENvbm5lY3Rvck9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBwb3N0X21lXzEgPSByZXF1aXJlKFwicG9zdC1tZVwiKTtcbmNvbnN0IHNreW5ldF9teXNreV91dGlsc18xID0gcmVxdWlyZShcInNreW5ldC1teXNreS11dGlsc1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4uL3V0aWxzL3VybFwiKTtcbmV4cG9ydHMuZGVmYXVsdENvbm5lY3Rvck9wdGlvbnMgPSB7XG4gICAgZGV2OiBmYWxzZSxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgYWxwaGE6IGZhbHNlLFxuICAgIGhhbmRzaGFrZU1heEF0dGVtcHRzOiBza3luZXRfbXlza3lfdXRpbHNfMS5kZWZhdWx0SGFuZHNoYWtlTWF4QXR0ZW1wdHMsXG4gICAgaGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbDogc2t5bmV0X215c2t5X3V0aWxzXzEuZGVmYXVsdEhhbmRzaGFrZUF0dGVtcHRzSW50ZXJ2YWwsXG59O1xuY2xhc3MgQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGNsaWVudCwgY2hpbGRGcmFtZSwgY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRGcmFtZSA9IGNoaWxkRnJhbWU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8vIFN0YXRpYyBpbml0aWFsaXplclxuICAgIHN0YXRpYyBhc3luYyBpbml0KGNsaWVudCwgZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdENvbm5lY3Rvck9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICAgICAgLy8gR2V0IHRoZSBVUkwgZm9yIHRoZSBkb21haW4gb24gdGhlIGN1cnJlbnQgcG9ydGFsLlxuICAgICAgICBsZXQgZG9tYWluVXJsID0gYXdhaXQgY2xpZW50LmdldEZ1bGxEb21haW5VcmwoZG9tYWluKTtcbiAgICAgICAgaWYgKG9wdHMuZGV2KSB7XG4gICAgICAgICAgICBkb21haW5VcmwgPSB1cmxfMS5hZGRVcmxRdWVyeShkb21haW5VcmwsIHsgZGV2OiBcInRydWVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kZWJ1Zykge1xuICAgICAgICAgICAgZG9tYWluVXJsID0gdXJsXzEuYWRkVXJsUXVlcnkoZG9tYWluVXJsLCB7IGRlYnVnOiBcInRydWVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5hbHBoYSkge1xuICAgICAgICAgICAgZG9tYWluVXJsID0gdXJsXzEuYWRkVXJsUXVlcnkoZG9tYWluVXJsLCB7IGFscGhhOiBcInRydWVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGlmcmFtZS5cbiAgICAgICAgY29uc3QgY2hpbGRGcmFtZSA9IHNreW5ldF9teXNreV91dGlsc18xLmNyZWF0ZUlmcmFtZShkb21haW5VcmwsIGRvbWFpblVybCk7XG4gICAgICAgIGNvbnN0IGNoaWxkV2luZG93ID0gY2hpbGRGcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSBpZnJhbWUuXG4gICAgICAgIGNvbnN0IG1lc3NlbmdlciA9IG5ldyBwb3N0X21lXzEuV2luZG93TWVzc2VuZ2VyKHtcbiAgICAgICAgICAgIGxvY2FsV2luZG93OiB3aW5kb3csXG4gICAgICAgICAgICByZW1vdGVXaW5kb3c6IGNoaWxkV2luZG93LFxuICAgICAgICAgICAgcmVtb3RlT3JpZ2luOiBcIipcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBwb3N0X21lXzEuUGFyZW50SGFuZHNoYWtlKG1lc3Nlbmdlciwge30sIG9wdHMuaGFuZHNoYWtlTWF4QXR0ZW1wdHMsIG9wdHMuaGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbCk7XG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgY29tcG9uZW50IGNvbm5lY3Rvci5cbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0b3IoZG9tYWluVXJsLCBjbGllbnQsIGNoaWxkRnJhbWUsIGNvbm5lY3Rpb24sIG9wdHMpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKG1ldGhvZCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnJlbW90ZUhhbmRsZSgpLmNhbGwobWV0aG9kLCAuLi5hcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3RvciA9IENvbm5lY3RvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYWNMaWJyYXJ5ID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JcIik7XG5jbGFzcyBEYWNMaWJyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihkYWNEb21haW4pIHtcbiAgICAgICAgdGhpcy5kYWNEb21haW4gPSBkYWNEb21haW47XG4gICAgfVxuICAgIGFzeW5jIGluaXQoY2xpZW50LCBjdXN0b21PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gYXdhaXQgY29ubmVjdG9yXzEuQ29ubmVjdG9yLmluaXQoY2xpZW50LCB0aGlzLmRhY0RvbWFpbiwgY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb24ucmVtb3RlSGFuZGxlKCkuY2FsbChcImluaXRcIik7XG4gICAgfVxuICAgIG9uVXNlckxvZ2luKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0IHdhcyBub3QgY2FsbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb24ucmVtb3RlSGFuZGxlKCkuY2FsbChcIm9uVXNlckxvZ2luXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGFjTGlicmFyeSA9IERhY0xpYnJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXlTa3kgPSBleHBvcnRzLmxvYWRNeVNreSA9IGV4cG9ydHMubXlTa3lBbHBoYURvbWFpbiA9IGV4cG9ydHMubXlTa3lEZXZEb21haW4gPSBleHBvcnRzLm15U2t5RG9tYWluID0gZXhwb3J0cy5EYWNMaWJyYXJ5ID0gdm9pZCAwO1xudmFyIGRhY18xID0gcmVxdWlyZShcIi4vZGFjXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGFjTGlicmFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGFjXzEuRGFjTGlicmFyeTsgfSB9KTtcbmNvbnN0IHBvc3RfbWVfMSA9IHJlcXVpcmUoXCJwb3N0LW1lXCIpO1xuY29uc3Qgc2t5bmV0X215c2t5X3V0aWxzXzEgPSByZXF1aXJlKFwic2t5bmV0LW15c2t5LXV0aWxzXCIpO1xuY29uc3QgY29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JcIik7XG5jb25zdCByZWdpc3RyeV8xID0gcmVxdWlyZShcIi4uL3JlZ2lzdHJ5XCIpO1xuY29uc3Qgc2t5ZGJfMSA9IHJlcXVpcmUoXCIuLi9za3lkYlwiKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHR3ZWFrXzEgPSByZXF1aXJlKFwiLi90d2Vha1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi91dGlscy92YWxpZGF0aW9uXCIpO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL29wdGlvbnNcIik7XG5leHBvcnRzLm15U2t5RG9tYWluID0gXCJza3luZXQtbXlza3kuaG5zXCI7XG5leHBvcnRzLm15U2t5RGV2RG9tYWluID0gXCJza3luZXQtbXlza3ktZGV2Lmhuc1wiO1xuZXhwb3J0cy5teVNreUFscGhhRG9tYWluID0gXCJzYW5kYnJpZGdlLmhuc1wiO1xuY29uc3QgbXlTa3lVaVJlbGF0aXZlVXJsID0gXCJ1aS5odG1sXCI7XG5jb25zdCBteVNreVVpVGl0bGUgPSBcIk15U2t5IFVJXCI7XG5jb25zdCBbbXlTa3lVaVcsIG15U2t5VWlIXSA9IFs2MDAsIDYwMF07XG5hc3luYyBmdW5jdGlvbiBsb2FkTXlTa3koc2thcHBEb21haW4sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICBjb25zdCBteVNreSA9IGF3YWl0IE15U2t5Lk5ldyh0aGlzLCBza2FwcERvbWFpbiwgY3VzdG9tT3B0aW9ucyk7XG4gICAgcmV0dXJuIG15U2t5O1xufVxuZXhwb3J0cy5sb2FkTXlTa3kgPSBsb2FkTXlTa3k7XG5jbGFzcyBNeVNreSB7XG4gICAgLy8gPT09PT09PT09PT09XG4gICAgLy8gQ29uc3RydWN0b3JzXG4gICAgLy8gPT09PT09PT09PT09XG4gICAgY29uc3RydWN0b3IoY29ubmVjdG9yLCBwZXJtaXNzaW9ucywgaG9zdERvbWFpbikge1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RG9tYWluID0gaG9zdERvbWFpbjtcbiAgICAgICAgdGhpcy5kYWNzID0gW107XG4gICAgICAgIHRoaXMuZ3JhbnRlZFBlcm1pc3Npb25zID0gW107XG4gICAgICAgIHRoaXMucGVuZGluZ1Blcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBOZXcoY2xpZW50LCBza2FwcERvbWFpbiwgY3VzdG9tT3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0geyAuLi5jb25uZWN0b3JfMS5kZWZhdWx0Q29ubmVjdG9yT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgICAgICAvLyBFbmZvcmNlIHNpbmdsZXRvbi5cbiAgICAgICAgaWYgKE15U2t5Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gTXlTa3kuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbWFpbiA9IGV4cG9ydHMubXlTa3lEb21haW47XG4gICAgICAgIGlmIChvcHRzLmFscGhhKSB7XG4gICAgICAgICAgICBkb21haW4gPSBleHBvcnRzLm15U2t5QWxwaGFEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5kZXYpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGV4cG9ydHMubXlTa3lEZXZEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdG9yID0gYXdhaXQgY29ubmVjdG9yXzEuQ29ubmVjdG9yLmluaXQoY2xpZW50LCBkb21haW4sIGN1c3RvbU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBob3N0RG9tYWluID0gYXdhaXQgY2xpZW50LmV4dHJhY3REb21haW4od2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgaWYgKHNrYXBwRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBcmUgdGhlc2UgcGVybWlzc2lvbnMgY29ycmVjdD9cbiAgICAgICAgICAgIGNvbnN0IHBlcm0xID0gbmV3IHNreW5ldF9teXNreV91dGlsc18xLlBlcm1pc3Npb24oaG9zdERvbWFpbiwgc2thcHBEb21haW4sIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1DYXRlZ29yeS5IaWRkZW4sIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1UeXBlLlJlYWQpO1xuICAgICAgICAgICAgY29uc3QgcGVybTIgPSBuZXcgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybWlzc2lvbihob3N0RG9tYWluLCBza2FwcERvbWFpbiwgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybUNhdGVnb3J5LkhpZGRlbiwgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybVR5cGUuV3JpdGUpO1xuICAgICAgICAgICAgcGVybWlzc2lvbnMucHVzaChwZXJtMSwgcGVybTIpO1xuICAgICAgICB9XG4gICAgICAgIE15U2t5Lmluc3RhbmNlID0gbmV3IE15U2t5KGNvbm5lY3RvciwgcGVybWlzc2lvbnMsIGhvc3REb21haW4pO1xuICAgICAgICByZXR1cm4gTXlTa3kuaW5zdGFuY2U7XG4gICAgfVxuICAgIC8vID09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgQVBJXG4gICAgLy8gPT09PT09PT09PVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBnaXZlbiBEQUNzLlxuICAgICAqL1xuICAgIGFzeW5jIGxvYWREYWNzKC4uLmRhY3MpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkYWMgb2YgZGFjcykge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmxvYWREYWMoZGFjKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYWNzLnB1c2goLi4uZGFjcyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkUGVybWlzc2lvbnMoLi4ucGVybWlzc2lvbnMpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUGVybWlzc2lvbnMucHVzaCguLi5wZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrTG9naW4oKSB7XG4gICAgICAgIGNvbnN0IFtzZWVkRm91bmQsIHBlcm1pc3Npb25zUmVzcG9uc2VdID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuY29ubmVjdGlvbi5yZW1vdGVIYW5kbGUoKS5jYWxsKFwiY2hlY2tMb2dpblwiLCB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyk7XG4gICAgICAgIC8vIFNhdmUgZ3JhbnRlZCBhbmQgZmFpbGVkIHBlcm1pc3Npb25zLlxuICAgICAgICBjb25zdCB7IGdyYW50ZWRQZXJtaXNzaW9ucywgZmFpbGVkUGVybWlzc2lvbnMgfSA9IHBlcm1pc3Npb25zUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuZ3JhbnRlZFBlcm1pc3Npb25zID0gZ3JhbnRlZFBlcm1pc3Npb25zO1xuICAgICAgICB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyA9IGZhaWxlZFBlcm1pc3Npb25zO1xuICAgICAgICBjb25zdCBsb2dnZWRJbiA9IHNlZWRGb3VuZCAmJiBmYWlsZWRQZXJtaXNzaW9ucy5sZW5ndGggPT09IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlTG9naW4obG9nZ2VkSW4pO1xuICAgICAgICByZXR1cm4gbG9nZ2VkSW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBteXNreSBjb25uZWN0aW9uIGJ5OlxuICAgICAqXG4gICAgICogMS4gRGVzdHJveWluZyB0aGUgY29ubmVjdGVkIERBQ3MsXG4gICAgICpcbiAgICAgKiAyLiBDbG9zaW5nIHRoZSBjb25uZWN0aW9uLFxuICAgICAqXG4gICAgICogMy4gQ2xvc2luZyB0aGUgY2hpbGQgaWZyYW1lXG4gICAgICovXG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVE9ETzogRm9yIGFsbCBjb25uZWN0ZWQgZGFjcywgc2VuZCBhIGRlc3Ryb3kgY2FsbC5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIGFsbCBjb25uZWN0ZWQgZGFjcy5cbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNoaWxkIGlmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yLmNoaWxkRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmNoaWxkRnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbm5lY3Rvci5jaGlsZEZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsb2dvdXQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0aW9uLnJlbW90ZUhhbmRsZSgpLmNhbGwoXCJsb2dvdXRcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RMb2dpbkFjY2VzcygpIHtcbiAgICAgICAgbGV0IHVpV2luZG93O1xuICAgICAgICBsZXQgdWlDb25uZWN0aW9uO1xuICAgICAgICBsZXQgc2VlZEZvdW5kID0gZmFsc2U7XG4gICAgICAgIC8vIEFkZCBlcnJvciBsaXN0ZW5lci5cbiAgICAgICAgY29uc3QgeyBwcm9taXNlOiBwcm9taXNlRXJyb3IsIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXJFcnJvciB9ID0gc2t5bmV0X215c2t5X3V0aWxzXzEubW9uaXRvcldpbmRvd0Vycm9yKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHRoaXMgcHJvbWlzZSBydW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIHJlamVjdCBvbiB3aW5kb3cgY2xvc2Ugb3IgYW55IGVycm9ycy5cbiAgICAgICAgICAgIHByb21pc2VFcnJvci5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gc2t5bmV0X215c2t5X3V0aWxzXzEuZXJyb3JXaW5kb3dDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aXRob3V0IHVwZGF0aW5nIHRoZSBwZW5kaW5nIHBlcm1pc3Npb25zLlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTGF1bmNoIHRoZSBVSS5cbiAgICAgICAgICAgICAgICB1aVdpbmRvdyA9IGF3YWl0IHRoaXMubGF1bmNoVUkoKTtcbiAgICAgICAgICAgICAgICB1aUNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmNvbm5lY3RVaSh1aVdpbmRvdyk7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgVUkgdGhlIGxpc3Qgb2YgcmVxdWlyZWQgcGVybWlzc2lvbnMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgYSBkdWFsLXByb21pc2UgdGhhdCBhbHNvIGNhbGxzIHBpbmcoKSBvbiBhbiBpbnRlcnZhbCBhbmQgcmVqZWN0cyBpZiBubyByZXNwb25zZSB3YXMgZm91bmQgaW4gYSBnaXZlbiBhbW91bnQgb2YgdGltZS5cbiAgICAgICAgICAgICAgICBjb25zdCBbc2VlZEZvdW5kUmVzcG9uc2UsIHBlcm1pc3Npb25zUmVzcG9uc2VdID0gYXdhaXQgdWlDb25uZWN0aW9uLnJlbW90ZUhhbmRsZSgpLmNhbGwoXCJyZXF1ZXN0TG9naW5BY2Nlc3NcIiwgdGhpcy5wZW5kaW5nUGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgICAgIHNlZWRGb3VuZCA9IHNlZWRGb3VuZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgZmFpbGVkIHBlcm1pc3Npb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZ3JhbnRlZFBlcm1pc3Npb25zLCBmYWlsZWRQZXJtaXNzaW9ucyB9ID0gcGVybWlzc2lvbnNSZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYW50ZWRQZXJtaXNzaW9ucyA9IGdyYW50ZWRQZXJtaXNzaW9ucztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyA9IGZhaWxlZFBlcm1pc3Npb25zO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHByb21pc2VcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgd2luZG93LlxuICAgICAgICAgICAgaWYgKHVpV2luZG93KSB7XG4gICAgICAgICAgICAgICAgdWlXaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgaWYgKHVpQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHVpQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGxpc3RlbmVycyBhbmQgcHJvbWlzZXMuXG4gICAgICAgICAgICBjb250cm9sbGVyRXJyb3IuY2xlYW51cCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9nZ2VkSW4gPSBzZWVkRm91bmQgJiYgdGhpcy5wZW5kaW5nUGVybWlzc2lvbnMubGVuZ3RoID09PSAwO1xuICAgICAgICB0aGlzLmhhbmRsZUxvZ2luKGxvZ2dlZEluKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlZEluO1xuICAgIH1cbiAgICBhc3luYyB1c2VySUQob3B0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25uZWN0b3IuY29ubmVjdGlvbi5yZW1vdGVIYW5kbGUoKS5jYWxsKFwidXNlcklEXCIsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIERpc2NvdmVyYWJsZSBKU09OIGF0IHRoZSBnaXZlbiBwYXRoIHRocm91Z2ggTXlTa3ksIGlmIHRoZSB1c2VyIGhhcyBnaXZlbiBwZXJtaXNzaW9ucyB0byBkbyBzby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGRhdGEgcGF0aC5cbiAgICAgKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAgICAgKiBAcmV0dXJucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBqc29uIGRhdGEgYXMgd2VsbCBhcyB0aGUgc2t5bGluayBmb3IgdGhlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SlNPTihwYXRoLCBjdXN0b21PcHRpb25zKSB7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBhdGhcIiwgcGF0aCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBza3lkYl8xLmRlZmF1bHRHZXRKU09OT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAuLi5za3lkYl8xLmRlZmF1bHRHZXRKU09OT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnRoaXMuY29ubmVjdG9yLmNsaWVudC5jdXN0b21PcHRpb25zLFxuICAgICAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy51c2VySUQoKTtcbiAgICAgICAgY29uc3QgZGF0YUtleSA9IHR3ZWFrXzEuZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsocGF0aCk7XG4gICAgICAgIG9wdHMuaGFzaGVkRGF0YUtleUhleCA9IHRydWU7IC8vIERvIG5vdCBoYXNoIHRoZSB0d2VhayBhbnltb3JlLlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25uZWN0b3IuY2xpZW50LmRiLmdldEpTT04ocHVibGljS2V5LCBkYXRhS2V5LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZW50cnkgbGluayBmb3IgdGhlIGVudHJ5IGF0IHRoZSBnaXZlbiBwYXRoLiBUaGlzIGlzIGEgdjIgc2t5bGluay5cbiAgICAgKiBUaGlzIGxpbmsgc3RheXMgdGhlIHNhbWUgZXZlbiBpZiB0aGUgY29udGVudCBhdCB0aGUgZW50cnkgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGRhdGEgcGF0aC5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBlbnRyeSBsaW5rLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEVudHJ5TGluayhwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBhdGhcIiwgcGF0aCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMudXNlcklEKCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0d2Vha18xLmRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrKHBhdGgpO1xuICAgICAgICBjb25zdCBvcHRzID0gcmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zO1xuICAgICAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNsaWVudC5yZWdpc3RyeS5nZXRFbnRyeUxpbmsocHVibGljS2V5LCBkYXRhS2V5LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBEaXNjb3ZlcmFibGUgSlNPTiBhdCB0aGUgZ2l2ZW4gcGF0aCB0aHJvdWdoIE15U2t5LCBpZiB0aGUgdXNlciBoYXMgZ2l2ZW4gcGVybWlzc2lvbnMgdG8gZG8gc28uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBkYXRhIHBhdGguXG4gICAgICogQHBhcmFtIGpzb24gLSBUaGUganNvbiB0byBzZXQuXG4gICAgICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gICAgICogQHJldHVybnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUganNvbiBkYXRhIGFzIHdlbGwgYXMgdGhlIHNreWxpbmsgZm9yIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIHNldEpTT04ocGF0aCwganNvbiwgY3VzdG9tT3B0aW9ucykge1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwYXRoXCIsIHBhdGgsIFwicGFyYW1ldGVyXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPYmplY3QoXCJqc29uXCIsIGpzb24sIFwicGFyYW1ldGVyXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgc2t5ZGJfMS5kZWZhdWx0U2V0SlNPTk9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4uc2t5ZGJfMS5kZWZhdWx0U2V0SlNPTk9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmNvbm5lY3Rvci5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMudXNlcklEKCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0d2Vha18xLmRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrKHBhdGgpO1xuICAgICAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICAgICAgY29uc3QgW2VudHJ5LCBkYXRhTGlua10gPSBhd2FpdCBza3lkYl8xLmdldE9yQ3JlYXRlUmVnaXN0cnlFbnRyeSh0aGlzLmNvbm5lY3Rvci5jbGllbnQsIHN0cmluZ18xLmhleFRvVWludDhBcnJheShwdWJsaWNLZXkpLCBkYXRhS2V5LCBqc29uLCBvcHRzKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduUmVnaXN0cnlFbnRyeShlbnRyeSwgcGF0aCk7XG4gICAgICAgIGNvbnN0IHNldEVudHJ5T3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCByZWdpc3RyeV8xLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMpO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jbGllbnQucmVnaXN0cnkucG9zdFNpZ25lZEVudHJ5KHB1YmxpY0tleSwgZW50cnksIHNpZ25hdHVyZSwgc2V0RW50cnlPcHRzKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YToganNvbiwgZGF0YUxpbmsgfTtcbiAgICB9XG4gICAgLy8gPT09PT09PT09PT09PT09PVxuICAgIC8vIEludGVybmFsIE1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09XG4gICAgYXN5bmMgY2F0Y2hFcnJvcihlcnJvck1zZykge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChza3luZXRfbXlza3lfdXRpbHNfMS5kaXNwYXRjaGVkRXJyb3JFdmVudCwgeyBkZXRhaWw6IGVycm9yTXNnIH0pO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIGxhdW5jaFVJKCkge1xuICAgICAgICBjb25zdCBteVNreVVybCA9IG5ldyBVUkwodGhpcy5jb25uZWN0b3IudXJsKTtcbiAgICAgICAgbXlTa3lVcmwucGF0aG5hbWUgPSBteVNreVVpUmVsYXRpdmVVcmw7XG4gICAgICAgIGNvbnN0IHVpVXJsID0gbXlTa3lVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gT3BlbiB0aGUgd2luZG93LlxuICAgICAgICBjb25zdCBjaGlsZFdpbmRvdyA9IHV0aWxzXzEucG9wdXBDZW50ZXIodWlVcmwsIG15U2t5VWlUaXRsZSwgbXlTa3lVaVcsIG15U2t5VWlIKTtcbiAgICAgICAgaWYgKCFjaGlsZFdpbmRvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgb3BlbiB3aW5kb3cgYXQgJyR7dWlVcmx9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZFdpbmRvdztcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdFVpKGNoaWxkV2luZG93KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbm5lY3Rvci5vcHRpb25zO1xuICAgICAgICAvLyBDb21wbGV0ZSBoYW5kc2hha2Ugd2l0aCBVSSB3aW5kb3cuXG4gICAgICAgIGNvbnN0IG1lc3NlbmdlciA9IG5ldyBwb3N0X21lXzEuV2luZG93TWVzc2VuZ2VyKHtcbiAgICAgICAgICAgIGxvY2FsV2luZG93OiB3aW5kb3csXG4gICAgICAgICAgICByZW1vdGVXaW5kb3c6IGNoaWxkV2luZG93LFxuICAgICAgICAgICAgcmVtb3RlT3JpZ2luOiBcIipcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgICAgICBjYXRjaEVycm9yOiB0aGlzLmNhdGNoRXJyb3IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBwb3N0X21lXzEuUGFyZW50SGFuZHNoYWtlKG1lc3NlbmdlciwgbWV0aG9kcywgb3B0aW9ucy5oYW5kc2hha2VNYXhBdHRlbXB0cywgb3B0aW9ucy5oYW5kc2hha2VBdHRlbXB0c0ludGVydmFsKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGFzeW5jIGxvYWREYWMoZGFjKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgREFDLlxuICAgICAgICBhd2FpdCBkYWMuaW5pdCh0aGlzLmNvbm5lY3Rvci5jbGllbnQsIHRoaXMuY29ubmVjdG9yLm9wdGlvbnMpO1xuICAgICAgICAvLyBBZGQgREFDIHBlcm1pc3Npb25zLlxuICAgICAgICBjb25zdCBwZXJtcyA9IGRhYy5nZXRQZXJtaXNzaW9ucygpO1xuICAgICAgICB0aGlzLmFkZFBlcm1pc3Npb25zKC4uLnBlcm1zKTtcbiAgICB9XG4gICAgaGFuZGxlTG9naW4obG9nZ2VkSW4pIHtcbiAgICAgICAgaWYgKGxvZ2dlZEluKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhYyBvZiB0aGlzLmRhY3MpIHtcbiAgICAgICAgICAgICAgICBkYWMub25Vc2VyTG9naW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduUmVnaXN0cnlFbnRyeShlbnRyeSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25uZWN0b3IuY29ubmVjdGlvbi5yZW1vdGVIYW5kbGUoKS5jYWxsKFwic2lnblJlZ2lzdHJ5RW50cnlcIiwgZW50cnksIHBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXlTa3kgPSBNeVNreTtcbk15U2t5Lmluc3RhbmNlID0gbnVsbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayA9IGV4cG9ydHMuaGFzaFBhdGhDb21wb25lbnQgPSBleHBvcnRzLnNwbGl0UGF0aCA9IGV4cG9ydHMuRGlzY292ZXJhYmxlQnVja2V0VHdlYWsgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG9cIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCBkaXNjb3ZlcmFibGVCdWNrZXRUd2Vha1ZlcnNpb24gPSAxO1xuY2xhc3MgRGlzY292ZXJhYmxlQnVja2V0VHdlYWsge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhIYXNoZXMgPSBwYXRocy5tYXAoaGFzaFBhdGhDb21wb25lbnQpO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBkaXNjb3ZlcmFibGVCdWNrZXRUd2Vha1ZlcnNpb247XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGhIYXNoZXM7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IDEgKyAzMiAqIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICBidWYuc2V0KFt0aGlzLnZlcnNpb25dKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aExldmVsIG9mIHRoaXMucGF0aCkge1xuICAgICAgICAgICAgYnVmLnNldChwYXRoTGV2ZWwsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZ2V0SGFzaCgpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSB0aGlzLmVuY29kZSgpO1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuaGFzaEFsbChlbmNvZGluZyk7XG4gICAgfVxufVxuZXhwb3J0cy5EaXNjb3ZlcmFibGVCdWNrZXRUd2VhayA9IERpc2NvdmVyYWJsZUJ1Y2tldFR3ZWFrO1xuZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIik7XG59XG5leHBvcnRzLnNwbGl0UGF0aCA9IHNwbGl0UGF0aDtcbmZ1bmN0aW9uIGhhc2hQYXRoQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjcnlwdG9fMS5oYXNoQWxsKHN0cmluZ18xLnN0cmluZ1RvVWludDhBcnJheVV0ZjgoY29tcG9uZW50KSk7XG59XG5leHBvcnRzLmhhc2hQYXRoQ29tcG9uZW50ID0gaGFzaFBhdGhDb21wb25lbnQ7XG5mdW5jdGlvbiBkZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKSB7XG4gICAgY29uc3QgZGJ0ID0gbmV3IERpc2NvdmVyYWJsZUJ1Y2tldFR3ZWFrKHBhdGgpO1xuICAgIGNvbnN0IGJ5dGVzID0gZGJ0LmdldEhhc2goKTtcbiAgICByZXR1cm4gc3RyaW5nXzEudG9IZXhTdHJpbmcoYnl0ZXMpO1xufVxuZXhwb3J0cy5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayA9IGRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvcHVwQ2VudGVyID0gZXhwb3J0cy5leHRyYWN0RG9tYWluID0gZXhwb3J0cy5nZXRGdWxsRG9tYWluVXJsID0gdm9pZCAwO1xuY29uc3Qgc2t5bmV0X215c2t5X3V0aWxzXzEgPSByZXF1aXJlKFwic2t5bmV0LW15c2t5LXV0aWxzXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJsXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBmdWxsIFVSTCBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBkb21haW4sXG4gKiBlLmcuIFwiZGFjLmhuc1wiID0+IFwiaHR0cHM6Ly9kYWMuaG5zLnNpYXNreS5uZXRcIlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gQ29tcG9uZW50IGRvbWFpbi5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIGZvciB0aGUgY29tcG9uZW50LlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGdWxsRG9tYWluVXJsKGRvbWFpbikge1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgcmV0dXJuIHVybF8xLmdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBkb21haW4pO1xufVxuZXhwb3J0cy5nZXRGdWxsRG9tYWluVXJsID0gZ2V0RnVsbERvbWFpblVybDtcbi8qKlxuICogRXh0cmFjdHMgdGhlIGRvbWFpbiBmcm9tIHRoZSBjdXJyZW50IHBvcnRhbCBVUkwsXG4gKiBlLmcuIChcImRhYy5obnMuc2lhc2t5Lm5ldFwiKSA9PiBcImRhYy5obnNcIlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZnVsbERvbWFpbiAtIEZ1bGwgVVJMLlxuICogQHJldHVybnMgLSBUaGUgZXh0cmFjdGVkIGRvbWFpbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdERvbWFpbihmdWxsRG9tYWluKSB7XG4gICAgY29uc3QgcG9ydGFsVXJsID0gYXdhaXQgdGhpcy5wb3J0YWxVcmwoKTtcbiAgICByZXR1cm4gdXJsXzEuZXh0cmFjdERvbWFpbkZvclBvcnRhbChwb3J0YWxVcmwsIGZ1bGxEb21haW4pO1xufVxuZXhwb3J0cy5leHRyYWN0RG9tYWluID0gZXh0cmFjdERvbWFpbjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHBvcHVwIHdpbmRvdy4gRnJvbSBTa3lJRC5cbiAqL1xuZnVuY3Rpb24gcG9wdXBDZW50ZXIodXJsLCB0aXRsZSwgdywgaCkge1xuICAgIHVybCA9IHNreW5ldF9teXNreV91dGlsc18xLmVuc3VyZVVybCh1cmwpO1xuICAgIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICAgIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gICAgY29uc3QgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiB3aW5kb3cuc2NyZWVuWTtcbiAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICA6IHNjcmVlbi53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgPyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogc2NyZWVuLmhlaWdodDtcbiAgICBjb25zdCBzeXN0ZW1ab29tID0gd2lkdGggLyB3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGg7XG4gICAgY29uc3QgbGVmdCA9ICh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdDtcbiAgICBjb25zdCB0b3AgPSAoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3A7XG4gICAgY29uc3QgbmV3V2luZG93ID0gd2luZG93Lm9wZW4odXJsLCB0aXRsZSwgYFxuc2Nyb2xsYmFycz15ZXMsXG53aWR0aD0ke3cgLyBzeXN0ZW1ab29tfSxcbmhlaWdodD0ke2ggLyBzeXN0ZW1ab29tfSxcbnRvcD0ke3RvcH0sXG5sZWZ0PSR7bGVmdH1cbmApO1xuICAgIGlmICghbmV3V2luZG93KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBvcGVuIHdpbmRvd1wiKTtcbiAgICB9XG4gICAgaWYgKG5ld1dpbmRvdy5mb2N1cykge1xuICAgICAgICBuZXdXaW5kb3cuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1dpbmRvdztcbn1cbmV4cG9ydHMucG9wdXBDZW50ZXIgPSBwb3B1cENlbnRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVJlZ2lzdHJ5RW50cnkgPSBleHBvcnRzLnBvc3RTaWduZWRFbnRyeSA9IGV4cG9ydHMuc2lnbkVudHJ5ID0gZXhwb3J0cy5zZXRFbnRyeSA9IGV4cG9ydHMuZ2V0RW50cnlMaW5rID0gZXhwb3J0cy5nZXRFbnRyeVVybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0RW50cnlVcmwgPSBleHBvcnRzLmdldEVudHJ5ID0gZXhwb3J0cy5yZWdleFJldmlzaW9uTm9RdW90ZXMgPSBleHBvcnRzLkRFRkFVTFRfR0VUX0VOVFJZX1RJTUVPVVQgPSBleHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCB0d2VldG5hY2xfMSA9IHJlcXVpcmUoXCJ0d2VldG5hY2xcIik7XG5jb25zdCBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9jcnlwdG9cIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0aW9uXCIpO1xuY29uc3Qgc2lhXzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL3NpYVwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vc2t5bGluay9mb3JtYXRcIik7XG5leHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICBlbmRwb2ludEdldEVudHJ5OiBcIi9za3luZXQvcmVnaXN0cnlcIixcbiAgICBoYXNoZWREYXRhS2V5SGV4OiBmYWxzZSxcbn07XG5leHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICBlbmRwb2ludFNldEVudHJ5OiBcIi9za3luZXQvcmVnaXN0cnlcIixcbiAgICBoYXNoZWREYXRhS2V5SGV4OiBmYWxzZSxcbn07XG5leHBvcnRzLkRFRkFVTFRfR0VUX0VOVFJZX1RJTUVPVVQgPSA1OyAvLyA1IHNlY29uZHNcbi8qKlxuICogUmVnZXggZm9yIEpTT04gcmV2aXNpb24gdmFsdWUgd2l0aG91dCBxdW90ZXMuXG4gKi9cbmV4cG9ydHMucmVnZXhSZXZpc2lvbk5vUXVvdGVzID0gL1wicmV2aXNpb25cIjpcXHMqKFswLTldKykvO1xuLyoqXG4gKiBSZWdleCBmb3IgSlNPTiByZXZpc2lvbiB2YWx1ZSB3aXRoIHF1b3Rlcy5cbiAqL1xuY29uc3QgcmVnZXhSZXZpc2lvbldpdGhRdW90ZXMgPSAvXCJyZXZpc2lvblwiOlxccypcIihbMC05XSspXCIvO1xuLyoqXG4gKiBHZXRzIHRoZSByZWdpc3RyeSBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwdWJsaWNLZXkgYW5kIGRhdGFLZXkuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgdXNlciBwdWJsaWMga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUga2V5IG9mIHRoZSBkYXRhIHRvIGZldGNoIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgc2lnbmVkIHJlZ2lzdHJ5IGVudHJ5LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJldHVybmVkIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCB0aGUgcmV0dXJuZWQgZW50cnkgb3IgdGhlIHByb3ZpZGVkIHRpbWVvdXQgaXMgaW52YWxpZCBvciB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCB2YWxpZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnkocHVibGljS2V5LCBkYXRhS2V5LCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRFbnRyeVVybGAuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmdldEVudHJ5VXJsKHB1YmxpY0tleSwgZGF0YUtleSwgb3B0cyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgZW5kcG9pbnRQYXRoOiBvcHRzLmVuZHBvaW50R2V0RW50cnksXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3BvbnNlIHRvIGFkZCBxdW90ZXMsIHNpbmNlIHVpbnQ2NCBjYW5ub3QgYmUgYWNjdXJhdGVseVxuICAgICAgICAgICAgLy8gcmVhZCBieSBKUyBzbyB0aGUgcmV2aXNpb24gbmVlZHMgdG8gYmUgcGFyc2VkIGFzIGEgc3RyaW5nLlxuICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcmV2aXNpb24gdmFsdWUgZnJvbSBhIEpTT04gaW50ZWdlciB0byBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKGV4cG9ydHMucmVnZXhSZXZpc2lvbk5vUXVvdGVzLCAnXCJyZXZpc2lvblwiOlwiJDFcIicpO1xuICAgICAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aW5nIHRoZSBKU09OIGRhdGEgdG8gYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIG5vdCBKU09OLCBpdCdzIGxpa2VseSBhbiBIVE1MIGVycm9yIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gaGFuZGxlR2V0RW50cnlFcnJSZXNwb25zZShlcnIpO1xuICAgIH1cbiAgICAvLyBTYW5pdHkgY2hlY2suXG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicmVzcG9uc2UuZGF0YS5kYXRhXCIsIHJlc3BvbnNlLmRhdGEuZGF0YSwgXCJlbnRyeSByZXNwb25zZSBmaWVsZFwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicmVzcG9uc2UuZGF0YS5yZXZpc2lvblwiLCByZXNwb25zZS5kYXRhLnJldmlzaW9uLCBcImVudHJ5IHJlc3BvbnNlIGZpZWxkXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJyZXNwb25zZS5kYXRhLnNpZ25hdHVyZVwiLCByZXNwb25zZS5kYXRhLnNpZ25hdHVyZSwgXCJlbnRyeSByZXNwb25zZSBmaWVsZFwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCBub3QgZ2V0IGEgY29tcGxldGUgZW50cnkgcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuIEVycm9yOiAke2Vycn1gKTtcbiAgICB9XG4gICAgLy8gVXNlIGVtcHR5IHN0cmluZyBpZiB0aGUgZGF0YSBpcyBlbXB0eS5cbiAgICBsZXQgZGF0YSA9IFwiXCI7XG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuZGF0YSkge1xuICAgICAgICBkYXRhID0gc3RyaW5nXzEudWludDhBcnJheVRvU3RyaW5nVXRmOChzdHJpbmdfMS5oZXhUb1VpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YS5kYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lZEVudHJ5ID0ge1xuICAgICAgICBlbnRyeToge1xuICAgICAgICAgICAgZGF0YUtleSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSByZXZpc2lvbiBmcm9tIGEgc3RyaW5nIHRvIGJpZ2ludC5cbiAgICAgICAgICAgIHJldmlzaW9uOiBCaWdJbnQocmVzcG9uc2UuZGF0YS5yZXZpc2lvbiksXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hdHVyZTogYnVmZmVyXzEuQnVmZmVyLmZyb20oc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHJlc3BvbnNlLmRhdGEuc2lnbmF0dXJlKSksXG4gICAgfTtcbiAgICBpZiAoc2lnbmVkRW50cnkgJiZcbiAgICAgICAgIXR3ZWV0bmFjbF8xLnNpZ24uZGV0YWNoZWQudmVyaWZ5KGNyeXB0b18xLmhhc2hSZWdpc3RyeUVudHJ5KHNpZ25lZEVudHJ5LmVudHJ5LCBvcHRzLmhhc2hlZERhdGFLZXlIZXgpLCBuZXcgVWludDhBcnJheShzaWduZWRFbnRyeS5zaWduYXR1cmUpLCBzdHJpbmdfMS5oZXhUb1VpbnQ4QXJyYXkocHVibGljS2V5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IHZlcmlmeSBzaWduYXR1cmUgZnJvbSByZXRyaWV2ZWQsIHNpZ25lZCByZWdpc3RyeSBlbnRyeSAtLSBwb3NzaWJsZSBjb3JydXB0ZWQgZW50cnlcIik7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWRFbnRyeTtcbn1cbmV4cG9ydHMuZ2V0RW50cnkgPSBnZXRFbnRyeTtcbi8qKlxuICogR2V0cyB0aGUgcmVnaXN0cnkgZW50cnkgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpY0tleSBhbmQgZGF0YUtleS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSB1c2VyIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gZGF0YUtleSAtIFRoZSBrZXkgb2YgdGhlIGRhdGEgdG8gZmV0Y2ggZm9yIHRoZSBnaXZlbiB1c2VyLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIGdldCBlbnRyeSBVUkwuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgcHJvdmlkZWQgdGltZW91dCBpcyBpbnZhbGlkIG9yIHRoZSBnaXZlbiBrZXkgaXMgbm90IHZhbGlkLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFbnRyeVVybChwdWJsaWNLZXksIGRhdGFLZXksIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldEVudHJ5VXJsRm9yUG9ydGFsYC5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgcmV0dXJuIGdldEVudHJ5VXJsRm9yUG9ydGFsKHBvcnRhbFVybCwgcHVibGljS2V5LCBkYXRhS2V5LCBvcHRzKTtcbn1cbmV4cG9ydHMuZ2V0RW50cnlVcmwgPSBnZXRFbnRyeVVybDtcbi8qKlxuICogR2V0cyB0aGUgcmVnaXN0cnkgZW50cnkgVVJMIHdpdGhvdXQgYW4gaW5pdGlhbGl6ZWQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBwb3J0YWxVcmwgLSBUaGUgcG9ydGFsIFVSTC5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgdXNlciBwdWJsaWMga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUga2V5IG9mIHRoZSBkYXRhIHRvIGZldGNoIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBnZXQgZW50cnkgVVJMLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIGtleSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGdldEVudHJ5VXJsRm9yUG9ydGFsKHBvcnRhbFVybCwgcHVibGljS2V5LCBkYXRhS2V5LCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicG9ydGFsVXJsXCIsIHBvcnRhbFVybCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicHVibGljS2V5XCIsIHB1YmxpY0tleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZGF0YUtleVwiLCBkYXRhS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0R2V0RW50cnlPcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICAvLyBUcmltIHRoZSBwcmVmaXggaWYgaXQgd2FzIHBhc3NlZCBpbi5cbiAgICBwdWJsaWNLZXkgPSBzdHJpbmdfMS50cmltUHJlZml4KHB1YmxpY0tleSwgXCJlZDI1NTE5OlwiKTtcbiAgICBpZiAoIXN0cmluZ18xLmlzSGV4U3RyaW5nKHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBwdWJsaWMga2V5ICcke3B1YmxpY0tleX0nIGlzIG5vdCBhIHZhbGlkIGhleC1lbmNvZGVkIHN0cmluZyBvciBjb250YWlucyBhbiBpbnZhbGlkIHByZWZpeGApO1xuICAgIH1cbiAgICAvLyBIYXNoIGFuZCBoZXggZW5jb2RlIHRoZSBnaXZlbiBkYXRhIGtleSBpZiBpdCBpcyBub3QgYSBoYXNoIGFscmVhZHkuXG4gICAgbGV0IGRhdGFLZXlIYXNoSGV4ID0gZGF0YUtleTtcbiAgICBpZiAoIW9wdHMuaGFzaGVkRGF0YUtleUhleCkge1xuICAgICAgICBkYXRhS2V5SGFzaEhleCA9IHN0cmluZ18xLnRvSGV4U3RyaW5nKGNyeXB0b18xLmhhc2hEYXRhS2V5KGRhdGFLZXkpKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB7XG4gICAgICAgIHB1YmxpY2tleTogYGVkMjU1MTk6JHtwdWJsaWNLZXl9YCxcbiAgICAgICAgZGF0YWtleTogZGF0YUtleUhhc2hIZXgsXG4gICAgICAgIHRpbWVvdXQ6IGV4cG9ydHMuREVGQVVMVF9HRVRfRU5UUllfVElNRU9VVCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSB1cmxfMS5tYWtlVXJsKHBvcnRhbFVybCwgb3B0cy5lbmRwb2ludEdldEVudHJ5KTtcbiAgICB1cmwgPSB1cmxfMS5hZGRVcmxRdWVyeSh1cmwsIHF1ZXJ5KTtcbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy5nZXRFbnRyeVVybEZvclBvcnRhbCA9IGdldEVudHJ5VXJsRm9yUG9ydGFsO1xuLyoqXG4gKiBHZXRzIHRoZSBlbnRyeSBsaW5rIGZvciB0aGUgZW50cnkgYXQgdGhlIGdpdmVuIHB1YmxpYyBrZXkgYW5kIGRhdGEga2V5LiBUaGlzIGxpbmsgc3RheXMgdGhlIHNhbWUgZXZlbiBpZiB0aGUgY29udGVudCBhdCB0aGUgZW50cnkgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSB1c2VyIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gZGF0YUtleSAtIFRoZSBrZXkgb2YgdGhlIGRhdGEgdG8gZmV0Y2ggZm9yIHRoZSBnaXZlbiB1c2VyLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSBlbnRyeSBsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIGtleSBpcyBub3QgdmFsaWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEVudHJ5TGluayhwdWJsaWNLZXksIGRhdGFLZXksIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwdWJsaWNLZXlcIiwgcHVibGljS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJkYXRhS2V5XCIsIGRhdGFLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIFRyaW0gdGhlIHByZWZpeCBpZiBpdCB3YXMgcGFzc2VkIGluLlxuICAgIHB1YmxpY0tleSA9IHN0cmluZ18xLnRyaW1QcmVmaXgocHVibGljS2V5LCBcImVkMjU1MTk6XCIpO1xuICAgIGlmICghc3RyaW5nXzEuaXNIZXhTdHJpbmcocHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdmVuIHB1YmxpYyBrZXkgJyR7cHVibGljS2V5fScgaXMgbm90IGEgdmFsaWQgaGV4LWVuY29kZWQgc3RyaW5nIG9yIGNvbnRhaW5zIGFuIGludmFsaWQgcHJlZml4YCk7XG4gICAgfVxuICAgIGNvbnN0IHNpYVB1YmxpY0tleSA9IHNpYV8xLm5ld0VkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICBsZXQgdHdlYWs7XG4gICAgaWYgKG9wdHMuaGFzaGVkRGF0YUtleUhleCkge1xuICAgICAgICB0d2VhayA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShkYXRhS2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHR3ZWFrID0gY3J5cHRvXzEuaGFzaERhdGFLZXkoZGF0YUtleSk7XG4gICAgfVxuICAgIGNvbnN0IHNreWxpbmsgPSBzaWFfMS5uZXdTa3lsaW5rVjIoc2lhUHVibGljS2V5LCB0d2VhaykudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gZm9ybWF0XzEuZm9ybWF0U2t5bGluayhza3lsaW5rKTtcbn1cbmV4cG9ydHMuZ2V0RW50cnlMaW5rID0gZ2V0RW50cnlMaW5rO1xuLyoqXG4gKiBTZXRzIHRoZSByZWdpc3RyeSBlbnRyeS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgdXNlciBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBlbnRyeSAtIFRoZSBlbnRyeSB0byBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gQW4gZW1wdHkgcHJvbWlzZS5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBlbnRyeSByZXZpc2lvbiBkb2VzIG5vdCBmaXQgaW4gNjQgYml0cyBvciB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCB2YWxpZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0RW50cnkocHJpdmF0ZUtleSwgZW50cnksIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJwcml2YXRlS2V5XCIsIHByaXZhdGVLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRlUmVnaXN0cnlFbnRyeShcImVudHJ5XCIsIGVudHJ5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0U2V0RW50cnlPcHRpb25zKTtcbiAgICAvLyBBc3NlcnQgdGhlIGlucHV0IGlzIDY0IGJpdHMuXG4gICAgbnVtYmVyXzEuYXNzZXJ0VWludDY0KGVudHJ5LnJldmlzaW9uKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IHByaXZhdGVLZXlBcnJheSA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduRW50cnkocHJpdmF0ZUtleSwgZW50cnksIG9wdHMuaGFzaGVkRGF0YUtleUhleCk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXk6IHB1YmxpY0tleUFycmF5IH0gPSB0d2VldG5hY2xfMS5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleShwcml2YXRlS2V5QXJyYXkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlZ2lzdHJ5LnBvc3RTaWduZWRFbnRyeShzdHJpbmdfMS50b0hleFN0cmluZyhwdWJsaWNLZXlBcnJheSksIGVudHJ5LCBzaWduYXR1cmUsIG9wdHMpO1xufVxuZXhwb3J0cy5zZXRFbnRyeSA9IHNldEVudHJ5O1xuYXN5bmMgZnVuY3Rpb24gc2lnbkVudHJ5KHByaXZhdGVLZXksIGVudHJ5LCBoYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgLy8gVE9ETzogUHVibGljbHkgYXZhaWxhYmxlLCB2YWxpZGF0ZSBpbnB1dC5cbiAgICBjb25zdCBwcml2YXRlS2V5QXJyYXkgPSBzdHJpbmdfMS5oZXhUb1VpbnQ4QXJyYXkocHJpdmF0ZUtleSk7XG4gICAgLy8gU2lnbiB0aGUgZW50cnkuXG4gICAgLy8gVE9ETzogc2lnbmF0dXJlIHR5cGUgc2hvdWxkIGJlIFNpZ25hdHVyZT9cbiAgICByZXR1cm4gdHdlZXRuYWNsXzEuc2lnbihjcnlwdG9fMS5oYXNoUmVnaXN0cnlFbnRyeShlbnRyeSwgaGFzaGVkRGF0YUtleUhleCksIHByaXZhdGVLZXlBcnJheSk7XG59XG5leHBvcnRzLnNpZ25FbnRyeSA9IHNpZ25FbnRyeTtcbmFzeW5jIGZ1bmN0aW9uIHBvc3RTaWduZWRFbnRyeShwdWJsaWNLZXksIGVudHJ5LCBzaWduYXR1cmUsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJwdWJsaWNLZXlcIiwgcHVibGljS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICAvLyBUT0RPOiBWYWxpZGF0ZSBlbnRyeSBhbmQgc2lnbmF0dXJlXG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZW50cnkuZGF0YUtleVwiLCBlbnRyeS5kYXRhS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0U2V0RW50cnlPcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIEhhc2ggYW5kIGhleCBlbmNvZGUgdGhlIGdpdmVuIGRhdGEga2V5IGlmIGl0IGlzIG5vdCBhIGhhc2ggYWxyZWFkeS5cbiAgICBsZXQgZGF0YWtleSA9IGVudHJ5LmRhdGFLZXk7XG4gICAgaWYgKCFvcHRzLmhhc2hlZERhdGFLZXlIZXgpIHtcbiAgICAgICAgZGF0YWtleSA9IHN0cmluZ18xLnRvSGV4U3RyaW5nKGNyeXB0b18xLmhhc2hEYXRhS2V5KGVudHJ5LmRhdGFLZXkpKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgcHVibGlja2V5OiB7XG4gICAgICAgICAgICBhbGdvcml0aG06IFwiZWQyNTUxOVwiLFxuICAgICAgICAgICAga2V5OiBBcnJheS5mcm9tKHN0cmluZ18xLmhleFRvVWludDhBcnJheShwdWJsaWNLZXkpKSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YWtleSxcbiAgICAgICAgLy8gU2V0IHRoZSByZXZpc2lvbiBhcyBhIHN0cmluZyBoZXJlIHNpbmNlIHRoZSB2YWx1ZSBtYXkgYmUgdXAgdG8gNjQgYml0cy5cbiAgICAgICAgLy8gV2UgcmVtb3ZlIHRoZSBxdW90ZXMgbGF0ZXIgaW4gdHJhbnNmb3JtUmVxdWVzdC5cbiAgICAgICAgcmV2aXNpb246IGVudHJ5LnJldmlzaW9uLnRvU3RyaW5nKCksXG4gICAgICAgIGRhdGE6IEFycmF5LmZyb20oYnVmZmVyXzEuQnVmZmVyLmZyb20oZW50cnkuZGF0YSkpLFxuICAgICAgICBzaWduYXR1cmU6IEFycmF5LmZyb20oc2lnbmF0dXJlKSxcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBlbmRwb2ludFBhdGg6IG9wdHMuZW5kcG9pbnRTZXRFbnRyeSxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXF1ZXN0IHRvIHJlbW92ZSBxdW90ZXMsIHNpbmNlIHRoZSByZXZpc2lvbiBuZWVkcyB0byBiZVxuICAgICAgICAvLyBwYXJzZWQgYXMgYSB1aW50NjQgb24gdGhlIEdvIHNpZGUuXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgZGF0YSB0byBKU09OLlxuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSByZXZpc2lvbiB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIGEgSlNPTiBpbnRlZ2VyLlxuICAgICAgICAgICAgcmV0dXJuIGpzb24ucmVwbGFjZShyZWdleFJldmlzaW9uV2l0aFF1b3RlcywgJ1wicmV2aXNpb25cIjokMScpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5wb3N0U2lnbmVkRW50cnkgPSBwb3N0U2lnbmVkRW50cnk7XG5mdW5jdGlvbiB2YWxpZGF0ZVJlZ2lzdHJ5RW50cnkobmFtZSwgdmFsdWUsIHZhbHVlS2luZCkge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9iamVjdChuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoYCR7bmFtZX0uZGF0YUtleWAsIHZhbHVlLmRhdGFLZXksIGAke3ZhbHVlS2luZH0gZmllbGRgKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoYCR7bmFtZX0uZGF0YWAsIHZhbHVlLmRhdGEsIGAke3ZhbHVlS2luZH0gZmllbGRgKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVCaWdpbnQoYCR7bmFtZX0ucmV2aXNpb25gLCB2YWx1ZS5yZXZpc2lvbiwgYCR7dmFsdWVLaW5kfSBmaWVsZGApO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJlZ2lzdHJ5RW50cnkgPSB2YWxpZGF0ZVJlZ2lzdHJ5RW50cnk7XG4vKipcbiAqIEhhbmRsZXMgZXJyb3IgcmVzcG9uc2VzIHJldHVybmVkIGluIGdldEVudHJ5LlxuICpcbiAqIEBwYXJhbSBlcnIgLSBUaGUgQXhpb3MgZXJyb3IuXG4gKiBAcmV0dXJucyAtIEFuIGVtcHR5IHNpZ25lZCByZWdpc3RyeSBlbnRyeSBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgNDA0LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIG5vdCA0MDQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUdldEVudHJ5RXJyUmVzcG9uc2UoZXJyKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIWVyci5yZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlc3BvbnNlIGZpZWxkIG5vdCBmb3VuZCwgaW5jb21wbGV0ZSBBeGlvcyBlcnJvci4gRnVsbCBlcnJvcjogJHtlcnJ9YCk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFlcnIucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVzcG9uc2UgZGlkIG5vdCBjb250YWluIGV4cGVjdGVkIGZpZWxkICdzdGF0dXMnLiBGdWxsIGVycm9yOiAke2Vycn1gKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgc3RhdHVzIHdhcyA0MDQgXCJub3QgZm91bmRcIiBhbmQgcmV0dXJuIG51bGwgaWYgc28uXG4gICAgaWYgKGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4geyBlbnRyeTogbnVsbCwgc2lnbmF0dXJlOiBudWxsIH07XG4gICAgfVxuICAgIHRocm93IGVycjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRPckNyZWF0ZVJlZ2lzdHJ5RW50cnkgPSBleHBvcnRzLnNldEpTT04gPSBleHBvcnRzLmdldEpTT04gPSBleHBvcnRzLmRlZmF1bHRTZXRKU09OT3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdEdldEpTT05PcHRpb25zID0gZXhwb3J0cy5KU09OX1JFU1BPTlNFX1ZFUlNJT04gPSB2b2lkIDA7XG5jb25zdCB0d2VldG5hY2xfMSA9IHJlcXVpcmUoXCJ0d2VldG5hY2xcIik7XG5jb25zdCByZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcmVnaXN0cnlcIik7XG5jb25zdCBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCB1cGxvYWRfMSA9IHJlcXVpcmUoXCIuL3VwbG9hZFwiKTtcbmNvbnN0IGRvd25sb2FkXzEgPSByZXF1aXJlKFwiLi9kb3dubG9hZFwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRpb25cIik7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi91dGlscy9vcHRpb25zXCIpO1xuZXhwb3J0cy5KU09OX1JFU1BPTlNFX1ZFUlNJT04gPSAyO1xuZXhwb3J0cy5kZWZhdWx0R2V0SlNPTk9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICAuLi5yZWdpc3RyeV8xLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMsXG4gICAgLi4uZG93bmxvYWRfMS5kZWZhdWx0RG93bmxvYWRPcHRpb25zLFxuICAgIGNhY2hlZERhdGFMaW5rOiB1bmRlZmluZWQsXG59O1xuZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICAuLi5leHBvcnRzLmRlZmF1bHRHZXRKU09OT3B0aW9ucyxcbiAgICAuLi5yZWdpc3RyeV8xLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMsXG4gICAgLi4udXBsb2FkXzEuZGVmYXVsdFVwbG9hZE9wdGlvbnMsXG59O1xuLyoqXG4gKiBHZXRzIHRoZSBKU09OIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwdWJsaWNLZXkgYW5kIGRhdGFLZXkuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgdXNlciBwdWJsaWMga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUga2V5IG9mIHRoZSBkYXRhIHRvIGZldGNoIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgcmV0dXJuZWQgSlNPTiBhbmQgcmV2aXNpb24gbnVtYmVyLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJldHVybmVkIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCB0aGUgcmV0dXJuZWQgZW50cnksIG9yIGlmIHRoZSBza3lsaW5rIGluIHRoZSBlbnRyeSBpcyBpbnZhbGlkLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRKU09OKHB1YmxpY0tleSwgZGF0YUtleSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRHZXRKU09OT3B0aW9ucyk7XG4gICAgLy8gUmVzdCBvZiB2YWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldEVudHJ5YC5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRHZXRKU09OT3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgLy8gTG9va3VwIHRoZSByZWdpc3RyeSBlbnRyeS5cbiAgICBjb25zdCBnZXRFbnRyeU9wdHMgPSBvcHRpb25zXzEuZXh0cmFjdE9wdGlvbnMob3B0cywgcmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zKTtcbiAgICBjb25zdCB7IGVudHJ5IH0gPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmdldEVudHJ5KHB1YmxpY0tleSwgZGF0YUtleSwgZ2V0RW50cnlPcHRzKTtcbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZGF0YUxpbms6IG51bGwgfTtcbiAgICB9XG4gICAgY29uc3QgZGF0YUxpbmsgPSBlbnRyeS5kYXRhO1xuICAgIC8vIElmIGEgY2FjaGVkIGRhdGEgbGluayBpcyBwcm92aWRlZCBhbmQgdGhlIGRhdGEgbGluayBoYXNuJ3QgY2hhbmdlZCwgcmV0dXJuLlxuICAgIGlmIChvcHRzLmNhY2hlZERhdGFMaW5rICYmIGRhdGFMaW5rID09PSBvcHRzLmNhY2hlZERhdGFMaW5rKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGRhdGFMaW5rIH07XG4gICAgfVxuICAgIC8vIERvd25sb2FkIHRoZSBkYXRhIGluIHRoZSByZXR1cm5lZCBkYXRhIGxpbmsuXG4gICAgY29uc3QgZG93bmxvYWRPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIGRvd25sb2FkXzEuZGVmYXVsdERvd25sb2FkT3B0aW9ucyk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmdldEZpbGVDb250ZW50KGRhdGFMaW5rLCBkb3dubG9hZE9wdHMpO1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBkYXRhIGZvciB0aGUgZW50cnkgYXQgZGF0YSBrZXkgJyR7ZGF0YUtleX0nIGlzIG5vdCBKU09OLmApO1xuICAgIH1cbiAgICBpZiAoIShkYXRhW1wiX2RhdGFcIl0gJiYgZGF0YVtcIl92XCJdKSkge1xuICAgICAgICAvLyBMZWdhY3kgZGF0YSBwcmlvciB0byB2NCwgcmV0dXJuIGFzLWlzLlxuICAgICAgICByZXR1cm4geyBkYXRhLCBkYXRhTGluayB9O1xuICAgIH1cbiAgICBjb25zdCBhY3R1YWxEYXRhID0gZGF0YVtcIl9kYXRhXCJdO1xuICAgIGlmICh0eXBlb2YgYWN0dWFsRGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBkYXRhICdfZGF0YScgZm9yIHRoZSBlbnRyeSBhdCBkYXRhIGtleSAnJHtkYXRhS2V5fScgaXMgbm90IEpTT04uYCk7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGFjdHVhbERhdGEsIGRhdGFMaW5rIH07XG59XG5leHBvcnRzLmdldEpTT04gPSBnZXRKU09OO1xuLyoqXG4gKiBTZXRzIGEgSlNPTiBvYmplY3QgYXQgdGhlIHJlZ2lzdHJ5IGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpY0tleSBhbmQgZGF0YUtleS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgdXNlciBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBkYXRhS2V5IC0gVGhlIGtleSBvZiB0aGUgZGF0YSB0byBmZXRjaCBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gKiBAcGFyYW0ganNvbiAtIFRoZSBKU09OIGRhdGEgdG8gc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQga2V5cyBhcmUgbm90IHZhbGlkIHN0cmluZ3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldEpTT04ocHJpdmF0ZUtleSwgZGF0YUtleSwganNvbiwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUhleFN0cmluZyhcInByaXZhdGVLZXlcIiwgcHJpdmF0ZUtleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZGF0YUtleVwiLCBkYXRhS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPYmplY3QoXCJqc29uXCIsIGpzb24sIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRTZXRKU09OT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlBcnJheSB9ID0gdHdlZXRuYWNsXzEuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkoc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHByaXZhdGVLZXkpKTtcbiAgICBjb25zdCBbZW50cnksIHNreWxpbmtdID0gYXdhaXQgZ2V0T3JDcmVhdGVSZWdpc3RyeUVudHJ5KHRoaXMsIHB1YmxpY0tleUFycmF5LCBkYXRhS2V5LCBqc29uLCBvcHRzKTtcbiAgICAvLyBVcGRhdGUgdGhlIHJlZ2lzdHJ5LlxuICAgIGNvbnN0IHNldEVudHJ5T3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCByZWdpc3RyeV8xLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMucmVnaXN0cnkuc2V0RW50cnkocHJpdmF0ZUtleSwgZW50cnksIHNldEVudHJ5T3B0cyk7XG4gICAgcmV0dXJuIHsgZGF0YToganNvbiwgZGF0YUxpbms6IHNreWxpbmsgfTtcbn1cbmV4cG9ydHMuc2V0SlNPTiA9IHNldEpTT047XG5hc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZVJlZ2lzdHJ5RW50cnkoY2xpZW50LCBwdWJsaWNLZXlBcnJheSwgZGF0YUtleSwganNvbiwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIE5vdCBwdWJsaWNseSBhdmFpbGFibGUsIGRvbid0IHZhbGlkYXRlIGlucHV0LlxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdFNldEpTT05PcHRpb25zLFxuICAgICAgICAuLi5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIFNldCB0aGUgaGlkZGVuIF9kYXRhIGFuZCBfdiBmaWVsZHMuXG4gICAgY29uc3QgZGF0YSA9IHsgX2RhdGE6IGpzb24sIF92OiBleHBvcnRzLkpTT05fUkVTUE9OU0VfVkVSU0lPTiB9O1xuICAgIC8vIENyZWF0ZSB0aGUgZGF0YSB0byB1cGxvYWQgdG8gYWNxdWlyZSBpdHMgc2t5bGluay5cbiAgICBsZXQgZGF0YUtleUhleCA9IGRhdGFLZXk7XG4gICAgaWYgKCFvcHRzLmhhc2hlZERhdGFLZXlIZXgpIHtcbiAgICAgICAgZGF0YUtleUhleCA9IHN0cmluZ18xLnRvSGV4U3RyaW5nKHN0cmluZ18xLnN0cmluZ1RvVWludDhBcnJheVV0ZjgoZGF0YUtleSkpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gbmV3IEZpbGUoW0pTT04uc3RyaW5naWZ5KGRhdGEpXSwgYGRrOiR7ZGF0YUtleUhleH1gLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pO1xuICAgIC8vIFN0YXJ0IGZpbGUgdXBsb2FkLCBkbyBub3QgYmxvY2suXG4gICAgY29uc3QgdXBsb2FkT3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCB1cGxvYWRfMS5kZWZhdWx0VXBsb2FkT3B0aW9ucyk7XG4gICAgY29uc3Qgc2t5ZmlsZVByb21pc2UgPSBjbGllbnQudXBsb2FkRmlsZShmaWxlLCB1cGxvYWRPcHRzKTtcbiAgICAvLyBGZXRjaCB0aGUgY3VycmVudCB2YWx1ZSB0byBmaW5kIG91dCB0aGUgcmV2aXNpb24uXG4gICAgLy9cbiAgICAvLyBTdGFydCBnZXRFbnRyeSwgZG8gbm90IGJsb2NrLlxuICAgIGNvbnN0IGdldEVudHJ5T3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCByZWdpc3RyeV8xLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5UHJvbWlzZSA9IGNsaWVudC5yZWdpc3RyeS5nZXRFbnRyeShzdHJpbmdfMS50b0hleFN0cmluZyhwdWJsaWNLZXlBcnJheSksIGRhdGFLZXksIGdldEVudHJ5T3B0cyk7XG4gICAgLy8gQmxvY2sgdW50aWwgYm90aCBnZXRFbnRyeSBhbmQgdXBsb2FkRmlsZSBhcmUgZmluaXNoZWQuXG4gICAgY29uc3QgW3NpZ25lZEVudHJ5LCBza3lmaWxlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZW50cnlQcm9taXNlLFxuICAgICAgICBza3lmaWxlUHJvbWlzZSxcbiAgICBdKTtcbiAgICBsZXQgcmV2aXNpb247XG4gICAgaWYgKHNpZ25lZEVudHJ5LmVudHJ5ID09PSBudWxsKSB7XG4gICAgICAgIHJldmlzaW9uID0gQmlnSW50KDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV2aXNpb24gPSBzaWduZWRFbnRyeS5lbnRyeS5yZXZpc2lvbiArIEJpZ0ludCgxKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgaWYgdGhlIHJldmlzaW9uIGlzIGFscmVhZHkgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgaWYgKHJldmlzaW9uID4gbnVtYmVyXzEuTUFYX1JFVklTSU9OKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnJlbnQgZW50cnkgYWxyZWFkeSBoYXMgbWF4aW11bSBhbGxvd2VkIHJldmlzaW9uLCBjb3VsZCBub3QgdXBkYXRlIHRoZSBlbnRyeVwiKTtcbiAgICB9XG4gICAgLy8gQXNzZXJ0IHRoZSBpbnB1dCBpcyA2NCBiaXRzLlxuICAgIG51bWJlcl8xLmFzc2VydFVpbnQ2NChyZXZpc2lvbik7XG4gICAgLy8gQnVpbGQgdGhlIHJlZ2lzdHJ5IHZhbHVlLlxuICAgIGNvbnN0IGRhdGFMaW5rID0gc2t5ZmlsZS5za3lsaW5rO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICBkYXRhS2V5LFxuICAgICAgICBkYXRhOiBzdHJpbmdfMS50cmltVXJpUHJlZml4KGRhdGFMaW5rLCB1cmxfMS51cmlTa3luZXRQcmVmaXgpLFxuICAgICAgICByZXZpc2lvbixcbiAgICB9O1xuICAgIHJldHVybiBbZW50cnksIGRhdGFMaW5rXTtcbn1cbmV4cG9ydHMuZ2V0T3JDcmVhdGVSZWdpc3RyeUVudHJ5ID0gZ2V0T3JDcmVhdGVSZWdpc3RyeUVudHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdFNreWxpbmsgPSBleHBvcnRzLmNvbnZlcnRTa3lsaW5rVG9CYXNlMzIgPSB2b2lkIDA7XG5jb25zdCBiYXNlNjRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmFzZTY0LWpzXCIpKTtcbmNvbnN0IGJhc2UzMl9lbmNvZGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmFzZTMyLWVuY29kZVwiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCIuLi91dGlscy91cmxcIik7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBiYXNlNjQgc2t5bGluayB0byBiYXNlMzIuXG4gKlxuICogQHBhcmFtIHNreWxpbmsgLSBUaGUgYmFzZTY0IHNreWxpbmsuXG4gKiBAcmV0dXJucyAtIFRoZSBjb252ZXJ0ZWQgYmFzZTMyIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTa3lsaW5rVG9CYXNlMzIoc2t5bGluaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBiYXNlNjRfanNfMS5kZWZhdWx0LnRvQnl0ZUFycmF5KHNreWxpbmsucGFkRW5kKHNreWxpbmsubGVuZ3RoICsgNCAtIChza3lsaW5rLmxlbmd0aCAlIDQpLCBcIj1cIikpO1xuICAgIHJldHVybiBiYXNlMzJfZW5jb2RlXzEuZGVmYXVsdChkZWNvZGVkLCBcIlJGQzQ2NDgtSEVYXCIsIHsgcGFkZGluZzogZmFsc2UgfSkudG9Mb3dlckNhc2UoKTtcbn1cbmV4cG9ydHMuY29udmVydFNreWxpbmtUb0Jhc2UzMiA9IGNvbnZlcnRTa3lsaW5rVG9CYXNlMzI7XG4vKipcbiAqIEZvcm1hdHMgdGhlIHNreWxpbmsgYnkgYWRkaW5nIHRoZSBzaWE6IHByZWZpeC5cbiAqXG4gKiBAcGFyYW0gc2t5bGluayAtIFRoZSBza3lsaW5rLlxuICogQHJldHVybnMgLSBUaGUgZm9ybWF0dGVkIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFNreWxpbmsoc2t5bGluaykge1xuICAgIGlmIChza3lsaW5rID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHNreWxpbms7XG4gICAgfVxuICAgIGlmICghc2t5bGluay5zdGFydHNXaXRoKHVybF8xLnVyaVNreW5ldFByZWZpeCkpIHtcbiAgICAgICAgc2t5bGluayA9IGAke3VybF8xLnVyaVNreW5ldFByZWZpeH0ke3NreWxpbmt9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNreWxpbms7XG59XG5leHBvcnRzLmZvcm1hdFNreWxpbmsgPSBmb3JtYXRTa3lsaW5rO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlU2t5bGlua0Jhc2UzMiA9IGV4cG9ydHMucGFyc2VTa3lsaW5rID0gdm9pZCAwO1xuY29uc3QgdXJsX3BhcnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybC1wYXJzZVwiKSk7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCIuLi91dGlscy91cmxcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbmNvbnN0IGRlZmF1bHRQYXJzZVNreWxpbmtPcHRpb25zID0ge1xuICAgIGZyb21TdWJkb21haW46IGZhbHNlLFxuICAgIGluY2x1ZGVQYXRoOiBmYWxzZSxcbiAgICBvbmx5UGF0aDogZmFsc2UsXG59O1xuY29uc3QgU0tZTElOS19NQVRDSEVSID0gXCIoW2EtekEtWjAtOV8tXXs0Nn0pXCI7XG5jb25zdCBTS1lMSU5LX01BVENIRVJfU1VCRE9NQUlOID0gXCIoW2EtejAtOV8tXXs1NX0pXCI7XG5jb25zdCBTS1lMSU5LX0RJUkVDVF9SRUdFWCA9IG5ldyBSZWdFeHAoYF4ke1NLWUxJTktfTUFUQ0hFUn0kYCk7XG5jb25zdCBTS1lMSU5LX1BBVEhOQU1FX1JFR0VYID0gbmV3IFJlZ0V4cChgXi8/JHtTS1lMSU5LX01BVENIRVJ9KCgvLiopPykkYCk7XG5jb25zdCBTS1lMSU5LX1NVQkRPTUFJTl9SRUdFWCA9IG5ldyBSZWdFeHAoYF4ke1NLWUxJTktfTUFUQ0hFUl9TVUJET01BSU59KFxcXFwuLiopPyRgKTtcbmNvbnN0IFNLWUxJTktfRElSRUNUX01BVENIX1BPU0lUSU9OID0gMTtcbmNvbnN0IFNLWUxJTktfUEFUSF9NQVRDSF9QT1NJVElPTiA9IDI7XG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gc3RyaW5nIGZvciBhIGJhc2U2NCBza3lsaW5rLCBvciBiYXNlMzIgaWYgb3B0cy5mcm9tU3ViZG9tYWluIGlzIGdpdmVuLiBJZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIHByZWZpeGVkIHdpdGggc2lhOiwgc2lhOi8vLCBvciBhIHBvcnRhbCBVUkwsIHRob3NlIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIHJhdyBza3lsaW5rIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gUGxhaW4gc2t5bGluaywgc2t5bGluayB3aXRoIFVSSSBwcmVmaXgsIG9yIFVSTCB3aXRoIHNreWxpbmsgYXMgdGhlIGZpcnN0IHBhdGggZWxlbWVudC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgYmFzZTY0IChvciBiYXNlMzIpIHNreWxpbmssIG9wdGlvbmFsbHkgd2l0aCB0aGUgcGF0aCBpbmNsdWRlZC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IG9uIGludmFsaWQgY29tYmluYXRpb24gb2Ygb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTa3lsaW5rKHNreWxpbmtVcmwsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJza3lsaW5rVXJsXCIsIHNreWxpbmtVcmwsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBkZWZhdWx0UGFyc2VTa3lsaW5rT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdFBhcnNlU2t5bGlua09wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBpZiAob3B0cy5pbmNsdWRlUGF0aCAmJiBvcHRzLm9ubHlQYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbmNsdWRlUGF0aCBhbmQgb25seVBhdGggb3B0aW9ucyBjYW5ub3QgYm90aCBiZSBzZXRcIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmluY2x1ZGVQYXRoICYmIG9wdHMuZnJvbVN1YmRvbWFpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW5jbHVkZVBhdGggYW5kIGZyb21TdWJkb21haW4gb3B0aW9ucyBjYW5ub3QgYm90aCBiZSBzZXRcIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmZyb21TdWJkb21haW4pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU2t5bGlua0Jhc2UzMihza3lsaW5rVXJsLCBvcHRzKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHNreWxpbmsgcHJlZml4ZWQgd2l0aCBzaWE6IG9yIHNpYTovLyBhbmQgZXh0cmFjdCBpdC5cbiAgICAvLyBFeGFtcGxlOiBzaWE6WEFCdmk3SnRKYlFTTUFjRHduVW5tcDJGS0RQamc4X3RUVEZQNEJ3TVN4VmRFZ1xuICAgIC8vIEV4YW1wbGU6IHNpYTovL1hBQnZpN0p0SmJRU01BY0R3blVubXAyRktEUGpnOF90VFRGUDRCd01TeFZkRWdcbiAgICBza3lsaW5rVXJsID0gc3RyaW5nXzEudHJpbVVyaVByZWZpeChza3lsaW5rVXJsLCB1cmxfMS51cmlTa3luZXRQcmVmaXgpO1xuICAgIC8vIENoZWNrIGZvciBkaXJlY3QgYmFzZTY0IHNreWxpbmsgbWF0Y2guXG4gICAgY29uc3QgbWF0Y2hEaXJlY3QgPSBza3lsaW5rVXJsLm1hdGNoKFNLWUxJTktfRElSRUNUX1JFR0VYKTtcbiAgICBpZiAobWF0Y2hEaXJlY3QpIHtcbiAgICAgICAgaWYgKG9wdHMub25seVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaERpcmVjdFtTS1lMSU5LX0RJUkVDVF9NQVRDSF9QT1NJVElPTl07XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBza3lsaW5rIHBhc3NlZCBpbiBhbiB1cmwgYW5kIGV4dHJhY3QgaXQuXG4gICAgLy8gRXhhbXBsZTogaHR0cHM6Ly9zaWFza3kubmV0L1hBQnZpN0p0SmJRU01BY0R3blVubXAyRktEUGpnOF90VFRGUDRCd01TeFZkRWdcbiAgICAvLyBFeGFtcGxlOiBodHRwczovL2JnMDZ2MnRpZGtpcjg0aGcwczFzNHQ5N2phZW9hYTFqc2Uxc3ZyYWQ2NTd1MDcwYzljYWxxNGcuc2lhc2t5Lm5ldCAoaWYgb3B0cy5mcm9tU3ViZG9tYWluID0gdHJ1ZSlcbiAgICAvLyBQYXNzIGVtcHR5IG9iamVjdCBhcyBzZWNvbmQgcGFyYW0gdG8gZGlzYWJsZSB1c2luZyBsb2NhdGlvbiBhcyBiYXNlIHVybFxuICAgIC8vIHdoZW4gcGFyc2luZyBpbiBicm93c2VyLlxuICAgIGNvbnN0IHBhcnNlZCA9IHVybF9wYXJzZV8xLmRlZmF1bHQoc2t5bGlua1VybCwge30pO1xuICAgIGNvbnN0IHNreWxpbmtBbmRQYXRoID0gc3RyaW5nXzEudHJpbVN1ZmZpeChwYXJzZWQucGF0aG5hbWUsIFwiL1wiKTtcbiAgICBjb25zdCBtYXRjaFBhdGhuYW1lID0gc2t5bGlua0FuZFBhdGgubWF0Y2goU0tZTElOS19QQVRITkFNRV9SRUdFWCk7XG4gICAgaWYgKCFtYXRjaFBhdGhuYW1lKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwYXRoID0gbWF0Y2hQYXRobmFtZVtTS1lMSU5LX1BBVEhfTUFUQ0hfUE9TSVRJT05dO1xuICAgIGlmIChvcHRzLmluY2x1ZGVQYXRoKVxuICAgICAgICByZXR1cm4gc3RyaW5nXzEudHJpbUZvcndhcmRTbGFzaChza3lsaW5rQW5kUGF0aCk7XG4gICAgZWxzZSBpZiAob3B0cy5vbmx5UGF0aClcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbWF0Y2hQYXRobmFtZVtTS1lMSU5LX0RJUkVDVF9NQVRDSF9QT1NJVElPTl07XG59XG5leHBvcnRzLnBhcnNlU2t5bGluayA9IHBhcnNlU2t5bGluaztcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIHRoZSBnaXZlbiBzdHJpbmcgZm9yIGEgYmFzZTMyIHNreWxpbmsuXG4gKlxuICogQHBhcmFtIHNreWxpbmtVcmwgLSBCYXNlMzIgc2t5bGluay5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgYmFzZTMyIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2t5bGlua0Jhc2UzMihza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gRG8gbm90IHZhbGlkYXRlLCB0aGlzIGhlbHBlciBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBwYXJzZVNreWxpbmsuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdFBhcnNlU2t5bGlua09wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICAvLyBQYXNzIGVtcHR5IG9iamVjdCBhcyBzZWNvbmQgcGFyYW0gdG8gZGlzYWJsZSB1c2luZyBsb2NhdGlvbiBhcyBiYXNlIHVybFxuICAgIC8vIHdoZW4gcGFyc2luZyBpbiBicm93c2VyLlxuICAgIGNvbnN0IHBhcnNlZCA9IHVybF9wYXJzZV8xLmRlZmF1bHQoc2t5bGlua1VybCwge30pO1xuICAgIC8vIENoZWNrIGlmIHRoZSBob3N0bmFtZSBjb250YWlucyBhIHNreWxpbmsgc3ViZG9tYWluLlxuICAgIGNvbnN0IG1hdGNoSG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWUubWF0Y2goU0tZTElOS19TVUJET01BSU5fUkVHRVgpO1xuICAgIGlmIChtYXRjaEhvc3RuYW1lKSB7XG4gICAgICAgIGlmIChvcHRzLm9ubHlQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nXzEudHJpbVN1ZmZpeChwYXJzZWQucGF0aG5hbWUsIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hIb3N0bmFtZVtTS1lMSU5LX0RJUkVDVF9NQVRDSF9QT1NJVElPTl07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5wYXJzZVNreWxpbmtCYXNlMzIgPSBwYXJzZVNreWxpbmtCYXNlMzI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3U2t5bGlua1YyID0gZXhwb3J0cy5uZXdFZDI1NTE5UHVibGljS2V5ID0gZXhwb3J0cy5uZXdTcGVjaWZpZXIgPSBleHBvcnRzLlNpYVNreWxpbmsgPSB2b2lkIDA7XG5jb25zdCBiYXNlNjRfanNfMSA9IHJlcXVpcmUoXCJiYXNlNjQtanNcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG9cIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2VuY29kaW5nXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyaW5nXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL3ZhbGlkYXRpb25cIik7XG4vLyBUaGUgcmF3IHNpemUgb2YgdGhlIGRhdGEgdGhhdCBnZXRzIHB1dCBpbnRvIGEgbGluay5cbmNvbnN0IFJBV19TS1lMSU5LX1NJWkUgPSAzNDtcbmNsYXNzIFNpYVNreWxpbmsge1xuICAgIGNvbnN0cnVjdG9yKGJpdGZpZWxkLCBtZXJrbGVSb290KSB7XG4gICAgICAgIHRoaXMuYml0ZmllbGQgPSBiaXRmaWVsZDtcbiAgICAgICAgdGhpcy5tZXJrbGVSb290ID0gbWVya2xlUm9vdDtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlTnVtYmVyKFwiYml0ZmllbGRcIiwgYml0ZmllbGQsIFwiY29uc3RydWN0b3IgcGFyYW1ldGVyXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVVaW50OEFycmF5TGVuKFwibWVya2xlUm9vdFwiLCBtZXJrbGVSb290LCBcImNvbnN0cnVjdG9yIHBhcmFtZXRlclwiLCAzMik7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihSQVdfU0tZTElOS19TSVpFKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpO1xuICAgICAgICB2aWV3LnNldFVpbnQxNigwLCB0aGlzLmJpdGZpZWxkLCB0cnVlKTtcbiAgICAgICAgY29uc3QgdWludDhCeXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgIHVpbnQ4Qnl0ZXMuc2V0KHRoaXMubWVya2xlUm9vdCwgMik7XG4gICAgICAgIHJldHVybiB1aW50OEJ5dGVzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGJhc2U2NCA9IGJhc2U2NF9qc18xLmZyb21CeXRlQXJyYXkodGhpcy50b0J5dGVzKCkpO1xuICAgICAgICAvLyBDaGFuZ2UgdG8gVVJMIGVuY29kaW5nLlxuICAgICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xuICAgICAgICAvLyBSZW1vdmUgcGFkZGluZyBjaGFyYWN0ZXJzLlxuICAgICAgICByZXR1cm4gc3RyaW5nXzEudHJpbVN1ZmZpeChiYXNlNjQsIFwiPVwiKTtcbiAgICB9XG59XG5leHBvcnRzLlNpYVNreWxpbmsgPSBTaWFTa3lsaW5rO1xuY29uc3QgU1BFQ0lGSUVSX0xFTiA9IDE2O1xuLyoqXG4gKiBSZXR1cm5zIGEgc3BlY2lmaWVyIGZvciBnaXZlbiBuYW1lLCBhIHNwZWNpZmllciBjYW4gb25seSBiZSAxNiBieXRlcyBzbyB3ZVxuICogcGFuaWMgaWYgdGhlIGdpdmVuIG5hbWUgaXMgdG9vIGxvbmcuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZS5cbiAqIEByZXR1cm5zIC0gVGhlIHNwZWNpZmllciwgaWYgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIG5ld1NwZWNpZmllcihuYW1lKSB7XG4gICAgdmFsaWRhdGVTcGVjaWZpZXIobmFtZSk7XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gbmV3IFVpbnQ4QXJyYXkoU1BFQ0lGSUVSX0xFTik7XG4gICAgc3BlY2lmaWVyLnNldChzdHJpbmdfMS5zdHJpbmdUb1VpbnQ4QXJyYXlVdGY4KG5hbWUpKTtcbiAgICByZXR1cm4gc3BlY2lmaWVyO1xufVxuZXhwb3J0cy5uZXdTcGVjaWZpZXIgPSBuZXdTcGVjaWZpZXI7XG5jb25zdCBQVUJMSUNfS0VZX1NJWkUgPSAzMjtcbmNsYXNzIFNpYVB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IoYWxnb3JpdGhtLCBrZXkpIHtcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICBtYXJzaGFsU2lhKCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFNQRUNJRklFUl9MRU4gKyA4ICsgUFVCTElDX0tFWV9TSVpFKTtcbiAgICAgICAgYnl0ZXMuc2V0KHRoaXMuYWxnb3JpdGhtKTtcbiAgICAgICAgYnl0ZXMuc2V0KGVuY29kaW5nXzEuZW5jb2RlUHJlZml4ZWRCeXRlcyh0aGlzLmtleSksIFNQRUNJRklFUl9MRU4pO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNpYSBwdWJsaWMga2V5LiBNYXRjaGVzIEVkMjU1MTlQdWJsaWNLZXkgaW4gc2lhLlxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgaGV4LWVuY29kZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIC0gVGhlIFNpYVB1YmxpY0tleS5cbiAqL1xuZnVuY3Rpb24gbmV3RWQyNTUxOVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJwdWJsaWNLZXlcIiwgcHVibGljS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICBjb25zdCBhbGdvcml0aG0gPSBuZXdTcGVjaWZpZXIoXCJlZDI1NTE5XCIpO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHB1YmxpY0tleSk7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlVWludDhBcnJheUxlbihcInB1YmxpY0tleUJ5dGVzXCIsIHB1YmxpY0tleUJ5dGVzLCBcImNvbnZlcnRlZCBwdWJsaWNLZXlcIiwgUFVCTElDX0tFWV9TSVpFKTtcbiAgICByZXR1cm4gbmV3IFNpYVB1YmxpY0tleShhbGdvcml0aG0sIHB1YmxpY0tleUJ5dGVzKTtcbn1cbmV4cG9ydHMubmV3RWQyNTUxOVB1YmxpY0tleSA9IG5ld0VkMjU1MTlQdWJsaWNLZXk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdjIgc2t5bGluay4gTWF0Y2hlcyBOZXdTa3lsaW5rVjIgaW4gc2t5ZC5cbiAqXG4gKiBAcGFyYW0gc2lhUHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgYXMgYSBTaWFQdWJsaWNLZXkuXG4gKiBAcGFyYW0gdHdlYWsgLSBUaGUgaGFzaGVkIHR3ZWFrLlxuICogQHJldHVybnMgLSBUaGUgdjIgc2t5bGluay5cbiAqL1xuZnVuY3Rpb24gbmV3U2t5bGlua1YyKHNpYVB1YmxpY0tleSwgdHdlYWspIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gMjtcbiAgICBjb25zdCBiaXRmaWVsZCA9IHZlcnNpb24gLSAxO1xuICAgIGNvbnN0IG1lcmtsZVJvb3QgPSBkZXJpdmVSZWdpc3RyeUVudHJ5SUQoc2lhUHVibGljS2V5LCB0d2Vhayk7XG4gICAgcmV0dXJuIG5ldyBTaWFTa3lsaW5rKGJpdGZpZWxkLCBtZXJrbGVSb290KTtcbn1cbmV4cG9ydHMubmV3U2t5bGlua1YyID0gbmV3U2t5bGlua1YyO1xuLyoqXG4gKiBBIGhlbHBlciB0byBkZXJpdmUgYW4gZW50cnkgaWQgZm9yIGEgcmVnaXN0cnkga2V5IHZhbHVlIHBhaXIuIE1hdGNoZXMgYERlcml2ZVJlZ2lzdHJ5RW50cnlJRGAgaW4gc2lhLlxuICpcbiAqIEBwYXJhbSBwdWJLZXkgLSBUaGUgc2lhIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gdHdlYWsgLSBUaGUgdHdlYWsuXG4gKiBAcmV0dXJucyAtIFRoZSBlbnRyeSBJRCBhcyBhIGhhc2ggb2YgdGhlIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gZGVyaXZlUmVnaXN0cnlFbnRyeUlEKHB1YktleSwgdHdlYWspIHtcbiAgICByZXR1cm4gY3J5cHRvXzEuaGFzaEFsbChwdWJLZXkubWFyc2hhbFNpYSgpLCB0d2Vhayk7XG59XG4vKipcbiAqIFBlcmZvcm1zIHZhbGlkYXRpb24gY2hlY2tzIG9uIHRoZSBzcGVjaWZpZXIgbmFtZSwgaXQgcGFuaWNzIHdoZW4gdGhlIGlucHV0IGlzXG4gKiBpbnZhbGlkIHNlZWluZyB3ZSB3YW50IHRvIGNhdGNoIHRoaXMgb24gcnVudGltZS5cbiAqIE1hdGNoZXMgYHZhbGlkYXRlU3BlY2lmaWVyYCBpbiBzaWEuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgc3BlY2lmaWVyIG5hbWUuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc3BlY2lmaWVyIG5hbWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNwZWNpZmllcihuYW1lKSB7XG4gICAgaWYgKCFzdHJpbmdfMS5pc0FTQ0lJU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNwZWNpZmllciBoYXMgdG8gYmUgQVNDSUlcIik7XG4gICAgfVxuICAgIGlmIChuYW1lLmxlbmd0aCA+IFNQRUNJRklFUl9MRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BlY2lmaWVyIG1heCBsZW5ndGggZXhjZWVkZWRcIik7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVwbG9hZERpcmVjdG9yeVJlcXVlc3QgPSBleHBvcnRzLnVwbG9hZERpcmVjdG9yeSA9IGV4cG9ydHMudXBsb2FkRmlsZVJlcXVlc3QgPSBleHBvcnRzLnVwbG9hZEZpbGUgPSBleHBvcnRzLmRlZmF1bHRVcGxvYWRPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZmlsZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvZmlsZVwiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL3NreWxpbmsvZm9ybWF0XCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbmV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICBlbmRwb2ludFVwbG9hZDogXCIvc2t5bmV0L3NreWZpbGVcIixcbiAgICBwb3J0YWxGaWxlRmllbGRuYW1lOiBcImZpbGVcIixcbiAgICBwb3J0YWxEaXJlY3RvcnlGaWxlRmllbGRuYW1lOiBcImZpbGVzW11cIixcbiAgICBjdXN0b21GaWxlbmFtZTogXCJcIixcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxufTtcbi8qKlxuICogVXBsb2FkcyBhIGZpbGUgdG8gU2t5bmV0LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UGF0aD1cIi9za3luZXQvc2t5ZmlsZVwiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSByZXR1cm5lZCBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBidXQgdGhlIHVwbG9hZCByZXNwb25zZSBkb2VzIG5vdCBjb250YWluIGEgY29tcGxldGUgcmVzcG9uc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZSwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgdXBsb2FkRGlyZWN0b3J5UmVxdWVzdGAuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVwbG9hZEZpbGVSZXF1ZXN0KGZpbGUsIGN1c3RvbU9wdGlvbnMpO1xuICAgIC8vIFNhbml0eSBjaGVjay5cbiAgICB2YWxpZGF0ZVVwbG9hZFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBza3lsaW5rID0gZm9ybWF0XzEuZm9ybWF0U2t5bGluayhyZXNwb25zZS5kYXRhLnNreWxpbmspO1xuICAgIGNvbnN0IG1lcmtsZXJvb3QgPSByZXNwb25zZS5kYXRhLm1lcmtsZXJvb3Q7XG4gICAgY29uc3QgYml0ZmllbGQgPSByZXNwb25zZS5kYXRhLmJpdGZpZWxkO1xuICAgIHJldHVybiB7IHNreWxpbmssIG1lcmtsZXJvb3QsIGJpdGZpZWxkIH07XG59XG5leHBvcnRzLnVwbG9hZEZpbGUgPSB1cGxvYWRGaWxlO1xuLyoqXG4gKiBNYWtlcyBhIHJlcXVlc3QgdG8gdXBsb2FkIGEgZmlsZSB0byBTa3luZXQuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGZpbGUgdG8gdXBsb2FkLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL3NreW5ldC9za3lmaWxlXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIHVwbG9hZCByZXNwb25zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZVJlcXVlc3QoZmlsZSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRlRmlsZShcImZpbGVcIiwgZmlsZSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZmlsZSA9IGVuc3VyZUZpbGVPYmplY3RDb25zaXN0ZW5jeShmaWxlKTtcbiAgICBpZiAob3B0cy5jdXN0b21GaWxlbmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQob3B0cy5wb3J0YWxGaWxlRmllbGRuYW1lLCBmaWxlLCBvcHRzLmN1c3RvbUZpbGVuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChvcHRzLnBvcnRhbEZpbGVGaWVsZG5hbWUsIGZpbGUpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBlbmRwb2ludFBhdGg6IG9wdHMuZW5kcG9pbnRVcGxvYWQsXG4gICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydHMudXBsb2FkRmlsZVJlcXVlc3QgPSB1cGxvYWRGaWxlUmVxdWVzdDtcbi8qKlxuICogVXBsb2FkcyBhIGRpcmVjdG9yeSB0byBTa3luZXQuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBkaXJlY3RvcnkgLSBGaWxlIG9iamVjdHMgdG8gdXBsb2FkLCBpbmRleGVkIGJ5IHRoZWlyIHBhdGggc3RyaW5ncy5cbiAqIEBwYXJhbSBmaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvc2t5bmV0L3NreWZpbGVcIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgcmV0dXJuZWQgc2t5bGluay5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwgYnV0IHRoZSB1cGxvYWQgcmVzcG9uc2UgZG9lcyBub3QgY29udGFpbiBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiB1cGxvYWREaXJlY3RvcnkoZGlyZWN0b3J5LCBmaWxlbmFtZSwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgdXBsb2FkRGlyZWN0b3J5UmVxdWVzdGAuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVwbG9hZERpcmVjdG9yeVJlcXVlc3QoZGlyZWN0b3J5LCBmaWxlbmFtZSwgY3VzdG9tT3B0aW9ucyk7XG4gICAgLy8gU2FuaXR5IGNoZWNrLlxuICAgIHZhbGlkYXRlVXBsb2FkUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IHNreWxpbmsgPSBmb3JtYXRfMS5mb3JtYXRTa3lsaW5rKHJlc3BvbnNlLmRhdGEuc2t5bGluayk7XG4gICAgY29uc3QgbWVya2xlcm9vdCA9IHJlc3BvbnNlLmRhdGEubWVya2xlcm9vdDtcbiAgICBjb25zdCBiaXRmaWVsZCA9IHJlc3BvbnNlLmRhdGEuYml0ZmllbGQ7XG4gICAgcmV0dXJuIHsgc2t5bGluaywgbWVya2xlcm9vdCwgYml0ZmllbGQgfTtcbn1cbmV4cG9ydHMudXBsb2FkRGlyZWN0b3J5ID0gdXBsb2FkRGlyZWN0b3J5O1xuLyoqXG4gKiBNYWtlcyBhIHJlcXVlc3QgdG8gdXBsb2FkIGEgZGlyZWN0b3J5IHRvIFNreW5ldC5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRpcmVjdG9yeSAtIEZpbGUgb2JqZWN0cyB0byB1cGxvYWQsIGluZGV4ZWQgYnkgdGhlaXIgcGF0aCBzdHJpbmdzLlxuICogQHBhcmFtIGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UGF0aD1cIi9za3luZXQvc2t5ZmlsZVwiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSB1cGxvYWQgcmVzcG9uc2UuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQgZmlsZW5hbWUgaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiB1cGxvYWREaXJlY3RvcnlSZXF1ZXN0KGRpcmVjdG9yeSwgZmlsZW5hbWUsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPYmplY3QoXCJkaXJlY3RvcnlcIiwgZGlyZWN0b3J5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJmaWxlbmFtZVwiLCBmaWxlbmFtZSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgT2JqZWN0LmVudHJpZXMoZGlyZWN0b3J5KS5mb3JFYWNoKChbcGF0aCwgZmlsZV0pID0+IHtcbiAgICAgICAgZmlsZSA9IGVuc3VyZUZpbGVPYmplY3RDb25zaXN0ZW5jeShmaWxlKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG9wdHMucG9ydGFsRGlyZWN0b3J5RmlsZUZpZWxkbmFtZSwgZmlsZSwgcGF0aCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZW5kcG9pbnRQYXRoOiBvcHRzLmVuZHBvaW50VXBsb2FkLFxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgcXVlcnk6IHsgZmlsZW5hbWUgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnRzLnVwbG9hZERpcmVjdG9yeVJlcXVlc3QgPSB1cGxvYWREaXJlY3RvcnlSZXF1ZXN0O1xuLyoqXG4gKiBTb21ldGltZXMgZmlsZSBvYmplY3QgbWlnaHQgaGF2ZSBoYWQgdGhlIHR5cGUgcHJvcGVydHkgZGVmaW5lZCBtYW51YWxseSB3aXRoXG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkgYW5kIHNvbWUgYnJvd3NlcnMgKG5hbWVseSBmaXJlZm94KSBjYW4gaGF2ZSBwcm9ibGVtc1xuICogcmVhZGluZyBpdCBhZnRlciB0aGUgZmlsZSBoYXMgYmVlbiBhcHBlbmRlZCB0byBmb3JtIGRhdGEuIFRvIG92ZXJjb21lIHRoaXMsXG4gKiB3ZSByZWNyZWF0ZSB0aGUgZmlsZSBvYmplY3QgdXNpbmcgbmF0aXZlIEZpbGUgY29uc3RydWN0b3Igd2l0aCBhIHR5cGUgZGVmaW5lZFxuICogYXMgYSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBpbnB1dCBmaWxlLlxuICogQHJldHVybnMgLSBUaGUgcHJvY2Vzc2VkIGZpbGUuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vTmVidWxvdXNMYWJzL3NreW5ldC13ZWJwb3J0YWwvaXNzdWVzLzI5MHwgUmVsYXRlZCBJc3N1ZX1cbiAqL1xuZnVuY3Rpb24gZW5zdXJlRmlsZU9iamVjdENvbnNpc3RlbmN5KGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IEZpbGUoW2ZpbGVdLCBmaWxlLm5hbWUsIHsgdHlwZTogZmlsZV8xLmdldEZpbGVNaW1lVHlwZShmaWxlKSB9KTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBnaXZlbiB2YWx1ZSBhcyBhIGZpbGUuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCBmaWxlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbGUobmFtZSwgdmFsdWUsIHZhbHVlS2luZCkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwiJ0ZpbGUnXCIpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSB1cGxvYWQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIHVwbG9hZCByZXNwb25zZS5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIG5vdCBhIHZhbGlkIHVwbG9hZCByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2UuZGF0YSBmaWVsZCBtaXNzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInNreWxpbmtcIiwgcmVzcG9uc2UuZGF0YS5za3lsaW5rLCBcInVwbG9hZCByZXNwb25zZSBmaWVsZFwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwibWVya2xlcm9vdFwiLCByZXNwb25zZS5kYXRhLm1lcmtsZXJvb3QsIFwidXBsb2FkIHJlc3BvbnNlIGZpZWxkXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVOdW1iZXIoXCJiaXRmaWVsZFwiLCByZXNwb25zZS5kYXRhLmJpdGZpZWxkLCBcInVwbG9hZCByZXNwb25zZSBmaWVsZFwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCBub3QgZ2V0IGEgY29tcGxldGUgdXBsb2FkIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVV0ZjhTdHJpbmcgPSBleHBvcnRzLmVuY29kZVByZWZpeGVkQnl0ZXMgPSBleHBvcnRzLmVuY29kZUJpZ2ludEFzVWludDY0ID0gZXhwb3J0cy5lbmNvZGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbnVtYmVyIGludG8gYSB1aW50OCBhcnJheVxuICpcbiAqIEBwYXJhbSBudW0gLSBOdW1iZXIgdG8gZW5jb2RlLlxuICogQHJldHVybnMgLSBOdW1iZXIgZW5jb2RlZCBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZU51bWJlcihudW0pIHtcbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGVuY29kZWQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBudW0gJiAweGZmO1xuICAgICAgICBlbmNvZGVkW2luZGV4XSA9IGJ5dGU7XG4gICAgICAgIG51bSA9IG51bSA+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmV4cG9ydHMuZW5jb2RlTnVtYmVyID0gZW5jb2RlTnVtYmVyO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBiaWdpbnQgaW50byBhIHVpbnQ4IGFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnQgLSBCaWdpbnQgdG8gZW5jb2RlLlxuICogQHJldHVybnMgLSBCaWdpbnQgZW5jb2RlZCBhcyBhIGJ5dGUgYXJyYXkuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW50IGRvZXMgbm90IGZpdCBpbiA2NCBiaXRzLlxuICovXG5mdW5jdGlvbiBlbmNvZGVCaWdpbnRBc1VpbnQ2NChpbnQpIHtcbiAgICAvLyBBc3NlcnQgdGhlIGlucHV0IGlzIDY0IGJpdHMuXG4gICAgbnVtYmVyXzEuYXNzZXJ0VWludDY0KGludCk7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBlbmNvZGVkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBieXRlID0gaW50ICYgQmlnSW50KDB4ZmYpO1xuICAgICAgICBlbmNvZGVkW2luZGV4XSA9IE51bWJlcihieXRlKTtcbiAgICAgICAgaW50ID0gaW50ID4+IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5leHBvcnRzLmVuY29kZUJpZ2ludEFzVWludDY0ID0gZW5jb2RlQmlnaW50QXNVaW50NjQ7XG4vKipcbiAqIEVuY29kZXMgdGhlIHVpbnQ4YXJyYXksIHByZWZpeGVkIGJ5IGl0cyBsZW5ndGguXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGlucHV0IGFycmF5LlxuICogQHJldHVybnMgLSBUaGUgZW5jb2RlZCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBlbmNvZGVQcmVmaXhlZEJ5dGVzKGJ5dGVzKSB7XG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig4ICsgbGVuKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgLy8gU2lhIHVzZXMgc2V0VWludDY0IHdoaWNoIGlzIHVuYXZhaWxhYmxlIGluIEpTLlxuICAgIHZpZXcuc2V0VWludDMyKDAsIGxlbiwgdHJ1ZSk7XG4gICAgY29uc3QgdWludDhCeXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdWludDhCeXRlcy5zZXQoYnl0ZXMsIDgpO1xuICAgIHJldHVybiB1aW50OEJ5dGVzO1xufVxuZXhwb3J0cy5lbmNvZGVQcmVmaXhlZEJ5dGVzID0gZW5jb2RlUHJlZml4ZWRCeXRlcztcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gVVRGLTggc3RyaW5nIGludG8gYSB1aW50OCBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgbGVuZ3RoIGFuZCB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHJldHVybnMgLSBTdHJpbmcgZW5jb2RlZCBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVV0ZjhTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gc3RyaW5nXzEuc3RyaW5nVG9VaW50OEFycmF5VXRmOChzdHIpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBuZXcgVWludDhBcnJheSg4ICsgYnl0ZUFycmF5Lmxlbmd0aCk7XG4gICAgZW5jb2RlZC5zZXQoZW5jb2RlTnVtYmVyKGJ5dGVBcnJheS5sZW5ndGgpKTtcbiAgICBlbmNvZGVkLnNldChieXRlQXJyYXksIDgpO1xuICAgIHJldHVybiBlbmNvZGVkO1xufVxuZXhwb3J0cy5lbmNvZGVVdGY4U3RyaW5nID0gZW5jb2RlVXRmOFN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGaWxlTWltZVR5cGUgPSBleHBvcnRzLmdldFJvb3REaXJlY3RvcnkgPSBleHBvcnRzLmdldFJlbGF0aXZlRmlsZVBhdGggPSB2b2lkIDA7XG5jb25zdCBsaXRlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1pbWUvbGl0ZVwiKSk7XG5jb25zdCBwYXRoX2Jyb3dzZXJpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGF0aC1icm93c2VyaWZ5XCIpKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuLyoqXG4gKiBHZXRzIHRoZSBwYXRoIGZvciB0aGUgZmlsZS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlLlxuICogQHJldHVybnMgLSBUaGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZVBhdGgoZmlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZpbGUud2Via2l0UmVsYXRpdmVQYXRoIHx8IGZpbGUucGF0aCB8fCBmaWxlLm5hbWU7XG59XG4vKipcbiAqIEdldHMgdGhlIGZpbGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIHBhdGgsIGUuZy4gYGJhcmAgaW4gYC9mb28vYmFyYC5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBpbnB1dCBmaWxlLlxuICogQHJldHVybnMgLSBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLlxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUZpbGVQYXRoKGZpbGUpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGdldEZpbGVQYXRoKGZpbGUpO1xuICAgIGNvbnN0IHsgcm9vdCwgZGlyLCBiYXNlIH0gPSBwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0LnBhcnNlKGZpbGVQYXRoKTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGhfYnJvd3NlcmlmeV8xLmRlZmF1bHQubm9ybWFsaXplKGRpcikuc2xpY2Uocm9vdC5sZW5ndGgpLnNwbGl0KHBhdGhfYnJvd3NlcmlmeV8xLmRlZmF1bHQuc2VwKS5zbGljZSgxKTtcbiAgICByZXR1cm4gcGF0aF9icm93c2VyaWZ5XzEuZGVmYXVsdC5qb2luKC4uLnJlbGF0aXZlLCBiYXNlKTtcbn1cbmV4cG9ydHMuZ2V0UmVsYXRpdmVGaWxlUGF0aCA9IGdldFJlbGF0aXZlRmlsZVBhdGg7XG4vKipcbiAqIEdldHMgdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBmaWxlIHBhdGgsIGUuZy4gYGZvb2AgaW4gYC9mb28vYmFyYC5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBpbnB1dCBmaWxlLlxuICogQHJldHVybnMgLSBUaGUgcm9vdCBkaXJlY3RvcnkuXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3REaXJlY3RvcnkoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZ2V0RmlsZVBhdGgoZmlsZSk7XG4gICAgY29uc3QgeyByb290LCBkaXIgfSA9IHBhdGhfYnJvd3NlcmlmeV8xLmRlZmF1bHQucGFyc2UoZmlsZVBhdGgpO1xuICAgIHJldHVybiBwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0Lm5vcm1hbGl6ZShkaXIpLnNsaWNlKHJvb3QubGVuZ3RoKS5zcGxpdChwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0LnNlcClbMF07XG59XG5leHBvcnRzLmdldFJvb3REaXJlY3RvcnkgPSBnZXRSb290RGlyZWN0b3J5O1xuLyoqXG4gKiBHZXQgdGhlIGZpbGUgbWltZSB0eXBlLiBJbiBjYXNlIHRoZSB0eXBlIGlzIG5vdCBwcm92aWRlZCwgdXNlIG1pbWUtZGIgYW5kIHRyeVxuICogdG8gZ3Vlc3MgdGhlIGZpbGUgdHlwZSBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGZpbGUuXG4gKiBAcmV0dXJucyAtIFRoZSBtaW1lIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVNaW1lVHlwZShmaWxlKSB7XG4gICAgaWYgKGZpbGUudHlwZSlcbiAgICAgICAgcmV0dXJuIGZpbGUudHlwZTtcbiAgICBsZXQgeyBleHQgfSA9IHBhdGhfYnJvd3NlcmlmeV8xLmRlZmF1bHQucGFyc2UoZmlsZS5uYW1lKTtcbiAgICBleHQgPSBzdHJpbmdfMS50cmltUHJlZml4KGV4dCwgXCIuXCIpO1xuICAgIGlmIChleHQgIT09IFwiXCIpIHtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBsaXRlXzEuZGVmYXVsdC5nZXRUeXBlKGV4dCk7XG4gICAgICAgIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy5nZXRGaWxlTWltZVR5cGUgPSBnZXRGaWxlTWltZVR5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0VWludDY0ID0gZXhwb3J0cy5NQVhfUkVWSVNJT04gPSB2b2lkIDA7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciBhbiBlbnRyeSByZXZpc2lvbi4gU2V0dGluZyBhbiBlbnRyeSByZXZpc2lvbiB0byB0aGlzIHZhbHVlIHByZXZlbnRzIGl0IGZyb20gYmVpbmcgdXBkYXRlZCBmdXJ0aGVyLlxuICovXG5leHBvcnRzLk1BWF9SRVZJU0lPTiA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpOyAvLyBtYXggdWludDY0XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYmlnaW50IGNhbiBmaXQgaW4gYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0gaW50IC0gVGhlIHByb3ZpZGVkIGludGVnZXIuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW50IGRvZXMgbm90IGZpdCBpbiA2NCBiaXRzLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQmlnSW50L2FzVWludE4gfCBNRE4gRGVtb31cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VWludDY0KGludCkge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUJpZ2ludChcImludFwiLCBpbnQsIFwicGFyYW1ldGVyXCIpO1xuICAgIGlmIChpbnQgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAke2ludH0gbXVzdCBiZSBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlcjsgd2FzIG5lZ2F0aXZlYCk7XG4gICAgfVxuICAgIGlmIChpbnQgPiBleHBvcnRzLk1BWF9SRVZJU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICR7aW50fSBkb2VzIG5vdCBmaXQgaW4gYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcjsgZXhjZWVkcyAyXjY0LTFgKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFVpbnQ2NCA9IGFzc2VydFVpbnQ2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdEJhc2VPcHRpb25zID0gdm9pZCAwO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBiYXNlIGN1c3RvbSBvcHRpb25zLlxuICovXG5leHBvcnRzLmRlZmF1bHRCYXNlT3B0aW9ucyA9IHtcbiAgICBBUElLZXk6IFwiXCIsXG4gICAgY3VzdG9tVXNlckFnZW50OiBcIlwiLFxuICAgIGN1c3RvbUNvb2tpZTogXCJcIixcbiAgICBvblVwbG9hZFByb2dyZXNzOiB1bmRlZmluZWQsXG59O1xuLyoqXG4gKiBFeHRyYWN0IG9ubHkgdGhlIG1vZGVsJ3MgY3VzdG9tIG9wdGlvbnMgZnJvbSB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIFRoZSBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG1vZGVsIC0gVGhlIG1vZGVsIG9wdGlvbnMuXG4gKiBAcmV0dXJucyAtIFRoZSBleHRyYWN0ZWQgY3VzdG9tIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RPcHRpb25zKG9wdHMsIG1vZGVsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBtb2RlbCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZGVsLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBvcHRzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5leHRyYWN0T3B0aW9ucyA9IGV4dHJhY3RPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvSGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuaGV4VG9VaW50OEFycmF5ID0gZXhwb3J0cy51aW50OEFycmF5VG9TdHJpbmdVdGY4ID0gZXhwb3J0cy5zdHJpbmdUb1VpbnQ4QXJyYXlVdGY4ID0gZXhwb3J0cy50cmltVXJpUHJlZml4ID0gZXhwb3J0cy50cmltU3VmZml4ID0gZXhwb3J0cy50cmltUHJlZml4ID0gZXhwb3J0cy50cmltRm9yd2FyZFNsYXNoID0gZXhwb3J0cy5pc0FTQ0lJU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTdHJpbmcgY29udGFpbnMgb25seSBBU0NJSSBieXRlcy5cbiAqIEZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MzEzMjEzLzYwODUyNDIuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBpbnB1dCBzdHJpbmcuXG4gKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHN0cmluZyBpcyBBU0NJSS5cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSVN0cmluZyhzdHIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydHMuaXNBU0NJSVN0cmluZyA9IGlzQVNDSUlTdHJpbmc7XG4vKipcbiAqIFJlbW92ZXMgc2xhc2hlcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0cmltRm9yd2FyZFNsYXNoKHN0cikge1xuICAgIHJldHVybiB0cmltUHJlZml4KHRyaW1TdWZmaXgoc3RyLCBcIi9cIiksIFwiL1wiKTtcbn1cbmV4cG9ydHMudHJpbUZvcndhcmRTbGFzaCA9IHRyaW1Gb3J3YXJkU2xhc2g7XG4vLyBUT0RPOiBNb3ZlIHRvIG15c2t5LXV0aWxzXG4vKipcbiAqIFJlbW92ZXMgYSBwcmVmaXggZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBwcmVmaXggLSBUaGUgcHJlZml4IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbbGltaXRdIC0gTWF4aW11bSBhbW91bnQgb2YgdGltZXMgdG8gdHJpbS4gTm8gbGltaXQgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIC0gVGhlIHByb2Nlc3NlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRyaW1QcmVmaXgoc3RyLCBwcmVmaXgsIGxpbWl0KSB7XG4gICAgd2hpbGUgKHN0ci5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIGxpbWl0IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVByZWZpeCA9IHRyaW1QcmVmaXg7XG4vLyBUT0RPOiBNb3ZlIHRvIG15c2t5LXV0aWxzXG4vKipcbiAqIFJlbW92ZXMgYSBzdWZmaXggZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBzdWZmaXggLSBUaGUgc3VmZml4IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbbGltaXRdIC0gTWF4aW11bSBhbW91bnQgb2YgdGltZXMgdG8gdHJpbS4gTm8gbGltaXQgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIC0gVGhlIHByb2Nlc3NlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRyaW1TdWZmaXgoc3RyLCBzdWZmaXgsIGxpbWl0KSB7XG4gICAgd2hpbGUgKHN0ci5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIGxpbWl0IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVN1ZmZpeCA9IHRyaW1TdWZmaXg7XG4vKipcbiAqIFJlbW92ZXMgYSBVUkkgcHJlZml4IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gcHJlZml4IC0gVGhlIHByZWZpeCB0byByZW1vdmUuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0cmltVXJpUHJlZml4KHN0ciwgcHJlZml4KSB7XG4gICAgY29uc3QgbG9uZ1ByZWZpeCA9IGAke3ByZWZpeH0vL2A7XG4gICAgaWYgKHN0ci5zdGFydHNXaXRoKGxvbmdQcmVmaXgpKSB7XG4gICAgICAgIC8vIGxvbmdQcmVmaXggaXMgZXhhY3RseSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIHJldHVybiBzdHIuc2xpY2UobG9uZ1ByZWZpeC5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAvLyBlbHNlIHByZWZpeCBpcyBleGFjdGx5IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgcmV0dXJuIHN0ci5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVVyaVByZWZpeCA9IHRyaW1VcmlQcmVmaXg7XG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgdWludDggYXJyYXkgY29udGFpbmluZyB2YWxpZCBVVEYtOCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgLSBUaGUgdWludDggYXJyYXkuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXlVdGY4KHN0cikge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInN0clwiLCBzdHIsIFwicGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyXzEuQnVmZmVyLmZyb20oc3RyLCBcInV0Zi04XCIpKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9VaW50OEFycmF5VXRmOCA9IHN0cmluZ1RvVWludDhBcnJheVV0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgdWludDggYXJyYXkgY29udGFpbmluZyB2YWxpZCB1dGYtOCBieXRlcyB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgdWludDggYXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvU3RyaW5nVXRmOChhcnJheSkge1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShhcnJheSkudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbn1cbmV4cG9ydHMudWludDhBcnJheVRvU3RyaW5nVXRmOCA9IHVpbnQ4QXJyYXlUb1N0cmluZ1V0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgdWludDggYXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIHVpbnQ4IGFycmF5LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIGhleC1lbmNvZGVkIHN0cmluZyBvciBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleFRvVWludDhBcnJheShzdHIpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJzdHJcIiwgc3RyLCBcInBhcmFtZXRlclwiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gc3RyLm1hdGNoKC8uezEsMn0vZyk7XG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvbl8xLnRocm93VmFsaWRhdGlvbkVycm9yKFwic3RyXCIsIHN0ciwgXCJwYXJhbWV0ZXJcIiwgXCJhIGhleC1lbmNvZGVkIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hdGNoZXMubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbn1cbmV4cG9ydHMuaGV4VG9VaW50OEFycmF5ID0gaGV4VG9VaW50OEFycmF5O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIGEgdmFsaWQgaGV4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nLlxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBpbnB1dCBpcyBoZXgtZW5jb2RlZC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHN0cikge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInN0clwiLCBzdHIsIFwicGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiAvXlswLTlBLUZhLWZdKiQvZy50ZXN0KHN0cik7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZUFycmF5IC0gVGhlIGJ5dGUgYXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIGhleCBzdHJpbmcuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ2MDg4MTl8U3RhY2sgT3ZlcmZsb3d9XG4gKi9cbmZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ5dGVBcnJheSkge1xuICAgIGxldCBzID0gXCJcIjtcbiAgICBieXRlQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICBzICs9IChcIjBcIiArIChieXRlICYgMHhmZikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG59XG5leHBvcnRzLnRvSGV4U3RyaW5nID0gdG9IZXhTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdERvbWFpbkZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0RnVsbERvbWFpblVybEZvclBvcnRhbCA9IGV4cG9ydHMubWFrZVVybCA9IGV4cG9ydHMuYWRkVXJsUXVlcnkgPSBleHBvcnRzLmFkZFN1YmRvbWFpbiA9IGV4cG9ydHMuYWRkUGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBvcnRhbFVybCA9IGV4cG9ydHMudXJpU2t5bmV0UHJlZml4ID0gZXhwb3J0cy51cmlIYW5kc2hha2VSZXNvbHZlclByZWZpeCA9IGV4cG9ydHMudXJpSGFuZHNoYWtlUHJlZml4ID0gZXhwb3J0cy5kZWZhdWx0U2t5bmV0UG9ydGFsVXJsID0gdm9pZCAwO1xuY29uc3QgdXJsX3BhcnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybC1wYXJzZVwiKSk7XG5jb25zdCB1cmxfam9pbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ1cmwtam9pblwiKSk7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5leHBvcnRzLmRlZmF1bHRTa3luZXRQb3J0YWxVcmwgPSBcImh0dHBzOi8vc2lhc2t5Lm5ldFwiO1xuZXhwb3J0cy51cmlIYW5kc2hha2VQcmVmaXggPSBcImhuczpcIjtcbmV4cG9ydHMudXJpSGFuZHNoYWtlUmVzb2x2ZXJQcmVmaXggPSBcImhuc3JlczpcIjtcbmV4cG9ydHMudXJpU2t5bmV0UHJlZml4ID0gXCJzaWE6XCI7XG4vLyBUT0RPOiBUaGlzIHdpbGwgYmUgc21hcnRlci4gU2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTmVidWxvdXNMYWJzL3NreW5ldC1kb2NzL2lzc3Vlcy8yMS5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBwb3J0YWwgVVJMLlxuICpcbiAqIEByZXR1cm5zIC0gVGhlIHBvcnRhbCBVUkwuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0YWxVcmwoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIFwiL1wiOyAvLyBkZWZhdWx0IHRvIHBhdGggcm9vdCBvbiBzc3JcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbn1cbmV4cG9ydHMuZGVmYXVsdFBvcnRhbFVybCA9IGRlZmF1bHRQb3J0YWxVcmw7XG4vKipcbiAqIEFkZHMgYSBwYXRoIHRvIHRoZSBnaXZlbiBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBnaXZlbiBwYXRoLlxuICogQHJldHVybnMgLSBUaGUgZmluYWwgVVJMLlxuICovXG5mdW5jdGlvbiBhZGRQYXRoKHVybCwgcGF0aCkge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBwYXRoID0gc3RyaW5nXzEudHJpbUZvcndhcmRTbGFzaChwYXRoKTtcbiAgICBsZXQgc3RyO1xuICAgIGlmICh1cmwgPT09IFwibG9jYWxob3N0XCIpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgbG9jYWxob3N0LlxuICAgICAgICBzdHIgPSBgbG9jYWxob3N0LyR7cGF0aH1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgVVJMIG9iamVjdCBhbmQgc2V0IHRoZSBwYXRobmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICB1cmxPYmoucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICBzdHIgPSB1cmxPYmoudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ18xLnRyaW1TdWZmaXgoc3RyLCBcIi9cIik7XG59XG5leHBvcnRzLmFkZFBhdGggPSBhZGRQYXRoO1xuLyoqXG4gKiBBZGRzIGEgc3ViZG9tYWluIHRvIHRoZSBnaXZlbiBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwuXG4gKiBAcGFyYW0gc3ViZG9tYWluIC0gVGhlIHN1YmRvbWFpbiB0byBhZGQuXG4gKiBAcmV0dXJucyAtIFRoZSBmaW5hbCBVUkwuXG4gKi9cbmZ1bmN0aW9uIGFkZFN1YmRvbWFpbih1cmwsIHN1YmRvbWFpbikge1xuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICB1cmxPYmouaG9zdG5hbWUgPSBgJHtzdWJkb21haW59LiR7dXJsT2JqLmhvc3RuYW1lfWA7XG4gICAgY29uc3Qgc3RyID0gdXJsT2JqLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHN0cmluZ18xLnRyaW1TdWZmaXgoc3RyLCBcIi9cIik7XG59XG5leHBvcnRzLmFkZFN1YmRvbWFpbiA9IGFkZFN1YmRvbWFpbjtcbi8qKlxuICogQWRkcyBhIHF1ZXJ5IHRvIHRoZSBnaXZlbiBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwuXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIC0gVGhlIGZpbmFsIFVSTC5cbiAqL1xuZnVuY3Rpb24gYWRkVXJsUXVlcnkodXJsLCBxdWVyeSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHVybF9wYXJzZV8xLmRlZmF1bHQodXJsLCB0cnVlKTtcbiAgICAvLyBDb21iaW5lIHRoZSBkZXNpcmVkIHF1ZXJ5IHBhcmFtcyB3aXRoIHRoZSBhbHJlYWR5IGV4aXN0aW5nIG9uZXMuXG4gICAgcXVlcnkgPSB7IC4uLnBhcnNlZC5xdWVyeSwgLi4ucXVlcnkgfTtcbiAgICBwYXJzZWQuc2V0KFwicXVlcnlcIiwgcXVlcnkpO1xuICAgIHJldHVybiBwYXJzZWQudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuYWRkVXJsUXVlcnkgPSBhZGRVcmxRdWVyeTtcbi8qKlxuICogUHJvcGVybHkgam9pbnMgcGF0aHMgdG9nZXRoZXIgdG8gY3JlYXRlIGEgVVJMLiBUYWtlcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuICogYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gQXJyYXkgb2YgVVJMIHBhcnRzIHRvIGpvaW4uXG4gKiBAcmV0dXJucyAtIEZpbmFsIFVSTCBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbnB1dCBwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gbWFrZVVybCguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbGlkYXRpb25fMS50aHJvd1ZhbGlkYXRpb25FcnJvcihcImFyZ3NcIiwgYXJncywgXCJwYXJhbWV0ZXJcIiwgXCJub24tZW1wdHlcIik7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHVybF9qb2luXzEuZGVmYXVsdChhY2MsIGN1cikpO1xufVxuZXhwb3J0cy5tYWtlVXJsID0gbWFrZVVybDtcbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBkb21haW4sXG4gKiBlLmcuIChcImh0dHBzOi8vc2lhc2t5Lm5ldFwiLCBcImRhYy5obnMvcGF0aC9maWxlXCIpID0+IFwiaHR0cHM6Ly9kYWMuaG5zLnNpYXNreS5uZXQvcGF0aC9maWxlXCJcbiAqXG4gKiBAcGFyYW0gcG9ydGFsVXJsIC0gVGhlIHBvcnRhbCBVUkwuXG4gKiBAcGFyYW0gZG9tYWluIC0gRG9tYWluLlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBkb21haW4uXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBkb21haW4pIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwb3J0YWxVcmxcIiwgcG9ydGFsVXJsLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJkb21haW5cIiwgZG9tYWluLCBcInBhcmFtZXRlclwiKTtcbiAgICBkb21haW4gPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KGRvbWFpbiwgZXhwb3J0cy51cmlTa3luZXRQcmVmaXgpO1xuICAgIGRvbWFpbiA9IHN0cmluZ18xLnRyaW1Gb3J3YXJkU2xhc2goZG9tYWluKTtcbiAgICAvLyBTcGxpdCBvbiBmaXJzdCAvIHRvIGdldCB0aGUgcGF0aC5cbiAgICBsZXQgcGF0aDtcbiAgICBbZG9tYWluLCBwYXRoXSA9IGRvbWFpbi5zcGxpdCgvXFwvKC4rKS8pO1xuICAgIC8vIEFkZCB0byBzdWJkb21haW4uXG4gICAgbGV0IHVybDtcbiAgICBpZiAoZG9tYWluID09PSBcImxvY2FsaG9zdFwiKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGxvY2FsaG9zdC5cbiAgICAgICAgdXJsID0gXCJsb2NhbGhvc3RcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9IGFkZFN1YmRvbWFpbihwb3J0YWxVcmwsIGRvbWFpbik7XG4gICAgfVxuICAgIC8vIEFkZCBiYWNrIHRoZSBwYXRoIGlmIHRoZXJlIHdhcyBvbmUuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdXJsID0gYWRkUGF0aCh1cmwsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy5nZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsID0gZ2V0RnVsbERvbWFpblVybEZvclBvcnRhbDtcbi8qKlxuICogRXh0cmFjdHMgdGhlIGRvbWFpbiBmcm9tIHRoZSBnaXZlbiBwb3J0YWwgVVJMLFxuICogZS5nLiAoXCJodHRwczovL3NpYXNreS5uZXRcIiwgXCJkYWMuaG5zLnNpYXNreS5uZXQvcGF0aC9maWxlXCIpID0+IFwiZGFjLmhucy9wYXRoL2ZpbGVcIlxuICpcbiAqIEBwYXJhbSBwb3J0YWxVcmwgLSBUaGUgcG9ydGFsIFVSTC5cbiAqIEBwYXJhbSBmdWxsRG9tYWluIC0gRnVsbCBVUkwuXG4gKiBAcmV0dXJucyAtIFRoZSBleHRyYWN0ZWQgZG9tYWluLlxuICovXG5mdW5jdGlvbiBleHRyYWN0RG9tYWluRm9yUG9ydGFsKHBvcnRhbFVybCwgZnVsbERvbWFpbikge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBvcnRhbFVybFwiLCBwb3J0YWxVcmwsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImZ1bGxEb21haW5cIiwgZnVsbERvbWFpbiwgXCJwYXJhbWV0ZXJcIik7XG4gICAgbGV0IHBhdGg7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgdGhlIGRvbWFpbiBmcm9tIHRoZSBmdWxsRG9tYWluLlxuICAgICAgICBjb25zdCBmdWxsRG9tYWluT2JqID0gbmV3IFVSTChmdWxsRG9tYWluKTtcbiAgICAgICAgZnVsbERvbWFpbiA9IGZ1bGxEb21haW5PYmouaG9zdG5hbWU7XG4gICAgICAgIHBhdGggPSBmdWxsRG9tYWluT2JqLnBhdGhuYW1lO1xuICAgICAgICBwYXRoID0gc3RyaW5nXzEudHJpbUZvcndhcmRTbGFzaChwYXRoKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBJZiBmdWxsRG9tYWluIGlzIG5vdCBhIFVSTCwgaWdub3JlIHRoZSBlcnJvciBhbmQgdXNlIGl0IGFzLWlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUcmltIGFueSBzbGFzaGVzIGZyb20gdGhlIGlucHV0IFVSTC5cbiAgICAgICAgZnVsbERvbWFpbiA9IHN0cmluZ18xLnRyaW1Gb3J3YXJkU2xhc2goZnVsbERvbWFpbik7XG4gICAgICAgIC8vIFNwbGl0IG9uIGZpcnN0IC8gdG8gZ2V0IHRoZSBwYXRoLlxuICAgICAgICBbZnVsbERvbWFpbiwgcGF0aF0gPSBmdWxsRG9tYWluLnNwbGl0KC9cXC8oLispLyk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgcG9ydGFsIGRvbWFpbi5cbiAgICBjb25zdCBwb3J0YWxVcmxPYmogPSBuZXcgVVJMKHBvcnRhbFVybCk7XG4gICAgY29uc3QgcG9ydGFsRG9tYWluID0gc3RyaW5nXzEudHJpbUZvcndhcmRTbGFzaChwb3J0YWxVcmxPYmouaG9zdG5hbWUpO1xuICAgIC8vIFJlbW92ZSB0aGUgcG9ydGFsIGRvbWFpbiBmcm9tIHRoZSBkb21haW4uXG4gICAgbGV0IGRvbWFpbiA9IHN0cmluZ18xLnRyaW1TdWZmaXgoZnVsbERvbWFpbiwgcG9ydGFsRG9tYWluLCAxKTtcbiAgICBkb21haW4gPSBzdHJpbmdfMS50cmltU3VmZml4KGRvbWFpbiwgXCIuXCIpO1xuICAgIC8vIEFkZCBiYWNrIHRoZSBwYXRoIGlmIHRoZXJlIGlzIG9uZS5cbiAgICBpZiAocGF0aCAmJiBwYXRoICE9PSBcIlwiKSB7XG4gICAgICAgIHBhdGggPSBzdHJpbmdfMS50cmltRm9yd2FyZFNsYXNoKHBhdGgpO1xuICAgICAgICBkb21haW4gPSBgJHtkb21haW59LyR7cGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gZG9tYWluO1xufVxuZXhwb3J0cy5leHRyYWN0RG9tYWluRm9yUG9ydGFsID0gZXh0cmFjdERvbWFpbkZvclBvcnRhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aHJvd1ZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMudmFsaWRhdGVVaW50OEFycmF5TGVuID0gZXhwb3J0cy52YWxpZGF0ZVVpbnQ4QXJyYXkgPSBleHBvcnRzLnZhbGlkYXRlSGV4U3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZVN0cmluZyA9IGV4cG9ydHMudmFsaWRhdGVOdW1iZXIgPSBleHBvcnRzLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QgPSBleHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy52YWxpZGF0ZUJpZ2ludCA9IHZvaWQgMDtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgYmlnaW50LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgYmlnaW50LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJpZ2ludChuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJiaWdpbnRcIikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBcInR5cGUgJ2JpZ2ludCdcIik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUJpZ2ludCA9IHZhbGlkYXRlQmlnaW50O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWVLaW5kIC0gVGhlIGtpbmQgb2YgdmFsdWUgdGhhdCBpcyBiZWluZyBjaGVja2VkIChlLmcuIFwicGFyYW1ldGVyXCIsIFwicmVzcG9uc2UgZmllbGRcIiwgZXRjLilcbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIG5vdCBhIHZhbGlkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QobmFtZSwgdmFsdWUsIHZhbHVlS2luZCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgXCJ0eXBlICdvYmplY3QnXCIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgXCJub24tbnVsbFwiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYW4gb3B0aW9uYWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHBhcmFtIG1vZGVsIC0gQSBtb2RlbCBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgcG9zc2libGUgZmllbGRzLiAndmFsdWUnIGRvZXMgbm90IG5lZWQgdG8gaGF2ZSBhbGwgZmllbGRzLCBidXQgaXQgbWF5IG5vdCBoYXZlIGFueSBmaWVsZHMgbm90IGNvbnRhaW5lZCBpbiAnbW9kZWwnLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgb3B0aW9uYWwgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIG1vZGVsKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIG9rYXksIHRoZSBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFsaWRhdGVPYmplY3QobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgLy8gQ2hlY2sgaWYgYWxsIGdpdmVuIHByb3BlcnRpZXMgb2YgdmFsdWUgYWxzbyBleGlzdCBpbiB0aGUgbW9kZWwuXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiBtb2RlbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0ICR7dmFsdWVLaW5kfSAnJHtuYW1lfScgY29udGFpbnMgdW5leHBlY3RlZCBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QgPSB2YWxpZGF0ZU9wdGlvbmFsT2JqZWN0O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBcInR5cGUgJ251bWJlcidcIik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZU51bWJlciA9IHZhbGlkYXRlTnVtYmVyO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBcInR5cGUgJ3N0cmluZydcIik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVN0cmluZyA9IHZhbGlkYXRlU3RyaW5nO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgaGV4LWVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhleFN0cmluZyhuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgdmFsaWRhdGVTdHJpbmcobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgaWYgKCFzdHJpbmdfMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgXCJhIGhleC1lbmNvZGVkIHN0cmluZ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlSGV4U3RyaW5nID0gdmFsaWRhdGVIZXhTdHJpbmc7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSB1aW50OGFycmF5LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgdWludDhhcnJheS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVVaW50OEFycmF5KG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwiJ1VpbnQ4QXJyYXknXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVVaW50OEFycmF5ID0gdmFsaWRhdGVVaW50OEFycmF5O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgdWludDhhcnJheSBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHBhcmFtIGxlbiAtIFRoZSBsZW5ndGggdG8gY2hlY2suXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCB1aW50OGFycmF5IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVWludDhBcnJheUxlbihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBsZW4pIHtcbiAgICB2YWxpZGF0ZVVpbnQ4QXJyYXkobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgY29uc3QgYWN0dWFsTGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIGlmIChhY3R1YWxMZW4gIT09IGxlbikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBgJ1VpbnQ4QXJyYXknIG9mIGxlbmd0aCAke2xlbn0sIHdhcyBsZW5ndGggJHthY3R1YWxMZW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVVpbnQ4QXJyYXlMZW4gPSB2YWxpZGF0ZVVpbnQ4QXJyYXlMZW47XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBmb3IgdGhlIGdpdmVuIHZhbHVlXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAcGFyYW0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgYXNwZWN0IG9mIHRoZSB2YWx1ZSB0aGF0IGNvdWxkIG5vdCBiZSB2YWxpZGF0ZWQgKGUuZy4gXCJ0eXBlICdzdHJpbmcnXCIgb3IgXCJub24tbnVsbFwiKS5cbiAqIEB0aHJvd3MgLSBXaWxsIGFsd2F5cyB0aHJvdy5cbiAqL1xuZnVuY3Rpb24gdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dmFsdWVLaW5kfSAnJHtuYW1lfScgdG8gYmUgJHtleHBlY3RlZH0sIHdhcyAnJHt2YWx1ZX0nYCk7XG59XG5leHBvcnRzLnRocm93VmFsaWRhdGlvbkVycm9yID0gdGhyb3dWYWxpZGF0aW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHR5cGVNYXAgW09iamVjdF0gTWFwIG9mIE1JTUUgdHlwZSAtPiBBcnJheVtleHRlbnNpb25zXVxuICogQHBhcmFtIC4uLlxuICovXG5mdW5jdGlvbiBNaW1lKCkge1xuICB0aGlzLl90eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2V4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5kZWZpbmUoYXJndW1lbnRzW2ldKTtcbiAgfVxuXG4gIHRoaXMuZGVmaW5lID0gdGhpcy5kZWZpbmUuYmluZCh0aGlzKTtcbiAgdGhpcy5nZXRUeXBlID0gdGhpcy5nZXRUeXBlLmJpbmQodGhpcyk7XG4gIHRoaXMuZ2V0RXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb24uYmluZCh0aGlzKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgbWltZXR5cGUgLT4gZXh0ZW5zaW9uIG1hcHBpbmdzLiAgRWFjaCBrZXkgaXMgYSBtaW1lLXR5cGUgdGhhdCBtYXBzXG4gKiB0byBhbiBhcnJheSBvZiBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZS4gIFRoZSBmaXJzdCBleHRlbnNpb24gaXNcbiAqIHVzZWQgYXMgdGhlIGRlZmF1bHQgZXh0ZW5zaW9uIGZvciB0aGUgdHlwZS5cbiAqXG4gKiBlLmcuIG1pbWUuZGVmaW5lKHsnYXVkaW8vb2dnJywgWydvZ2EnLCAnb2dnJywgJ3NweCddfSk7XG4gKlxuICogSWYgYSB0eXBlIGRlY2xhcmVzIGFuIGV4dGVuc2lvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCwgYW4gZXJyb3Igd2lsbFxuICogYmUgdGhyb3duLiAgVG8gc3VwcHJlc3MgdGhpcyBlcnJvciBhbmQgZm9yY2UgdGhlIGV4dGVuc2lvbiB0byBiZSBhc3NvY2lhdGVkXG4gKiB3aXRoIHRoZSBuZXcgdHlwZSwgcGFzcyBgZm9yY2VgPXRydWUuICBBbHRlcm5hdGl2ZWx5LCB5b3UgbWF5IHByZWZpeCB0aGVcbiAqIGV4dGVuc2lvbiB3aXRoIFwiKlwiIHRvIG1hcCB0aGUgdHlwZSB0byBleHRlbnNpb24sIHdpdGhvdXQgbWFwcGluZyB0aGVcbiAqIGV4dGVuc2lvbiB0byB0aGUgdHlwZS5cbiAqXG4gKiBlLmcuIG1pbWUuZGVmaW5lKHsnYXVkaW8vd2F2JywgWyd3YXYnXX0sIHsnYXVkaW8veC13YXYnLCBbJyp3YXYnXX0pO1xuICpcbiAqXG4gKiBAcGFyYW0gbWFwIChPYmplY3QpIHR5cGUgZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSBmb3JjZSAoQm9vbGVhbikgaWYgdHJ1ZSwgZm9yY2Ugb3ZlcnJpZGluZyBvZiBleGlzdGluZyBkZWZpbml0aW9uc1xuICovXG5NaW1lLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbih0eXBlTWFwLCBmb3JjZSkge1xuICBmb3IgKGxldCB0eXBlIGluIHR5cGVNYXApIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IHR5cGVNYXBbdHlwZV0ubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgLy8gJyonIHByZWZpeCA9IG5vdCB0aGUgcHJlZmVycmVkIHR5cGUgZm9yIHRoaXMgZXh0ZW5zaW9uLiAgU28gZml4dXAgdGhlXG4gICAgICAvLyBleHRlbnNpb24sIGFuZCBza2lwIGl0LlxuICAgICAgaWYgKGV4dFswXSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvcmNlICYmIChleHQgaW4gdGhpcy5fdHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQXR0ZW1wdCB0byBjaGFuZ2UgbWFwcGluZyBmb3IgXCInICsgZXh0ICtcbiAgICAgICAgICAnXCIgZXh0ZW5zaW9uIGZyb20gXCInICsgdGhpcy5fdHlwZXNbZXh0XSArICdcIiB0byBcIicgKyB0eXBlICtcbiAgICAgICAgICAnXCIuIFBhc3MgYGZvcmNlPXRydWVgIHRvIGFsbG93IHRoaXMsIG90aGVyd2lzZSByZW1vdmUgXCInICsgZXh0ICtcbiAgICAgICAgICAnXCIgZnJvbSB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGZvciBcIicgKyB0eXBlICsgJ1wiLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHlwZXNbZXh0XSA9IHR5cGU7XG4gICAgfVxuXG4gICAgLy8gVXNlIGZpcnN0IGV4dGVuc2lvbiBhcyBkZWZhdWx0XG4gICAgaWYgKGZvcmNlIHx8ICF0aGlzLl9leHRlbnNpb25zW3R5cGVdKSB7XG4gICAgICBjb25zdCBleHQgPSBleHRlbnNpb25zWzBdO1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1t0eXBlXSA9IChleHRbMF0gIT09ICcqJykgPyBleHQgOiBleHQuc3Vic3RyKDEpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMb29rdXAgYSBtaW1lIHR5cGUgYmFzZWQgb24gZXh0ZW5zaW9uXG4gKi9cbk1pbWUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHBhdGggPSBTdHJpbmcocGF0aCk7XG4gIGxldCBsYXN0ID0gcGF0aC5yZXBsYWNlKC9eLipbL1xcXFxdLywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBleHQgPSBsYXN0LnJlcGxhY2UoL14uKlxcLi8sICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGxldCBoYXNQYXRoID0gbGFzdC5sZW5ndGggPCBwYXRoLmxlbmd0aDtcbiAgbGV0IGhhc0RvdCA9IGV4dC5sZW5ndGggPCBsYXN0Lmxlbmd0aCAtIDE7XG5cbiAgcmV0dXJuIChoYXNEb3QgfHwgIWhhc1BhdGgpICYmIHRoaXMuX3R5cGVzW2V4dF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpbGUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCBhIG1pbWUgdHlwZVxuICovXG5NaW1lLnByb3RvdHlwZS5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbih0eXBlKSB7XG4gIHR5cGUgPSAvXlxccyooW147XFxzXSopLy50ZXN0KHR5cGUpICYmIFJlZ0V4cC4kMTtcbiAgcmV0dXJuIHR5cGUgJiYgdGhpcy5fZXh0ZW5zaW9uc1t0eXBlLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmxldCBNaW1lID0gcmVxdWlyZSgnLi9NaW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBNaW1lKHJlcXVpcmUoJy4vdHlwZXMvc3RhbmRhcmQnKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcImFwcGxpY2F0aW9uL2FuZHJldy1pbnNldFwiOltcImV6XCJdLFwiYXBwbGljYXRpb24vYXBwbGl4d2FyZVwiOltcImF3XCJdLFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIjpbXCJhdG9tXCJdLFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIjpbXCJhdG9tY2F0XCJdLFwiYXBwbGljYXRpb24vYXRvbWRlbGV0ZWQreG1sXCI6W1wiYXRvbWRlbGV0ZWRcIl0sXCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiOltcImF0b21zdmNcIl0sXCJhcHBsaWNhdGlvbi9hdHNjLWR3ZCt4bWxcIjpbXCJkd2RcIl0sXCJhcHBsaWNhdGlvbi9hdHNjLWhlbGQreG1sXCI6W1wiaGVsZFwiXSxcImFwcGxpY2F0aW9uL2F0c2MtcnNhdCt4bWxcIjpbXCJyc2F0XCJdLFwiYXBwbGljYXRpb24vYmRvY1wiOltcImJkb2NcIl0sXCJhcHBsaWNhdGlvbi9jYWxlbmRhcit4bWxcIjpbXCJ4Y3NcIl0sXCJhcHBsaWNhdGlvbi9jY3htbCt4bWxcIjpbXCJjY3htbFwiXSxcImFwcGxpY2F0aW9uL2NkZngreG1sXCI6W1wiY2RmeFwiXSxcImFwcGxpY2F0aW9uL2NkbWktY2FwYWJpbGl0eVwiOltcImNkbWlhXCJdLFwiYXBwbGljYXRpb24vY2RtaS1jb250YWluZXJcIjpbXCJjZG1pY1wiXSxcImFwcGxpY2F0aW9uL2NkbWktZG9tYWluXCI6W1wiY2RtaWRcIl0sXCJhcHBsaWNhdGlvbi9jZG1pLW9iamVjdFwiOltcImNkbWlvXCJdLFwiYXBwbGljYXRpb24vY2RtaS1xdWV1ZVwiOltcImNkbWlxXCJdLFwiYXBwbGljYXRpb24vY3Utc2VlbWVcIjpbXCJjdVwiXSxcImFwcGxpY2F0aW9uL2Rhc2greG1sXCI6W1wibXBkXCJdLFwiYXBwbGljYXRpb24vZGF2bW91bnQreG1sXCI6W1wiZGF2bW91bnRcIl0sXCJhcHBsaWNhdGlvbi9kb2Nib29rK3htbFwiOltcImRia1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCI6W1wiZHNzY1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MreG1sXCI6W1wieGRzc2NcIl0sXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6W1wiZWNtYVwiLFwiZXNcIl0sXCJhcHBsaWNhdGlvbi9lbW1hK3htbFwiOltcImVtbWFcIl0sXCJhcHBsaWNhdGlvbi9lbW90aW9ubWwreG1sXCI6W1wiZW1vdGlvbm1sXCJdLFwiYXBwbGljYXRpb24vZXB1Yit6aXBcIjpbXCJlcHViXCJdLFwiYXBwbGljYXRpb24vZXhpXCI6W1wiZXhpXCJdLFwiYXBwbGljYXRpb24vZmR0K3htbFwiOltcImZkdFwiXSxcImFwcGxpY2F0aW9uL2ZvbnQtdGRwZnJcIjpbXCJwZnJcIl0sXCJhcHBsaWNhdGlvbi9nZW8ranNvblwiOltcImdlb2pzb25cIl0sXCJhcHBsaWNhdGlvbi9nbWwreG1sXCI6W1wiZ21sXCJdLFwiYXBwbGljYXRpb24vZ3B4K3htbFwiOltcImdweFwiXSxcImFwcGxpY2F0aW9uL2d4ZlwiOltcImd4ZlwiXSxcImFwcGxpY2F0aW9uL2d6aXBcIjpbXCJnelwiXSxcImFwcGxpY2F0aW9uL2hqc29uXCI6W1wiaGpzb25cIl0sXCJhcHBsaWNhdGlvbi9oeXBlcnN0dWRpb1wiOltcInN0a1wiXSxcImFwcGxpY2F0aW9uL2lua21sK3htbFwiOltcImlua1wiLFwiaW5rbWxcIl0sXCJhcHBsaWNhdGlvbi9pcGZpeFwiOltcImlwZml4XCJdLFwiYXBwbGljYXRpb24vaXRzK3htbFwiOltcIml0c1wiXSxcImFwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZVwiOltcImphclwiLFwid2FyXCIsXCJlYXJcIl0sXCJhcHBsaWNhdGlvbi9qYXZhLXNlcmlhbGl6ZWQtb2JqZWN0XCI6W1wic2VyXCJdLFwiYXBwbGljYXRpb24vamF2YS12bVwiOltcImNsYXNzXCJdLFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOltcImpzXCIsXCJtanNcIl0sXCJhcHBsaWNhdGlvbi9qc29uXCI6W1wianNvblwiLFwibWFwXCJdLFwiYXBwbGljYXRpb24vanNvbjVcIjpbXCJqc29uNVwiXSxcImFwcGxpY2F0aW9uL2pzb25tbCtqc29uXCI6W1wianNvbm1sXCJdLFwiYXBwbGljYXRpb24vbGQranNvblwiOltcImpzb25sZFwiXSxcImFwcGxpY2F0aW9uL2xncit4bWxcIjpbXCJsZ3JcIl0sXCJhcHBsaWNhdGlvbi9sb3N0K3htbFwiOltcImxvc3R4bWxcIl0sXCJhcHBsaWNhdGlvbi9tYWMtYmluaGV4NDBcIjpbXCJocXhcIl0sXCJhcHBsaWNhdGlvbi9tYWMtY29tcGFjdHByb1wiOltcImNwdFwiXSxcImFwcGxpY2F0aW9uL21hZHMreG1sXCI6W1wibWFkc1wiXSxcImFwcGxpY2F0aW9uL21hbmlmZXN0K2pzb25cIjpbXCJ3ZWJtYW5pZmVzdFwiXSxcImFwcGxpY2F0aW9uL21hcmNcIjpbXCJtcmNcIl0sXCJhcHBsaWNhdGlvbi9tYXJjeG1sK3htbFwiOltcIm1yY3hcIl0sXCJhcHBsaWNhdGlvbi9tYXRoZW1hdGljYVwiOltcIm1hXCIsXCJuYlwiLFwibWJcIl0sXCJhcHBsaWNhdGlvbi9tYXRobWwreG1sXCI6W1wibWF0aG1sXCJdLFwiYXBwbGljYXRpb24vbWJveFwiOltcIm1ib3hcIl0sXCJhcHBsaWNhdGlvbi9tZWRpYXNlcnZlcmNvbnRyb2wreG1sXCI6W1wibXNjbWxcIl0sXCJhcHBsaWNhdGlvbi9tZXRhbGluayt4bWxcIjpbXCJtZXRhbGlua1wiXSxcImFwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWxcIjpbXCJtZXRhNFwiXSxcImFwcGxpY2F0aW9uL21ldHMreG1sXCI6W1wibWV0c1wiXSxcImFwcGxpY2F0aW9uL21tdC1hZWkreG1sXCI6W1wibWFlaVwiXSxcImFwcGxpY2F0aW9uL21tdC11c2QreG1sXCI6W1wibXVzZFwiXSxcImFwcGxpY2F0aW9uL21vZHMreG1sXCI6W1wibW9kc1wiXSxcImFwcGxpY2F0aW9uL21wMjFcIjpbXCJtMjFcIixcIm1wMjFcIl0sXCJhcHBsaWNhdGlvbi9tcDRcIjpbXCJtcDRzXCIsXCJtNHBcIl0sXCJhcHBsaWNhdGlvbi9tcmItY29uc3VtZXIreG1sXCI6W1wiKnhkZlwiXSxcImFwcGxpY2F0aW9uL21yYi1wdWJsaXNoK3htbFwiOltcIip4ZGZcIl0sXCJhcHBsaWNhdGlvbi9tc3dvcmRcIjpbXCJkb2NcIixcImRvdFwiXSxcImFwcGxpY2F0aW9uL214ZlwiOltcIm14ZlwiXSxcImFwcGxpY2F0aW9uL24tcXVhZHNcIjpbXCJucVwiXSxcImFwcGxpY2F0aW9uL24tdHJpcGxlc1wiOltcIm50XCJdLFwiYXBwbGljYXRpb24vbm9kZVwiOltcImNqc1wiXSxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiOltcImJpblwiLFwiZG1zXCIsXCJscmZcIixcIm1hclwiLFwic29cIixcImRpc3RcIixcImRpc3R6XCIsXCJwa2dcIixcImJwa1wiLFwiZHVtcFwiLFwiZWxjXCIsXCJkZXBsb3lcIixcImV4ZVwiLFwiZGxsXCIsXCJkZWJcIixcImRtZ1wiLFwiaXNvXCIsXCJpbWdcIixcIm1zaVwiLFwibXNwXCIsXCJtc21cIixcImJ1ZmZlclwiXSxcImFwcGxpY2F0aW9uL29kYVwiOltcIm9kYVwiXSxcImFwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sXCI6W1wib3BmXCJdLFwiYXBwbGljYXRpb24vb2dnXCI6W1wib2d4XCJdLFwiYXBwbGljYXRpb24vb21kb2MreG1sXCI6W1wib21kb2NcIl0sXCJhcHBsaWNhdGlvbi9vbmVub3RlXCI6W1wib25ldG9jXCIsXCJvbmV0b2MyXCIsXCJvbmV0bXBcIixcIm9uZXBrZ1wiXSxcImFwcGxpY2F0aW9uL294cHNcIjpbXCJveHBzXCJdLFwiYXBwbGljYXRpb24vcDJwLW92ZXJsYXkreG1sXCI6W1wicmVsb1wiXSxcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIjpbXCIqeGVyXCJdLFwiYXBwbGljYXRpb24vcGRmXCI6W1wicGRmXCJdLFwiYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZFwiOltcInBncFwiXSxcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIjpbXCJhc2NcIixcInNpZ1wiXSxcImFwcGxpY2F0aW9uL3BpY3MtcnVsZXNcIjpbXCJwcmZcIl0sXCJhcHBsaWNhdGlvbi9wa2NzMTBcIjpbXCJwMTBcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1taW1lXCI6W1wicDdtXCIsXCJwN2NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIjpbXCJwN3NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzOFwiOltcInA4XCJdLFwiYXBwbGljYXRpb24vcGtpeC1hdHRyLWNlcnRcIjpbXCJhY1wiXSxcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiOltcImNlclwiXSxcImFwcGxpY2F0aW9uL3BraXgtY3JsXCI6W1wiY3JsXCJdLFwiYXBwbGljYXRpb24vcGtpeC1wa2lwYXRoXCI6W1wicGtpcGF0aFwiXSxcImFwcGxpY2F0aW9uL3BraXhjbXBcIjpbXCJwa2lcIl0sXCJhcHBsaWNhdGlvbi9wbHMreG1sXCI6W1wicGxzXCJdLFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiOltcImFpXCIsXCJlcHNcIixcInBzXCJdLFwiYXBwbGljYXRpb24vcHJvdmVuYW5jZSt4bWxcIjpbXCJwcm92eFwiXSxcImFwcGxpY2F0aW9uL3Bza2MreG1sXCI6W1wicHNrY3htbFwiXSxcImFwcGxpY2F0aW9uL3JhbWwreWFtbFwiOltcInJhbWxcIl0sXCJhcHBsaWNhdGlvbi9yZGYreG1sXCI6W1wicmRmXCIsXCJvd2xcIl0sXCJhcHBsaWNhdGlvbi9yZWdpbmZvK3htbFwiOltcInJpZlwiXSxcImFwcGxpY2F0aW9uL3JlbGF4LW5nLWNvbXBhY3Qtc3ludGF4XCI6W1wicm5jXCJdLFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sXCI6W1wicmxcIl0sXCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cy1kaWZmK3htbFwiOltcInJsZFwiXSxcImFwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWxcIjpbXCJyc1wiXSxcImFwcGxpY2F0aW9uL3JvdXRlLWFwZCt4bWxcIjpbXCJyYXBkXCJdLFwiYXBwbGljYXRpb24vcm91dGUtcy10c2lkK3htbFwiOltcInNsc1wiXSxcImFwcGxpY2F0aW9uL3JvdXRlLXVzZCt4bWxcIjpbXCJydXNkXCJdLFwiYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnNcIjpbXCJnYnJcIl0sXCJhcHBsaWNhdGlvbi9ycGtpLW1hbmlmZXN0XCI6W1wibWZ0XCJdLFwiYXBwbGljYXRpb24vcnBraS1yb2FcIjpbXCJyb2FcIl0sXCJhcHBsaWNhdGlvbi9yc2QreG1sXCI6W1wicnNkXCJdLFwiYXBwbGljYXRpb24vcnNzK3htbFwiOltcInJzc1wiXSxcImFwcGxpY2F0aW9uL3J0ZlwiOltcInJ0ZlwiXSxcImFwcGxpY2F0aW9uL3NibWwreG1sXCI6W1wic2JtbFwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdFwiOltcInNjcVwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2VcIjpbXCJzY3NcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjpbXCJzcHFcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlXCI6W1wic3BwXCJdLFwiYXBwbGljYXRpb24vc2RwXCI6W1wic2RwXCJdLFwiYXBwbGljYXRpb24vc2VubWwreG1sXCI6W1wic2VubWx4XCJdLFwiYXBwbGljYXRpb24vc2Vuc21sK3htbFwiOltcInNlbnNtbHhcIl0sXCJhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uXCI6W1wic2V0cGF5XCJdLFwiYXBwbGljYXRpb24vc2V0LXJlZ2lzdHJhdGlvbi1pbml0aWF0aW9uXCI6W1wic2V0cmVnXCJdLFwiYXBwbGljYXRpb24vc2hmK3htbFwiOltcInNoZlwiXSxcImFwcGxpY2F0aW9uL3NpZXZlXCI6W1wic2l2XCIsXCJzaWV2ZVwiXSxcImFwcGxpY2F0aW9uL3NtaWwreG1sXCI6W1wic21pXCIsXCJzbWlsXCJdLFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCI6W1wicnFcIl0sXCJhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWxcIjpbXCJzcnhcIl0sXCJhcHBsaWNhdGlvbi9zcmdzXCI6W1wiZ3JhbVwiXSxcImFwcGxpY2F0aW9uL3NyZ3MreG1sXCI6W1wiZ3J4bWxcIl0sXCJhcHBsaWNhdGlvbi9zcnUreG1sXCI6W1wic3J1XCJdLFwiYXBwbGljYXRpb24vc3NkbCt4bWxcIjpbXCJzc2RsXCJdLFwiYXBwbGljYXRpb24vc3NtbCt4bWxcIjpbXCJzc21sXCJdLFwiYXBwbGljYXRpb24vc3dpZCt4bWxcIjpbXCJzd2lkdGFnXCJdLFwiYXBwbGljYXRpb24vdGVpK3htbFwiOltcInRlaVwiLFwidGVpY29ycHVzXCJdLFwiYXBwbGljYXRpb24vdGhyYXVkK3htbFwiOltcInRmaVwiXSxcImFwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGFcIjpbXCJ0c2RcIl0sXCJhcHBsaWNhdGlvbi90b21sXCI6W1widG9tbFwiXSxcImFwcGxpY2F0aW9uL3R0bWwreG1sXCI6W1widHRtbFwiXSxcImFwcGxpY2F0aW9uL3VianNvblwiOltcInVialwiXSxcImFwcGxpY2F0aW9uL3VyYy1yZXNzaGVldCt4bWxcIjpbXCJyc2hlZXRcIl0sXCJhcHBsaWNhdGlvbi91cmMtdGFyZ2V0ZGVzYyt4bWxcIjpbXCJ0ZFwiXSxcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiOltcInZ4bWxcIl0sXCJhcHBsaWNhdGlvbi93YXNtXCI6W1wid2FzbVwiXSxcImFwcGxpY2F0aW9uL3dpZGdldFwiOltcIndndFwiXSxcImFwcGxpY2F0aW9uL3dpbmhscFwiOltcImhscFwiXSxcImFwcGxpY2F0aW9uL3dzZGwreG1sXCI6W1wid3NkbFwiXSxcImFwcGxpY2F0aW9uL3dzcG9saWN5K3htbFwiOltcIndzcG9saWN5XCJdLFwiYXBwbGljYXRpb24veGFtbCt4bWxcIjpbXCJ4YW1sXCJdLFwiYXBwbGljYXRpb24veGNhcC1hdHQreG1sXCI6W1wieGF2XCJdLFwiYXBwbGljYXRpb24veGNhcC1jYXBzK3htbFwiOltcInhjYVwiXSxcImFwcGxpY2F0aW9uL3hjYXAtZGlmZit4bWxcIjpbXCJ4ZGZcIl0sXCJhcHBsaWNhdGlvbi94Y2FwLWVsK3htbFwiOltcInhlbFwiXSxcImFwcGxpY2F0aW9uL3hjYXAtZXJyb3IreG1sXCI6W1wieGVyXCJdLFwiYXBwbGljYXRpb24veGNhcC1ucyt4bWxcIjpbXCJ4bnNcIl0sXCJhcHBsaWNhdGlvbi94ZW5jK3htbFwiOltcInhlbmNcIl0sXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIjpbXCJ4aHRtbFwiLFwieGh0XCJdLFwiYXBwbGljYXRpb24veGxpZmYreG1sXCI6W1wieGxmXCJdLFwiYXBwbGljYXRpb24veG1sXCI6W1wieG1sXCIsXCJ4c2xcIixcInhzZFwiLFwicm5nXCJdLFwiYXBwbGljYXRpb24veG1sLWR0ZFwiOltcImR0ZFwiXSxcImFwcGxpY2F0aW9uL3hvcCt4bWxcIjpbXCJ4b3BcIl0sXCJhcHBsaWNhdGlvbi94cHJvYyt4bWxcIjpbXCJ4cGxcIl0sXCJhcHBsaWNhdGlvbi94c2x0K3htbFwiOltcIip4c2xcIixcInhzbHRcIl0sXCJhcHBsaWNhdGlvbi94c3BmK3htbFwiOltcInhzcGZcIl0sXCJhcHBsaWNhdGlvbi94dit4bWxcIjpbXCJteG1sXCIsXCJ4aHZtbFwiLFwieHZtbFwiLFwieHZtXCJdLFwiYXBwbGljYXRpb24veWFuZ1wiOltcInlhbmdcIl0sXCJhcHBsaWNhdGlvbi95aW4reG1sXCI6W1wieWluXCJdLFwiYXBwbGljYXRpb24vemlwXCI6W1wiemlwXCJdLFwiYXVkaW8vM2dwcFwiOltcIiozZ3BwXCJdLFwiYXVkaW8vYWRwY21cIjpbXCJhZHBcIl0sXCJhdWRpby9hbXJcIjpbXCJhbXJcIl0sXCJhdWRpby9iYXNpY1wiOltcImF1XCIsXCJzbmRcIl0sXCJhdWRpby9taWRpXCI6W1wibWlkXCIsXCJtaWRpXCIsXCJrYXJcIixcInJtaVwiXSxcImF1ZGlvL21vYmlsZS14bWZcIjpbXCJteG1mXCJdLFwiYXVkaW8vbXAzXCI6W1wiKm1wM1wiXSxcImF1ZGlvL21wNFwiOltcIm00YVwiLFwibXA0YVwiXSxcImF1ZGlvL21wZWdcIjpbXCJtcGdhXCIsXCJtcDJcIixcIm1wMmFcIixcIm1wM1wiLFwibTJhXCIsXCJtM2FcIl0sXCJhdWRpby9vZ2dcIjpbXCJvZ2FcIixcIm9nZ1wiLFwic3B4XCIsXCJvcHVzXCJdLFwiYXVkaW8vczNtXCI6W1wiczNtXCJdLFwiYXVkaW8vc2lsa1wiOltcInNpbFwiXSxcImF1ZGlvL3dhdlwiOltcIndhdlwiXSxcImF1ZGlvL3dhdmVcIjpbXCIqd2F2XCJdLFwiYXVkaW8vd2VibVwiOltcIndlYmFcIl0sXCJhdWRpby94bVwiOltcInhtXCJdLFwiZm9udC9jb2xsZWN0aW9uXCI6W1widHRjXCJdLFwiZm9udC9vdGZcIjpbXCJvdGZcIl0sXCJmb250L3R0ZlwiOltcInR0ZlwiXSxcImZvbnQvd29mZlwiOltcIndvZmZcIl0sXCJmb250L3dvZmYyXCI6W1wid29mZjJcIl0sXCJpbWFnZS9hY2VzXCI6W1wiZXhyXCJdLFwiaW1hZ2UvYXBuZ1wiOltcImFwbmdcIl0sXCJpbWFnZS9hdmlmXCI6W1wiYXZpZlwiXSxcImltYWdlL2JtcFwiOltcImJtcFwiXSxcImltYWdlL2NnbVwiOltcImNnbVwiXSxcImltYWdlL2RpY29tLXJsZVwiOltcImRybGVcIl0sXCJpbWFnZS9lbWZcIjpbXCJlbWZcIl0sXCJpbWFnZS9maXRzXCI6W1wiZml0c1wiXSxcImltYWdlL2czZmF4XCI6W1wiZzNcIl0sXCJpbWFnZS9naWZcIjpbXCJnaWZcIl0sXCJpbWFnZS9oZWljXCI6W1wiaGVpY1wiXSxcImltYWdlL2hlaWMtc2VxdWVuY2VcIjpbXCJoZWljc1wiXSxcImltYWdlL2hlaWZcIjpbXCJoZWlmXCJdLFwiaW1hZ2UvaGVpZi1zZXF1ZW5jZVwiOltcImhlaWZzXCJdLFwiaW1hZ2UvaGVqMmtcIjpbXCJoZWoyXCJdLFwiaW1hZ2UvaHNqMlwiOltcImhzajJcIl0sXCJpbWFnZS9pZWZcIjpbXCJpZWZcIl0sXCJpbWFnZS9qbHNcIjpbXCJqbHNcIl0sXCJpbWFnZS9qcDJcIjpbXCJqcDJcIixcImpwZzJcIl0sXCJpbWFnZS9qcGVnXCI6W1wianBlZ1wiLFwianBnXCIsXCJqcGVcIl0sXCJpbWFnZS9qcGhcIjpbXCJqcGhcIl0sXCJpbWFnZS9qcGhjXCI6W1wiamhjXCJdLFwiaW1hZ2UvanBtXCI6W1wianBtXCJdLFwiaW1hZ2UvanB4XCI6W1wianB4XCIsXCJqcGZcIl0sXCJpbWFnZS9qeHJcIjpbXCJqeHJcIl0sXCJpbWFnZS9qeHJhXCI6W1wianhyYVwiXSxcImltYWdlL2p4cnNcIjpbXCJqeHJzXCJdLFwiaW1hZ2UvanhzXCI6W1wianhzXCJdLFwiaW1hZ2UvanhzY1wiOltcImp4c2NcIl0sXCJpbWFnZS9qeHNpXCI6W1wianhzaVwiXSxcImltYWdlL2p4c3NcIjpbXCJqeHNzXCJdLFwiaW1hZ2Uva3R4XCI6W1wia3R4XCJdLFwiaW1hZ2Uva3R4MlwiOltcImt0eDJcIl0sXCJpbWFnZS9wbmdcIjpbXCJwbmdcIl0sXCJpbWFnZS9zZ2lcIjpbXCJzZ2lcIl0sXCJpbWFnZS9zdmcreG1sXCI6W1wic3ZnXCIsXCJzdmd6XCJdLFwiaW1hZ2UvdDM4XCI6W1widDM4XCJdLFwiaW1hZ2UvdGlmZlwiOltcInRpZlwiLFwidGlmZlwiXSxcImltYWdlL3RpZmYtZnhcIjpbXCJ0ZnhcIl0sXCJpbWFnZS93ZWJwXCI6W1wid2VicFwiXSxcImltYWdlL3dtZlwiOltcIndtZlwiXSxcIm1lc3NhZ2UvZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6W1wiZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCJdLFwibWVzc2FnZS9nbG9iYWxcIjpbXCJ1OG1zZ1wiXSxcIm1lc3NhZ2UvZ2xvYmFsLWRlbGl2ZXJ5LXN0YXR1c1wiOltcInU4ZHNuXCJdLFwibWVzc2FnZS9nbG9iYWwtZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6W1widThtZG5cIl0sXCJtZXNzYWdlL2dsb2JhbC1oZWFkZXJzXCI6W1widThoZHJcIl0sXCJtZXNzYWdlL3JmYzgyMlwiOltcImVtbFwiLFwibWltZVwiXSxcIm1vZGVsLzNtZlwiOltcIjNtZlwiXSxcIm1vZGVsL2dsdGYranNvblwiOltcImdsdGZcIl0sXCJtb2RlbC9nbHRmLWJpbmFyeVwiOltcImdsYlwiXSxcIm1vZGVsL2lnZXNcIjpbXCJpZ3NcIixcImlnZXNcIl0sXCJtb2RlbC9tZXNoXCI6W1wibXNoXCIsXCJtZXNoXCIsXCJzaWxvXCJdLFwibW9kZWwvbXRsXCI6W1wibXRsXCJdLFwibW9kZWwvb2JqXCI6W1wib2JqXCJdLFwibW9kZWwvc3RsXCI6W1wic3RsXCJdLFwibW9kZWwvdnJtbFwiOltcIndybFwiLFwidnJtbFwiXSxcIm1vZGVsL3gzZCtiaW5hcnlcIjpbXCIqeDNkYlwiLFwieDNkYnpcIl0sXCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIjpbXCJ4M2RiXCJdLFwibW9kZWwveDNkK3ZybWxcIjpbXCIqeDNkdlwiLFwieDNkdnpcIl0sXCJtb2RlbC94M2QreG1sXCI6W1wieDNkXCIsXCJ4M2R6XCJdLFwibW9kZWwveDNkLXZybWxcIjpbXCJ4M2R2XCJdLFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiOltcImFwcGNhY2hlXCIsXCJtYW5pZmVzdFwiXSxcInRleHQvY2FsZW5kYXJcIjpbXCJpY3NcIixcImlmYlwiXSxcInRleHQvY29mZmVlc2NyaXB0XCI6W1wiY29mZmVlXCIsXCJsaXRjb2ZmZWVcIl0sXCJ0ZXh0L2Nzc1wiOltcImNzc1wiXSxcInRleHQvY3N2XCI6W1wiY3N2XCJdLFwidGV4dC9odG1sXCI6W1wiaHRtbFwiLFwiaHRtXCIsXCJzaHRtbFwiXSxcInRleHQvamFkZVwiOltcImphZGVcIl0sXCJ0ZXh0L2pzeFwiOltcImpzeFwiXSxcInRleHQvbGVzc1wiOltcImxlc3NcIl0sXCJ0ZXh0L21hcmtkb3duXCI6W1wibWFya2Rvd25cIixcIm1kXCJdLFwidGV4dC9tYXRobWxcIjpbXCJtbWxcIl0sXCJ0ZXh0L21keFwiOltcIm1keFwiXSxcInRleHQvbjNcIjpbXCJuM1wiXSxcInRleHQvcGxhaW5cIjpbXCJ0eHRcIixcInRleHRcIixcImNvbmZcIixcImRlZlwiLFwibGlzdFwiLFwibG9nXCIsXCJpblwiLFwiaW5pXCJdLFwidGV4dC9yaWNodGV4dFwiOltcInJ0eFwiXSxcInRleHQvcnRmXCI6W1wiKnJ0ZlwiXSxcInRleHQvc2dtbFwiOltcInNnbWxcIixcInNnbVwiXSxcInRleHQvc2hleFwiOltcInNoZXhcIl0sXCJ0ZXh0L3NsaW1cIjpbXCJzbGltXCIsXCJzbG1cIl0sXCJ0ZXh0L3NwZHhcIjpbXCJzcGR4XCJdLFwidGV4dC9zdHlsdXNcIjpbXCJzdHlsdXNcIixcInN0eWxcIl0sXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCI6W1widHN2XCJdLFwidGV4dC90cm9mZlwiOltcInRcIixcInRyXCIsXCJyb2ZmXCIsXCJtYW5cIixcIm1lXCIsXCJtc1wiXSxcInRleHQvdHVydGxlXCI6W1widHRsXCJdLFwidGV4dC91cmktbGlzdFwiOltcInVyaVwiLFwidXJpc1wiLFwidXJsc1wiXSxcInRleHQvdmNhcmRcIjpbXCJ2Y2FyZFwiXSxcInRleHQvdnR0XCI6W1widnR0XCJdLFwidGV4dC94bWxcIjpbXCIqeG1sXCJdLFwidGV4dC95YW1sXCI6W1wieWFtbFwiLFwieW1sXCJdLFwidmlkZW8vM2dwcFwiOltcIjNncFwiLFwiM2dwcFwiXSxcInZpZGVvLzNncHAyXCI6W1wiM2cyXCJdLFwidmlkZW8vaDI2MVwiOltcImgyNjFcIl0sXCJ2aWRlby9oMjYzXCI6W1wiaDI2M1wiXSxcInZpZGVvL2gyNjRcIjpbXCJoMjY0XCJdLFwidmlkZW8vaXNvLnNlZ21lbnRcIjpbXCJtNHNcIl0sXCJ2aWRlby9qcGVnXCI6W1wianBndlwiXSxcInZpZGVvL2pwbVwiOltcIipqcG1cIixcImpwZ21cIl0sXCJ2aWRlby9tajJcIjpbXCJtajJcIixcIm1qcDJcIl0sXCJ2aWRlby9tcDJ0XCI6W1widHNcIl0sXCJ2aWRlby9tcDRcIjpbXCJtcDRcIixcIm1wNHZcIixcIm1wZzRcIl0sXCJ2aWRlby9tcGVnXCI6W1wibXBlZ1wiLFwibXBnXCIsXCJtcGVcIixcIm0xdlwiLFwibTJ2XCJdLFwidmlkZW8vb2dnXCI6W1wib2d2XCJdLFwidmlkZW8vcXVpY2t0aW1lXCI6W1wicXRcIixcIm1vdlwiXSxcInZpZGVvL3dlYm1cIjpbXCJ3ZWJtXCJdfTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgd2hpdGVzcGFjZSA9ICdbXFxcXHgwOVxcXFx4MEFcXFxceDBCXFxcXHgwQ1xcXFx4MERcXFxceDIwXFxcXHhBMFxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1RkVGRl0nXG4gICwgbGVmdCA9IG5ldyBSZWdFeHAoJ14nKyB3aGl0ZXNwYWNlICsnKycpO1xuXG4vKipcbiAqIFRyaW0gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShsZWZ0LCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHRIYW5kc2hha2VBdHRlbXB0c0ludGVydmFsID0gZXhwb3J0cy5kZWZhdWx0SGFuZHNoYWtlTWF4QXR0ZW1wdHMgPSBleHBvcnRzLm1vbml0b3JXaW5kb3dFcnJvciA9IGV4cG9ydHMuZXJyb3JXaW5kb3dDbG9zZWQgPSBleHBvcnRzLmRpc3BhdGNoZWRFcnJvckV2ZW50ID0gZXhwb3J0cy50cmltU3VmZml4ID0gZXhwb3J0cy5lbnN1cmVVcmwgPSBleHBvcnRzLmNyZWF0ZUlmcmFtZSA9IGV4cG9ydHMuY3JlYXRlRnVsbFNjcmVlbklmcmFtZSA9IGV4cG9ydHMuUGVybVdyaXRlID0gZXhwb3J0cy5QZXJtUmVhZCA9IGV4cG9ydHMuUGVybUxlZ2FjeVNreUlEID0gZXhwb3J0cy5QZXJtSGlkZGVuID0gZXhwb3J0cy5QZXJtRGlzY292ZXJhYmxlID0gZXhwb3J0cy5wZXJtVHlwZVRvU3RyaW5nID0gZXhwb3J0cy5wZXJtQ2F0ZWdvcnlUb1N0cmluZyA9IGV4cG9ydHMuUGVybVR5cGUgPSBleHBvcnRzLlBlcm1DYXRlZ29yeSA9IGV4cG9ydHMuUGVybWlzc2lvbiA9IGV4cG9ydHMuc2FuaXRpemVQYXRoID0gZXhwb3J0cy5nZXRQYXJlbnRQYXRoID0gZXhwb3J0cy5nZXRQYXRoRG9tYWluID0gdm9pZCAwO1xudmFyIHBhdGhzXzEgPSByZXF1aXJlKFwiLi9wYXRoc1wiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwYXRoc18xLCBcImdldFBhdGhEb21haW5cIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGF0aHNfMSwgXCJnZXRQYXJlbnRQYXRoXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBhdGhzXzEsIFwic2FuaXRpemVQYXRoXCIpO1xudmFyIHBlcm1pc3Npb25zXzEgPSByZXF1aXJlKFwiLi9wZXJtaXNzaW9uc1wiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcIlBlcm1pc3Npb25cIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtQ2F0ZWdvcnlcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtVHlwZVwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcInBlcm1DYXRlZ29yeVRvU3RyaW5nXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwicGVybVR5cGVUb1N0cmluZ1wiKTtcbi8vIENvbnN0YW50c1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwiUGVybURpc2NvdmVyYWJsZVwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcIlBlcm1IaWRkZW5cIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtTGVnYWN5U2t5SURcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtUmVhZFwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcIlBlcm1Xcml0ZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgdXRpbHNfMSwgXCJjcmVhdGVGdWxsU2NyZWVuSWZyYW1lXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHV0aWxzXzEsIFwiY3JlYXRlSWZyYW1lXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHV0aWxzXzEsIFwiZW5zdXJlVXJsXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHV0aWxzXzEsIFwidHJpbVN1ZmZpeFwiKTtcbnZhciB3aW5kb3dfbGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuL3dpbmRvdy1saXN0ZW5lclwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB3aW5kb3dfbGlzdGVuZXJfMSwgXCJkaXNwYXRjaGVkRXJyb3JFdmVudFwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB3aW5kb3dfbGlzdGVuZXJfMSwgXCJlcnJvcldpbmRvd0Nsb3NlZFwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB3aW5kb3dfbGlzdGVuZXJfMSwgXCJtb25pdG9yV2luZG93RXJyb3JcIik7XG5leHBvcnRzLmRlZmF1bHRIYW5kc2hha2VNYXhBdHRlbXB0cyA9IDE1MDtcbmV4cG9ydHMuZGVmYXVsdEhhbmRzaGFrZUF0dGVtcHRzSW50ZXJ2YWwgPSAxMDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhbml0aXplUGF0aCA9IGV4cG9ydHMuZ2V0UGFyZW50UGF0aCA9IGV4cG9ydHMuZ2V0UGF0aERvbWFpbiA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEdldHMgdGhlIHJvb3QgcGF0aCBkb21haW4gZm9yIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGdpdmVuIHBhdGguXG4gKiBAcmV0dXJucyAtIFRoZSBwYXRoIGRvbWFpbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aERvbWFpbihwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpWzBdO1xufVxuZXhwb3J0cy5nZXRQYXRoRG9tYWluID0gZ2V0UGF0aERvbWFpbjtcbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHBhdGggZm9yIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGdpdmVuIHBhdGguXG4gKiBAcmV0dXJucyAtIFRoZSBwYXJlbnQgcGF0aCwgb3IgbnVsbCBpZiBubyBwYXJlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudFBhdGgocGF0aCkge1xuICAgIHBhdGggPSBzYW5pdGl6ZVBhdGgocGF0aCk7XG4gICAgdmFyIHBhdGhBcnJheSA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXRoQXJyYXkubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhdGhBcnJheS5wb3AoKTtcbiAgICBwYXRoID0gcGF0aEFycmF5LmpvaW4oXCIvXCIpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5nZXRQYXJlbnRQYXRoID0gZ2V0UGFyZW50UGF0aDtcbi8qKlxuICogU2FuaXRpemVzIHRoZSBwYXRoIGJ5IHJlbW92aW5nIHRyYWlsaW5nIHNsYXNoZXMgYW5kIHJlbW92aW5nIHJlcGVhdGluZyBhZGphY2VudCBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGdpdmVuIHBhdGhcbiAqIEByZXR1cm5zIC0gVGhlIHNhbml0aXplZCBwYXRoLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZVBhdGgocGF0aCkge1xuICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzLlxuICAgIHBhdGggPSB1dGlsc18xLnRyaW1TdWZmaXgocGF0aCwgXCIvXCIpO1xuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgYWRqYWNlbnQgc2xhc2hlcy5cbiAgICB2YXIgcGF0aEFycmF5ID0gQXJyYXkuZnJvbShwYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGggLSAxOykge1xuICAgICAgICBpZiAocGF0aEFycmF5W2ldID09PSBcIi9cIiAmJiBwYXRoQXJyYXlbaSArIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgcGF0aEFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGF0aEFycmF5LmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLnNhbml0aXplUGF0aCA9IHNhbml0aXplUGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucGVybVR5cGVUb1N0cmluZyA9IGV4cG9ydHMucGVybUNhdGVnb3J5VG9TdHJpbmcgPSBleHBvcnRzLlBlcm1UeXBlID0gZXhwb3J0cy5QZXJtV3JpdGUgPSBleHBvcnRzLlBlcm1SZWFkID0gZXhwb3J0cy5QZXJtQ2F0ZWdvcnkgPSBleHBvcnRzLlBlcm1MZWdhY3lTa3lJRCA9IGV4cG9ydHMuUGVybUhpZGRlbiA9IGV4cG9ydHMuUGVybURpc2NvdmVyYWJsZSA9IGV4cG9ydHMuUGVybWlzc2lvbiA9IHZvaWQgMDtcbnZhciBQZXJtaXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcm1pc3Npb24ocmVxdWVzdG9yLCBwYXRoLCBjYXRlZ29yeSwgcGVybVR5cGUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0b3IgPSByZXF1ZXN0b3I7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICAgICAgdGhpcy5wZXJtVHlwZSA9IHBlcm1UeXBlO1xuICAgICAgICBpZiAodHlwZW9mIGNhdGVnb3J5ICE9PSBcIm51bWJlclwiIHx8ICEoY2F0ZWdvcnkgaW4gUGVybUNhdGVnb3J5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCAnY2F0ZWdvcnknIGVudW0gdmFsdWUgXCIgKyBjYXRlZ29yeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtVHlwZSAhPT0gXCJudW1iZXJcIiB8fCAhKHBlcm1UeXBlIGluIFBlcm1UeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCAncGVybVR5cGUnIGVudW0gdmFsdWUgXCIgKyBwZXJtVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFBlcm1pc3Npb247XG59KCkpO1xuZXhwb3J0cy5QZXJtaXNzaW9uID0gUGVybWlzc2lvbjtcbi8vIERlZmluZSBjYXRlZ29yeSBjb25zdGFudHMgZm9yIG5vbi1UUyB1c2Vycy5cbmV4cG9ydHMuUGVybURpc2NvdmVyYWJsZSA9IDE7XG5leHBvcnRzLlBlcm1IaWRkZW4gPSAyO1xuZXhwb3J0cy5QZXJtTGVnYWN5U2t5SUQgPSAzO1xuLyoqXG4gKiBEZWZpbmVzIHdoYXQgdHlwZSBvZiBmaWxlIGlzIGJlaW5nIHJlcXVlc3RlZC4gRGlzY292ZXJhYmxlIGZpbGVzIGFyZSB2aXNpYmxlXG4gKiB0byB0aGUgZW50aXJlIHdvcmxkLCBoaWRkZW4gZmlsZXMgYXJlIG9ubHkgdmlzaWJsZSB0byB0aGUgdXNlciAodW5sZXNzXG4gKiBzaGFyZWQpLCBhbmQgTGVnYWN5U2t5SUQgZmlsZXMgYXJlIHN1cHBvcnRlZCBmaWxlcyBmcm9tIHRoZSBsZWdhY3kgU2t5SURcbiAqIGxvZ2luIHN5c3RlbS5cbiAqL1xudmFyIFBlcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoUGVybUNhdGVnb3J5KSB7XG4gICAgUGVybUNhdGVnb3J5W1Blcm1DYXRlZ29yeVtcIkRpc2NvdmVyYWJsZVwiXSA9IGV4cG9ydHMuUGVybURpc2NvdmVyYWJsZV0gPSBcIkRpc2NvdmVyYWJsZVwiO1xuICAgIFBlcm1DYXRlZ29yeVtQZXJtQ2F0ZWdvcnlbXCJIaWRkZW5cIl0gPSBleHBvcnRzLlBlcm1IaWRkZW5dID0gXCJIaWRkZW5cIjtcbiAgICBQZXJtQ2F0ZWdvcnlbUGVybUNhdGVnb3J5W1wiTGVnYWN5U2t5SURcIl0gPSBleHBvcnRzLlBlcm1MZWdhY3lTa3lJRF0gPSBcIkxlZ2FjeVNreUlEXCI7XG59KShQZXJtQ2F0ZWdvcnkgPSBleHBvcnRzLlBlcm1DYXRlZ29yeSB8fCAoZXhwb3J0cy5QZXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLy8gRGVmaW5lIHR5cGUgY29uc3RhbnRzIGZvciBub24tVFMgdXNlcnMuXG5leHBvcnRzLlBlcm1SZWFkID0gNDtcbmV4cG9ydHMuUGVybVdyaXRlID0gNTtcbnZhciBQZXJtVHlwZTtcbihmdW5jdGlvbiAoUGVybVR5cGUpIHtcbiAgICBQZXJtVHlwZVtQZXJtVHlwZVtcIlJlYWRcIl0gPSBleHBvcnRzLlBlcm1SZWFkXSA9IFwiUmVhZFwiO1xuICAgIFBlcm1UeXBlW1Blcm1UeXBlW1wiV3JpdGVcIl0gPSBleHBvcnRzLlBlcm1Xcml0ZV0gPSBcIldyaXRlXCI7XG59KShQZXJtVHlwZSA9IGV4cG9ydHMuUGVybVR5cGUgfHwgKGV4cG9ydHMuUGVybVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gcGVybWlzc2lvbiBjYXRlZ29yeSB0byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gY2F0ZWdvcnkgLSBUaGUgZ2l2ZW4gY2F0ZWdvcnkuXG4gKiBAcmV0dXJucyAtIFRoZSBzdHJpbmcuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgY2F0ZWdvcnkgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBwZXJtQ2F0ZWdvcnlUb1N0cmluZyhjYXRlZ29yeSkge1xuICAgIGlmIChjYXRlZ29yeSA9PT0gUGVybUNhdGVnb3J5LkRpc2NvdmVyYWJsZSkge1xuICAgICAgICByZXR1cm4gXCJEaXNjb3ZlcmFibGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2F0ZWdvcnkgPT09IFBlcm1DYXRlZ29yeS5IaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiSGlkZGVuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhdGVnb3J5ID09PSBQZXJtQ2F0ZWdvcnkuTGVnYWN5U2t5SUQpIHtcbiAgICAgICAgcmV0dXJuIFwiTGVnYWN5U2t5SURcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVybWlzc2lvbiBjYXRlZ29yeSBcIiArIGNhdGVnb3J5KTtcbiAgICB9XG59XG5leHBvcnRzLnBlcm1DYXRlZ29yeVRvU3RyaW5nID0gcGVybUNhdGVnb3J5VG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBwZXJtaXNzaW9uIHR5cGUgdG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHBlcm1UeXBlIC0gVGhlIGdpdmVuIHR5cGUuXG4gKiBAcmV0dXJucyAtIFRoZSBzdHJpbmcuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgdHlwZSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHBlcm1UeXBlVG9TdHJpbmcocGVybVR5cGUpIHtcbiAgICBpZiAocGVybVR5cGUgPT09IFBlcm1UeXBlLlJlYWQpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVhZFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwZXJtVHlwZSA9PT0gUGVybVR5cGUuV3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiV3JpdGVcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVybWlzc2lvbiB0eXBlIFwiICsgcGVybVR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMucGVybVR5cGVUb1N0cmluZyA9IHBlcm1UeXBlVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJtaXNzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnRyaW1TdWZmaXggPSBleHBvcnRzLmVuc3VyZVVybCA9IGV4cG9ydHMuY3JlYXRlRnVsbFNjcmVlbklmcmFtZSA9IGV4cG9ydHMuY3JlYXRlSWZyYW1lID0gdm9pZCAwO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGludmlzaWJsZSBpZnJhbWUgd2l0aCB0aGUgZ2l2ZW4gc3JjIGFuZCBhZGRzIGl0IHRvIHRoZSBwYWdlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoc3JjVXJsLCBuYW1lKSB7XG4gICAgc3JjVXJsID0gZW5zdXJlVXJsKHNyY1VybCk7XG4gICAgdmFyIGNoaWxkRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGNoaWxkRnJhbWUuc3JjID0gc3JjVXJsO1xuICAgIGNoaWxkRnJhbWUubmFtZSA9IG5hbWU7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgLy8gU2V0IHNhbmRib3ggcGVybWlzc2lvbnMuXG4gICAgLy8gVE9ETzogRW5hYmxlIHNhbmRib3hpbmc/XG4gICAgLy8gY2hpbGRGcmFtZS5zYW5kYm94LmFkZChcImFsbG93LXNhbWUtb3JpZ2luXCIpO1xuICAgIC8vIGNoaWxkRnJhbWUuc2FuZGJveC5hZGQoXCJhbGxvdy1zY3JpcHRzXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hpbGRGcmFtZSk7XG4gICAgcmV0dXJuIGNoaWxkRnJhbWU7XG59XG5leHBvcnRzLmNyZWF0ZUlmcmFtZSA9IGNyZWF0ZUlmcmFtZTtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bGwtc2NyZWVuIGlmcmFtZSB3aXRoIHRoZSBnaXZlbiBzcmMgYW5kIGFkZHMgaXQgdG8gdGhlIHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bGxTY3JlZW5JZnJhbWUoc3JjVXJsLCBuYW1lKSB7XG4gICAgc3JjVXJsID0gZW5zdXJlVXJsKHNyY1VybCk7XG4gICAgdmFyIGNoaWxkRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGNoaWxkRnJhbWUuc3JjID0gc3JjVXJsO1xuICAgIGNoaWxkRnJhbWUubmFtZSA9IG5hbWU7XG4gICAgLy8gU2V0IHByb3BlcnRpZXMgdG8gbWFrZSB0aGUgaWZyYW1lIGZ1bGwtc2NyZWVuLlxuICAgIGNoaWxkRnJhbWUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLmJvcmRlciA9IFwibm9uZVwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUubWFyZ2luID0gXCIwXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS56SW5kZXggPSBcIjk5OTk5OVwiO1xuICAgIC8vIFNldCBzYW5kYm94IHBlcm1pc3Npb25zLlxuICAgIC8vIFRPRE86IEVuYWJsZSBzYW5kYm94aW5nP1xuICAgIC8vIGNoaWxkRnJhbWUuc2FuZGJveC5hZGQoXCJhbGxvdy1zYW1lLW9yaWdpblwiKTtcbiAgICAvLyBjaGlsZEZyYW1lLnNhbmRib3guYWRkKFwiYWxsb3ctc2NyaXB0c1wiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNoaWxkRnJhbWUpO1xuICAgIHJldHVybiBjaGlsZEZyYW1lO1xufVxuZXhwb3J0cy5jcmVhdGVGdWxsU2NyZWVuSWZyYW1lID0gY3JlYXRlRnVsbFNjcmVlbklmcmFtZTtcbmZ1bmN0aW9uIGVuc3VyZVVybCh1cmwpIHtcbiAgICByZXR1cm4gZW5zdXJlUHJlZml4KHVybCwgXCJodHRwczovL1wiKTtcbn1cbmV4cG9ydHMuZW5zdXJlVXJsID0gZW5zdXJlVXJsO1xuLyoqXG4gKiBSZW1vdmVzIGEgc3VmZml4IGZyb20gdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gc3VmZml4IC0gVGhlIHN1ZmZpeCB0byByZW1vdmUuXG4gKiBAcGFyYW0gW2xpbWl0XSAtIE1heGltdW0gYW1vdW50IG9mIHRpbWVzIHRvIHRyaW0uIE5vIGxpbWl0IGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0cmltU3VmZml4KHN0ciwgc3VmZml4LCBsaW1pdCkge1xuICAgIHdoaWxlIChzdHIuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICBsaW1pdCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnRyaW1TdWZmaXggPSB0cmltU3VmZml4O1xuZnVuY3Rpb24gZW5zdXJlUHJlZml4KHMsIHByZWZpeCkge1xuICAgIGlmICghcy5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgcyA9IFwiXCIgKyBwcmVmaXggKyBzO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubW9uaXRvcldpbmRvd0Vycm9yID0gZXhwb3J0cy5Qcm9taXNlQ29udHJvbGxlciA9IGV4cG9ydHMuZGlzcGF0Y2hlZEVycm9yRXZlbnQgPSBleHBvcnRzLmVycm9yV2luZG93Q2xvc2VkID0gdm9pZCAwO1xuZXhwb3J0cy5lcnJvcldpbmRvd0Nsb3NlZCA9IFwid2luZG93LWNsb3NlZFwiO1xuZXhwb3J0cy5kaXNwYXRjaGVkRXJyb3JFdmVudCA9IFwiY2F0Y2hFcnJvclwiO1xudmFyIFByb21pc2VDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb21pc2VDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBQcm9taXNlQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRW1wdHkgdW50aWwgaW1wbGVtZW50ZWQgaW4gbW9uaXRvcldpbmRvd0Vycm9yLlxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2VDb250cm9sbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvbWlzZUNvbnRyb2xsZXIgPSBQcm9taXNlQ29udHJvbGxlcjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yIGZyb20gdGhlIHdpbmRvdyBvbiBhbiBpbnRlcnZhbC5cbiAqL1xuZnVuY3Rpb24gbW9uaXRvcldpbmRvd0Vycm9yKCkge1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IFByb21pc2VDb250cm9sbGVyKCk7XG4gICAgdmFyIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV4cG9ydHMuZGlzcGF0Y2hlZEVycm9yRXZlbnQsIGhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBlLmRldGFpbDtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvZXNuJ3QgcmVjb2duaXplIHNpZ25hbCBvcHRpb24uXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV4cG9ydHMuZGlzcGF0Y2hlZEVycm9yRXZlbnQsIGhhbmRsZUV2ZW50LCB7XG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xlYW51cCBmdW5jdGlvbi5cbiAgICAgICAgY29udHJvbGxlci5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQWJvcnQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2U6IHByb21pc2UsIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIgfTtcbn1cbmV4cG9ydHMubW9uaXRvcldpbmRvd0Vycm9yID0gbW9uaXRvcldpbmRvd0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93LWxpc3RlbmVyLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9EYXRhVmlldyAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgZGF0YWAgdG8gYmUgYW4gQXJyYXlCdWZmZXIsIEJ1ZmZlciwgSW50OEFycmF5LCBVaW50OEFycmF5IG9yIFVpbnQ4Q2xhbXBlZEFycmF5Jylcbn1cbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIlxyXG5pbXBvcnQgeyBTa3luZXRDbGllbnQsIE15U2t5LCBKc29uRGF0YSB9IGZyb20gXCJza3luZXQtanNcIjtcclxuaW1wb3J0IHsgQ2hpbGRIYW5kc2hha2UsIENvbm5lY3Rpb24sIFdpbmRvd01lc3NlbmdlciB9IGZyb20gXCJwb3N0LW1lXCI7XHJcbmltcG9ydCB7IElDb250ZW50SW5mbywgc2thcHBBY3Rpb25UeXBlLElTa2FwcERBQywgSVB1Ymxpc2hlZEFwcCwgSUluZGV4LCBJUGFnZSwgSUNvbnRlbnRQZXJzaXN0ZW5jZSwgSU5ld0NvbnRlbnRQZXJzaXN0ZW5jZSwgRW50cnlUeXBlLCBJREFDUmVzcG9uc2UsIElEaWN0aW9uYXJ5LCBJRmlsZVBhdGhzLCBJQXBwQ29tbWVudHMsIElBcHBJbmZvLCBJQXBwU3RhdHMsIElEZXBsb3llZEFwcCB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG4vLyBEQUMgY29uc3RzXHJcbmNvbnN0IERBVEFfRE9NQUlOID0gXCJza2FwcHMuaG5zXCI7XHJcblxyXG4vL2NvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XHJcbmNvbnN0IERFQlVHX0VOQUJMRUQgPSAgdHJ1ZTtcclxuY29uc3QgREVWX0VOQUJMRUQgPSB0cnVlO1xyXG5cclxuLy8gcGFnZSBjb25zdHNcclxuY29uc3QgRU5UUllfTUFYX1NJWkUgPSAxIDw8IDEyOyAvLyA0a2liXHJcbmNvbnN0IFBBR0VfUkVGID0gJ1tOVU1dJztcclxuXHJcbi8vIGluZGV4IGNvbnN0c1xyXG5jb25zdCBJTkRFWF9ERUZBVUxUX1BBR0VfU0laRSA9IDEwMDA7XHJcbmNvbnN0IElOREVYX1ZFUlNJT04gPSAxO1xyXG5cclxuLy8gQ29udGVudFJlY29yZERBQyBpcyBhIERBQyB0aGF0IGFsbG93cyByZWNvcmRpbmcgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCBwaWVjZXNcclxuLy8gb2YgY29udGVudC4gVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBpbnRlcmFjdGlvbnMgd2hpY2ggYXJlOlxyXG4vLyAtIGNvbnRlbnQgY3JlYXRpb25cclxuLy8gLSBjb250ZW50IGludGVyYWN0aW9uIChjYW4gYmUgYW55dGhpbmcpXHJcbi8vXHJcbi8vIFRoZSBEQUMgd2lsbCBzdG9yZSB0aGVzZSBpbnRlcmFjdGlvbnMgYWNyb3NzIGEgZmFub3V0IGRhdGEgc3RydWN0dXJlIHRoYXRcclxuLy8gY29uc2lzdHMgb2YgYW4gaW5kZXggZmlsZSB0aGF0IHBvaW50cyB0byBtdWx0aXBsZSBwYWdlIGZpbGVzLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTa2FwcERBQyBpbXBsZW1lbnRzIElTa2FwcERBQyB7XHJcbiAgcHJvdGVjdGVkIGNvbm5lY3Rpb246IFByb21pc2U8Q29ubmVjdGlvbj47XHJcblxyXG4gIHByaXZhdGUgY2xpZW50OiBTa3luZXRDbGllbnRcclxuICBwcml2YXRlIG15U2t5OiBNeVNreTtcclxuICBwcml2YXRlIHBhdGhzOiBJRmlsZVBhdGhzO1xyXG4gIHByaXZhdGUgc2thcHA6IHN0cmluZztcclxuICBwcml2YXRlIHNrYXBwRGljdCA6IGFueT17fTtcclxuICBwdWJsaWMgY29uc3RydWN0b3IoXHJcbiAgKSB7XHJcbiAgICAvLyBjcmVhdGUgY2xpZW50XHJcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTa3luZXRDbGllbnQoKTtcclxuXHJcbiAgICAvLyBkZWZpbmUgQVBJXHJcbiAgICBjb25zdCBtZXRob2RzID0ge1xyXG4gICAgICBpbml0OiB0aGlzLmluaXQuYmluZCh0aGlzKSxcclxuICAgICAgb25Vc2VyTG9naW46IHRoaXMub25Vc2VyTG9naW4uYmluZCh0aGlzKSxcclxuICAgICAgc2thcHBBY3Rpb246IHRoaXMuc2thcHBBY3Rpb24uYmluZCh0aGlzKSxcclxuICAgICAgZ2V0UHVibGlzaGVkQXBwczogdGhpcy5nZXRQdWJsaXNoZWRBcHBzLmJpbmQodGhpcyksXHJcbiAgICAgIGdldFNrYXBwc0luZm86IHRoaXMuZ2V0U2thcHBzSW5mby5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXRTa2FwcFN0YXRzOiB0aGlzLmdldFNrYXBwU3RhdHMuYmluZCh0aGlzKSxcclxuICAgICAgZ2V0U2thcHBDb21tZW50czogdGhpcy5nZXRTa2FwcENvbW1lbnRzLmJpbmQodGhpcyksXHJcbiAgICAgIGdldERlcGxveWVkQXBwczogdGhpcy5nZXREZXBsb3llZEFwcHMuYmluZCh0aGlzKSxcclxuICAgICAgZ2V0UHVibGlzaGVkQXBwc0NvdW50OiB0aGlzLmdldFB1Ymxpc2hlZEFwcHNDb3VudC5iaW5kKHRoaXMpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNyZWF0ZSBjb25uZWN0aW9uXHJcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBDaGlsZEhhbmRzaGFrZShcclxuICAgICAgbmV3IFdpbmRvd01lc3Nlbmdlcih7XHJcbiAgICAgICAgbG9jYWxXaW5kb3c6IHdpbmRvdyxcclxuICAgICAgICByZW1vdGVXaW5kb3c6IHdpbmRvdy5wYXJlbnQsXHJcbiAgICAgICAgcmVtb3RlT3JpZ2luOiBcIipcIixcclxuICAgICAgfSksXHJcbiAgICAgIG1ldGhvZHMsXHJcbiAgICApO1xyXG4gIH1cclxuICBwdWJsaWMgYXN5bmMgc2thcHBBY3Rpb24oYWN0aW9uOiBza2FwcEFjdGlvblR5cGUsIGFwcElkOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPiB7XHJcbiAgICBsZXQgcmVzdWx0OklEQUNSZXNwb25zZSA9IHtcclxuICAgICAgc3VibWl0dGVkOmZhbHNlLFxyXG4gICAgICBcclxuICAgIH07XHJcbiAgICB0cnl7XHJcbiAgICBzd2l0Y2goYWN0aW9uKXtcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5ERVBMT1k6XHJcbiAgICAgICAgY2FzZSBza2FwcEFjdGlvblR5cGUuUkVERVBMT1k6XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldERlcGxveWVkQXBwSW5mbyhhcHBJZCxkYXRhKVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEZXBsb3llZEluZGV4KGFwcElkKTtcclxuICAgICAgICAgIHJlc3VsdC5zdWJtaXR0ZWQ9dHJ1ZVxyXG4gICAgICAgICAgYnJlYWs7IFxyXG4gICAgICAgIGNhc2Ugc2thcHBBY3Rpb25UeXBlLlBVQkxJU0g6XHJcbiAgICAgICAgICBsZXQgYXBwc3RhdHM6SUFwcFN0YXRzPXtcclxuICAgICAgICAgICAgaWQ6YXBwSWQsXHJcbiAgICAgICAgICAgIHZlcnNpb246JzEnLFxyXG4gICAgICAgICAgICBwcmV2U2t5bGluazonJyxcclxuICAgICAgICAgICAgdHM6IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpLFxyXG4gICAgICAgICAgICBjb250ZW50IDoge1xyXG4gICAgICAgICAgICAgIGZhdm9yaXRlIDogMCxcclxuICAgICAgICAgICAgICB2aWV3ZWQ6IDAsIC8vIGNvdW50ZXIgaW5jcmVtZW50cyBldmVyeXRpbWUgY2FyZCBpcyBjbGlja2VkIHRvIHZpZXcgZGV0YWlsc1xyXG4gICAgICAgICAgICAgIGxpa2VkIDogMCxcclxuICAgICAgICAgICAgICBhY2Nlc3NlZCA6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRQdWJsaXNoZWRBcHBTdGF0cyhhcHBJZCxhcHBzdGF0cylcclxuICAgICAgICAgIGxldCBhcHBjb21tZW50czpJQXBwQ29tbWVudHM9e1xyXG4gICAgICAgICAgICBpZDphcHBJZCxcclxuICAgICAgICAgICAgdmVyc2lvbjonMScsXHJcbiAgICAgICAgICAgIHByZXZTa3lsaW5rOicnLFxyXG4gICAgICAgICAgICB0czogKG5ldyBEYXRlKCkpLnRvVVRDU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6e1xyXG4gICAgICAgICAgICAgIGNvbW1lbnRzOltdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0UHVibGlzaGVkQXBwQ29tbWVudHMoYXBwSWQsYXBwY29tbWVudHMpXHJcbiAgICAgICAgY2FzZSBza2FwcEFjdGlvblR5cGUuUkVQVUJMSVNIOlxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRQdWJsaXNoZWRBcHBJbmZvKGFwcElkLGRhdGEpXHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVB1Ymxpc2VkSW5kZXgoYXBwSWQpO1xyXG4gICAgICAgICAgcmVzdWx0LnN1Ym1pdHRlZD10cnVlXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5MSUtFRDpcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5VTkxJS0VEOlxyXG4gICAgICAgICAgaWYoYXdhaXQgdGhpcy5jaGVja1B1Ymxpc2hlZEFwcChhcHBJZCkpe1xyXG4gICAgICAgICAgbGV0IGxpa2U6SUFwcFN0YXRzID0gYXdhaXQgdGhpcy5nZXRQdWJsaXNoZWRBcHBTdGF0cyhhcHBJZCk7XHJcbiAgICAgICAgICBsaWtlLnRzPSAobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAgIGxpa2UuY29udGVudC5saWtlZD1hY3Rpb249PXNrYXBwQWN0aW9uVHlwZS5MSUtFRD8xOjA7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldFB1Ymxpc2hlZEFwcFN0YXRzKGFwcElkLGxpa2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7ICAgICAgIFxyXG4gICAgICAgIGNhc2Ugc2thcHBBY3Rpb25UeXBlLkZBVk9SSVRFOlxyXG4gICAgICAgIGNhc2Ugc2thcHBBY3Rpb25UeXBlLlVORkFWT1JJVEU6XHJcbiAgICAgICAgICBpZihhd2FpdCB0aGlzLmNoZWNrUHVibGlzaGVkQXBwKGFwcElkKSl7XHJcbiAgICAgICAgICBsZXQgZmF2OklBcHBTdGF0cyA9IGF3YWl0IHRoaXMuZ2V0UHVibGlzaGVkQXBwU3RhdHMoYXBwSWQpO1xyXG4gICAgICAgICAgZmF2LnRzPSAobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAgIGZhdi5jb250ZW50LmZhdm9yaXRlPWFjdGlvbj09c2thcHBBY3Rpb25UeXBlLkZBVk9SSVRFPzE6MDtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0UHVibGlzaGVkQXBwU3RhdHMoYXBwSWQsZmF2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrOyBcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5WSUVXRUQ6XHJcbiAgICAgICAgICBpZihhd2FpdCB0aGlzLmNoZWNrUHVibGlzaGVkQXBwKGFwcElkKSl7XHJcbiAgICAgICAgICBsZXQgdmlldzpJQXBwU3RhdHMgPSBhd2FpdCB0aGlzLmdldFB1Ymxpc2hlZEFwcFN0YXRzKGFwcElkKTtcclxuICAgICAgICAgIHZpZXcudHM9IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgICAgdmlldy5jb250ZW50LnZpZXdlZCs9MTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0UHVibGlzaGVkQXBwU3RhdHMoYXBwSWQsdmlldyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5BQ0NFU1NFRDpcclxuICAgICAgICAgIGlmKGF3YWl0IHRoaXMuY2hlY2tQdWJsaXNoZWRBcHAoYXBwSWQpKXtcclxuICAgICAgICAgIGxldCBhY2Nlc3M6SUFwcFN0YXRzID0gYXdhaXQgdGhpcy5nZXRQdWJsaXNoZWRBcHBTdGF0cyhhcHBJZCk7XHJcbiAgICAgICAgICBhY2Nlc3MudHM9IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgICAgYWNjZXNzLmNvbnRlbnQuYWNjZXNzZWQrPTE7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldFB1Ymxpc2hlZEFwcFN0YXRzKGFwcElkLGFjY2Vzcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5BRERfQ09NTUVOVDpcclxuICAgICAgICAgIGlmKCBhd2FpdCB0aGlzLmNoZWNrUHVibGlzaGVkQXBwKGFwcElkKSl7XHJcbiAgICAgICAgICBsZXQgY29tbWVudDpJQXBwQ29tbWVudHMgPSBhd2FpdCB0aGlzLmdldFB1Ymxpc2hlZEFwcENvbW1lbnRzKGFwcElkKTtcclxuICAgICAgICAgIGNvbW1lbnQudHM9IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgICAgY29tbWVudC5jb250ZW50LmNvbW1lbnRzLnB1c2goe3RpbWVzdGFtcDoobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKSwgY29tbWVudDpkYXRhLmNvbW1lbnR9KVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRQdWJsaXNoZWRBcHBDb21tZW50cyhhcHBJZCxjb21tZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrOyAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhpcy5sb2coJ05vIHN1Y2ggSW1wbGVtZW50YXRpb24nKTtcclxuICAgIH1cclxuICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgcmVzdWx0LmVycm9yPWVycm9yO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjaGVja1B1Ymxpc2hlZEFwcChhcHBJZDpzdHJpbmcpe1xyXG4gICAgbGV0IGluZGV4RGF0YTphbnkgPXt9O1xyXG4gICAgdHJ5e1xyXG4gICAgICBpbmRleERhdGE9YXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5QVUJMSVNIRURfSU5ERVhfUEFUSCk7XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICB0aHJvdyBFcnJvcignTk8gSW5kZXggcHJlc2VudCcpXHJcbiAgICB9XHJcbiAgICBpZihpbmRleERhdGEucHVibGlzaGVkLmluY2x1ZGVzKGFwcElkKSl7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVQdWJsaXNlZEluZGV4KGFwcElkOnN0cmluZyl7XHJcbiAgICBsZXQgaW5kZXhEYXRhOmFueSA9e307XHJcbiAgICB0cnl7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9JTkRFWF9QQVRIKTtcclxuICAgIH1jYXRjaChlcnJvcil7XHJcbiAgICAgIGluZGV4RGF0YVsncHVibGlzaGVkJ109W11cclxuICAgIH1cclxuICAgIGlmKGluZGV4RGF0YT09bnVsbCB8fCBpbmRleERhdGE9PXVuZGVmaW5lZCB8fGluZGV4RGF0YS5wdWJsaXNoZWQ9PW51bGwgfHxpbmRleERhdGEucHVibGlzaGVkPT11bmRlZmluZWQpXHJcbiAgICB7aW5kZXhEYXRhPXt9XHJcbiAgICBpbmRleERhdGFbJ3B1Ymxpc2hlZCddPVtdfVxyXG4gICAgaWYoIWluZGV4RGF0YS5wdWJsaXNoZWQuaW5jbHVkZXMoYXBwSWQpKXtcclxuICAgICAgaW5kZXhEYXRhLnB1Ymxpc2hlZC5wdXNoKGFwcElkKTtcclxuICAgICAgdGhpcy5teVNreS5zZXRKU09OKHRoaXMucGF0aHMuUFVCTElTSEVEX0lOREVYX1BBVEgsaW5kZXhEYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVEZXBsb3llZEluZGV4KGFwcElkOnN0cmluZyl7XHJcbiAgICBsZXQgaW5kZXhEYXRhOmFueSA9e307XHJcbiAgICB0cnl7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLkRFUExPWUVEX0lOREVYX1BBVEgpO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgaW5kZXhEYXRhWydkZXBsb3llZCddPVtdXHJcbiAgICB9XHJcbiAgICBpZihpbmRleERhdGE9PW51bGwgfHwgaW5kZXhEYXRhPT11bmRlZmluZWQgfHxpbmRleERhdGEuZGVwbG95ZWQ9PW51bGwgfHxpbmRleERhdGEuZGVwbG95ZWQ9PXVuZGVmaW5lZClcclxuICAgIHtpbmRleERhdGE9e31cclxuICAgIGluZGV4RGF0YVsnZGVwbG95ZWQnXT1bXX1cclxuICAgIGlmKCFpbmRleERhdGEuZGVwbG95ZWQuaW5jbHVkZXMoYXBwSWQpKXtcclxuICAgICAgaW5kZXhEYXRhLmRlcGxveWVkLnB1c2goYXBwSWQpO1xyXG4gICAgICB0aGlzLm15U2t5LnNldEpTT04odGhpcy5wYXRocy5ERVBMT1lFRF9JTkRFWF9QQVRILGluZGV4RGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGV4dHJhY3QgdGhlIHNrYXBwbmFtZSBhbmQgdXNlIGl0IHRvIHNldCB0aGUgZmlsZXBhdGhzXHJcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gbmV3IFVSTChkb2N1bWVudC5yZWZlcnJlcikuaG9zdG5hbWVcclxuICAgICAgY29uc3Qgc2thcHAgPSBhd2FpdCB0aGlzLmNsaWVudC5leHRyYWN0RG9tYWluKGhvc3RuYW1lKVxyXG4gICAgICB0aGlzLmxvZyhcImxvYWRlZCBmcm9tIHNrYXBwXCIsIHNrYXBwKVxyXG4gICAgICB0aGlzLnNrYXBwID0gc2thcHA7XHJcblxyXG4gICAgICB0aGlzLnBhdGhzID0ge1xyXG4gICAgICAgIFNLQVBQU19ESUNUX1BBVEg6IGAke0RBVEFfRE9NQUlOfS9za2FwcC1kaWN0Lmpzb25gLC8ve3NrYXBwX25hbWU6dHJ1ZS9mYWxzZX1cclxuICAgICAgICBQVUJMSVNIRURfSU5ERVhfUEFUSDogYCR7REFUQV9ET01BSU59LyR7c2thcHB9L3B1Ymxpc2hlZC9pbmRleC5qc29uYCxcclxuICAgICAgICAvLy9KU09OIERhdGE6IFthcHBJZDEsIEFwcElkMi4uLi5dXHJcbiAgICAgICAgLy9QQVRIX0V4YW1wbGU6IC9za3lhcHBzLmhucy9za2FwcC5obnMvcHVibGlzaGVkL2luZGV4Lmpzb24sIC9za3lhcHBzLmhucy9hbm90aGVyQXBwU3RvcmUuaG5zL3B1Ymxpc2hlZC9pbmRleC5qc29uLi5ldGNcclxuICAgICAgICBQVUJMSVNIRURfQVBQX0lORk9fUEFUSDpgJHtEQVRBX0RPTUFJTn0vJHtza2FwcH0vcHVibGlzaGVkL2AsXHJcbiAgICAgICAgUFVCTElTSEVEX0FQUF9DT01NRU5UX1BBVEg6IGAke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQvYCwvL2FwcC1jb21tZW50cy5qc29uXHJcbiAgICAgICAgUFVCTElTSEVEX0FQUF9TVEFUU19QQVRIOiBgJHtEQVRBX0RPTUFJTn0vJHtza2FwcH0vcHVibGlzaGVkL2AsLy9hcHAtc3RhdHMuanNvblxyXG4gICAgICAgIERFUExPWUVEX0lOREVYX1BBVEg6IGAke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9kZXBsb3llZC9pbmRleC5qc29uYCxcclxuICAgICAgICAvL0pTT04gRGF0YTogW2FwcElkMSwgQXBwSWQyLi4uLl1cclxuICAgICAgICBERVBMT1lFRF9BUFBfSU5GT19QQVRIOiBgJHtEQVRBX0RPTUFJTn0vJHtza2FwcH0vZGVwbG95ZWQvYCxcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbG9hZCBteXNreVxyXG4gICAgICBjb25zdCBvcHRzID0geyBkZXY6IERFVl9FTkFCTEVEIH1cclxuICAgICAgdGhpcy5teVNreSA9IGF3YWl0IHRoaXMuY2xpZW50LmxvYWRNeVNreShEQVRBX0RPTUFJTiwgb3B0cylcclxuXHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2coJ0ZhaWxlZCB0byBsb2FkIE15U2t5LCBlcnI6ICcsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICB0cnl7XHJcbiAgICAgLy90aGlzLnNrYXBwRGljdD0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5TS0FQUFNfRElDVF9QQVRIKVxyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgdGhpcy5sb2coJ0ZhaWxlZCB0byBsb2FkIHNrYXBwRGljdCwgZXJyOiAnLCBlcnJvcilcclxuICAgICAgdGhpcy5za2FwcERpY3RbdGhpcy5za2FwcF09dHJ1ZTtcclxuICAgICAgLy90aGlzLm15U2t5LnNldEpTT04odGhpcy5wYXRocy5TS0FQUFNfRElDVF9QQVRILHRoaXMuc2thcHBEaWN0KTtcclxuICAgICAgdGhpcy5sb2coJ3VwZGF0ZWQgY3VycmVudCBza2FwcCB0byBza2FwcCBkaWN0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0UHVibGlzaGVkQXBwcyhhcHBJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgbGV0IGluZGV4RGF0YTphbnkgPXt9O1xyXG4gICAgbGV0IHJlc3VsdHM6YW55W10gPSBbXTtcclxuICAgIGlmKGFwcElkcyA9PW51bGwgfHwgYXBwSWRzLmxlbmd0aD09MCApe1xyXG4gICAgIHRyeSB7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9JTkRFWF9QQVRIKTtcclxuICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOTyBQVUJMSVNIRUQgQVBQXCIpO1xyXG4gICAgIH0gXHJcbiAgICAgYXBwSWRzID0gaW5kZXhEYXRhLnB1Ymxpc2hlZDtcclxuICAgIH1cclxuICAgIGZvcihsZXQgYXBwaWQgb2YgYXBwSWRzKXtcclxuICAgICAgbGV0IGFwcERhdGEgOmFueTtcclxuICAgICAgdHJ5e1xyXG4gICAgICAgIGFwcERhdGE9IGF3YWl0IHRoaXMuZ2V0UHVibGlzaGVkQXBwSW5mbyhhcHBpZCk7XHJcbiAgICAgIHJlc3VsdHMucHVzaChhcHBEYXRhKTtcclxuICAgICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICB0aGlzLmxvZygnbWlzc2luZyBqc29uIGZvciBhcHBpZCA6JyxhcHBpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGdldFB1Ymxpc2hlZEFwcHNDb3VudChhcHBJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGxldCBpbmRleERhdGE6YW55ID17fTtcclxuICAgIC8vbGV0IHJlc3VsdHM6YW55W10gPSBbXTtcclxuICAgIGlmKGFwcElkcyA9PW51bGwgfHwgYXBwSWRzLmxlbmd0aD09MCApe1xyXG4gICAgIHRyeSB7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9JTkRFWF9QQVRIKTtcclxuICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOTyBQVUJMSVNIRUQgQVBQXCIpO1xyXG4gICAgIH0gXHJcbiAgICAgYXBwSWRzID0gaW5kZXhEYXRhLnB1Ymxpc2hlZDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGFwcElkcy5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0U2thcHBzSW5mbyhhcHBJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgbGV0IGluZGV4RGF0YTphbnkgPXt9O1xyXG4gICAgbGV0IHJlc3VsdHM6YW55W10gPSBbXTtcclxuICAgIGlmKGFwcElkcyA9PW51bGwgfHwgYXBwSWRzLmxlbmd0aD09MCApe1xyXG4gICAgIHRyeSB7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9JTkRFWF9QQVRIKTtcclxuICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOTyBQVUJMSVNIRUQgQVBQXCIpO1xyXG4gICAgIH0gXHJcbiAgICAgYXBwSWRzID0gaW5kZXhEYXRhLnB1Ymxpc2hlZDtcclxuICAgIH1cclxuICAgIGZvcihsZXQgYXBwaWQgb2YgYXBwSWRzKXtcclxuICAgICAgbGV0IGFwcE1hc3Rlcjphbnk9e307XHJcbiAgICAgIGxldCBhcHBEYXRhIDphbnk7XHJcbiAgICAgIGxldCBhcHBTdGF0cyA6YW55O1xyXG4gICAgICBsZXQgYXBwQ29tbWVudHMgOmFueTtcclxuICAgICAgdHJ5e1xyXG4gICAgICAgIGFwcERhdGE9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlKHRoaXMucGF0aHMuUFVCTElTSEVEX0FQUF9JTkZPX1BBVEgrYXBwaWQrJy8nKydhcHBJbmZvLmpzb24nKTtcclxuICAgICAgICBhcHBTdGF0cz0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5QVUJMSVNIRURfQVBQX0lORk9fUEFUSCthcHBpZCsnLycrJ2FwcFN0YXRzLmpzb24nKTtcclxuICAgICAgICBhcHBDb21tZW50cz0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5QVUJMSVNIRURfQVBQX0lORk9fUEFUSCthcHBpZCsnLycrJ2FwcENvbW1lbnRzLmpzb24nKTtcclxuICAgICAgICBhcHBNYXN0ZXI9e1xyXG4gICAgICAgICAgYXBwZGF0YTphcHBEYXRhLFxyXG4gICAgICAgICAgYXBwc3RhdHM6IGFwcFN0YXRzLFxyXG4gICAgICAgICAgYXBwY29tbWVudHM6IGFwcENvbW1lbnRzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdHMucHVzaChhcHBNYXN0ZXIpO1xyXG4gICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHRoaXMubG9nKCdtaXNzaW5nIGpzb24gZm9yIGFwcGlkIDonLGFwcGlkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG4gIHB1YmxpYyBhc3luYyBnZXRTa2FwcFN0YXRzKGFwcElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgbGV0IGFwcERhdGEgOmFueTtcclxuICAgIHRyeXtcclxuICAgICAgYXBwRGF0YT0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5QVUJMSVNIRURfQVBQX0lORk9fUEFUSCthcHBJZCsnLycrJ2FwcFN0YXRzLmpzb24nKTtcclxuICAgIFxyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgdGhpcy5sb2coJ21pc3NpbmcganNvbiBmb3IgYXBwaWQgOicsYXBwSWQpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGpzb24gZm9yIGFwcGlkIDpcIithcHBJZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwRGF0YTtcclxuICB9XHJcbiAgcHVibGljIGFzeW5jIGdldFNrYXBwQ29tbWVudHMoYXBwSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICBsZXQgYXBwRGF0YSA6YW55O1xyXG4gICAgdHJ5e1xyXG4gICAgICBhcHBEYXRhPSBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9BUFBfSU5GT19QQVRIK2FwcElkKycvJysnYXBwQ29tbWVudHMuanNvbicpO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgdGhpcy5sb2coJ21pc3NpbmcganNvbiBmb3IgYXBwaWQgOicsYXBwSWQpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGpzb24gZm9yIGFwcGlkIDpcIithcHBJZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwRGF0YTtcclxuICB9XHJcbiAgcHVibGljIGFzeW5jIGdldERlcGxveWVkQXBwcyhhcHBJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT4ge1xyXG4gICAgbGV0IGluZGV4RGF0YTphbnkgPXt9O1xyXG4gICAgbGV0IHJlc3VsdHM6SURlcGxveWVkQXBwW10gPSBbXTtcclxuICAgIGlmKGFwcElkcyA9PW51bGwgfHwgYXBwSWRzLmxlbmd0aD09MCApe1xyXG4gICAgIHRyeSB7XHJcbiAgICAgIGluZGV4RGF0YT1hd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLkRFUExPWUVEX0lOREVYX1BBVEgpO1xyXG4gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5PIERFUExPWUVEIEFQUFwiKTtcclxuICAgICB9IFxyXG4gICAgIGFwcElkcyA9IGluZGV4RGF0YS5kZXBsb3llZDtcclxuICAgIH1cclxuICAgIGZvcihsZXQgYXBwaWQgb2YgYXBwSWRzKXtcclxuICAgICAgbGV0IGFwcERhdGEgOmFueTtcclxuICAgICAgdHJ5e1xyXG4gICAgICAgIGFwcERhdGE9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRBcHBJbmZvKGFwcGlkKTtcclxuICAgICAgcmVzdWx0cy5wdXNoKGFwcERhdGEpO1xyXG4gICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHRoaXMubG9nKCdtaXNzaW5nIGpzb24gZm9yIGFwcGlkIDonLGFwcGlkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0UHVibGlzaGVkQXBwSW5mbyhhcHBJZDpzdHJpbmcpOlByb21pc2U8YW55PntcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9BUFBfSU5GT19QQVRIK2FwcElkKycvJysnYXBwSW5mby5qc29uJyk7XHJcbiAgfVxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0UHVibGlzaGVkQXBwU3RhdHMoYXBwSWQ6c3RyaW5nKTpQcm9taXNlPGFueT57XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlKHRoaXMucGF0aHMuUFVCTElTSEVEX0FQUF9JTkZPX1BBVEgrYXBwSWQrJy8nKydhcHBTdGF0cy5qc29uJykpO1xyXG4gIH1cclxuICBwcml2YXRlIGFzeW5jIHNldFB1Ymxpc2hlZEFwcFN0YXRzKGFwcElkOnN0cmluZyxkYXRhOmFueSl7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5teVNreS5zZXRKU09OKHRoaXMucGF0aHMuUFVCTElTSEVEX0FQUF9JTkZPX1BBVEgrYXBwSWQrJy8nKydhcHBTdGF0cy5qc29uJyxkYXRhKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRQdWJsaXNoZWRBcHBDb21tZW50cyhhcHBJZDpzdHJpbmcpOlByb21pc2U8YW55PntcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlBVQkxJU0hFRF9BUFBfSU5GT19QQVRIK2FwcElkKycvJysnYXBwQ29tbWVudHMuanNvbicpO1xyXG4gIH1cclxuICBwcml2YXRlIGFzeW5jIHNldFB1Ymxpc2hlZEFwcENvbW1lbnRzKGFwcElkOnN0cmluZyxkYXRhOmFueSl7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5teVNreS5zZXRKU09OKHRoaXMucGF0aHMuUFVCTElTSEVEX0FQUF9JTkZPX1BBVEgrYXBwSWQrJy8nKydhcHBDb21tZW50cy5qc29uJyxkYXRhKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBhc3luYyBzZXRQdWJsaXNoZWRBcHBJbmZvKGFwcElkOnN0cmluZywgYXBwRGF0YTphbnkpe1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubXlTa3kuc2V0SlNPTih0aGlzLnBhdGhzLlBVQkxJU0hFRF9BUFBfSU5GT19QQVRIK2FwcElkKycvJysnYXBwSW5mby5qc29uJyxhcHBEYXRhKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBhc3luYyBnZXREZXBsb3llZEFwcEluZm8oYXBwSWQ6c3RyaW5nKXtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLkRFUExPWUVEX0FQUF9JTkZPX1BBVEgrYXBwSWQrJy8nKydhcHBJbmZvLmpzb24nKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBhc3luYyBzZXREZXBsb3llZEFwcEluZm8oYXBwSWQ6c3RyaW5nLCBhcHBEYXRhOmFueSl7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5teVNreS5zZXRKU09OKHRoaXMucGF0aHMuREVQTE9ZRURfQVBQX0lORk9fUEFUSCthcHBJZCsnLycrJ2FwcEluZm8uanNvbicsYXBwRGF0YSk7XHJcbiAgfVxyXG4gIC8vIG9uVXNlckxvZ2luIGlzIGNhbGxlZCBieSBNeVNreSB3aGVuIHRoZSB1c2VyIGhhcyBsb2dnZWQgaW4gc3VjY2Vzc2Z1bGx5XHJcbiAgcHVibGljIGFzeW5jIG9uVXNlckxvZ2luKCkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHNrYXBwIG5hbWUgaW4gdGhlIGRpY3Rpb25hcnlcclxuICAgIFxyXG4gIH1cclxuXHJcblxyXG4gIC8vIHJlZ2lzdGVyU2thcHBOYW1lIGlzIGNhbGxlZCBvbiBpbml0IGFuZCBlbnN1cmVzIHRoaXMgc2thcHAgbmFtZSBpc1xyXG4gIC8vIHJlZ2lzdGVyZWQgaW4gdGhlIHNrYXBwIG5hbWUgZGljdGlvbmFyeS5cclxuICBwcml2YXRlIGFzeW5jIHJlZ2lzdGVyU2thcHBOYW1lKCkge1xyXG4gICAgY29uc3QgeyBTS0FQUFNfRElDVF9QQVRIIH0gPSB0aGlzLnBhdGhzO1xyXG4gICAgbGV0IHNrYXBwcyA9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlPElEaWN0aW9uYXJ5PihTS0FQUFNfRElDVF9QQVRIKTtcclxuICAgIGlmICghc2thcHBzKSB7XHJcbiAgICAgIHNrYXBwcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgc2thcHBzW3RoaXMuc2thcHBdID0gdHJ1ZTtcclxuICAgIGF3YWl0IHRoaXMudXBkYXRlRmlsZShTS0FQUFNfRElDVF9QQVRILCBza2FwcHMpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIGRvd25sb2FkRmlsZSBtZXJlbHkgd3JhcHMgZ2V0SlNPTiBidXQgaXMgdHlwZWQgaW4gYSB3YXkgdGhhdCBhdm9pZHNcclxuICAvLyByZXBlYXRpbmcgdGhlIGF3a3dhcmQgXCJhcyB1bmtub3duIGFzIFRcIiBldmVyeXdoZXJlXHJcbiAgcHJpdmF0ZSBhc3luYyBkb3dubG9hZEZpbGU8VD4ocGF0aDogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xyXG4gICAgdGhpcy5sb2coJyMjIyBTa2FwcC1SZWNvcmQgIyMjIDo6IGRvd25sb2FkaW5nIGZpbGUgYXQgcGF0aCcsIHBhdGgpXHJcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMubXlTa3kuZ2V0SlNPTihwYXRoKVxyXG4gICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgIHRoaXMubG9nKCdubyBkYXRhIGZvdW5kIGF0IHBhdGgnLCBwYXRoKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMubG9nKCdkYXRhIGZvdW5kIGF0IHBhdGgnLCBwYXRoLCBkYXRhKVxyXG4gICAgcmV0dXJuIGRhdGEgYXMgdW5rbm93biBhcyBUXHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGVGaWxlIG1lcmVseSB3cmFwcyBzZXRKU09OIGJ1dCBpcyB0eXBlZCBpbiBhIHdheSB0aGF0IGF2b2lkcyByZXBlYXRpbmdcclxuICAvLyB0aGUgYXdrd2FycyBcImFzIHVua25vd24gYXMgSnNvbkRhdGFcIiBldmVyeXdoZXJlXHJcbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVGaWxlPFQ+KHBhdGg6IHN0cmluZywgZGF0YTogVCkge1xyXG4gICAgdGhpcy5sb2coJ3VwZGF0aW5nIGZpbGUgYXQgcGF0aCcsIHBhdGgsIGRhdGEpXHJcbiAgICBhd2FpdCB0aGlzLm15U2t5LnNldEpTT04ocGF0aCwgZGF0YSBhcyB1bmtub3duIGFzIEpzb25EYXRhKVxyXG4gIH1cclxuXHJcblxyXG5cclxuICAvLyB0b1BlcnNpc3RlbmNlIHR1cm5zIGNvbnRlbnQgaW5mbyBpbnRvIGEgY29udGVudCBwZXJzaXN0ZW5jZSBvYmplY3RcclxuICBwcml2YXRlIHRvUGVyc2lzdGVuY2UoZGF0YTogSUNvbnRlbnRJbmZvKTogSUNvbnRlbnRQZXJzaXN0ZW5jZSB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IHtcclxuICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcclxuICAgICAgLi4uZGF0YSxcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGVyc2lzdGVuY2UubWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBwZXJzaXN0ZW5jZS5tZXRhZGF0YSA9IHt9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyB2YWxpZGF0ZSB0aGUgZ2l2ZW4gZGF0YSBkb2VzIG5vdCBleGNlZWQgbWF4IHNpemVcclxuICAgIGNvbnN0IHNpemUgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwZXJzaXN0ZW5jZSkpLmxlbmd0aFxyXG4gICAgaWYgKHNpemUgPiBFTlRSWV9NQVhfU0laRSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudHJ5IGV4Y2VlZHMgbWF4IHNpemUsICR7bGVuZ3RofT4ke0VOVFJZX01BWF9TSVpFfWApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlO1xyXG4gIH1cclxuXHJcbiAgLy8gbG9nIHByaW50cyB0byBzdGRvdXQgb25seSBpZiBERUJVR19FTkFCTEVEIGZsYWcgaXMgc2V0XHJcbiAgcHJpdmF0ZSBsb2cobWVzc2FnZTogc3RyaW5nLCAuLi5vcHRpb25hbENvbnRleHQ6IGFueVtdKSB7XHJcbiAgICBpZiAoREVCVUdfRU5BQkxFRCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5vcHRpb25hbENvbnRleHQpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTa2FwcERBQyBmcm9tIFwiLi9kYWNcIjtcclxuXHJcbihhc3luYyAoKSA9PiB7XHJcbiAgbmV3IFNrYXBwREFDKCk7XHJcbn0pKCk7XHJcbiIsIlxyXG5leHBvcnQgaW50ZXJmYWNlIElTa2FwcERBQyB7XHJcbiAgc2thcHBBY3Rpb24oYWN0aW9uOiBza2FwcEFjdGlvblR5cGUsIGFwcElkOnN0cmluZyxkYXRhOmFueSk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPjtcclxuICBnZXRQdWJsaXNoZWRBcHBzKGFwcElkczogc3RyaW5nW10pOiBQcm9taXNlPGFueVtdPjtcclxuICBnZXRTa2FwcHNJbmZvKGFwcElkczogc3RyaW5nW10pOiBQcm9taXNlPGFueVtdPjtcclxuICBnZXRTa2FwcFN0YXRzKGFwcElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XHJcbiAgZ2V0U2thcHBDb21tZW50cyhhcHBJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xyXG4gIGdldERlcGxveWVkQXBwcyhhcHBJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnRlbnRJbmZvIHtcclxuICBza3lsaW5rOiBzdHJpbmc7ICAgIC8vIHNreWxpbmtcclxuICBtZXRhZGF0YTogb2JqZWN0OyAgIC8vIHNob3VsZCBiZSB2YWxpZCBKU09OXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIHNrYXBwQWN0aW9uVHlwZSB7XHJcbiAgJ1BVQkxJU0gnLFxyXG4gICdSRVBVQkxJU0gnLFxyXG4gICdERVBMT1knLFxyXG4gICdSRURFUExPWScsXHJcbiAgJ1ZJRVdFRCcsXHJcbiAgJ0FDQ0VTU0VEJyxcclxuICAnRkFWT1JJVEUnLFxyXG4gICdVTkZBVk9SSVRFJyxcclxuICAnTElLRUQnLFxyXG4gICdVTkxJS0VEJyxcclxuICAnQUREX0NPTU1FTlQnLFxyXG4gICdFRElUX0NPTU1FTlQnLFxyXG4gICdSRU1PVkVfQ09NTUVOVCdcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgSUFwcFxyXG4gIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHZlcnNpb24gOiBzdHJpbmc7Ly9cInZlcnNpb25cIjogXCIxXCIsXHJcbiAgcHJldlNreWxpbms6c3RyaW5nIDsvL1wicHJldlNreWxpbmtcIjpcIlwiLFxyXG4gIHRzOiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIElEZXBsb3llZEFwcCBleHRlbmRzIElBcHB7XHJcbiAgICBjb250ZW50OiBJQXBwQ29udGVudDsvL1wiY29udGVudFwiOiAsXHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcCBleHRlbmRzIElBcHB7XHJcbiAgICBjb250ZW50OiBJUHVibGlzaEFwcENvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIElQdWJsaXNoQXBwQ29udGVudCBleHRlbmRzIElBcHBDb250ZW50XHJcbiAge1xyXG4gICAgc2thcHBMb2dvOnN0cmluZzsvL1wic2thcHBMb2dvXCI6IFwiWzQ2IENoYXJhY3RlciBTS1lMSU5LXVwiLFxyXG4gICAgZGVtb1VybDpzdHJpbmc7Ly9cImRlbW9VcmxcIjogXCJbNDYgQ2hhcmFjdGVyIFNLWUxJTktdXCIsXHJcbiAgICBhZ2U6c3RyaW5nOy8vXCJhZ2VcIjogXCJbMTgrfGdlbmVyYWxdXCIsXHJcbiAgICBhcHBVcmw6c3RyaW5nOy8vXCJhcHBVcmxcIjogXCJza3lsaW5rIFVSTFwiLFxyXG4gICAgY2F0ZWdvcnk6IHN0cmluZ1tdLFxyXG4gICAgdGFnczogc3RyaW5nW10sXHJcbiAgICBhcHBTdGF0dXM6IHN0cmluZyxcclxuICAgIGFwcERlc2NyaXB0aW9uOiBzdHJpbmcsXHJcbiAgICByZWxlYXNlTm90ZXM6IHN0cmluZyxcclxuICAgIHN1cHBvcnREZXRhaWxzOiBzdHJpbmcsXHJcbiAgICBjb25uZWN0aW9uczogSVNvY2lhbENvbm5lY3RcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIElTb2NpYWxDb25uZWN0IHtcclxuICB0d2l0dGVyOiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICBkaXNjb3JkOiBzdHJpbmc7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgSUFwcENvbnRlbnR7XHJcbiAgICBcclxuICAgIHN0b3JhZ2VHYXRld2F5OnN0cmluZzsvL1wic3RvcmFnZUdhdGV3YXlcIjogXCJza3luZXRwb3J0YWxVcmxcIixcclxuICAgIGhuczpzdHJpbmc7Ly8gIFwiaG5zXCI6IFwic2t5ZmVlZFwiLFxyXG4gICAgc2t5bGluazpzdHJpbmcgOy8vICBcInNreWxpbmtcIjogXCJza3lsaW5rXCIsXHJcbiAgICBkZWZhdWx0UGF0aDpzdHJpbmc7IC8vICBcImRlZmF1bHRQYXRoXCI6IFwiaW5kZXguaHRtbCBvciBFTVBUWVwiLFxyXG4gICAgcG9ydGFsTWluVmVyc2lvbjpzdHJpbmc7IC8vICBcInBvcnRhbE1pblZlcnNpb25cIjogXCIxLjVcIixcclxuICAgIHNvdXJjZUNvZGU6c3RyaW5nOy8vICBcInNvdXJjZUNvZGVcIjogXCJnaXQgdXJsXCIsXHJcbiAgICBoaXN0b3J5OiBzdHJpbmdbXTsvLyAgXCJoaXN0b3J5XCI6IFsgXCJsaXN0IG9mIHNreWxpbmtzXCJdXHJcbiAgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQXBwSW5mbyB7XHJcbiAgc2t5bGluazogc3RyaW5nOyAgICAvLyBza3lsaW5rXHJcbiAgbWV0YWRhdGE6IG9iamVjdDsgICAvLyBzaG91bGQgYmUgdmFsaWQgSlNPTlxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFwcFN0YXRzIGV4dGVuZHMgSUFwcFxyXG57XHJcbiAgY29udGVudDogSUFwcFN0YXRzQ29udGVudHM7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBJQXBwU3RhdHNDb250ZW50c3tcclxuICBmYXZvcml0ZSA6IG51bWJlcjtcclxuICB2aWV3ZWQ6IG51bWJlcjsgLy8gY291bnRlciBpbmNyZW1lbnRzIGV2ZXJ5dGltZSBjYXJkIGlzIGNsaWNrZWQgdG8gdmlldyBkZXRhaWxzXHJcbiAgbGlrZWQgOiBudW1iZXI7XHJcbiAgYWNjZXNzZWQgOiBudW1iZXI7IC8vIGNvdW50ZXIgaW5jcmVtZW50cyBldmVyeXRpbWUgYXBwIFVSTCBpcyBjbGlja2VkIFxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFwcENvbW1lbnRzIGV4dGVuZHMgSUFwcFxyXG57XHJcbiAgY29udGVudDogSUFwcENvbW1lbnRzQ29udGVudHNcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIElBcHBDb21tZW50c0NvbnRlbnRze1xyXG4gIGNvbW1lbnRzIDogSUNvbW1lbnRzW107XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBJQ29tbWVudHN7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgY29tbWVudDpzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnRlbnRQZXJzaXN0ZW5jZSB7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7ICAvLyB1bml4IHRpbWVzdGFtcCBvZiByZWNvcmRpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJTmV3Q29udGVudFBlcnNpc3RlbmNlIGV4dGVuZHMgSUNvbnRlbnRQZXJzaXN0ZW5jZSB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3Rpb25QZXJzaXN0ZW5jZSBleHRlbmRzIElDb250ZW50UGVyc2lzdGVuY2UgeyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElJbmRleCB7XHJcbiAgdmVyc2lvbjogbnVtYmVyO1xyXG5cclxuICBjdXJyUGFnZU51bWJlcjogbnVtYmVyO1xyXG4gIGN1cnJQYWdlTnVtRW50cmllczogbnVtYmVyO1xyXG5cclxuICBwYWdlczogc3RyaW5nW107XHJcbiAgcGFnZVNpemU6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUGFnZTxJRW50cnk+IHtcclxuICB2ZXJzaW9uOiBudW1iZXI7XHJcblxyXG4gIGluZGV4UGF0aDogc3RyaW5nOyAvLyBiYWNrIHJlZmVyZW5jZSB0byB0aGUgaW5kZXhcclxuICBwYWdlUGF0aDogc3RyaW5nOyAvLyBiYWNrIHJlZmVyZW5jZSB0byB0aGUgcGF0aFxyXG5cclxuICBlbnRyaWVzOiBJRW50cnlbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJRGljdGlvbmFyeSB7XHJcbiAgW2tleTpzdHJpbmddOiBib29sZWFuXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBJREFDUmVzcG9uc2Uge1xyXG4gIHN1Ym1pdHRlZDogYm9vbGVhbjtcclxuICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGVudW0gRW50cnlUeXBlIHtcclxuICAnTkVXQ09OVEVOVCcsXHJcbiAgJ0lOVEVSQUNUSU9OUydcclxufVxyXG5cclxuLy8gTk9URTogdGhlIHZhbHVlcyBjb250YWluZWQgYnkgdGhpcyBpbnRlcmZhY2UgYXJlICdzdGF0aWMnLCBtZWFuaW5nIHRoZXkgd29uJ3RcclxuLy8gY2hhbmdlIGFmdGVyIHRoZSBEQUMgaGFzIGluaXRpYWxpemVkLiBUaGF0IGlzIHdoeSB0aGV5IGFyZSB1cHBlcmNhc2VkLFxyXG4vLyBiZWNhdXNlIGRlc2N0cnVjdHVyZWQgdGhleSB3aWxsIGxvb2sgbGlrZSByZWd1bGFyIGNvbnN0YW50cy5cclxuLy9cclxuLy8gZS5nLiBjb25zdCB7IE5DX0lOREVYX1BBVEggfSA9IHRoaXMucGF0aHM7XHJcbmV4cG9ydCBpbnRlcmZhY2UgSUZpbGVQYXRocyB7XHJcblNLQVBQU19ESUNUX1BBVEg6IHN0cmluZzsgLy97c2thcHBfbmFtZTp0cnVlL2ZhbHNlfVxyXG4vL0pTT04gZGF0YToge1wic2thcHAuaG5zXCI6e30sIFwic2t5ZmVlZC5obnNcIjp7fSwgXCJTa3lTcGFjZXMuaG5zXCI6IHt9fVxyXG5cclxuUFVCTElTSEVEX0lOREVYX1BBVEg6IHN0cmluZzsgLy8ke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQvaW5kZXguanNvblxyXG4vLy9KU09OIERhdGE6IFthcHBJZDEsIEFwcElkMi4uLi5dXHJcbi8vUEFUSF9FeGFtcGxlOiAvc2t5YXBwcy5obnMvc2thcHAuaG5zL3B1Ymxpc2hlZC9pbmRleC5qc29uLCAvc2t5YXBwcy5obnMvYW5vdGhlckFwcFN0b3JlLmhucy9wdWJsaXNoZWQvaW5kZXguanNvbi4uZXRjXHJcblBVQkxJU0hFRF9BUFBfSU5GT19QQVRIOiBzdHJpbmc7Ly8ke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQve2FwcGlkfS9hcHBJbmZvLmpzb25cclxuUFVCTElTSEVEX0FQUF9DT01NRU5UX1BBVEg6IHN0cmluZzsvLyR7REFUQV9ET01BSU59LyR7c2thcHB9L3B1Ymxpc2hlZC97YXBwaWR9L2NvbW1lbnRzLmpzb25cclxuUFVCTElTSEVEX0FQUF9TVEFUU19QQVRIOiBzdHJpbmc7Ly8ke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQve2FwcGlkfS9zdGF0cy5qc29uXHJcblxyXG5ERVBMT1lFRF9JTkRFWF9QQVRIOiBzdHJpbmc7Ly8ke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9kZXBsb3llZC9pbmRleC5qc29uXHJcbi8vSlNPTiBEYXRhOiBbYXBwSWQxLCBBcHBJZDIuLi4uXVxyXG5ERVBMT1lFRF9BUFBfSU5GT19QQVRIOiBzdHJpbmc7Ly8ke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9kZXBsb3llZC97YXBwaWR9L2FwcEluZm8uanNvblxyXG59IiwiKGZ1bmN0aW9uKG5hY2wpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gUG9ydGVkIGluIDIwMTQgYnkgRG1pdHJ5IENoZXN0bnlraCBhbmQgRGV2aSBNYW5kaXJpLlxuLy8gUHVibGljIGRvbWFpbi5cbi8vXG4vLyBJbXBsZW1lbnRhdGlvbiBkZXJpdmVkIGZyb20gVHdlZXROYUNsIHZlcnNpb24gMjAxNDA0MjcuXG4vLyBTZWUgZm9yIGRldGFpbHM6IGh0dHA6Ly90d2VldG5hY2wuY3IueXAudG8vXG5cbnZhciBnZiA9IGZ1bmN0aW9uKGluaXQpIHtcbiAgdmFyIGksIHIgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgaWYgKGluaXQpIGZvciAoaSA9IDA7IGkgPCBpbml0Lmxlbmd0aDsgaSsrKSByW2ldID0gaW5pdFtpXTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyAgUGx1Z2dhYmxlLCBpbml0aWFsaXplZCBpbiBoaWdoLWxldmVsIEFQSSBiZWxvdy5cbnZhciByYW5kb21ieXRlcyA9IGZ1bmN0aW9uKC8qIHgsIG4gKi8pIHsgdGhyb3cgbmV3IEVycm9yKCdubyBQUk5HJyk7IH07XG5cbnZhciBfMCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbnZhciBfOSA9IG5ldyBVaW50OEFycmF5KDMyKTsgXzlbMF0gPSA5O1xuXG52YXIgZ2YwID0gZ2YoKSxcbiAgICBnZjEgPSBnZihbMV0pLFxuICAgIF8xMjE2NjUgPSBnZihbMHhkYjQxLCAxXSksXG4gICAgRCA9IGdmKFsweDc4YTMsIDB4MTM1OSwgMHg0ZGNhLCAweDc1ZWIsIDB4ZDhhYiwgMHg0MTQxLCAweDBhNGQsIDB4MDA3MCwgMHhlODk4LCAweDc3NzksIDB4NDA3OSwgMHg4Y2M3LCAweGZlNzMsIDB4MmI2ZiwgMHg2Y2VlLCAweDUyMDNdKSxcbiAgICBEMiA9IGdmKFsweGYxNTksIDB4MjZiMiwgMHg5Yjk0LCAweGViZDYsIDB4YjE1NiwgMHg4MjgzLCAweDE0OWEsIDB4MDBlMCwgMHhkMTMwLCAweGVlZjMsIDB4ODBmMiwgMHgxOThlLCAweGZjZTcsIDB4NTZkZiwgMHhkOWRjLCAweDI0MDZdKSxcbiAgICBYID0gZ2YoWzB4ZDUxYSwgMHg4ZjI1LCAweDJkNjAsIDB4Yzk1NiwgMHhhN2IyLCAweDk1MjUsIDB4Yzc2MCwgMHg2OTJjLCAweGRjNWMsIDB4ZmRkNiwgMHhlMjMxLCAweGMwYTQsIDB4NTNmZSwgMHhjZDZlLCAweDM2ZDMsIDB4MjE2OV0pLFxuICAgIFkgPSBnZihbMHg2NjU4LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2XSksXG4gICAgSSA9IGdmKFsweGEwYjAsIDB4NGEwZSwgMHgxYjI3LCAweGM0ZWUsIDB4ZTQ3OCwgMHhhZDJmLCAweDE4MDYsIDB4MmY0MywgMHhkN2E3LCAweDNkZmIsIDB4MDA5OSwgMHgyYjRkLCAweGRmMGIsIDB4NGZjMSwgMHgyNDgwLCAweDJiODNdKTtcblxuZnVuY3Rpb24gdHM2NCh4LCBpLCBoLCBsKSB7XG4gIHhbaV0gICA9IChoID4+IDI0KSAmIDB4ZmY7XG4gIHhbaSsxXSA9IChoID4+IDE2KSAmIDB4ZmY7XG4gIHhbaSsyXSA9IChoID4+ICA4KSAmIDB4ZmY7XG4gIHhbaSszXSA9IGggJiAweGZmO1xuICB4W2krNF0gPSAobCA+PiAyNCkgICYgMHhmZjtcbiAgeFtpKzVdID0gKGwgPj4gMTYpICAmIDB4ZmY7XG4gIHhbaSs2XSA9IChsID4+ICA4KSAgJiAweGZmO1xuICB4W2krN10gPSBsICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gIHZhciBpLGQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkIHw9IHhbeGkraV1eeVt5aStpXTtcbiAgcmV0dXJuICgxICYgKChkIC0gMSkgPj4+IDgpKSAtIDE7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMTYoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMTYpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzMyKHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDMyKTtcbn1cblxuZnVuY3Rpb24gY29yZV9zYWxzYTIwKG8sIHAsIGssIGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cbiAgIHgwID0gIHgwICsgIGowIHwgMDtcbiAgIHgxID0gIHgxICsgIGoxIHwgMDtcbiAgIHgyID0gIHgyICsgIGoyIHwgMDtcbiAgIHgzID0gIHgzICsgIGozIHwgMDtcbiAgIHg0ID0gIHg0ICsgIGo0IHwgMDtcbiAgIHg1ID0gIHg1ICsgIGo1IHwgMDtcbiAgIHg2ID0gIHg2ICsgIGo2IHwgMDtcbiAgIHg3ID0gIHg3ICsgIGo3IHwgMDtcbiAgIHg4ID0gIHg4ICsgIGo4IHwgMDtcbiAgIHg5ID0gIHg5ICsgIGo5IHwgMDtcbiAgeDEwID0geDEwICsgajEwIHwgMDtcbiAgeDExID0geDExICsgajExIHwgMDtcbiAgeDEyID0geDEyICsgajEyIHwgMDtcbiAgeDEzID0geDEzICsgajEzIHwgMDtcbiAgeDE0ID0geDE0ICsgajE0IHwgMDtcbiAgeDE1ID0geDE1ICsgajE1IHwgMDtcblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4MSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHgxID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDEgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4MSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDIgPj4+ICAwICYgMHhmZjtcbiAgb1sgOV0gPSB4MiA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgyID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzEyXSA9IHgzID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDMgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MyA+Pj4gMTYgJiAweGZmO1xuICBvWzE1XSA9IHgzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NCA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDQgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzJdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1szM10gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzM0XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzVdID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzM2XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzddID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szOF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzM5XSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0MF0gPSB4MTAgPj4+ICAwICYgMHhmZjtcbiAgb1s0MV0gPSB4MTAgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Ml0gPSB4MTAgPj4+IDE2ICYgMHhmZjtcbiAgb1s0M10gPSB4MTAgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ0XSA9IHgxMSA+Pj4gIDAgJiAweGZmO1xuICBvWzQ1XSA9IHgxMSA+Pj4gIDggJiAweGZmO1xuICBvWzQ2XSA9IHgxMSA+Pj4gMTYgJiAweGZmO1xuICBvWzQ3XSA9IHgxMSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDhdID0geDEyID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDldID0geDEyID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTBdID0geDEyID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTFdID0geDEyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Ml0gPSB4MTMgPj4+ICAwICYgMHhmZjtcbiAgb1s1M10gPSB4MTMgPj4+ICA4ICYgMHhmZjtcbiAgb1s1NF0gPSB4MTMgPj4+IDE2ICYgMHhmZjtcbiAgb1s1NV0gPSB4MTMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzU2XSA9IHgxNCA+Pj4gIDAgJiAweGZmO1xuICBvWzU3XSA9IHgxNCA+Pj4gIDggJiAweGZmO1xuICBvWzU4XSA9IHgxNCA+Pj4gMTYgJiAweGZmO1xuICBvWzU5XSA9IHgxNCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNjBdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNjFdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNjJdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNjNdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNvcmVfaHNhbHNhMjAobyxwLGssYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MTAgPj4+ICAwICYgMHhmZjtcbiAgb1sgOV0gPSB4MTAgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MTAgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MTAgPj4+IDI0ICYgMHhmZjtcblxuICBvWzEyXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzE1XSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDkgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfc2Fsc2EyMChvdXQsaW5wLGssYykge1xuICBjb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYykge1xuICBjb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxudmFyIHNpZ21hID0gbmV3IFVpbnQ4QXJyYXkoWzEwMSwgMTIwLCAxMTIsIDk3LCAxMTAsIDEwMCwgMzIsIDUxLCA1MCwgNDUsIDk4LCAxMjEsIDExNiwgMTAxLCAzMiwgMTA3XSk7XG4gICAgICAgICAgICAvLyBcImV4cGFuZCAzMi1ieXRlIGtcIlxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsYixuLGspIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgxNiksIHggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciB1LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeltpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHpbaV0gPSBuW2ldO1xuICB3aGlsZSAoYiA+PSA2NCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICAgIHUgPSAxO1xuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgeltpXSA9IHUgJiAweGZmO1xuICAgICAgdSA+Pj49IDg7XG4gICAgfVxuICAgIGIgLT0gNjQ7XG4gICAgY3BvcyArPSA2NDtcbiAgICBtcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLGNwb3MsYixuLGspIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgxNiksIHggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciB1LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeltpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHpbaV0gPSBuW2ldO1xuICB3aGlsZSAoYiA+PSA2NCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBjW2Nwb3MraV0gPSB4W2ldO1xuICAgIHUgPSAxO1xuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgeltpXSA9IHUgJiAweGZmO1xuICAgICAgdSA+Pj49IDg7XG4gICAgfVxuICAgIGIgLT0gNjQ7XG4gICAgY3BvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtKGMsY3BvcyxkLG4saykge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocyxuLGssc2lnbWEpO1xuICB2YXIgc24gPSBuZXcgVWludDhBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHNuW2ldID0gbltpKzE2XTtcbiAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLGNwb3MsZCxzbixzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV94b3IoYyxjcG9zLG0sbXBvcyxkLG4saykge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocyxuLGssc2lnbWEpO1xuICB2YXIgc24gPSBuZXcgVWludDhBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHNuW2ldID0gbltpKzE2XTtcbiAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxkLHNuLHMpO1xufVxuXG4vKlxuKiBQb3J0IG9mIEFuZHJldyBNb29uJ3MgUG9seTEzMDUtZG9ubmEtMTYuIFB1YmxpYyBkb21haW4uXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuKi9cblxudmFyIHBvbHkxMzA1ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIHRoaXMuZmluID0gMDtcblxuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3O1xuXG4gIHQwID0ga2V5WyAwXSAmIDB4ZmYgfCAoa2V5WyAxXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclswXSA9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICB0MSA9IGtleVsgMl0gJiAweGZmIHwgKGtleVsgM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgdDIgPSBrZXlbIDRdICYgMHhmZiB8IChrZXlbIDVdICYgMHhmZikgPDwgODsgdGhpcy5yWzJdID0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmMDM7XG4gIHQzID0ga2V5WyA2XSAmIDB4ZmYgfCAoa2V5WyA3XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclszXSA9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICB0NCA9IGtleVsgOF0gJiAweGZmIHwgKGtleVsgOV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNF0gPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgdGhpcy5yWzVdID0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZTtcbiAgdDUgPSBrZXlbMTBdICYgMHhmZiB8IChrZXlbMTFdICYgMHhmZikgPDwgODsgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gIHQ2ID0ga2V5WzEyXSAmIDB4ZmYgfCAoa2V5WzEzXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZjgxO1xuICB0NyA9IGtleVsxNF0gJiAweGZmIHwgKGtleVsxNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbOF0gPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgdGhpcy5yWzldID0gKCh0NyA+Pj4gIDUpKSAmIDB4MDA3ZjtcblxuICB0aGlzLnBhZFswXSA9IGtleVsxNl0gJiAweGZmIHwgKGtleVsxN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsxXSA9IGtleVsxOF0gJiAweGZmIHwgKGtleVsxOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsyXSA9IGtleVsyMF0gJiAweGZmIHwgKGtleVsyMV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFszXSA9IGtleVsyMl0gJiAweGZmIHwgKGtleVsyM10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs0XSA9IGtleVsyNF0gJiAweGZmIHwgKGtleVsyNV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs1XSA9IGtleVsyNl0gJiAweGZmIHwgKGtleVsyN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs2XSA9IGtleVsyOF0gJiAweGZmIHwgKGtleVsyOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs3XSA9IGtleVszMF0gJiAweGZmIHwgKGtleVszMV0gJiAweGZmKSA8PCA4O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmJsb2NrcyA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBoaWJpdCA9IHRoaXMuZmluID8gMCA6ICgxIDw8IDExKTtcbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NywgYztcbiAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5O1xuXG4gIHZhciBoMCA9IHRoaXMuaFswXSxcbiAgICAgIGgxID0gdGhpcy5oWzFdLFxuICAgICAgaDIgPSB0aGlzLmhbMl0sXG4gICAgICBoMyA9IHRoaXMuaFszXSxcbiAgICAgIGg0ID0gdGhpcy5oWzRdLFxuICAgICAgaDUgPSB0aGlzLmhbNV0sXG4gICAgICBoNiA9IHRoaXMuaFs2XSxcbiAgICAgIGg3ID0gdGhpcy5oWzddLFxuICAgICAgaDggPSB0aGlzLmhbOF0sXG4gICAgICBoOSA9IHRoaXMuaFs5XTtcblxuICB2YXIgcjAgPSB0aGlzLnJbMF0sXG4gICAgICByMSA9IHRoaXMuclsxXSxcbiAgICAgIHIyID0gdGhpcy5yWzJdLFxuICAgICAgcjMgPSB0aGlzLnJbM10sXG4gICAgICByNCA9IHRoaXMucls0XSxcbiAgICAgIHI1ID0gdGhpcy5yWzVdLFxuICAgICAgcjYgPSB0aGlzLnJbNl0sXG4gICAgICByNyA9IHRoaXMucls3XSxcbiAgICAgIHI4ID0gdGhpcy5yWzhdLFxuICAgICAgcjkgPSB0aGlzLnJbOV07XG5cbiAgd2hpbGUgKGJ5dGVzID49IDE2KSB7XG4gICAgdDAgPSBtW21wb3MrIDBdICYgMHhmZiB8IChtW21wb3MrIDFdICYgMHhmZikgPDwgODsgaDAgKz0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gICAgdDEgPSBtW21wb3MrIDJdICYgMHhmZiB8IChtW21wb3MrIDNdICYgMHhmZikgPDwgODsgaDEgKz0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gICAgdDIgPSBtW21wb3MrIDRdICYgMHhmZiB8IChtW21wb3MrIDVdICYgMHhmZikgPDwgODsgaDIgKz0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmZmY7XG4gICAgdDMgPSBtW21wb3MrIDZdICYgMHhmZiB8IChtW21wb3MrIDddICYgMHhmZikgPDwgODsgaDMgKz0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gICAgdDQgPSBtW21wb3MrIDhdICYgMHhmZiB8IChtW21wb3MrIDldICYgMHhmZikgPDwgODsgaDQgKz0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmY7XG4gICAgaDUgKz0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZjtcbiAgICB0NSA9IG1bbXBvcysxMF0gJiAweGZmIHwgKG1bbXBvcysxMV0gJiAweGZmKSA8PCA4OyBoNiArPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgICB0NiA9IG1bbXBvcysxMl0gJiAweGZmIHwgKG1bbXBvcysxM10gJiAweGZmKSA8PCA4OyBoNyArPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWZmZjtcbiAgICB0NyA9IG1bbXBvcysxNF0gJiAweGZmIHwgKG1bbXBvcysxNV0gJiAweGZmKSA8PCA4OyBoOCArPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgICBoOSArPSAoKHQ3ID4+PiA1KSkgfCBoaWJpdDtcblxuICAgIGMgPSAwO1xuXG4gICAgZDAgPSBjO1xuICAgIGQwICs9IGgwICogcjA7XG4gICAgZDAgKz0gaDEgKiAoNSAqIHI5KTtcbiAgICBkMCArPSBoMiAqICg1ICogcjgpO1xuICAgIGQwICs9IGgzICogKDUgKiByNyk7XG4gICAgZDAgKz0gaDQgKiAoNSAqIHI2KTtcbiAgICBjID0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcbiAgICBkMCArPSBoNSAqICg1ICogcjUpO1xuICAgIGQwICs9IGg2ICogKDUgKiByNCk7XG4gICAgZDAgKz0gaDcgKiAoNSAqIHIzKTtcbiAgICBkMCArPSBoOCAqICg1ICogcjIpO1xuICAgIGQwICs9IGg5ICogKDUgKiByMSk7XG4gICAgYyArPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuXG4gICAgZDEgPSBjO1xuICAgIGQxICs9IGgwICogcjE7XG4gICAgZDEgKz0gaDEgKiByMDtcbiAgICBkMSArPSBoMiAqICg1ICogcjkpO1xuICAgIGQxICs9IGgzICogKDUgKiByOCk7XG4gICAgZDEgKz0gaDQgKiAoNSAqIHI3KTtcbiAgICBjID0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcbiAgICBkMSArPSBoNSAqICg1ICogcjYpO1xuICAgIGQxICs9IGg2ICogKDUgKiByNSk7XG4gICAgZDEgKz0gaDcgKiAoNSAqIHI0KTtcbiAgICBkMSArPSBoOCAqICg1ICogcjMpO1xuICAgIGQxICs9IGg5ICogKDUgKiByMik7XG4gICAgYyArPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuXG4gICAgZDIgPSBjO1xuICAgIGQyICs9IGgwICogcjI7XG4gICAgZDIgKz0gaDEgKiByMTtcbiAgICBkMiArPSBoMiAqIHIwO1xuICAgIGQyICs9IGgzICogKDUgKiByOSk7XG4gICAgZDIgKz0gaDQgKiAoNSAqIHI4KTtcbiAgICBjID0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcbiAgICBkMiArPSBoNSAqICg1ICogcjcpO1xuICAgIGQyICs9IGg2ICogKDUgKiByNik7XG4gICAgZDIgKz0gaDcgKiAoNSAqIHI1KTtcbiAgICBkMiArPSBoOCAqICg1ICogcjQpO1xuICAgIGQyICs9IGg5ICogKDUgKiByMyk7XG4gICAgYyArPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuXG4gICAgZDMgPSBjO1xuICAgIGQzICs9IGgwICogcjM7XG4gICAgZDMgKz0gaDEgKiByMjtcbiAgICBkMyArPSBoMiAqIHIxO1xuICAgIGQzICs9IGgzICogcjA7XG4gICAgZDMgKz0gaDQgKiAoNSAqIHI5KTtcbiAgICBjID0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcbiAgICBkMyArPSBoNSAqICg1ICogcjgpO1xuICAgIGQzICs9IGg2ICogKDUgKiByNyk7XG4gICAgZDMgKz0gaDcgKiAoNSAqIHI2KTtcbiAgICBkMyArPSBoOCAqICg1ICogcjUpO1xuICAgIGQzICs9IGg5ICogKDUgKiByNCk7XG4gICAgYyArPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuXG4gICAgZDQgPSBjO1xuICAgIGQ0ICs9IGgwICogcjQ7XG4gICAgZDQgKz0gaDEgKiByMztcbiAgICBkNCArPSBoMiAqIHIyO1xuICAgIGQ0ICs9IGgzICogcjE7XG4gICAgZDQgKz0gaDQgKiByMDtcbiAgICBjID0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcbiAgICBkNCArPSBoNSAqICg1ICogcjkpO1xuICAgIGQ0ICs9IGg2ICogKDUgKiByOCk7XG4gICAgZDQgKz0gaDcgKiAoNSAqIHI3KTtcbiAgICBkNCArPSBoOCAqICg1ICogcjYpO1xuICAgIGQ0ICs9IGg5ICogKDUgKiByNSk7XG4gICAgYyArPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuXG4gICAgZDUgPSBjO1xuICAgIGQ1ICs9IGgwICogcjU7XG4gICAgZDUgKz0gaDEgKiByNDtcbiAgICBkNSArPSBoMiAqIHIzO1xuICAgIGQ1ICs9IGgzICogcjI7XG4gICAgZDUgKz0gaDQgKiByMTtcbiAgICBjID0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcbiAgICBkNSArPSBoNSAqIHIwO1xuICAgIGQ1ICs9IGg2ICogKDUgKiByOSk7XG4gICAgZDUgKz0gaDcgKiAoNSAqIHI4KTtcbiAgICBkNSArPSBoOCAqICg1ICogcjcpO1xuICAgIGQ1ICs9IGg5ICogKDUgKiByNik7XG4gICAgYyArPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuXG4gICAgZDYgPSBjO1xuICAgIGQ2ICs9IGgwICogcjY7XG4gICAgZDYgKz0gaDEgKiByNTtcbiAgICBkNiArPSBoMiAqIHI0O1xuICAgIGQ2ICs9IGgzICogcjM7XG4gICAgZDYgKz0gaDQgKiByMjtcbiAgICBjID0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcbiAgICBkNiArPSBoNSAqIHIxO1xuICAgIGQ2ICs9IGg2ICogcjA7XG4gICAgZDYgKz0gaDcgKiAoNSAqIHI5KTtcbiAgICBkNiArPSBoOCAqICg1ICogcjgpO1xuICAgIGQ2ICs9IGg5ICogKDUgKiByNyk7XG4gICAgYyArPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuXG4gICAgZDcgPSBjO1xuICAgIGQ3ICs9IGgwICogcjc7XG4gICAgZDcgKz0gaDEgKiByNjtcbiAgICBkNyArPSBoMiAqIHI1O1xuICAgIGQ3ICs9IGgzICogcjQ7XG4gICAgZDcgKz0gaDQgKiByMztcbiAgICBjID0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcbiAgICBkNyArPSBoNSAqIHIyO1xuICAgIGQ3ICs9IGg2ICogcjE7XG4gICAgZDcgKz0gaDcgKiByMDtcbiAgICBkNyArPSBoOCAqICg1ICogcjkpO1xuICAgIGQ3ICs9IGg5ICogKDUgKiByOCk7XG4gICAgYyArPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuXG4gICAgZDggPSBjO1xuICAgIGQ4ICs9IGgwICogcjg7XG4gICAgZDggKz0gaDEgKiByNztcbiAgICBkOCArPSBoMiAqIHI2O1xuICAgIGQ4ICs9IGgzICogcjU7XG4gICAgZDggKz0gaDQgKiByNDtcbiAgICBjID0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcbiAgICBkOCArPSBoNSAqIHIzO1xuICAgIGQ4ICs9IGg2ICogcjI7XG4gICAgZDggKz0gaDcgKiByMTtcbiAgICBkOCArPSBoOCAqIHIwO1xuICAgIGQ4ICs9IGg5ICogKDUgKiByOSk7XG4gICAgYyArPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuXG4gICAgZDkgPSBjO1xuICAgIGQ5ICs9IGgwICogcjk7XG4gICAgZDkgKz0gaDEgKiByODtcbiAgICBkOSArPSBoMiAqIHI3O1xuICAgIGQ5ICs9IGgzICogcjY7XG4gICAgZDkgKz0gaDQgKiByNTtcbiAgICBjID0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcbiAgICBkOSArPSBoNSAqIHI0O1xuICAgIGQ5ICs9IGg2ICogcjM7XG4gICAgZDkgKz0gaDcgKiByMjtcbiAgICBkOSArPSBoOCAqIHIxO1xuICAgIGQ5ICs9IGg5ICogcjA7XG4gICAgYyArPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuXG4gICAgYyA9ICgoKGMgPDwgMikgKyBjKSkgfCAwO1xuICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgZDAgPSBjICYgMHgxZmZmO1xuICAgIGMgPSAoYyA+Pj4gMTMpO1xuICAgIGQxICs9IGM7XG5cbiAgICBoMCA9IGQwO1xuICAgIGgxID0gZDE7XG4gICAgaDIgPSBkMjtcbiAgICBoMyA9IGQzO1xuICAgIGg0ID0gZDQ7XG4gICAgaDUgPSBkNTtcbiAgICBoNiA9IGQ2O1xuICAgIGg3ID0gZDc7XG4gICAgaDggPSBkODtcbiAgICBoOSA9IGQ5O1xuXG4gICAgbXBvcyArPSAxNjtcbiAgICBieXRlcyAtPSAxNjtcbiAgfVxuICB0aGlzLmhbMF0gPSBoMDtcbiAgdGhpcy5oWzFdID0gaDE7XG4gIHRoaXMuaFsyXSA9IGgyO1xuICB0aGlzLmhbM10gPSBoMztcbiAgdGhpcy5oWzRdID0gaDQ7XG4gIHRoaXMuaFs1XSA9IGg1O1xuICB0aGlzLmhbNl0gPSBoNjtcbiAgdGhpcy5oWzddID0gaDc7XG4gIHRoaXMuaFs4XSA9IGg4O1xuICB0aGlzLmhbOV0gPSBoOTtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihtYWMsIG1hY3Bvcykge1xuICB2YXIgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHZhciBjLCBtYXNrLCBmLCBpO1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgaSA9IHRoaXMubGVmdG92ZXI7XG4gICAgdGhpcy5idWZmZXJbaSsrXSA9IDE7XG4gICAgZm9yICg7IGkgPCAxNjsgaSsrKSB0aGlzLmJ1ZmZlcltpXSA9IDA7XG4gICAgdGhpcy5maW4gPSAxO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gIH1cblxuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICB0aGlzLmhbaV0gKz0gYztcbiAgICBjID0gdGhpcy5oW2ldID4+PiAxMztcbiAgICB0aGlzLmhbaV0gJj0gMHgxZmZmO1xuICB9XG4gIHRoaXMuaFswXSArPSAoYyAqIDUpO1xuICBjID0gdGhpcy5oWzBdID4+PiAxMztcbiAgdGhpcy5oWzBdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzFdICs9IGM7XG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMl0gKz0gYztcblxuICBnWzBdID0gdGhpcy5oWzBdICsgNTtcbiAgYyA9IGdbMF0gPj4+IDEzO1xuICBnWzBdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICBnW2ldID0gdGhpcy5oW2ldICsgYztcbiAgICBjID0gZ1tpXSA+Pj4gMTM7XG4gICAgZ1tpXSAmPSAweDFmZmY7XG4gIH1cbiAgZ1s5XSAtPSAoMSA8PCAxMyk7XG5cbiAgbWFzayA9IChjIF4gMSkgLSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgZ1tpXSAmPSBtYXNrO1xuICBtYXNrID0gfm1hc2s7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB0aGlzLmhbaV0gPSAodGhpcy5oW2ldICYgbWFzaykgfCBnW2ldO1xuXG4gIHRoaXMuaFswXSA9ICgodGhpcy5oWzBdICAgICAgICkgfCAodGhpcy5oWzFdIDw8IDEzKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzFdID0gKCh0aGlzLmhbMV0gPj4+ICAzKSB8ICh0aGlzLmhbMl0gPDwgMTApICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMl0gPSAoKHRoaXMuaFsyXSA+Pj4gIDYpIHwgKHRoaXMuaFszXSA8PCAgNykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFszXSA9ICgodGhpcy5oWzNdID4+PiAgOSkgfCAodGhpcy5oWzRdIDw8ICA0KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzRdID0gKCh0aGlzLmhbNF0gPj4+IDEyKSB8ICh0aGlzLmhbNV0gPDwgIDEpIHwgKHRoaXMuaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICB0aGlzLmhbNV0gPSAoKHRoaXMuaFs2XSA+Pj4gIDIpIHwgKHRoaXMuaFs3XSA8PCAxMSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs2XSA9ICgodGhpcy5oWzddID4+PiAgNSkgfCAodGhpcy5oWzhdIDw8ICA4KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzddID0gKCh0aGlzLmhbOF0gPj4+ICA4KSB8ICh0aGlzLmhbOV0gPDwgIDUpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuXG4gIGYgPSB0aGlzLmhbMF0gKyB0aGlzLnBhZFswXTtcbiAgdGhpcy5oWzBdID0gZiAmIDB4ZmZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDg7IGkrKykge1xuICAgIGYgPSAoKCh0aGlzLmhbaV0gKyB0aGlzLnBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICB0aGlzLmhbaV0gPSBmICYgMHhmZmZmO1xuICB9XG5cbiAgbWFjW21hY3BvcysgMF0gPSAodGhpcy5oWzBdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDFdID0gKHRoaXMuaFswXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAyXSA9ICh0aGlzLmhbMV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgM10gPSAodGhpcy5oWzFdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDRdID0gKHRoaXMuaFsyXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA1XSA9ICh0aGlzLmhbMl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNl0gPSAodGhpcy5oWzNdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDddID0gKHRoaXMuaFszXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA4XSA9ICh0aGlzLmhbNF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOV0gPSAodGhpcy5oWzRdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTBdID0gKHRoaXMuaFs1XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzExXSA9ICh0aGlzLmhbNV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMl0gPSAodGhpcy5oWzZdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTNdID0gKHRoaXMuaFs2XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE0XSA9ICh0aGlzLmhbN10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNV0gPSAodGhpcy5oWzddID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGksIHdhbnQ7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICB3YW50ID0gKDE2IC0gdGhpcy5sZWZ0b3Zlcik7XG4gICAgaWYgKHdhbnQgPiBieXRlcylcbiAgICAgIHdhbnQgPSBieXRlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2FudDsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIHRoaXMubGVmdG92ZXIgKz0gd2FudDtcbiAgICBpZiAodGhpcy5sZWZ0b3ZlciA8IDE2KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gICAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIH1cblxuICBpZiAoYnl0ZXMgPj0gMTYpIHtcbiAgICB3YW50ID0gYnl0ZXMgLSAoYnl0ZXMgJSAxNik7XG4gICAgdGhpcy5ibG9ja3MobSwgbXBvcywgd2FudCk7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gIH1cblxuICBpZiAoYnl0ZXMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICB0aGlzLmxlZnRvdmVyICs9IGJ5dGVzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGgob3V0LCBvdXRwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHMgPSBuZXcgcG9seTEzMDUoayk7XG4gIHMudXBkYXRlKG0sIG1wb3MsIG4pO1xuICBzLmZpbmlzaChvdXQsIG91dHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGgsIGhwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGNyeXB0b19vbmV0aW1lYXV0aCh4LDAsbSxtcG9zLG4sayk7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzE2KGgsaHBvcyx4LDApO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94KGMsbSxkLG4saykge1xuICB2YXIgaTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihjLDAsbSwwLGQsbixrKTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKGMsIDE2LCBjLCAzMiwgZCAtIDMyLCBjKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIGNbaV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sYyxkLG4saykge1xuICB2YXIgaTtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbSh4LDAsMzIsbixrKTtcbiAgaWYgKGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoYywgMTYsYywgMzIsZCAtIDMyLHgpICE9PSAwKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKG0sMCxjLDAsZCxuLGspO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBzZXQyNTUxOShyLCBhKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSA9IGFbaV18MDtcbn1cblxuZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICB2YXIgaSwgdiwgYyA9IDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdiA9IG9baV0gKyBjICsgNjU1MzU7XG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICBvW2ldID0gdiAtIGMgKiA2NTUzNjtcbiAgfVxuICBvWzBdICs9IGMtMSArIDM3ICogKGMtMSk7XG59XG5cbmZ1bmN0aW9uIHNlbDI1NTE5KHAsIHEsIGIpIHtcbiAgdmFyIHQsIGMgPSB+KGItMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHQgPSBjICYgKHBbaV0gXiBxW2ldKTtcbiAgICBwW2ldIF49IHQ7XG4gICAgcVtpXSBePSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpLCBqLCBiO1xuICB2YXIgbSA9IGdmKCksIHQgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgdFtpXSA9IG5baV07XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGZvciAoaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICBtWzBdID0gdFswXSAtIDB4ZmZlZDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgMTU7IGkrKykge1xuICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAoKG1baS0xXT4+MTYpICYgMSk7XG4gICAgICBtW2ktMV0gJj0gMHhmZmZmO1xuICAgIH1cbiAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKChtWzE0XT4+MTYpICYgMSk7XG4gICAgYiA9IChtWzE1XT4+MTYpICYgMTtcbiAgICBtWzE0XSAmPSAweGZmZmY7XG4gICAgc2VsMjU1MTkodCwgbSwgMS1iKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIG9bMippXSA9IHRbaV0gJiAweGZmO1xuICAgIG9bMippKzFdID0gdFtpXT4+ODtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoYywgYSk7XG4gIHBhY2syNTUxOShkLCBiKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG59XG5cbmZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShkLCBhKTtcbiAgcmV0dXJuIGRbMF0gJiAxO1xufVxuXG5mdW5jdGlvbiB1bnBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IG5bMippXSArIChuWzIqaSsxXSA8PCA4KTtcbiAgb1sxNV0gJj0gMHg3ZmZmO1xufVxuXG5mdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSArIGJbaV07XG59XG5cbmZ1bmN0aW9uIFoobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldIC0gYltpXTtcbn1cblxuZnVuY3Rpb24gTShvLCBhLCBiKSB7XG4gIHZhciB2LCBjLFxuICAgICB0MCA9IDAsICB0MSA9IDAsICB0MiA9IDAsICB0MyA9IDAsICB0NCA9IDAsICB0NSA9IDAsICB0NiA9IDAsICB0NyA9IDAsXG4gICAgIHQ4ID0gMCwgIHQ5ID0gMCwgdDEwID0gMCwgdDExID0gMCwgdDEyID0gMCwgdDEzID0gMCwgdDE0ID0gMCwgdDE1ID0gMCxcbiAgICB0MTYgPSAwLCB0MTcgPSAwLCB0MTggPSAwLCB0MTkgPSAwLCB0MjAgPSAwLCB0MjEgPSAwLCB0MjIgPSAwLCB0MjMgPSAwLFxuICAgIHQyNCA9IDAsIHQyNSA9IDAsIHQyNiA9IDAsIHQyNyA9IDAsIHQyOCA9IDAsIHQyOSA9IDAsIHQzMCA9IDAsXG4gICAgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdLFxuICAgIGI0ID0gYls0XSxcbiAgICBiNSA9IGJbNV0sXG4gICAgYjYgPSBiWzZdLFxuICAgIGI3ID0gYls3XSxcbiAgICBiOCA9IGJbOF0sXG4gICAgYjkgPSBiWzldLFxuICAgIGIxMCA9IGJbMTBdLFxuICAgIGIxMSA9IGJbMTFdLFxuICAgIGIxMiA9IGJbMTJdLFxuICAgIGIxMyA9IGJbMTNdLFxuICAgIGIxNCA9IGJbMTRdLFxuICAgIGIxNSA9IGJbMTVdO1xuXG4gIHYgPSBhWzBdO1xuICB0MCArPSB2ICogYjA7XG4gIHQxICs9IHYgKiBiMTtcbiAgdDIgKz0gdiAqIGIyO1xuICB0MyArPSB2ICogYjM7XG4gIHQ0ICs9IHYgKiBiNDtcbiAgdDUgKz0gdiAqIGI1O1xuICB0NiArPSB2ICogYjY7XG4gIHQ3ICs9IHYgKiBiNztcbiAgdDggKz0gdiAqIGI4O1xuICB0OSArPSB2ICogYjk7XG4gIHQxMCArPSB2ICogYjEwO1xuICB0MTEgKz0gdiAqIGIxMTtcbiAgdDEyICs9IHYgKiBiMTI7XG4gIHQxMyArPSB2ICogYjEzO1xuICB0MTQgKz0gdiAqIGIxNDtcbiAgdDE1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzFdO1xuICB0MSArPSB2ICogYjA7XG4gIHQyICs9IHYgKiBiMTtcbiAgdDMgKz0gdiAqIGIyO1xuICB0NCArPSB2ICogYjM7XG4gIHQ1ICs9IHYgKiBiNDtcbiAgdDYgKz0gdiAqIGI1O1xuICB0NyArPSB2ICogYjY7XG4gIHQ4ICs9IHYgKiBiNztcbiAgdDkgKz0gdiAqIGI4O1xuICB0MTAgKz0gdiAqIGI5O1xuICB0MTEgKz0gdiAqIGIxMDtcbiAgdDEyICs9IHYgKiBiMTE7XG4gIHQxMyArPSB2ICogYjEyO1xuICB0MTQgKz0gdiAqIGIxMztcbiAgdDE1ICs9IHYgKiBiMTQ7XG4gIHQxNiArPSB2ICogYjE1O1xuICB2ID0gYVsyXTtcbiAgdDIgKz0gdiAqIGIwO1xuICB0MyArPSB2ICogYjE7XG4gIHQ0ICs9IHYgKiBiMjtcbiAgdDUgKz0gdiAqIGIzO1xuICB0NiArPSB2ICogYjQ7XG4gIHQ3ICs9IHYgKiBiNTtcbiAgdDggKz0gdiAqIGI2O1xuICB0OSArPSB2ICogYjc7XG4gIHQxMCArPSB2ICogYjg7XG4gIHQxMSArPSB2ICogYjk7XG4gIHQxMiArPSB2ICogYjEwO1xuICB0MTMgKz0gdiAqIGIxMTtcbiAgdDE0ICs9IHYgKiBiMTI7XG4gIHQxNSArPSB2ICogYjEzO1xuICB0MTYgKz0gdiAqIGIxNDtcbiAgdDE3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzNdO1xuICB0MyArPSB2ICogYjA7XG4gIHQ0ICs9IHYgKiBiMTtcbiAgdDUgKz0gdiAqIGIyO1xuICB0NiArPSB2ICogYjM7XG4gIHQ3ICs9IHYgKiBiNDtcbiAgdDggKz0gdiAqIGI1O1xuICB0OSArPSB2ICogYjY7XG4gIHQxMCArPSB2ICogYjc7XG4gIHQxMSArPSB2ICogYjg7XG4gIHQxMiArPSB2ICogYjk7XG4gIHQxMyArPSB2ICogYjEwO1xuICB0MTQgKz0gdiAqIGIxMTtcbiAgdDE1ICs9IHYgKiBiMTI7XG4gIHQxNiArPSB2ICogYjEzO1xuICB0MTcgKz0gdiAqIGIxNDtcbiAgdDE4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzRdO1xuICB0NCArPSB2ICogYjA7XG4gIHQ1ICs9IHYgKiBiMTtcbiAgdDYgKz0gdiAqIGIyO1xuICB0NyArPSB2ICogYjM7XG4gIHQ4ICs9IHYgKiBiNDtcbiAgdDkgKz0gdiAqIGI1O1xuICB0MTAgKz0gdiAqIGI2O1xuICB0MTEgKz0gdiAqIGI3O1xuICB0MTIgKz0gdiAqIGI4O1xuICB0MTMgKz0gdiAqIGI5O1xuICB0MTQgKz0gdiAqIGIxMDtcbiAgdDE1ICs9IHYgKiBiMTE7XG4gIHQxNiArPSB2ICogYjEyO1xuICB0MTcgKz0gdiAqIGIxMztcbiAgdDE4ICs9IHYgKiBiMTQ7XG4gIHQxOSArPSB2ICogYjE1O1xuICB2ID0gYVs1XTtcbiAgdDUgKz0gdiAqIGIwO1xuICB0NiArPSB2ICogYjE7XG4gIHQ3ICs9IHYgKiBiMjtcbiAgdDggKz0gdiAqIGIzO1xuICB0OSArPSB2ICogYjQ7XG4gIHQxMCArPSB2ICogYjU7XG4gIHQxMSArPSB2ICogYjY7XG4gIHQxMiArPSB2ICogYjc7XG4gIHQxMyArPSB2ICogYjg7XG4gIHQxNCArPSB2ICogYjk7XG4gIHQxNSArPSB2ICogYjEwO1xuICB0MTYgKz0gdiAqIGIxMTtcbiAgdDE3ICs9IHYgKiBiMTI7XG4gIHQxOCArPSB2ICogYjEzO1xuICB0MTkgKz0gdiAqIGIxNDtcbiAgdDIwICs9IHYgKiBiMTU7XG4gIHYgPSBhWzZdO1xuICB0NiArPSB2ICogYjA7XG4gIHQ3ICs9IHYgKiBiMTtcbiAgdDggKz0gdiAqIGIyO1xuICB0OSArPSB2ICogYjM7XG4gIHQxMCArPSB2ICogYjQ7XG4gIHQxMSArPSB2ICogYjU7XG4gIHQxMiArPSB2ICogYjY7XG4gIHQxMyArPSB2ICogYjc7XG4gIHQxNCArPSB2ICogYjg7XG4gIHQxNSArPSB2ICogYjk7XG4gIHQxNiArPSB2ICogYjEwO1xuICB0MTcgKz0gdiAqIGIxMTtcbiAgdDE4ICs9IHYgKiBiMTI7XG4gIHQxOSArPSB2ICogYjEzO1xuICB0MjAgKz0gdiAqIGIxNDtcbiAgdDIxICs9IHYgKiBiMTU7XG4gIHYgPSBhWzddO1xuICB0NyArPSB2ICogYjA7XG4gIHQ4ICs9IHYgKiBiMTtcbiAgdDkgKz0gdiAqIGIyO1xuICB0MTAgKz0gdiAqIGIzO1xuICB0MTEgKz0gdiAqIGI0O1xuICB0MTIgKz0gdiAqIGI1O1xuICB0MTMgKz0gdiAqIGI2O1xuICB0MTQgKz0gdiAqIGI3O1xuICB0MTUgKz0gdiAqIGI4O1xuICB0MTYgKz0gdiAqIGI5O1xuICB0MTcgKz0gdiAqIGIxMDtcbiAgdDE4ICs9IHYgKiBiMTE7XG4gIHQxOSArPSB2ICogYjEyO1xuICB0MjAgKz0gdiAqIGIxMztcbiAgdDIxICs9IHYgKiBiMTQ7XG4gIHQyMiArPSB2ICogYjE1O1xuICB2ID0gYVs4XTtcbiAgdDggKz0gdiAqIGIwO1xuICB0OSArPSB2ICogYjE7XG4gIHQxMCArPSB2ICogYjI7XG4gIHQxMSArPSB2ICogYjM7XG4gIHQxMiArPSB2ICogYjQ7XG4gIHQxMyArPSB2ICogYjU7XG4gIHQxNCArPSB2ICogYjY7XG4gIHQxNSArPSB2ICogYjc7XG4gIHQxNiArPSB2ICogYjg7XG4gIHQxNyArPSB2ICogYjk7XG4gIHQxOCArPSB2ICogYjEwO1xuICB0MTkgKz0gdiAqIGIxMTtcbiAgdDIwICs9IHYgKiBiMTI7XG4gIHQyMSArPSB2ICogYjEzO1xuICB0MjIgKz0gdiAqIGIxNDtcbiAgdDIzICs9IHYgKiBiMTU7XG4gIHYgPSBhWzldO1xuICB0OSArPSB2ICogYjA7XG4gIHQxMCArPSB2ICogYjE7XG4gIHQxMSArPSB2ICogYjI7XG4gIHQxMiArPSB2ICogYjM7XG4gIHQxMyArPSB2ICogYjQ7XG4gIHQxNCArPSB2ICogYjU7XG4gIHQxNSArPSB2ICogYjY7XG4gIHQxNiArPSB2ICogYjc7XG4gIHQxNyArPSB2ICogYjg7XG4gIHQxOCArPSB2ICogYjk7XG4gIHQxOSArPSB2ICogYjEwO1xuICB0MjAgKz0gdiAqIGIxMTtcbiAgdDIxICs9IHYgKiBiMTI7XG4gIHQyMiArPSB2ICogYjEzO1xuICB0MjMgKz0gdiAqIGIxNDtcbiAgdDI0ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEwXTtcbiAgdDEwICs9IHYgKiBiMDtcbiAgdDExICs9IHYgKiBiMTtcbiAgdDEyICs9IHYgKiBiMjtcbiAgdDEzICs9IHYgKiBiMztcbiAgdDE0ICs9IHYgKiBiNDtcbiAgdDE1ICs9IHYgKiBiNTtcbiAgdDE2ICs9IHYgKiBiNjtcbiAgdDE3ICs9IHYgKiBiNztcbiAgdDE4ICs9IHYgKiBiODtcbiAgdDE5ICs9IHYgKiBiOTtcbiAgdDIwICs9IHYgKiBiMTA7XG4gIHQyMSArPSB2ICogYjExO1xuICB0MjIgKz0gdiAqIGIxMjtcbiAgdDIzICs9IHYgKiBiMTM7XG4gIHQyNCArPSB2ICogYjE0O1xuICB0MjUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTFdO1xuICB0MTEgKz0gdiAqIGIwO1xuICB0MTIgKz0gdiAqIGIxO1xuICB0MTMgKz0gdiAqIGIyO1xuICB0MTQgKz0gdiAqIGIzO1xuICB0MTUgKz0gdiAqIGI0O1xuICB0MTYgKz0gdiAqIGI1O1xuICB0MTcgKz0gdiAqIGI2O1xuICB0MTggKz0gdiAqIGI3O1xuICB0MTkgKz0gdiAqIGI4O1xuICB0MjAgKz0gdiAqIGI5O1xuICB0MjEgKz0gdiAqIGIxMDtcbiAgdDIyICs9IHYgKiBiMTE7XG4gIHQyMyArPSB2ICogYjEyO1xuICB0MjQgKz0gdiAqIGIxMztcbiAgdDI1ICs9IHYgKiBiMTQ7XG4gIHQyNiArPSB2ICogYjE1O1xuICB2ID0gYVsxMl07XG4gIHQxMiArPSB2ICogYjA7XG4gIHQxMyArPSB2ICogYjE7XG4gIHQxNCArPSB2ICogYjI7XG4gIHQxNSArPSB2ICogYjM7XG4gIHQxNiArPSB2ICogYjQ7XG4gIHQxNyArPSB2ICogYjU7XG4gIHQxOCArPSB2ICogYjY7XG4gIHQxOSArPSB2ICogYjc7XG4gIHQyMCArPSB2ICogYjg7XG4gIHQyMSArPSB2ICogYjk7XG4gIHQyMiArPSB2ICogYjEwO1xuICB0MjMgKz0gdiAqIGIxMTtcbiAgdDI0ICs9IHYgKiBiMTI7XG4gIHQyNSArPSB2ICogYjEzO1xuICB0MjYgKz0gdiAqIGIxNDtcbiAgdDI3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEzXTtcbiAgdDEzICs9IHYgKiBiMDtcbiAgdDE0ICs9IHYgKiBiMTtcbiAgdDE1ICs9IHYgKiBiMjtcbiAgdDE2ICs9IHYgKiBiMztcbiAgdDE3ICs9IHYgKiBiNDtcbiAgdDE4ICs9IHYgKiBiNTtcbiAgdDE5ICs9IHYgKiBiNjtcbiAgdDIwICs9IHYgKiBiNztcbiAgdDIxICs9IHYgKiBiODtcbiAgdDIyICs9IHYgKiBiOTtcbiAgdDIzICs9IHYgKiBiMTA7XG4gIHQyNCArPSB2ICogYjExO1xuICB0MjUgKz0gdiAqIGIxMjtcbiAgdDI2ICs9IHYgKiBiMTM7XG4gIHQyNyArPSB2ICogYjE0O1xuICB0MjggKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTRdO1xuICB0MTQgKz0gdiAqIGIwO1xuICB0MTUgKz0gdiAqIGIxO1xuICB0MTYgKz0gdiAqIGIyO1xuICB0MTcgKz0gdiAqIGIzO1xuICB0MTggKz0gdiAqIGI0O1xuICB0MTkgKz0gdiAqIGI1O1xuICB0MjAgKz0gdiAqIGI2O1xuICB0MjEgKz0gdiAqIGI3O1xuICB0MjIgKz0gdiAqIGI4O1xuICB0MjMgKz0gdiAqIGI5O1xuICB0MjQgKz0gdiAqIGIxMDtcbiAgdDI1ICs9IHYgKiBiMTE7XG4gIHQyNiArPSB2ICogYjEyO1xuICB0MjcgKz0gdiAqIGIxMztcbiAgdDI4ICs9IHYgKiBiMTQ7XG4gIHQyOSArPSB2ICogYjE1O1xuICB2ID0gYVsxNV07XG4gIHQxNSArPSB2ICogYjA7XG4gIHQxNiArPSB2ICogYjE7XG4gIHQxNyArPSB2ICogYjI7XG4gIHQxOCArPSB2ICogYjM7XG4gIHQxOSArPSB2ICogYjQ7XG4gIHQyMCArPSB2ICogYjU7XG4gIHQyMSArPSB2ICogYjY7XG4gIHQyMiArPSB2ICogYjc7XG4gIHQyMyArPSB2ICogYjg7XG4gIHQyNCArPSB2ICogYjk7XG4gIHQyNSArPSB2ICogYjEwO1xuICB0MjYgKz0gdiAqIGIxMTtcbiAgdDI3ICs9IHYgKiBiMTI7XG4gIHQyOCArPSB2ICogYjEzO1xuICB0MjkgKz0gdiAqIGIxNDtcbiAgdDMwICs9IHYgKiBiMTU7XG5cbiAgdDAgICs9IDM4ICogdDE2O1xuICB0MSAgKz0gMzggKiB0MTc7XG4gIHQyICArPSAzOCAqIHQxODtcbiAgdDMgICs9IDM4ICogdDE5O1xuICB0NCAgKz0gMzggKiB0MjA7XG4gIHQ1ICArPSAzOCAqIHQyMTtcbiAgdDYgICs9IDM4ICogdDIyO1xuICB0NyAgKz0gMzggKiB0MjM7XG4gIHQ4ICArPSAzOCAqIHQyNDtcbiAgdDkgICs9IDM4ICogdDI1O1xuICB0MTAgKz0gMzggKiB0MjY7XG4gIHQxMSArPSAzOCAqIHQyNztcbiAgdDEyICs9IDM4ICogdDI4O1xuICB0MTMgKz0gMzggKiB0Mjk7XG4gIHQxNCArPSAzOCAqIHQzMDtcbiAgLy8gdDE1IGxlZnQgYXMgaXNcblxuICAvLyBmaXJzdCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgLy8gc2Vjb25kIGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICBvWyAwXSA9IHQwO1xuICBvWyAxXSA9IHQxO1xuICBvWyAyXSA9IHQyO1xuICBvWyAzXSA9IHQzO1xuICBvWyA0XSA9IHQ0O1xuICBvWyA1XSA9IHQ1O1xuICBvWyA2XSA9IHQ2O1xuICBvWyA3XSA9IHQ3O1xuICBvWyA4XSA9IHQ4O1xuICBvWyA5XSA9IHQ5O1xuICBvWzEwXSA9IHQxMDtcbiAgb1sxMV0gPSB0MTE7XG4gIG9bMTJdID0gdDEyO1xuICBvWzEzXSA9IHQxMztcbiAgb1sxNF0gPSB0MTQ7XG4gIG9bMTVdID0gdDE1O1xufVxuXG5mdW5jdGlvbiBTKG8sIGEpIHtcbiAgTShvLCBhLCBhKTtcbn1cblxuZnVuY3Rpb24gaW52MjU1MTkobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MzsgYSA+PSAwOyBhLS0pIHtcbiAgICBTKGMsIGMpO1xuICAgIGlmKGEgIT09IDIgJiYgYSAhPT0gNCkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIHBvdzI1MjMobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MDsgYSA+PSAwOyBhLS0pIHtcbiAgICAgIFMoYywgYyk7XG4gICAgICBpZihhICE9PSAxKSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgciwgaTtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMzE7IGkrKykgeltpXSA9IG5baV07XG4gIHpbMzFdPShuWzMxXSYxMjcpfDY0O1xuICB6WzBdJj0yNDg7XG4gIHVucGFjazI1NTE5KHgscCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgYltpXT14W2ldO1xuICAgIGRbaV09YVtpXT1jW2ldPTA7XG4gIH1cbiAgYVswXT1kWzBdPTE7XG4gIGZvciAoaT0yNTQ7IGk+PTA7IC0taSkge1xuICAgIHI9KHpbaT4+PjNdPj4+KGkmNykpJjE7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBBKGMsYixkKTtcbiAgICBaKGIsYixkKTtcbiAgICBTKGQsZSk7XG4gICAgUyhmLGEpO1xuICAgIE0oYSxjLGEpO1xuICAgIE0oYyxiLGUpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIFMoYixhKTtcbiAgICBaKGMsZCxmKTtcbiAgICBNKGEsYyxfMTIxNjY1KTtcbiAgICBBKGEsYSxkKTtcbiAgICBNKGMsYyxhKTtcbiAgICBNKGEsZCxmKTtcbiAgICBNKGQsYix4KTtcbiAgICBTKGIsZSk7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHhbaSsxNl09YVtpXTtcbiAgICB4W2krMzJdPWNbaV07XG4gICAgeFtpKzQ4XT1iW2ldO1xuICAgIHhbaSs2NF09ZFtpXTtcbiAgfVxuICB2YXIgeDMyID0geC5zdWJhcnJheSgzMik7XG4gIHZhciB4MTYgPSB4LnN1YmFycmF5KDE2KTtcbiAgaW52MjU1MTkoeDMyLHgzMik7XG4gIE0oeDE2LHgxNix4MzIpO1xuICBwYWNrMjU1MTkocSx4MTYpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKSB7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBfOSk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfa2V5cGFpcih5LCB4KSB7XG4gIHJhbmRvbWJ5dGVzKHgsIDMyKTtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UoeSwgeCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCkge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocywgeCwgeSk7XG4gIHJldHVybiBjcnlwdG9fY29yZV9oc2Fsc2EyMChrLCBfMCwgcywgc2lnbWEpO1xufVxuXG52YXIgY3J5cHRvX2JveF9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveDtcbnZhciBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3hfb3BlbjtcblxuZnVuY3Rpb24gY3J5cHRvX2JveChjLCBtLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9hZnRlcm5tKGMsIG0sIGQsIG4sIGspO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X29wZW4obSwgYywgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tKG0sIGMsIGQsIG4sIGspO1xufVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKSB7XG4gIHZhciB3aCA9IG5ldyBJbnQzMkFycmF5KDE2KSwgd2wgPSBuZXcgSW50MzJBcnJheSgxNiksXG4gICAgICBiaDAsIGJoMSwgYmgyLCBiaDMsIGJoNCwgYmg1LCBiaDYsIGJoNyxcbiAgICAgIGJsMCwgYmwxLCBibDIsIGJsMywgYmw0LCBibDUsIGJsNiwgYmw3LFxuICAgICAgdGgsIHRsLCBpLCBqLCBoLCBsLCBhLCBiLCBjLCBkO1xuXG4gIHZhciBhaDAgPSBoaFswXSxcbiAgICAgIGFoMSA9IGhoWzFdLFxuICAgICAgYWgyID0gaGhbMl0sXG4gICAgICBhaDMgPSBoaFszXSxcbiAgICAgIGFoNCA9IGhoWzRdLFxuICAgICAgYWg1ID0gaGhbNV0sXG4gICAgICBhaDYgPSBoaFs2XSxcbiAgICAgIGFoNyA9IGhoWzddLFxuXG4gICAgICBhbDAgPSBobFswXSxcbiAgICAgIGFsMSA9IGhsWzFdLFxuICAgICAgYWwyID0gaGxbMl0sXG4gICAgICBhbDMgPSBobFszXSxcbiAgICAgIGFsNCA9IGhsWzRdLFxuICAgICAgYWw1ID0gaGxbNV0sXG4gICAgICBhbDYgPSBobFs2XSxcbiAgICAgIGFsNyA9IGhsWzddO1xuXG4gIHZhciBwb3MgPSAwO1xuICB3aGlsZSAobiA+PSAxMjgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgaiA9IDggKiBpICsgcG9zO1xuICAgICAgd2hbaV0gPSAobVtqKzBdIDw8IDI0KSB8IChtW2orMV0gPDwgMTYpIHwgKG1baisyXSA8PCA4KSB8IG1baiszXTtcbiAgICAgIHdsW2ldID0gKG1bais0XSA8PCAyNCkgfCAobVtqKzVdIDw8IDE2KSB8IChtW2orNl0gPDwgOCkgfCBtW2orN107XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBiaDAgPSBhaDA7XG4gICAgICBiaDEgPSBhaDE7XG4gICAgICBiaDIgPSBhaDI7XG4gICAgICBiaDMgPSBhaDM7XG4gICAgICBiaDQgPSBhaDQ7XG4gICAgICBiaDUgPSBhaDU7XG4gICAgICBiaDYgPSBhaDY7XG4gICAgICBiaDcgPSBhaDc7XG5cbiAgICAgIGJsMCA9IGFsMDtcbiAgICAgIGJsMSA9IGFsMTtcbiAgICAgIGJsMiA9IGFsMjtcbiAgICAgIGJsMyA9IGFsMztcbiAgICAgIGJsNCA9IGFsNDtcbiAgICAgIGJsNSA9IGFsNTtcbiAgICAgIGJsNiA9IGFsNjtcbiAgICAgIGJsNyA9IGFsNztcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYWg3O1xuICAgICAgbCA9IGFsNztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMVxuICAgICAgaCA9ICgoYWg0ID4+PiAxNCkgfCAoYWw0IDw8ICgzMi0xNCkpKSBeICgoYWg0ID4+PiAxOCkgfCAoYWw0IDw8ICgzMi0xOCkpKSBeICgoYWw0ID4+PiAoNDEtMzIpKSB8IChhaDQgPDwgKDMyLSg0MS0zMikpKSk7XG4gICAgICBsID0gKChhbDQgPj4+IDE0KSB8IChhaDQgPDwgKDMyLTE0KSkpIF4gKChhbDQgPj4+IDE4KSB8IChhaDQgPDwgKDMyLTE4KSkpIF4gKChhaDQgPj4+ICg0MS0zMikpIHwgKGFsNCA8PCAoMzItKDQxLTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBDaFxuICAgICAgaCA9IChhaDQgJiBhaDUpIF4gKH5haDQgJiBhaDYpO1xuICAgICAgbCA9IChhbDQgJiBhbDUpIF4gKH5hbDQgJiBhbDYpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIEtcbiAgICAgIGggPSBLW2kqMl07XG4gICAgICBsID0gS1tpKjIrMV07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gd1xuICAgICAgaCA9IHdoW2klMTZdO1xuICAgICAgbCA9IHdsW2klMTZdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgdGggPSBjICYgMHhmZmZmIHwgZCA8PCAxNjtcbiAgICAgIHRsID0gYSAmIDB4ZmZmZiB8IGIgPDwgMTY7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWEwXG4gICAgICBoID0gKChhaDAgPj4+IDI4KSB8IChhbDAgPDwgKDMyLTI4KSkpIF4gKChhbDAgPj4+ICgzNC0zMikpIHwgKGFoMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWwwID4+PiAoMzktMzIpKSB8IChhaDAgPDwgKDMyLSgzOS0zMikpKSk7XG4gICAgICBsID0gKChhbDAgPj4+IDI4KSB8IChhaDAgPDwgKDMyLTI4KSkpIF4gKChhaDAgPj4+ICgzNC0zMikpIHwgKGFsMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWgwID4+PiAoMzktMzIpKSB8IChhbDAgPDwgKDMyLSgzOS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gTWFqXG4gICAgICBoID0gKGFoMCAmIGFoMSkgXiAoYWgwICYgYWgyKSBeIChhaDEgJiBhaDIpO1xuICAgICAgbCA9IChhbDAgJiBhbDEpIF4gKGFsMCAmIGFsMikgXiAoYWwxICYgYWwyKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYmgzO1xuICAgICAgbCA9IGJsMztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgYWgxID0gYmgwO1xuICAgICAgYWgyID0gYmgxO1xuICAgICAgYWgzID0gYmgyO1xuICAgICAgYWg0ID0gYmgzO1xuICAgICAgYWg1ID0gYmg0O1xuICAgICAgYWg2ID0gYmg1O1xuICAgICAgYWg3ID0gYmg2O1xuICAgICAgYWgwID0gYmg3O1xuXG4gICAgICBhbDEgPSBibDA7XG4gICAgICBhbDIgPSBibDE7XG4gICAgICBhbDMgPSBibDI7XG4gICAgICBhbDQgPSBibDM7XG4gICAgICBhbDUgPSBibDQ7XG4gICAgICBhbDYgPSBibDU7XG4gICAgICBhbDcgPSBibDY7XG4gICAgICBhbDAgPSBibDc7XG5cbiAgICAgIGlmIChpJTE2ID09PSAxNSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgIGggPSB3aFtqXTtcbiAgICAgICAgICBsID0gd2xbal07XG5cbiAgICAgICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBoID0gd2hbKGorOSklMTZdO1xuICAgICAgICAgIGwgPSB3bFsoais5KSUxNl07XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWEwXG4gICAgICAgICAgdGggPSB3aFsoaisxKSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxKSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDEpIHwgKHRsIDw8ICgzMi0xKSkpIF4gKCh0aCA+Pj4gOCkgfCAodGwgPDwgKDMyLTgpKSkgXiAodGggPj4+IDcpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxKSB8ICh0aCA8PCAoMzItMSkpKSBeICgodGwgPj4+IDgpIHwgKHRoIDw8ICgzMi04KSkpIF4gKCh0bCA+Pj4gNykgfCAodGggPDwgKDMyLTcpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWExXG4gICAgICAgICAgdGggPSB3aFsoaisxNCklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMTQpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMTkpIHwgKHRsIDw8ICgzMi0xOSkpKSBeICgodGwgPj4+ICg2MS0zMikpIHwgKHRoIDw8ICgzMi0oNjEtMzIpKSkpIF4gKHRoID4+PiA2KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMTkpIHwgKHRoIDw8ICgzMi0xOSkpKSBeICgodGggPj4+ICg2MS0zMikpIHwgKHRsIDw8ICgzMi0oNjEtMzIpKSkpIF4gKCh0bCA+Pj4gNikgfCAodGggPDwgKDMyLTYpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgICAgICB3aFtqXSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgICAgICB3bFtqXSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZFxuICAgIGggPSBhaDA7XG4gICAgbCA9IGFsMDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFswXTtcbiAgICBsID0gaGxbMF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFswXSA9IGFoMCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFswXSA9IGFsMCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDE7XG4gICAgbCA9IGFsMTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsxXTtcbiAgICBsID0gaGxbMV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsxXSA9IGFoMSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsxXSA9IGFsMSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDI7XG4gICAgbCA9IGFsMjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsyXTtcbiAgICBsID0gaGxbMl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsyXSA9IGFoMiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsyXSA9IGFsMiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDM7XG4gICAgbCA9IGFsMztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFszXTtcbiAgICBsID0gaGxbM107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFszXSA9IGFoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFszXSA9IGFsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDQ7XG4gICAgbCA9IGFsNDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs0XTtcbiAgICBsID0gaGxbNF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs0XSA9IGFoNCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs0XSA9IGFsNCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDU7XG4gICAgbCA9IGFsNTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs1XTtcbiAgICBsID0gaGxbNV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs1XSA9IGFoNSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs1XSA9IGFsNSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDY7XG4gICAgbCA9IGFsNjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs2XTtcbiAgICBsID0gaGxbNl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs2XSA9IGFoNiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs2XSA9IGFsNiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDc7XG4gICAgbCA9IGFsNztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs3XTtcbiAgICBsID0gaGxbN107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs3XSA9IGFoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs3XSA9IGFsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIHBvcyArPSAxMjg7XG4gICAgbiAtPSAxMjg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2hhc2gob3V0LCBtLCBuKSB7XG4gIHZhciBoaCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgaGwgPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIHggPSBuZXcgVWludDhBcnJheSgyNTYpLFxuICAgICAgaSwgYiA9IG47XG5cbiAgaGhbMF0gPSAweDZhMDllNjY3O1xuICBoaFsxXSA9IDB4YmI2N2FlODU7XG4gIGhoWzJdID0gMHgzYzZlZjM3MjtcbiAgaGhbM10gPSAweGE1NGZmNTNhO1xuICBoaFs0XSA9IDB4NTEwZTUyN2Y7XG4gIGhoWzVdID0gMHg5YjA1Njg4YztcbiAgaGhbNl0gPSAweDFmODNkOWFiO1xuICBoaFs3XSA9IDB4NWJlMGNkMTk7XG5cbiAgaGxbMF0gPSAweGYzYmNjOTA4O1xuICBobFsxXSA9IDB4ODRjYWE3M2I7XG4gIGhsWzJdID0gMHhmZTk0ZjgyYjtcbiAgaGxbM10gPSAweDVmMWQzNmYxO1xuICBobFs0XSA9IDB4YWRlNjgyZDE7XG4gIGhsWzVdID0gMHgyYjNlNmMxZjtcbiAgaGxbNl0gPSAweGZiNDFiZDZiO1xuICBobFs3XSA9IDB4MTM3ZTIxNzk7XG5cbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKTtcbiAgbiAlPSAxMjg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IG1bYi1uK2ldO1xuICB4W25dID0gMTI4O1xuXG4gIG4gPSAyNTYtMTI4KihuPDExMj8xOjApO1xuICB4W24tOV0gPSAwO1xuICB0czY0KHgsIG4tOCwgIChiIC8gMHgyMDAwMDAwMCkgfCAwLCBiIDw8IDMpO1xuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIHgsIG4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHRzNjQob3V0LCA4KmksIGhoW2ldLCBobFtpXSk7XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKSxcbiAgICAgIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG5cbiAgWihhLCBwWzFdLCBwWzBdKTtcbiAgWih0LCBxWzFdLCBxWzBdKTtcbiAgTShhLCBhLCB0KTtcbiAgQShiLCBwWzBdLCBwWzFdKTtcbiAgQSh0LCBxWzBdLCBxWzFdKTtcbiAgTShiLCBiLCB0KTtcbiAgTShjLCBwWzNdLCBxWzNdKTtcbiAgTShjLCBjLCBEMik7XG4gIE0oZCwgcFsyXSwgcVsyXSk7XG4gIEEoZCwgZCwgZCk7XG4gIFooZSwgYiwgYSk7XG4gIFooZiwgZCwgYyk7XG4gIEEoZywgZCwgYyk7XG4gIEEoaCwgYiwgYSk7XG5cbiAgTShwWzBdLCBlLCBmKTtcbiAgTShwWzFdLCBoLCBnKTtcbiAgTShwWzJdLCBnLCBmKTtcbiAgTShwWzNdLCBlLCBoKTtcbn1cblxuZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHNlbDI1NTE5KHBbaV0sIHFbaV0sIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2sociwgcCkge1xuICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgaW52MjU1MTkoemksIHBbMl0pO1xuICBNKHR4LCBwWzBdLCB6aSk7XG4gIE0odHksIHBbMV0sIHppKTtcbiAgcGFjazI1NTE5KHIsIHR5KTtcbiAgclszMV0gXj0gcGFyMjU1MTkodHgpIDw8IDc7XG59XG5cbmZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICB2YXIgYiwgaTtcbiAgc2V0MjU1MTkocFswXSwgZ2YwKTtcbiAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFsyXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFszXSwgZ2YwKTtcbiAgZm9yIChpID0gMjU1OyBpID49IDA7IC0taSkge1xuICAgIGIgPSAoc1soaS84KXwwXSA+PiAoaSY3KSkgJiAxO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgIGFkZChxLCBwKTtcbiAgICBhZGQocCwgcCk7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbGFyYmFzZShwLCBzKSB7XG4gIHZhciBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICBzZXQyNTUxOShxWzBdLCBYKTtcbiAgc2V0MjU1MTkocVsxXSwgWSk7XG4gIHNldDI1NTE5KHFbMl0sIGdmMSk7XG4gIE0ocVszXSwgWCwgWSk7XG4gIHNjYWxhcm11bHQocCwgcSwgcyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCBzZWVkZWQpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICB2YXIgaTtcblxuICBpZiAoIXNlZWRlZCkgcmFuZG9tYnl0ZXMoc2ssIDMyKTtcbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgc2NhbGFyYmFzZShwLCBkKTtcbiAgcGFjayhwaywgcCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNrW2krMzJdID0gcGtbaV07XG4gIHJldHVybiAwO1xufVxuXG52YXIgTCA9IG5ldyBGbG9hdDY0QXJyYXkoWzB4ZWQsIDB4ZDMsIDB4ZjUsIDB4NWMsIDB4MWEsIDB4NjMsIDB4MTIsIDB4NTgsIDB4ZDYsIDB4OWMsIDB4ZjcsIDB4YTIsIDB4ZGUsIDB4ZjksIDB4ZGUsIDB4MTQsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MTBdKTtcblxuZnVuY3Rpb24gbW9kTChyLCB4KSB7XG4gIHZhciBjYXJyeSwgaSwgaiwgaztcbiAgZm9yIChpID0gNjM7IGkgPj0gMzI7IC0taSkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgIHhbal0gKz0gY2FycnkgLSAxNiAqIHhbaV0gKiBMW2ogLSAoaSAtIDMyKV07XG4gICAgICBjYXJyeSA9IE1hdGguZmxvb3IoKHhbal0gKyAxMjgpIC8gMjU2KTtcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgfVxuICAgIHhbal0gKz0gY2Fycnk7XG4gICAgeFtpXSA9IDA7XG4gIH1cbiAgY2FycnkgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgIHhbal0gJj0gMjU1O1xuICB9XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2krMV0gKz0geFtpXSA+PiA4O1xuICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHJbaV0gPSAwO1xuICBtb2RMKHIsIHgpO1xufVxuXG4vLyBOb3RlOiBkaWZmZXJlbmNlIGZyb20gQyAtIHNtbGVuIHJldHVybmVkLCBub3QgcGFzc2VkIGFzIGFyZ3VtZW50LlxuZnVuY3Rpb24gY3J5cHRvX3NpZ24oc20sIG0sIG4sIHNrKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgaSwgaiwgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHNtWzY0ICsgaV0gPSBtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcblxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4rMzIpO1xuICByZWR1Y2Uocik7XG4gIHNjYWxhcmJhc2UocCwgcik7XG4gIHBhY2soc20sIHApO1xuXG4gIGZvciAoaSA9IDMyOyBpIDwgNjQ7IGkrKykgc21baV0gPSBza1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpK2pdICs9IGhbaV0gKiBkW2pdO1xuICAgIH1cbiAgfVxuXG4gIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgcmV0dXJuIHNtbGVuO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksXG4gICAgICBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksXG4gICAgICBkZW42ID0gZ2YoKTtcblxuICBzZXQyNTUxOShyWzJdLCBnZjEpO1xuICB1bnBhY2syNTUxOShyWzFdLCBwKTtcbiAgUyhudW0sIHJbMV0pO1xuICBNKGRlbiwgbnVtLCBEKTtcbiAgWihudW0sIG51bSwgclsyXSk7XG4gIEEoZGVuLCByWzJdLCBkZW4pO1xuXG4gIFMoZGVuMiwgZGVuKTtcbiAgUyhkZW40LCBkZW4yKTtcbiAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgTSh0LCBkZW42LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG5cbiAgcG93MjUyMyh0LCB0KTtcbiAgTSh0LCB0LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0odCwgdCwgZGVuKTtcbiAgTShyWzBdLCB0LCBkZW4pO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgTShyWzBdLCByWzBdLCBJKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcblxuICBpZiAocGFyMjU1MTkoclswXSkgPT09IChwWzMxXT4+NykpIFooclswXSwgZ2YwLCByWzBdKTtcblxuICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgcGspIHtcbiAgdmFyIGk7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgaWYgKG4gPCA2NCkgcmV0dXJuIC0xO1xuXG4gIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gLTE7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpKzMyXSA9IHBrW2ldO1xuICBjcnlwdG9faGFzaChoLCBtLCBuKTtcbiAgcmVkdWNlKGgpO1xuICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgYWRkKHAsIHEpO1xuICBwYWNrKHQsIHApO1xuXG4gIG4gLT0gNjQ7XG4gIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpICsgNjRdO1xuICByZXR1cm4gbjtcbn1cblxudmFyIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCxcbiAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTID0gMTYsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICBjcnlwdG9fc2lnbl9CWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9TRUVEQllURVMgPSAzMixcbiAgICBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuXG5uYWNsLmxvd2xldmVsID0ge1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMDogY3J5cHRvX2NvcmVfaHNhbHNhMjAsXG4gIGNyeXB0b19zdHJlYW1feG9yOiBjcnlwdG9fc3RyZWFtX3hvcixcbiAgY3J5cHRvX3N0cmVhbTogY3J5cHRvX3N0cmVhbSxcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcjogY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcixcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAsXG4gIGNyeXB0b19vbmV0aW1lYXV0aDogY3J5cHRvX29uZXRpbWVhdXRoLFxuICBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5OiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5LFxuICBjcnlwdG9fdmVyaWZ5XzE2OiBjcnlwdG9fdmVyaWZ5XzE2LFxuICBjcnlwdG9fdmVyaWZ5XzMyOiBjcnlwdG9fdmVyaWZ5XzMyLFxuICBjcnlwdG9fc2VjcmV0Ym94OiBjcnlwdG9fc2VjcmV0Ym94LFxuICBjcnlwdG9fc2VjcmV0Ym94X29wZW46IGNyeXB0b19zZWNyZXRib3hfb3BlbixcbiAgY3J5cHRvX3NjYWxhcm11bHQ6IGNyeXB0b19zY2FsYXJtdWx0LFxuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlOiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlLFxuICBjcnlwdG9fYm94X2JlZm9yZW5tOiBjcnlwdG9fYm94X2JlZm9yZW5tLFxuICBjcnlwdG9fYm94X2FmdGVybm06IGNyeXB0b19ib3hfYWZ0ZXJubSxcbiAgY3J5cHRvX2JveDogY3J5cHRvX2JveCxcbiAgY3J5cHRvX2JveF9vcGVuOiBjcnlwdG9fYm94X29wZW4sXG4gIGNyeXB0b19ib3hfa2V5cGFpcjogY3J5cHRvX2JveF9rZXlwYWlyLFxuICBjcnlwdG9faGFzaDogY3J5cHRvX2hhc2gsXG4gIGNyeXB0b19zaWduOiBjcnlwdG9fc2lnbixcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcjogY3J5cHRvX3NpZ25fa2V5cGFpcixcbiAgY3J5cHRvX3NpZ25fb3BlbjogY3J5cHRvX3NpZ25fb3BlbixcblxuICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTLFxuXG4gIGdmOiBnZixcbiAgRDogRCxcbiAgTDogTCxcbiAgcGFjazI1NTE5OiBwYWNrMjU1MTksXG4gIHVucGFjazI1NTE5OiB1bnBhY2syNTUxOSxcbiAgTTogTSxcbiAgQTogQSxcbiAgUzogUyxcbiAgWjogWixcbiAgcG93MjUyMzogcG93MjUyMyxcbiAgYWRkOiBhZGQsXG4gIHNldDI1NTE5OiBzZXQyNTUxOSxcbiAgbW9kTDogbW9kTCxcbiAgc2NhbGFybXVsdDogc2NhbGFybXVsdCxcbiAgc2NhbGFyYmFzZTogc2NhbGFyYmFzZSxcbn07XG5cbi8qIEhpZ2gtbGV2ZWwgQVBJICovXG5cbmZ1bmN0aW9uIGNoZWNrTGVuZ3RocyhrLCBuKSB7XG4gIGlmIChrLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQga2V5IHNpemUnKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG5vbmNlIHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hMZW5ndGhzKHBrLCBzaykge1xuICBpZiAocGsubGVuZ3RoICE9PSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgaWYgKHNrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXJyYXlUeXBlcygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgdHlwZSwgdXNlIFVpbnQ4QXJyYXknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbnVwKGFycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyW2ldID0gMDtcbn1cblxubmFjbC5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgcmFuZG9tYnl0ZXMoYiwgbik7XG4gIHJldHVybiBiO1xufTtcblxubmFjbC5zZWNyZXRib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIG1baStjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtc2dbaV07XG4gIGNyeXB0b19zZWNyZXRib3goYywgbSwgbS5sZW5ndGgsIG5vbmNlLCBrZXkpO1xuICByZXR1cm4gYy5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5vcGVuID0gZnVuY3Rpb24oYm94LCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhib3gsIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgKyBib3gubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrKSBjW2krY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gYm94W2ldO1xuICBpZiAoYy5sZW5ndGggPCAzMikgcmV0dXJuIG51bGw7XG4gIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG5vbmNlLCBrZXkpICE9PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG0uc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gua2V5TGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTO1xubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUztcblxubmFjbC5zY2FsYXJNdWx0ID0gZnVuY3Rpb24obiwgcCkge1xuICBjaGVja0FycmF5VHlwZXMobiwgcCk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICBpZiAocC5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5iYXNlID0gZnVuY3Rpb24obikge1xuICBjaGVja0FycmF5VHlwZXMobik7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuc2NhbGFyTGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM7XG5uYWNsLnNjYWxhck11bHQuZ3JvdXBFbGVtZW50TGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfQllURVM7XG5cbm5hY2wuYm94ID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gobXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5iZWZvcmUgPSBmdW5jdGlvbihwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICBjaGVja0JveExlbmd0aHMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyk7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgcHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gaztcbn07XG5cbm5hY2wuYm94LmFmdGVyID0gbmFjbC5zZWNyZXRib3g7XG5cbm5hY2wuYm94Lm9wZW4gPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveC5vcGVuKG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3gub3Blbi5hZnRlciA9IG5hY2wuc2VjcmV0Ym94Lm9wZW47XG5cbm5hY2wuYm94LmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fYm94X2tleXBhaXIocGssIHNrKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHBrLCBzZWNyZXRLZXkpO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLmJveC5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTO1xubmFjbC5ib3guc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUztcbm5hY2wuYm94LnNoYXJlZEtleUxlbmd0aCA9IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUztcbm5hY2wuYm94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX2JveF9OT05DRUJZVEVTO1xubmFjbC5ib3gub3ZlcmhlYWRMZW5ndGggPSBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aDtcblxubmFjbC5zaWduID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMrbXNnLmxlbmd0aCk7XG4gIGNyeXB0b19zaWduKHNpZ25lZE1zZywgbXNnLCBtc2cubGVuZ3RoLCBzZWNyZXRLZXkpO1xuICByZXR1cm4gc2lnbmVkTXNnO1xufTtcblxubmFjbC5zaWduLm9wZW4gPSBmdW5jdGlvbihzaWduZWRNc2csIHB1YmxpY0tleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2lnbmVkTXNnLCBwdWJsaWNLZXkpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShzaWduZWRNc2cubGVuZ3RoKTtcbiAgdmFyIG1sZW4gPSBjcnlwdG9fc2lnbl9vcGVuKHRtcCwgc2lnbmVkTXNnLCBzaWduZWRNc2cubGVuZ3RoLCBwdWJsaWNLZXkpO1xuICBpZiAobWxlbiA8IDApIHJldHVybiBudWxsO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KG1sZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIG1baV0gPSB0bXBbaV07XG4gIHJldHVybiBtO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgdmFyIHNpZ25lZE1zZyA9IG5hY2wuc2lnbihtc2csIHNlY3JldEtleSk7XG4gIHZhciBzaWcgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKSBzaWdbaV0gPSBzaWduZWRNc2dbaV07XG4gIHJldHVybiBzaWc7XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5ID0gZnVuY3Rpb24obXNnLCBzaWcsIHB1YmxpY0tleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzaWcsIHB1YmxpY0tleSk7XG4gIGlmIChzaWcubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9CWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzaWduYXR1cmUgc2l6ZScpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIHZhciBzbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKSBzbVtpXSA9IHNpZ1tpXTtcbiAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgc21baStjcnlwdG9fc2lnbl9CWVRFU10gPSBtc2dbaV07XG4gIHJldHVybiAoY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgc20ubGVuZ3RoLCBwdWJsaWNLZXkpID49IDApO1xufTtcblxubmFjbC5zaWduLmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBrLmxlbmd0aDsgaSsrKSBwa1tpXSA9IHNlY3JldEtleVszMitpXTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWVkKTtcbiAgaWYgKHNlZWQubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUVEQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VlZCBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHNrW2ldID0gc2VlZFtpXTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHRydWUpO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTO1xubmFjbC5zaWduLnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5zaWduLnNlZWRMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUVEQllURVM7XG5uYWNsLnNpZ24uc2lnbmF0dXJlTGVuZ3RoID0gY3J5cHRvX3NpZ25fQllURVM7XG5cbm5hY2wuaGFzaCA9IGZ1bmN0aW9uKG1zZykge1xuICBjaGVja0FycmF5VHlwZXMobXNnKTtcbiAgdmFyIGggPSBuZXcgVWludDhBcnJheShjcnlwdG9faGFzaF9CWVRFUyk7XG4gIGNyeXB0b19oYXNoKGgsIG1zZywgbXNnLmxlbmd0aCk7XG4gIHJldHVybiBoO1xufTtcblxubmFjbC5oYXNoLmhhc2hMZW5ndGggPSBjcnlwdG9faGFzaF9CWVRFUztcblxubmFjbC52ZXJpZnkgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyh4LCB5KTtcbiAgLy8gWmVybyBsZW5ndGggYXJndW1lbnRzIGFyZSBjb25zaWRlcmVkIG5vdCBlcXVhbC5cbiAgaWYgKHgubGVuZ3RoID09PSAwIHx8IHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICh2bih4LCAwLCB5LCAwLCB4Lmxlbmd0aCkgPT09IDApID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxubmFjbC5zZXRQUk5HID0gZnVuY3Rpb24oZm4pIHtcbiAgcmFuZG9tYnl0ZXMgPSBmbjtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgLy8gSW5pdGlhbGl6ZSBQUk5HIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIENTUFJORy5cbiAgLy8gSWYgbm90LCBtZXRob2RzIGNhbGxpbmcgcmFuZG9tYnl0ZXMgd2lsbCB0aHJvdy5cbiAgdmFyIGNyeXB0byA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IChzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvKSA6IG51bGw7XG4gIGlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIEJyb3dzZXJzLlxuICAgIHZhciBRVU9UQSA9IDY1NTM2O1xuICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICB2YXIgaSwgdiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gUVVPVEEpIHtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2LnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihuIC0gaSwgUVVPVEEpKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgIGNsZWFudXAodik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm9kZS5qcy5cbiAgICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgICAgdmFyIGksIHYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgICBjbGVhbnVwKHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuXG59KSh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzIDogKHNlbGYubmFjbCA9IHNlbGYubmFjbCB8fCB7fSkpO1xuIiwiKGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pO1xuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKCk7XG59KSgndXJsam9pbicsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUgKHN0ckFycmF5KSB7XG4gICAgdmFyIHJlc3VsdEFycmF5ID0gW107XG4gICAgaWYgKHN0ckFycmF5Lmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJyc7IH1cblxuICAgIGlmICh0eXBlb2Ygc3RyQXJyYXlbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVcmwgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIHN0ckFycmF5WzBdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgcGFydCBpcyBhIHBsYWluIHByb3RvY29sLCB3ZSBjb21iaW5lIGl0IHdpdGggdGhlIG5leHQgcGFydC5cbiAgICBpZiAoc3RyQXJyYXlbMF0ubWF0Y2goL15bXi86XSs6XFwvKiQvKSAmJiBzdHJBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZmlyc3QgPSBzdHJBcnJheS5zaGlmdCgpO1xuICAgICAgc3RyQXJyYXlbMF0gPSBmaXJzdCArIHN0ckFycmF5WzBdO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIG11c3QgYmUgdHdvIG9yIHRocmVlIHNsYXNoZXMgaW4gdGhlIGZpbGUgcHJvdG9jb2wsIHR3byBzbGFzaGVzIGluIGFueXRoaW5nIGVsc2UuXG4gICAgaWYgKHN0ckFycmF5WzBdLm1hdGNoKC9eZmlsZTpcXC9cXC9cXC8vKSkge1xuICAgICAgc3RyQXJyYXlbMF0gPSBzdHJBcnJheVswXS5yZXBsYWNlKC9eKFteLzpdKyk6XFwvKi8sICckMTovLy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyQXJyYXlbMF0gPSBzdHJBcnJheVswXS5yZXBsYWNlKC9eKFteLzpdKyk6XFwvKi8sICckMTovLycpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBzdHJBcnJheVtpXTtcblxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VybCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgY29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJycpIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIC8vIFJlbW92aW5nIHRoZSBzdGFydGluZyBzbGFzaGVzIGZvciBlYWNoIGNvbXBvbmVudCBidXQgdGhlIGZpcnN0LlxuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQucmVwbGFjZSgvXltcXC9dKy8sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgc3RyQXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBSZW1vdmluZyB0aGUgZW5kaW5nIHNsYXNoZXMgZm9yIGVhY2ggY29tcG9uZW50IGJ1dCB0aGUgbGFzdC5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL1tcXC9dKyQvLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgdGhlIGxhc3QgY29tcG9uZW50IHdlIHdpbGwgY29tYmluZSBtdWx0aXBsZSBzbGFzaGVzIHRvIGEgc2luZ2xlIG9uZS5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL1tcXC9dKyQvLCAnLycpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRBcnJheS5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICB9XG5cbiAgICB2YXIgc3RyID0gcmVzdWx0QXJyYXkuam9pbignLycpO1xuICAgIC8vIEVhY2ggaW5wdXQgY29tcG9uZW50IGlzIG5vdyBzZXBhcmF0ZWQgYnkgYSBzaW5nbGUgc2xhc2ggZXhjZXB0IHRoZSBwb3NzaWJsZSBmaXJzdCBwbGFpbiBwcm90b2NvbCBwYXJ0LlxuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGJlZm9yZSBwYXJhbWV0ZXJzIG9yIGhhc2hcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFwvKFxcP3wmfCNbXiFdKS9nLCAnJDEnKTtcblxuICAgIC8vIHJlcGxhY2UgPyBpbiBwYXJhbWV0ZXJzIHdpdGggJlxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnPycpO1xuICAgIHN0ciA9IHBhcnRzLnNoaWZ0KCkgKyAocGFydHMubGVuZ3RoID4gMCA/ICc/JzogJycpICsgcGFydHMuam9pbignJicpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0O1xuXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnB1dCA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZShpbnB1dCk7XG4gIH07XG5cbn0pO1xuIiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9