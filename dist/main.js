/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/post-me/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/post-me/dist/index.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ChildHandshake = ChildHandshake;
  _exports.DebugMessenger = DebugMessenger;
  _exports.ParentHandshake = ParentHandshake;
  _exports.debug = debug;
  _exports.WorkerMessenger = _exports.WindowMessenger = _exports.PortMessenger = _exports.ConcreteEmitter = _exports.BareMessenger = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var MARKER = '@post-me';

  function createUniqueIdFn() {
    var __id = 0;
    return function () {
      var id = __id;
      __id += 1;
      return id;
    };
  }
  /**
   * A concrete implementation of the {@link Emitter} interface
   *
   * @public
   */


  var ConcreteEmitter = /*#__PURE__*/function () {
    function ConcreteEmitter() {
      _classCallCheck(this, ConcreteEmitter);

      this._listeners = {};
    }
    /** {@inheritDoc Emitter.addEventListener} */


    _createClass(ConcreteEmitter, [{
      key: "addEventListener",
      value: function addEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          listeners = new Set();
          this._listeners[eventName] = listeners;
        }

        listeners.add(listener);
      }
      /** {@inheritDoc Emitter.removeEventListener} */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners["delete"](listener);
      }
      /** {@inheritDoc Emitter.once} */

    }, {
      key: "once",
      value: function once(eventName) {
        var _this = this;

        return new Promise(function (resolve) {
          var listener = function listener(data) {
            _this.removeEventListener(eventName, listener);

            resolve(data);
          };

          _this.addEventListener(eventName, listener);
        });
      }
      /** @internal */

    }, {
      key: "emit",
      value: function emit(eventName, data) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners.forEach(function (listener) {
          listener(data);
        });
      }
      /** @internal */

    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        Object.values(this._listeners).forEach(function (listeners) {
          if (listeners) {
            listeners.clear();
          }
        });
      }
    }]);

    return ConcreteEmitter;
  }();

  _exports.ConcreteEmitter = ConcreteEmitter;
  var MessageType;

  (function (MessageType) {
    MessageType["HandshakeRequest"] = "handshake-request";
    MessageType["HandshakeResponse"] = "handshake-response";
    MessageType["Call"] = "call";
    MessageType["Response"] = "response";
    MessageType["Error"] = "error";
    MessageType["Event"] = "event";
    MessageType["Callback"] = "callback";
  })(MessageType || (MessageType = {})); // Message Creators


  function createHandshakeRequestMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeRequest,
      sessionId: sessionId
    };
  }

  function createHandshakeResponseMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeResponse,
      sessionId: sessionId
    };
  }

  function createCallMessage(sessionId, requestId, methodName, args) {
    return {
      type: MARKER,
      action: MessageType.Call,
      sessionId: sessionId,
      requestId: requestId,
      methodName: methodName,
      args: args
    };
  }

  function createResponsMessage(sessionId, requestId, result, error) {
    var message = {
      type: MARKER,
      action: MessageType.Response,
      sessionId: sessionId,
      requestId: requestId
    };

    if (result !== undefined) {
      message.result = result;
    }

    if (error !== undefined) {
      message.error = error;
    }

    return message;
  }

  function createCallbackMessage(sessionId, requestId, callbackId, args) {
    return {
      type: MARKER,
      action: MessageType.Callback,
      sessionId: sessionId,
      requestId: requestId,
      callbackId: callbackId,
      args: args
    };
  }

  function createEventMessage(sessionId, eventName, payload) {
    return {
      type: MARKER,
      action: MessageType.Event,
      sessionId: sessionId,
      eventName: eventName,
      payload: payload
    };
  } // Type Guards


  function isMessage(m) {
    return m && m.type === MARKER;
  }

  function isHandshakeRequestMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeRequest;
  }

  function isHandshakeResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeResponse;
  }

  function isCallMessage(m) {
    return isMessage(m) && m.action === MessageType.Call;
  }

  function isResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.Response;
  }

  function isCallbackMessage(m) {
    return isMessage(m) && m.action === MessageType.Callback;
  }

  function isEventMessage(m) {
    return isMessage(m) && m.action === MessageType.Event;
  }

  function makeCallbackEvent(requestId) {
    return "callback_".concat(requestId);
  }

  function makeResponseEvent(requestId) {
    return "response_".concat(requestId);
  }

  var Dispatcher = /*#__PURE__*/function (_ConcreteEmitter) {
    _inherits(Dispatcher, _ConcreteEmitter);

    var _super = _createSuper(Dispatcher);

    function Dispatcher(messenger, sessionId) {
      var _this2;

      _classCallCheck(this, Dispatcher);

      _this2 = _super.call(this);
      _this2.uniqueId = createUniqueIdFn();
      _this2.messenger = messenger;
      _this2.sessionId = sessionId;
      _this2.removeMessengerListener = _this2.messenger.addMessageListener(_this2.messengerListener.bind(_assertThisInitialized(_this2)));
      return _this2;
    }

    _createClass(Dispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isCallMessage(data)) {
          this.emit(MessageType.Call, data);
        } else if (isResponseMessage(data)) {
          this.emit(makeResponseEvent(data.requestId), data);
        } else if (isEventMessage(data)) {
          this.emit(MessageType.Event, data);
        } else if (isCallbackMessage(data)) {
          this.emit(makeCallbackEvent(data.requestId), data);
        }
      }
    }, {
      key: "callOnRemote",
      value: function callOnRemote(methodName, args, transfer) {
        var requestId = this.uniqueId();
        var callbackEvent = makeCallbackEvent(requestId);
        var responseEvent = makeResponseEvent(requestId);
        var message = createCallMessage(this.sessionId, requestId, methodName, args);
        this.messenger.postMessage(message, transfer);
        return {
          callbackEvent: callbackEvent,
          responseEvent: responseEvent
        };
      }
    }, {
      key: "respondToRemote",
      value: function respondToRemote(requestId, value, error, transfer) {
        if (error instanceof Error) {
          error = {
            name: error.name,
            message: error.message
          };
        }

        var message = createResponsMessage(this.sessionId, requestId, value, error);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "callbackToRemote",
      value: function callbackToRemote(requestId, callbackId, args) {
        var message = createCallbackMessage(this.sessionId, requestId, callbackId, args);
        this.messenger.postMessage(message);
      }
    }, {
      key: "emitToRemote",
      value: function emitToRemote(eventName, payload, transfer) {
        var message = createEventMessage(this.sessionId, eventName, payload);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return Dispatcher;
  }(ConcreteEmitter);

  var ParentHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter2) {
    _inherits(ParentHandshakeDispatcher, _ConcreteEmitter2);

    var _super2 = _createSuper(ParentHandshakeDispatcher);

    function ParentHandshakeDispatcher(messenger, sessionId) {
      var _this3;

      _classCallCheck(this, ParentHandshakeDispatcher);

      _this3 = _super2.call(this);
      _this3.messenger = messenger;
      _this3.sessionId = sessionId;
      _this3.removeMessengerListener = _this3.messenger.addMessageListener(_this3.messengerListener.bind(_assertThisInitialized(_this3)));
      return _this3;
    }

    _createClass(ParentHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isHandshakeResponseMessage(data)) {
          this.emit(data.sessionId, data);
        }
      }
    }, {
      key: "initiateHandshake",
      value: function initiateHandshake() {
        var message = createHandshakeRequestMessage(this.sessionId);
        this.messenger.postMessage(message);
        return this.sessionId;
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ParentHandshakeDispatcher;
  }(ConcreteEmitter);

  var ChildHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter3) {
    _inherits(ChildHandshakeDispatcher, _ConcreteEmitter3);

    var _super3 = _createSuper(ChildHandshakeDispatcher);

    function ChildHandshakeDispatcher(messenger) {
      var _this4;

      _classCallCheck(this, ChildHandshakeDispatcher);

      _this4 = _super3.call(this);
      _this4.messenger = messenger;
      _this4.removeMessengerListener = _this4.messenger.addMessageListener(_this4.messengerListener.bind(_assertThisInitialized(_this4)));
      return _this4;
    }

    _createClass(ChildHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (isHandshakeRequestMessage(data)) {
          this.emit(MessageType.HandshakeRequest, data);
        }
      }
    }, {
      key: "acceptHandshake",
      value: function acceptHandshake(sessionId) {
        var message = createHandshakeResponseMessage(sessionId);
        this.messenger.postMessage(message);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ChildHandshakeDispatcher;
  }(ConcreteEmitter);

  var ProxyType;

  (function (ProxyType) {
    ProxyType["Callback"] = "callback";
  })(ProxyType || (ProxyType = {}));

  function createCallbackProxy(callbackId) {
    return {
      type: MARKER,
      proxy: ProxyType.Callback,
      callbackId: callbackId
    };
  }

  function isCallbackProxy(p) {
    return p && p.type === MARKER && p.proxy === ProxyType.Callback;
  }

  var ConcreteRemoteHandle = /*#__PURE__*/function (_ConcreteEmitter4) {
    _inherits(ConcreteRemoteHandle, _ConcreteEmitter4);

    var _super4 = _createSuper(ConcreteRemoteHandle);

    function ConcreteRemoteHandle(dispatcher) {
      var _this5;

      _classCallCheck(this, ConcreteRemoteHandle);

      _this5 = _super4.call(this);
      _this5._dispatcher = dispatcher;
      _this5._callTransfer = {};

      _this5._dispatcher.addEventListener(MessageType.Event, _this5._handleEvent.bind(_assertThisInitialized(_this5)));

      return _this5;
    }

    _createClass(ConcreteRemoteHandle, [{
      key: "close",
      value: function close() {
        this.removeAllListeners();
      }
    }, {
      key: "setCallTransfer",
      value: function setCallTransfer(methodName, transfer) {
        this._callTransfer[methodName] = transfer;
      }
    }, {
      key: "call",
      value: function call(methodName) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return this.customCall(methodName, args);
      }
    }, {
      key: "customCall",
      value: function customCall(methodName, args) {
        var _this6 = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return new Promise(function (resolve, reject) {
          var sanitizedArgs = [];
          var callbacks = [];
          var callbackId = 0;
          args.forEach(function (arg) {
            if (typeof arg === 'function') {
              callbacks.push(arg);
              sanitizedArgs.push(createCallbackProxy(callbackId));
              callbackId += 1;
            } else {
              sanitizedArgs.push(arg);
            }
          });
          var hasCallbacks = callbacks.length > 0;
          var callbackListener = undefined;

          if (hasCallbacks) {
            callbackListener = function callbackListener(data) {
              var callbackId = data.callbackId,
                  args = data.args;
              callbacks[callbackId].apply(callbacks, _toConsumableArray(args));
            };
          }

          var transfer = options.transfer;

          if (transfer === undefined && _this6._callTransfer[methodName]) {
            var _this6$_callTransfer;

            transfer = (_this6$_callTransfer = _this6._callTransfer)[methodName].apply(_this6$_callTransfer, sanitizedArgs);
          }

          var _this6$_dispatcher$ca = _this6._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer),
              callbackEvent = _this6$_dispatcher$ca.callbackEvent,
              responseEvent = _this6$_dispatcher$ca.responseEvent;

          if (hasCallbacks) {
            _this6._dispatcher.addEventListener(callbackEvent, callbackListener);
          }

          _this6._dispatcher.once(responseEvent).then(function (response) {
            if (callbackListener) {
              _this6._dispatcher.removeEventListener(callbackEvent, callbackListener);
            }

            var result = response.result,
                error = response.error;

            if (error !== undefined) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        });
      }
    }, {
      key: "_handleEvent",
      value: function _handleEvent(data) {
        var eventName = data.eventName,
            payload = data.payload;
        this.emit(eventName, payload);
      }
    }]);

    return ConcreteRemoteHandle;
  }(ConcreteEmitter);

  var ConcreteLocalHandle = /*#__PURE__*/function () {
    function ConcreteLocalHandle(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteLocalHandle);

      this._dispatcher = dispatcher;
      this._methods = localMethods;
      this._returnTransfer = {};
      this._emitTransfer = {};

      this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));
    }

    _createClass(ConcreteLocalHandle, [{
      key: "emit",
      value: function emit(eventName, payload) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var transfer = options.transfer;

        if (transfer === undefined && this._emitTransfer[eventName]) {
          transfer = this._emitTransfer[eventName](payload);
        }

        this._dispatcher.emitToRemote(eventName, payload, transfer);
      }
    }, {
      key: "setMethods",
      value: function setMethods(methods) {
        this._methods = methods;
      }
    }, {
      key: "setMethod",
      value: function setMethod(methodName, method) {
        this._methods[methodName] = method;
      }
    }, {
      key: "setReturnTransfer",
      value: function setReturnTransfer(methodName, transfer) {
        this._returnTransfer[methodName] = transfer;
      }
    }, {
      key: "setEmitTransfer",
      value: function setEmitTransfer(eventName, transfer) {
        this._emitTransfer[eventName] = transfer;
      }
    }, {
      key: "_handleCall",
      value: function _handleCall(data) {
        var _this7 = this;

        var requestId = data.requestId,
            methodName = data.methodName,
            args = data.args;
        var callMethod = new Promise(function (resolve, reject) {
          var _this7$_methods;

          var method = _this7._methods[methodName];

          if (typeof method !== 'function') {
            reject(new Error("The method \"".concat(methodName, "\" has not been implemented.")));
            return;
          }

          var desanitizedArgs = args.map(function (arg) {
            if (isCallbackProxy(arg)) {
              var callbackId = arg.callbackId;
              return function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this7._dispatcher.callbackToRemote(requestId, callbackId, args);
              };
            } else {
              return arg;
            }
          });
          Promise.resolve((_this7$_methods = _this7._methods)[methodName].apply(_this7$_methods, _toConsumableArray(desanitizedArgs))).then(resolve)["catch"](reject);
        });
        callMethod.then(function (result) {
          var transfer;

          if (_this7._returnTransfer[methodName]) {
            transfer = _this7._returnTransfer[methodName](result);
          }

          _this7._dispatcher.respondToRemote(requestId, result, undefined, transfer);
        })["catch"](function (error) {
          _this7._dispatcher.respondToRemote(requestId, undefined, error);
        });
      }
    }]);

    return ConcreteLocalHandle;
  }();

  var ConcreteConnection = /*#__PURE__*/function () {
    function ConcreteConnection(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteConnection);

      this._dispatcher = dispatcher;
      this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);
      this._remoteHandle = new ConcreteRemoteHandle(dispatcher);
    }

    _createClass(ConcreteConnection, [{
      key: "close",
      value: function close() {
        this._dispatcher.close();

        this.remoteHandle().close();
      }
    }, {
      key: "localHandle",
      value: function localHandle() {
        return this._localHandle;
      }
    }, {
      key: "remoteHandle",
      value: function remoteHandle() {
        return this._remoteHandle;
      }
    }]);

    return ConcreteConnection;
  }();

  var uniqueSessionId = createUniqueIdFn();

  var runUntil = function runUntil(worker, condition, unfulfilled, maxAttempts, attemptInterval) {
    var attempt = 0;

    var fn = function fn() {
      if (!condition() && (attempt < maxAttempts || maxAttempts < 1)) {
        worker();
        attempt += 1;
        setTimeout(fn, attemptInterval);
      } else if (!condition() && attempt >= maxAttempts && maxAttempts >= 1) {
        unfulfilled();
      }
    };

    fn();
  };
  /**
   * Initiate the handshake from the Parent side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @param maxAttempts - The maximum number of handshake attempts
   * @param attemptsInterval - The interval between handshake attempts
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ParentHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
    var attemptsInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
    var thisSessionId = uniqueSessionId();
    var connected = false;
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ParentHandshakeDispatcher(messenger, thisSessionId);
      handshakeDispatcher.once(thisSessionId).then(function (response) {
        connected = true;
        handshakeDispatcher.close();
        var sessionId = response.sessionId;
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
      runUntil(function () {
        return handshakeDispatcher.initiateHandshake();
      }, function () {
        return connected;
      }, function () {
        return reject(new Error("Handshake failed, reached maximum number of attempts"));
      }, maxAttempts, attemptsInterval);
    });
  }
  /**
   * Initiate the handshake from the Child side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ChildHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ChildHandshakeDispatcher(messenger);
      handshakeDispatcher.once(MessageType.HandshakeRequest).then(function (response) {
        var sessionId = response.sessionId;
        handshakeDispatcher.acceptHandshake(sessionId);
        handshakeDispatcher.close();
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
    });
  }

  var acceptableMessageEvent = function acceptableMessageEvent(event, remoteWindow, acceptedOrigin) {
    var source = event.source,
        origin = event.origin;

    if (source !== remoteWindow) {
      return false;
    }

    if (origin !== acceptedOrigin && acceptedOrigin !== '*') {
      return false;
    }

    return true;
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with another Window.
   *
   * @public
   *
   */


  var WindowMessenger = function WindowMessenger(_ref) {
    var localWindow = _ref.localWindow,
        remoteWindow = _ref.remoteWindow,
        remoteOrigin = _ref.remoteOrigin;

    _classCallCheck(this, WindowMessenger);

    localWindow = localWindow || window;

    this.postMessage = function (message, transfer) {
      remoteWindow.postMessage(message, remoteOrigin, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        if (acceptableMessageEvent(event, remoteWindow, remoteOrigin)) {
          listener(event);
        }
      };

      localWindow.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        localWindow.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /** @public */


  _exports.WindowMessenger = WindowMessenger;

  var BareMessenger = function BareMessenger(postable) {
    _classCallCheck(this, BareMessenger);

    this.postMessage = function (message) {
      var transfer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      postable.postMessage(message, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        listener(event);
      };

      postable.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        postable.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a Worker.
   *
   * Takes a {@link Postable} representing the `Worker` (when calling from
   * the parent context) or the `self` `DedicatedWorkerGlobalScope` object
   * (when calling from the child context).
   *
   * @public
   *
   */


  _exports.BareMessenger = BareMessenger;

  var WorkerMessenger = /*#__PURE__*/function (_BareMessenger) {
    _inherits(WorkerMessenger, _BareMessenger);

    var _super5 = _createSuper(WorkerMessenger);

    function WorkerMessenger(_ref2) {
      var worker = _ref2.worker;

      _classCallCheck(this, WorkerMessenger);

      return _super5.call(this, worker);
    }

    return WorkerMessenger;
  }(BareMessenger);
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a MessagePort.
   *
   * @public
   *
   */


  _exports.WorkerMessenger = WorkerMessenger;

  var PortMessenger = /*#__PURE__*/function (_BareMessenger2) {
    _inherits(PortMessenger, _BareMessenger2);

    var _super6 = _createSuper(PortMessenger);

    function PortMessenger(_ref3) {
      var port = _ref3.port;

      _classCallCheck(this, PortMessenger);

      port.start();
      return _super6.call(this, port);
    }

    return PortMessenger;
  }(BareMessenger);
  /**
   * Create a logger function with a specific namespace
   *
   * @param namespace - The namespace will be prepended to all the arguments passed to the logger function
   * @param log - The underlying logger (`console.log` by default)
   *
   * @public
   *
   */


  _exports.PortMessenger = PortMessenger;

  function debug(namespace, log) {
    log = log || console.debug || console.log || function () {};

    return function () {
      for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        data[_key3] = arguments[_key3];
      }

      log.apply(void 0, [namespace].concat(data));
    };
  }
  /**
   * Decorate a {@link Messenger} so that it will log any message exchanged
   * @param messenger - The Messenger that will be decorated
   * @param log - The logger function that will receive each message
   * @returns A decorated Messenger
   *
   * @public
   *
   */


  function DebugMessenger(messenger, log) {
    log = log || debug('post-me');

    var debugListener = function debugListener(event) {
      var data = event.data;
      log('⬅️ received message', data);
    };

    messenger.addMessageListener(debugListener);
    return {
      postMessage: function postMessage(message, transfer) {
        log('➡️ sending message', message);
        messenger.postMessage(message, transfer);
      },
      addMessageListener: function addMessageListener(listener) {
        return messenger.addMessageListener(listener);
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/client.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkynetClient = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/skynet-js/node_modules/axios/index.js"));
const upload_1 = __webpack_require__(/*! ./upload */ "./node_modules/skynet-js/dist/cjs/upload.js");
const download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
const file_1 = __webpack_require__(/*! ./file */ "./node_modules/skynet-js/dist/cjs/file.js");
const skydb_1 = __webpack_require__(/*! ./skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const mysky_1 = __webpack_require__(/*! ./mysky */ "./node_modules/skynet-js/dist/cjs/mysky/index.js");
const utils_1 = __webpack_require__(/*! ./mysky/utils */ "./node_modules/skynet-js/dist/cjs/mysky/utils.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * The Skynet Client which can be used to access Skynet.
 */
class SkynetClient {
    /**
     * The Skynet Client which can be used to access Skynet.
     *
     * @class
     * @param [initialPortalUrl] The initial portal URL to use to access Skynet, if specified. A request will be made to this URL to get the actual portal URL. To use the default portal while passing custom options, pass "".
     * @param [customOptions] Configuration for the client.
     */
    constructor(initialPortalUrl = "", customOptions = {}) {
        // Set methods (defined in other files).
        // Upload
        this.uploadFile = upload_1.uploadFile;
        this.uploadFileRequest = upload_1.uploadFileRequest;
        this.uploadDirectory = upload_1.uploadDirectory;
        this.uploadDirectoryRequest = upload_1.uploadDirectoryRequest;
        // Download
        this.downloadFile = download_1.downloadFile;
        this.downloadFileHns = download_1.downloadFileHns;
        this.getSkylinkUrl = download_1.getSkylinkUrl;
        this.getHnsUrl = download_1.getHnsUrl;
        this.getHnsresUrl = download_1.getHnsresUrl;
        this.getMetadata = download_1.getMetadata;
        this.getFileContent = download_1.getFileContent;
        this.getFileContentHns = download_1.getFileContentHns;
        this.getFileContentRequest = download_1.getFileContentRequest;
        this.openFile = download_1.openFile;
        this.openFileHns = download_1.openFileHns;
        this.resolveHns = download_1.resolveHns;
        // MySky
        this.extractDomain = utils_1.extractDomain;
        this.getFullDomainUrl = utils_1.getFullDomainUrl;
        this.loadMySky = mysky_1.loadMySky;
        // File API
        this.file = {
            getJSON: file_1.getJSON.bind(this),
            getEntryData: file_1.getEntryData.bind(this),
            getEntryLink: file_1.getEntryLink.bind(this),
        };
        // SkyDB
        this.db = {
            deleteJSON: skydb_1.deleteJSON.bind(this),
            getJSON: skydb_1.getJSON.bind(this),
            setJSON: skydb_1.setJSON.bind(this),
            setDataLink: skydb_1.setDataLink.bind(this),
        };
        // SkyDB helpers
        this.registry = {
            getEntry: registry_1.getEntry.bind(this),
            getEntryUrl: registry_1.getEntryUrl.bind(this),
            getEntryLink: registry_1.getEntryLink.bind(this),
            setEntry: registry_1.setEntry.bind(this),
            postSignedEntry: registry_1.postSignedEntry.bind(this),
        };
        if (initialPortalUrl === "") {
            // Portal was not given, use the default portal URL. We'll still make a request for the resolved portal URL.
            initialPortalUrl = url_1.defaultPortalUrl();
        }
        else {
            // Portal was given, don't make the request for the resolved portal URL.
            this.givenPortalUrl = initialPortalUrl;
        }
        this.initialPortalUrl = initialPortalUrl;
        this.customOptions = customOptions;
    }
    /**
     * Make the request for the API portal URL.
     *
     * @returns - A promise that resolves when the request is complete.
     */
    /* istanbul ignore next */
    async initPortalUrl() {
        if (!SkynetClient.resolvedPortalUrl) {
            SkynetClient.resolvedPortalUrl = new Promise((resolve, reject) => {
                this.executeRequest({
                    ...this.customOptions,
                    method: "head",
                    url: this.initialPortalUrl,
                    endpointPath: "/",
                }).then((response) => {
                    if (typeof response.headers === "undefined") {
                        reject(new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists."));
                    }
                    const portalUrl = response.headers["skynet-portal-api"];
                    if (!portalUrl) {
                        reject(new Error("Could not get portal URL for the given portal"));
                    }
                    resolve(string_1.trimSuffix(portalUrl, "/"));
                });
            });
        }
        await SkynetClient.resolvedPortalUrl;
        return;
    }
    /**
     * Returns the API portal URL. Makes the request to get it if not done so already.
     *
     * @returns - the portal URL.
     */
    /* istanbul ignore next */
    async portalUrl() {
        if (this.givenPortalUrl) {
            return this.givenPortalUrl;
        }
        // Make the request if needed and not done so.
        this.initPortalUrl();
        return await SkynetClient.resolvedPortalUrl; // eslint-disable-line
    }
    /**
     * Creates and executes a request.
     *
     * @param config - Configuration for the request.
     * @returns - The response from axios.
     * @throws - Will throw if unimplemented options have been passed in.
     */
    async executeRequest(config) {
        var _a;
        // Build the URL.
        let url = config.url;
        if (!url) {
            const portalUrl = await this.portalUrl();
            url = url_1.makeUrl(portalUrl, config.endpointPath, (_a = config.extraPath) !== null && _a !== void 0 ? _a : "");
        }
        if (config.query) {
            url = url_1.addUrlQuery(url, config.query);
        }
        // Build headers.
        const headers = { ...config.headers };
        // Set some headers from common options.
        if (config.customUserAgent) {
            headers["User-Agent"] = config.customUserAgent;
        }
        if (config.customCookie) {
            headers["Cookie"] = config.customCookie;
        }
        const auth = config.APIKey ? { username: "", password: config.APIKey } : undefined;
        /* istanbul ignore next */
        const onUploadProgress = config.onUploadProgress &&
            function (event) {
                const progress = event.loaded / event.total;
                // Need the if-statement or TS complains.
                if (config.onUploadProgress)
                    config.onUploadProgress(progress, event);
            };
        return axios_1.default({
            url,
            method: config.method,
            data: config.data,
            headers,
            auth,
            onUploadProgress,
            transformRequest: config.transformRequest,
            transformResponse: config.transformResponse,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            // Allow cross-site cookies.
            withCredentials: true,
        });
    }
}
exports.SkynetClient = SkynetClient;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/crypto.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/crypto.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashRegistryEntry = exports.hashDataKey = exports.hashAll = exports.genKeyPairFromSeed = exports.genKeyPairAndSeed = exports.deriveChildSeed = void 0;
const sjcl_1 = __webpack_require__(/*! sjcl */ "./node_modules/skynet-js/node_modules/sjcl/sjcl.js");
const blakejs_1 = __webpack_require__(/*! blakejs */ "./node_modules/skynet-js/node_modules/blakejs/index.js");
const randombytes_1 = __importDefault(__webpack_require__(/*! randombytes */ "./node_modules/skynet-js/node_modules/randombytes/browser.js"));
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/skynet-js/node_modules/tweetnacl/nacl-fast.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const encoding_1 = __webpack_require__(/*! ./utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
/**
 * Returns a blake2b 256bit hasher. See `NewHash` in Sia.
 *
 * @returns - blake2b 256bit hasher.
 */
function newHash() {
    return blakejs_1.blake2bInit(32, null);
}
/**
 * Derives a child seed from the given master seed and sub seed.
 *
 * @param masterSeed - The master seed to derive from.
 * @param seed - The sub seed for the derivation.
 * @returns - The child seed derived from `masterSeed` using `seed`.
 * @throws - Will throw if the inputs are not strings.
 */
function deriveChildSeed(masterSeed, seed) {
    validation_1.validateString("masterSeed", masterSeed, "parameter");
    validation_1.validateString("seed", seed, "parameter");
    return string_1.toHexString(hashAll(encoding_1.encodeUtf8String(masterSeed), encoding_1.encodeUtf8String(seed)));
}
exports.deriveChildSeed = deriveChildSeed;
/**
 * Generates a master key pair and seed.
 *
 * @param [length=64] - The number of random bytes for the seed. Note that the string seed will be converted to hex representation, making it twice this length.
 * @returns - The generated key pair and seed.
 */
function genKeyPairAndSeed(length = 64) {
    validation_1.validateNumber("length", length, "parameter");
    const seed = makeSeed(length);
    return { ...genKeyPairFromSeed(seed), seed };
}
exports.genKeyPairAndSeed = genKeyPairAndSeed;
/**
 * Generates a public and private key from a provided, secure seed.
 *
 * @param seed - A secure seed.
 * @returns - The generated key pair.
 * @throws - Will throw if the input is not a string.
 */
function genKeyPairFromSeed(seed) {
    validation_1.validateString("seed", seed, "parameter");
    // Get a 32-byte key.
    const derivedKey = sjcl_1.misc.pbkdf2(seed, "", 1000, 32 * 8);
    const derivedKeyHex = sjcl_1.codec.hex.fromBits(derivedKey);
    const { publicKey, secretKey } = tweetnacl_1.sign.keyPair.fromSeed(string_1.hexToUint8Array(derivedKeyHex));
    return { publicKey: string_1.toHexString(publicKey), privateKey: string_1.toHexString(secretKey) };
}
exports.genKeyPairFromSeed = genKeyPairFromSeed;
/**
 * Takes all given arguments and hashes them.
 *
 * @param args - Byte arrays to hash.
 * @returns - The final hash as a byte array.
 */
function hashAll(...args) {
    const hasher = newHash();
    for (let i = 0; i < args.length; i++) {
        blakejs_1.blake2bUpdate(hasher, args[i]);
    }
    return blakejs_1.blake2bFinal(hasher);
}
exports.hashAll = hashAll;
/**
 * Hash the given data key.
 *
 * @param dataKey - Data key to hash.
 * @returns - Hash of the data key.
 */
function hashDataKey(dataKey) {
    return hashAll(encoding_1.encodeUtf8String(dataKey));
}
exports.hashDataKey = hashDataKey;
/**
 * Hashes the given registry entry.
 *
 * @param registryEntry - Registry entry to hash.
 * @param hashedDataKeyHex - Whether the data key is already hashed and in hex format. If not, we hash the data key.
 * @returns - Hash of the registry entry.
 */
function hashRegistryEntry(registryEntry, hashedDataKeyHex) {
    let dataKeyBytes;
    if (hashedDataKeyHex) {
        dataKeyBytes = string_1.hexToUint8Array(registryEntry.dataKey);
    }
    else {
        dataKeyBytes = hashDataKey(registryEntry.dataKey);
    }
    const dataBytes = encoding_1.encodePrefixedBytes(registryEntry.data);
    return hashAll(dataKeyBytes, dataBytes, encoding_1.encodeBigintAsUint64(registryEntry.revision));
}
exports.hashRegistryEntry = hashRegistryEntry;
/**
 * Generates a random seed of the given length in bytes.
 *
 * @param length - Length of the seed in bytes.
 * @returns - The generated seed.
 */
function makeSeed(length) {
    // Cryptographically-secure random number generator. It should use the
    // built-in crypto.getRandomValues in the browser.
    const array = randombytes_1.default(length);
    return string_1.toHexString(array);
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/download.js":
/*!*****************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/download.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHns = exports.openFileHns = exports.openFile = exports.getFileContentRequest = exports.getFileContentHns = exports.getFileContent = exports.getMetadata = exports.getHnsresUrl = exports.getHnsUrl = exports.getSkylinkUrlForPortal = exports.getSkylinkUrl = exports.downloadFileHns = exports.downloadFile = exports.defaultDownloadOptions = void 0;
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
const parse_1 = __webpack_require__(/*! ./skylink/parse */ "./node_modules/skynet-js/dist/cjs/skylink/parse.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultDownloadOptions = {
    ...options_1.defaultBaseOptions,
    endpointDownload: "/",
    download: false,
    path: undefined,
    range: undefined,
    query: undefined,
    subdomain: false,
};
const defaultGetMetadataOptions = {
    endpointGetMetadata: "/skynet/metadata",
    query: undefined,
};
const defaultDownloadHnsOptions = {
    ...exports.defaultDownloadOptions,
    endpointDownloadHns: "hns",
    hnsSubdomain: "hns",
    // Default to subdomain format for HNS URLs.
    subdomain: true,
};
const defaultResolveHnsOptions = {
    ...options_1.defaultBaseOptions,
    endpointResolveHns: "hnsres",
};
/**
 * Initiates a download of the content of the skylink within the browser.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - 46-character skylink, or a valid skylink URL. Can be followed by a path. Note that the skylink will not be encoded, so if your path might contain special characters, consider using `customOptions.path`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownload="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function downloadFile(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions, download: true };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    // Download the url.
    window.location.assign(url);
    return url;
}
exports.downloadFile = downloadFile;
/**
 * Initiates a download of the content of the skylink at the Handshake domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownloadHns="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the input domain is not a string.
 */
async function downloadFileHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions, download: true };
    const url = await this.getHnsUrl(domain, opts);
    // Download the url.
    window.location.assign(url);
    return url;
}
exports.downloadFileHns = downloadFileHns;
/**
 * Constructs the full URL for the given skylink.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownload="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getSkylinkUrl(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrlForPortal`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const portalUrl = await this.portalUrl();
    return getSkylinkUrlForPortal(portalUrl, skylinkUrl, opts);
}
exports.getSkylinkUrl = getSkylinkUrl;
/**
 * Gets the skylink URL without an initialized client.
 *
 * @param portalUrl - The portal URL.
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownload="/"] - The relative URL path of the portal endpoint.
 * @returns - The full URL for the skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
function getSkylinkUrlForPortal(portalUrl, skylinkUrl, customOptions) {
    var _a, _b;
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("skylinkUrl", skylinkUrl, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultDownloadOptions);
    const opts = { ...exports.defaultDownloadOptions, ...customOptions };
    const query = (_a = opts.query) !== null && _a !== void 0 ? _a : {};
    if (opts.download) {
        // Set the "attachment" parameter.
        query.attachment = true;
    }
    // URL-encode the path.
    let path = "";
    if (opts.path) {
        if (typeof opts.path !== "string") {
            throw new Error(`opts.path has to be a string, ${typeof opts.path} provided`);
        }
        // Encode each element of the path separately and join them.
        //
        // Don't use encodeURI because it does not encode characters such as '?'
        // etc. These are allowed as filenames on Skynet and should be encoded so
        // they are not treated as URL separators.
        path = opts.path
            .split("/")
            .map((element) => encodeURIComponent(element))
            .join("/");
    }
    let url;
    if (opts.subdomain) {
        // Get the path from the skylink. Use the empty string if not found.
        const skylinkPath = (_b = parse_1.parseSkylink(skylinkUrl, { onlyPath: true })) !== null && _b !== void 0 ? _b : "";
        // Get just the skylink.
        let skylink = parse_1.parseSkylink(skylinkUrl);
        if (skylink === null) {
            throw new Error(`Could not get skylink out of input '${skylinkUrl}'`);
        }
        // Convert the skylink (without the path) to base32.
        skylink = format_1.convertSkylinkToBase32(skylink);
        url = url_1.addSubdomain(portalUrl, skylink);
        url = url_1.makeUrl(url, skylinkPath, path);
    }
    else {
        // Get the skylink including the path.
        const skylink = parse_1.parseSkylink(skylinkUrl, { includePath: true });
        if (skylink === null) {
            throw new Error(`Could not get skylink with path out of input '${skylinkUrl}'`);
        }
        // Add additional path if passed in.
        url = url_1.makeUrl(portalUrl, opts.endpointDownload, skylink);
        url = url_1.makeUrl(url, path);
    }
    return url_1.addUrlQuery(url, query);
}
exports.getSkylinkUrlForPortal = getSkylinkUrlForPortal;
/**
 * Constructs the full URL for the given HNS domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownloadHns="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the HNS domain.
 * @throws - Will throw if the input domain is not a string.
 */
async function getHnsUrl(domain, customOptions) {
    var _a;
    validation_1.validateString("domain", domain, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultDownloadHnsOptions);
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const query = (_a = opts.query) !== null && _a !== void 0 ? _a : {};
    if (opts.download) {
        query.attachment = true;
    }
    domain = string_1.trimUriPrefix(domain, url_1.uriHandshakePrefix);
    const portalUrl = await this.portalUrl();
    const url = opts.subdomain
        ? url_1.addSubdomain(url_1.addSubdomain(portalUrl, opts.hnsSubdomain), domain)
        : url_1.makeUrl(portalUrl, opts.endpointDownloadHns, domain);
    return url_1.addUrlQuery(url, query);
}
exports.getHnsUrl = getHnsUrl;
/**
 * Constructs the full URL for the resolver for the given HNS domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointResolveHns="/hnsres"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL for the resolver for the HNS domain.
 * @throws - Will throw if the input domain is not a string.
 */
async function getHnsresUrl(domain, customOptions) {
    validation_1.validateString("domain", domain, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultResolveHnsOptions);
    const opts = { ...defaultResolveHnsOptions, ...this.customOptions, ...customOptions };
    domain = string_1.trimUriPrefix(domain, url_1.uriHandshakePrefix);
    const portalUrl = await this.portalUrl();
    return url_1.makeUrl(portalUrl, opts.endpointResolveHns, domain);
}
exports.getHnsresUrl = getHnsresUrl;
/**
 * Gets only the metadata for the given skylink without the contents.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFile` for the full list.
 * @param [customOptions.endpointGetMetadata="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The metadata in JSON format. Empty if no metadata was found.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getMetadata(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    var _a;
    const opts = { ...defaultGetMetadataOptions, ...this.customOptions, ...customOptions };
    // Don't include the path for now since the endpoint doesn't support it.
    const path = parse_1.parseSkylink(skylinkUrl, { onlyPath: true });
    if (path) {
        throw new Error("Skylink string should not contain a path");
    }
    const getSkylinkUrlOpts = { endpointDownload: opts.endpointGetMetadata, query: opts.query };
    const url = await this.getSkylinkUrl(skylinkUrl, getSkylinkUrlOpts);
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointGetMetadata,
        method: "GET",
        url,
    });
    validateGetMetadataResponse(response);
    const metadata = response.data;
    if (typeof response.headers === "undefined") {
        throw new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    const portalUrl = (_a = response.headers["skynet-portal-api"]) !== null && _a !== void 0 ? _a : "";
    const skylink = response.headers["skynet-skylink"] ? format_1.formatSkylink(response.headers["skynet-skylink"]) : "";
    return { metadata, portalUrl, skylink };
}
exports.getMetadata = getMetadata;
/**
 * Gets the contents of the file at the given skylink.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownload="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function getFileContent(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    return this.getFileContentRequest(url, opts);
}
exports.getFileContent = getFileContent;
/**
 * Gets the contents of the file at the given Handshake domain.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointDownloadHns="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the domain does not contain a skylink.
 */
async function getFileContentHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsUrl(domain, opts);
    return this.getFileContentRequest(url, opts);
}
exports.getFileContentHns = getFileContentHns;
/**
 * Does a GET request of the skylink, returning the data property of the response.
 *
 * @param this - SkynetClient
 * @param url - URL.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An object containing the data of the file, the content-type, metadata, and the file's skylink.
 * @throws - Will throw if the request does not succeed or the response is missing data.
 */
async function getFileContentRequest(url, customOptions) {
    // Not publicly available, don't validate input.
    var _a, _b;
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const headers = opts.range ? { Range: opts.range } : undefined;
    // GET request the data at the skylink.
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointDownload,
        method: "get",
        url,
        headers,
    });
    if (typeof response.data === "undefined") {
        throw new Error("Did not get 'data' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    if (typeof response.headers === "undefined") {
        throw new Error("Did not get 'headers' in response despite a successful request. Please try again and report this issue to the devs if it persists.");
    }
    const contentType = (_a = response.headers["content-type"]) !== null && _a !== void 0 ? _a : "";
    const portalUrl = (_b = response.headers["skynet-portal-api"]) !== null && _b !== void 0 ? _b : "";
    const skylink = response.headers["skynet-skylink"] ? format_1.formatSkylink(response.headers["skynet-skylink"]) : "";
    return { data: response.data, contentType, portalUrl, skylink };
}
exports.getFileContentRequest = getFileContentRequest;
/**
 * Opens the content of the skylink within the browser.
 *
 * @param this - SkynetClient
 * @param skylinkUrl - Skylink string. See `downloadFile`.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFile` for the full list.
 * @param [customOptions.endpointDownload="/"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the skylinkUrl does not contain a skylink or if the path option is not a string.
 */
async function openFile(skylinkUrl, customOptions) {
    // Validation is done in `getSkylinkUrl`.
    const opts = { ...exports.defaultDownloadOptions, ...this.customOptions, ...customOptions };
    const url = await this.getSkylinkUrl(skylinkUrl, opts);
    window.open(url, "_blank");
    return url;
}
exports.openFile = openFile;
/**
 * Opens the content of the skylink from the given Handshake domain within the browser.
 *
 * @param this - SkynetClient
 * @param domain - Handshake domain.
 * @param [customOptions] - Additional settings that can optionally be set. See `downloadFileHns` for the full list.
 * @param [customOptions.endpointDownloadHns="/hns"] - The relative URL path of the portal endpoint to contact.
 * @returns - The full URL that was used.
 * @throws - Will throw if the input domain is not a string.
 */
async function openFileHns(domain, customOptions) {
    // Validation is done in `getHnsUrl`.
    const opts = { ...defaultDownloadHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsUrl(domain, opts);
    // Open the url in a new tab.
    window.open(url, "_blank");
    return url;
}
exports.openFileHns = openFileHns;
/**
 * Resolves the given HNS domain to its skylink and returns it and the raw data.
 *
 * @param this - SkynetClient
 * @param domain - Handshake resolver domain.
 * @param [customOptions={}] - Additional settings that can optionally be set.
 * @param [customOptions.endpointResolveHns="/hnsres"] - The relative URL path of the portal endpoint to contact.
 * @returns - The raw data and corresponding skylink.
 * @throws - Will throw if the input domain is not a string.
 */
async function resolveHns(domain, customOptions) {
    // Validation is done in `getHnsresUrl`.
    const opts = { ...defaultResolveHnsOptions, ...this.customOptions, ...customOptions };
    const url = await this.getHnsresUrl(domain, opts);
    // Get the txt record from the hnsres domain on the portal.
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointResolveHns,
        method: "get",
        url,
    });
    validateResolveHnsResponse(response);
    if (response.data.skylink) {
        return { data: response.data, skylink: response.data.skylink };
    }
    else {
        const skylink = await this.registry.getEntryLink(response.data.registry.publickey, response.data.registry.datakey, {
            hashedDataKeyHex: true,
        });
        return { data: response.data, skylink };
    }
}
exports.resolveHns = resolveHns;
/**
 * @param response
 */
function validateGetMetadataResponse(response) {
    try {
        if (!response.data) {
            throw new Error("response.data field missing");
        }
    }
    catch (err) {
        throw new Error(`Metadata response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
}
/**
 * @param response
 */
function validateResolveHnsResponse(response) {
    try {
        if (!response.data) {
            throw new Error("response.data field missing");
        }
        if (response.data.skylink) {
            validation_1.validateString("response.data.skylink", response.data.skylink, "resolveHns response field");
        }
        else if (response.data.registry) {
            validation_1.validateObject("response.data.registry", response.data.registry, "resolveHns response field");
            validation_1.validateString("response.data.registry.publickey", response.data.registry.publickey, "resolveHns response field");
            validation_1.validateString("response.data.registry.datakey", response.data.registry.datakey, "resolveHns response field");
        }
        else {
            validation_1.throwValidationError("response.data", response.data, "response data object", "object containing skylink or registry field");
        }
    }
    catch (err) {
        throw new Error(`Did not get a complete resolve HNS response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/file.js":
/*!*************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/file.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEntryData = exports.getEntryLink = exports.getJSON = void 0;
const tweak_1 = __webpack_require__(/*! ./mysky/tweak */ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js");
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const skydb_1 = __webpack_require__(/*! ./skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * Gets Discoverable JSON set with MySky at the given data path for the given
 * public user ID.
 *
 * @param this - SkynetClient
 * @param userID - The MySky public user ID.
 * @param path - The data path.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An object containing the json data as well as the skylink for the data.
 */
async function getJSON(userID, path, customOptions) {
    validation_1.validateString("userID", userID, "parameter");
    validation_1.validateString("path", path, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultGetJSONOptions);
    const opts = {
        ...skydb_1.defaultGetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const dataKey = tweak_1.deriveDiscoverableTweak(path);
    opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
    return await this.db.getJSON(userID, dataKey, opts);
}
exports.getJSON = getJSON;
/**
 * Gets the entry link for the entry set with MySky at the given data path, for
 * the given public user ID. This is a v2 skylink. This link stays the same even
 * if the content at the entry changes.
 *
 * @param this - SkynetClient
 * @param userID - The MySky public user ID.
 * @param path - The data path.
 * @returns - The entry link.
 */
async function getEntryLink(userID, path) {
    validation_1.validateString("userID", userID, "parameter");
    validation_1.validateString("path", path, "parameter");
    const dataKey = tweak_1.deriveDiscoverableTweak(path);
    const opts = registry_1.defaultGetEntryOptions;
    opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
    return await this.registry.getEntryLink(userID, dataKey, opts);
}
exports.getEntryLink = getEntryLink;
/**
 * Gets the entry data for the entry set with MySky at the given data path, for
 * the given public user ID.
 *
 * @param this - SkynetClient
 * @param userID - The MySky public user ID.
 * @param path - The data path.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The entry data.
 */
async function getEntryData(userID, path, customOptions) {
    validation_1.validateString("userID", userID, "parameter");
    validation_1.validateString("path", path, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", registry_1.defaultGetEntryOptions);
    const opts = {
        ...registry_1.defaultGetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const dataKey = tweak_1.deriveDiscoverableTweak(path);
    opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
    const { entry } = await this.registry.getEntry(userID, dataKey, opts);
    if (!entry) {
        return { data: null };
    }
    return { data: entry.data };
}
exports.getEntryData = getEntryData;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermLegacySkyID = exports.PermDiscoverable = exports.PermHidden = exports.PermWrite = exports.PermRead = exports.PermType = exports.PermCategory = exports.Permission = exports.uriSkynetPrefix = exports.uriHandshakePrefix = exports.getFullDomainUrlForPortal = exports.extractDomainForPortal = exports.defaultSkynetPortalUrl = exports.defaultPortalUrl = exports.uint8ArrayToStringUtf8 = exports.stringToUint8ArrayUtf8 = exports.MAX_REVISION = exports.getRootDirectory = exports.getRelativeFilePath = exports.isSkylinkV2 = exports.isSkylinkV1 = exports.parseSkylink = exports.convertSkylinkToBase64 = exports.convertSkylinkToBase32 = exports.mySkyDevDomain = exports.mySkyDomain = exports.DacLibrary = exports.signEntry = exports.getEntryUrlForPortal = exports.getSkylinkUrlForPortal = exports.genKeyPairFromSeed = exports.genKeyPairAndSeed = exports.deriveChildSeed = exports.SkynetClient = void 0;
var client_1 = __webpack_require__(/*! ./client */ "./node_modules/skynet-js/dist/cjs/client.js");
Object.defineProperty(exports, "SkynetClient", ({ enumerable: true, get: function () { return client_1.SkynetClient; } }));
var crypto_1 = __webpack_require__(/*! ./crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
Object.defineProperty(exports, "deriveChildSeed", ({ enumerable: true, get: function () { return crypto_1.deriveChildSeed; } }));
Object.defineProperty(exports, "genKeyPairAndSeed", ({ enumerable: true, get: function () { return crypto_1.genKeyPairAndSeed; } }));
Object.defineProperty(exports, "genKeyPairFromSeed", ({ enumerable: true, get: function () { return crypto_1.genKeyPairFromSeed; } }));
var download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
Object.defineProperty(exports, "getSkylinkUrlForPortal", ({ enumerable: true, get: function () { return download_1.getSkylinkUrlForPortal; } }));
var registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
Object.defineProperty(exports, "getEntryUrlForPortal", ({ enumerable: true, get: function () { return registry_1.getEntryUrlForPortal; } }));
Object.defineProperty(exports, "signEntry", ({ enumerable: true, get: function () { return registry_1.signEntry; } }));
var mysky_1 = __webpack_require__(/*! ./mysky */ "./node_modules/skynet-js/dist/cjs/mysky/index.js");
Object.defineProperty(exports, "DacLibrary", ({ enumerable: true, get: function () { return mysky_1.DacLibrary; } }));
Object.defineProperty(exports, "mySkyDomain", ({ enumerable: true, get: function () { return mysky_1.mySkyDomain; } }));
Object.defineProperty(exports, "mySkyDevDomain", ({ enumerable: true, get: function () { return mysky_1.mySkyDevDomain; } }));
var format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
Object.defineProperty(exports, "convertSkylinkToBase32", ({ enumerable: true, get: function () { return format_1.convertSkylinkToBase32; } }));
Object.defineProperty(exports, "convertSkylinkToBase64", ({ enumerable: true, get: function () { return format_1.convertSkylinkToBase64; } }));
var parse_1 = __webpack_require__(/*! ./skylink/parse */ "./node_modules/skynet-js/dist/cjs/skylink/parse.js");
Object.defineProperty(exports, "parseSkylink", ({ enumerable: true, get: function () { return parse_1.parseSkylink; } }));
var sia_1 = __webpack_require__(/*! ./skylink/sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
Object.defineProperty(exports, "isSkylinkV1", ({ enumerable: true, get: function () { return sia_1.isSkylinkV1; } }));
Object.defineProperty(exports, "isSkylinkV2", ({ enumerable: true, get: function () { return sia_1.isSkylinkV2; } }));
var file_1 = __webpack_require__(/*! ./utils/file */ "./node_modules/skynet-js/dist/cjs/utils/file.js");
Object.defineProperty(exports, "getRelativeFilePath", ({ enumerable: true, get: function () { return file_1.getRelativeFilePath; } }));
Object.defineProperty(exports, "getRootDirectory", ({ enumerable: true, get: function () { return file_1.getRootDirectory; } }));
var number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
Object.defineProperty(exports, "MAX_REVISION", ({ enumerable: true, get: function () { return number_1.MAX_REVISION; } }));
var string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
Object.defineProperty(exports, "stringToUint8ArrayUtf8", ({ enumerable: true, get: function () { return string_1.stringToUint8ArrayUtf8; } }));
Object.defineProperty(exports, "uint8ArrayToStringUtf8", ({ enumerable: true, get: function () { return string_1.uint8ArrayToStringUtf8; } }));
var url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
Object.defineProperty(exports, "defaultPortalUrl", ({ enumerable: true, get: function () { return url_1.defaultPortalUrl; } }));
Object.defineProperty(exports, "defaultSkynetPortalUrl", ({ enumerable: true, get: function () { return url_1.defaultSkynetPortalUrl; } }));
Object.defineProperty(exports, "extractDomainForPortal", ({ enumerable: true, get: function () { return url_1.extractDomainForPortal; } }));
Object.defineProperty(exports, "getFullDomainUrlForPortal", ({ enumerable: true, get: function () { return url_1.getFullDomainUrlForPortal; } }));
Object.defineProperty(exports, "uriHandshakePrefix", ({ enumerable: true, get: function () { return url_1.uriHandshakePrefix; } }));
Object.defineProperty(exports, "uriSkynetPrefix", ({ enumerable: true, get: function () { return url_1.uriSkynetPrefix; } }));
// Re-export Permission API.
var skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js");
Object.defineProperty(exports, "Permission", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.Permission; } }));
Object.defineProperty(exports, "PermCategory", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermCategory; } }));
Object.defineProperty(exports, "PermType", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermType; } }));
Object.defineProperty(exports, "PermRead", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermRead; } }));
Object.defineProperty(exports, "PermWrite", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermWrite; } }));
Object.defineProperty(exports, "PermHidden", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermHidden; } }));
Object.defineProperty(exports, "PermDiscoverable", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermDiscoverable; } }));
Object.defineProperty(exports, "PermLegacySkyID", ({ enumerable: true, get: function () { return skynet_mysky_utils_1.PermLegacySkyID; } }));


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/connector.js":
/*!************************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/connector.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Connector = exports.defaultConnectorOptions = void 0;
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/skynet-js/node_modules/post-me/dist/index.js");
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
exports.defaultConnectorOptions = {
    dev: false,
    debug: false,
    alpha: false,
    handshakeMaxAttempts: skynet_mysky_utils_1.defaultHandshakeMaxAttempts,
    handshakeAttemptsInterval: skynet_mysky_utils_1.defaultHandshakeAttemptsInterval,
};
class Connector {
    constructor(url, client, childFrame, connection, options) {
        this.url = url;
        this.client = client;
        this.childFrame = childFrame;
        this.connection = connection;
        this.options = options;
    }
    // Static initializer
    static async init(client, domain, customOptions) {
        const opts = { ...exports.defaultConnectorOptions, ...customOptions };
        // Get the URL for the domain on the current portal.
        let domainUrl = await client.getFullDomainUrl(domain);
        if (opts.dev) {
            domainUrl = url_1.addUrlQuery(domainUrl, { dev: "true" });
        }
        if (opts.debug) {
            domainUrl = url_1.addUrlQuery(domainUrl, { debug: "true" });
        }
        if (opts.alpha) {
            domainUrl = url_1.addUrlQuery(domainUrl, { alpha: "true" });
        }
        // Create the iframe.
        const childFrame = skynet_mysky_utils_1.createIframe(domainUrl, domainUrl);
        const childWindow = childFrame.contentWindow;
        // Connect to the iframe.
        const messenger = new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: childWindow,
            remoteOrigin: "*",
        });
        const connection = await post_me_1.ParentHandshake(messenger, {}, opts.handshakeMaxAttempts, opts.handshakeAttemptsInterval);
        // Construct the component connector.
        return new Connector(domainUrl, client, childFrame, connection, opts);
    }
    async call(method, ...args) {
        return this.connection.remoteHandle().call(method, ...args);
    }
}
exports.Connector = Connector;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/dac.js":
/*!******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/dac.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DacLibrary = void 0;
const connector_1 = __webpack_require__(/*! ./connector */ "./node_modules/skynet-js/dist/cjs/mysky/connector.js");
class DacLibrary {
    constructor(dacDomain) {
        this.dacDomain = dacDomain;
    }
    async init(client, customOptions) {
        this.connector = await connector_1.Connector.init(client, this.dacDomain, customOptions);
        await this.connector.connection.remoteHandle().call("init");
    }
    onUserLogin() {
        if (!this.connector) {
            throw new Error("init was not called");
        }
        this.connector.connection.remoteHandle().call("onUserLogin");
    }
}
exports.DacLibrary = DacLibrary;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/index.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MySky = exports.loadMySky = exports.MAX_ENTRY_LENGTH = exports.mySkyAlphaDomain = exports.mySkyDevDomain = exports.mySkyDomain = exports.DacLibrary = void 0;
var dac_1 = __webpack_require__(/*! ./dac */ "./node_modules/skynet-js/dist/cjs/mysky/dac.js");
Object.defineProperty(exports, "DacLibrary", ({ enumerable: true, get: function () { return dac_1.DacLibrary; } }));
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/skynet-js/node_modules/post-me/dist/index.js");
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js");
const connector_1 = __webpack_require__(/*! ./connector */ "./node_modules/skynet-js/dist/cjs/mysky/connector.js");
const registry_1 = __webpack_require__(/*! ../registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const skydb_1 = __webpack_require__(/*! ../skydb */ "./node_modules/skynet-js/dist/cjs/skydb.js");
const tweak_1 = __webpack_require__(/*! ./tweak */ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/dist/cjs/mysky/utils.js");
const options_1 = __webpack_require__(/*! ../utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const sia_1 = __webpack_require__(/*! ../skylink/sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
exports.mySkyDomain = "skynet-mysky.hns";
exports.mySkyDevDomain = "skynet-mysky-dev.hns";
exports.mySkyAlphaDomain = "sandbridge.hns";
exports.MAX_ENTRY_LENGTH = 70;
const mySkyUiRelativeUrl = "ui.html";
const mySkyUiTitle = "MySky UI";
const [mySkyUiW, mySkyUiH] = [600, 600];
/**
 * Loads MySky. Note that this does not log in the user.
 *
 * @param this - The Skynet client.
 * @param skappDomain - The domain of the host skapp. For this domain permissions will be requested and, by default, automatically granted.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - Loaded (but not logged-in) MySky instance.
 */
async function loadMySky(skappDomain, customOptions) {
    const mySky = await MySky.New(this, skappDomain, customOptions);
    return mySky;
}
exports.loadMySky = loadMySky;
class MySky {
    // ============
    // Constructors
    // ============
    constructor(connector, permissions, hostDomain) {
        this.connector = connector;
        this.hostDomain = hostDomain;
        // Holds the loaded DACs.
        this.dacs = [];
        // Holds the currently granted permissions.
        this.grantedPermissions = [];
        this.pendingPermissions = permissions;
    }
    static async New(client, skappDomain, customOptions) {
        const opts = { ...connector_1.defaultConnectorOptions, ...customOptions };
        // Enforce singleton.
        if (MySky.instance) {
            return MySky.instance;
        }
        let domain = exports.mySkyDomain;
        if (opts.alpha) {
            domain = exports.mySkyAlphaDomain;
        }
        else if (opts.dev) {
            domain = exports.mySkyDevDomain;
        }
        const connector = await connector_1.Connector.init(client, domain, customOptions);
        const hostDomain = await client.extractDomain(window.location.hostname);
        const permissions = [];
        if (skappDomain) {
            // TODO: Are these permissions correct?
            const perm1 = new skynet_mysky_utils_1.Permission(hostDomain, skappDomain, skynet_mysky_utils_1.PermCategory.Hidden, skynet_mysky_utils_1.PermType.Read);
            const perm2 = new skynet_mysky_utils_1.Permission(hostDomain, skappDomain, skynet_mysky_utils_1.PermCategory.Hidden, skynet_mysky_utils_1.PermType.Write);
            permissions.push(perm1, perm2);
        }
        MySky.instance = new MySky(connector, permissions, hostDomain);
        return MySky.instance;
    }
    // ==========
    // Public API
    // ==========
    /**
     * Loads the given DACs.
     *
     * @param dacs - The DAC library instances to call `init` on.
     */
    async loadDacs(...dacs) {
        const promises = [];
        for (const dac of dacs) {
            promises.push(this.loadDac(dac));
        }
        this.dacs.push(...dacs);
        await Promise.all(promises);
    }
    async addPermissions(...permissions) {
        this.pendingPermissions.push(...permissions);
    }
    async checkLogin() {
        const [seedFound, permissionsResponse] = await this.connector.connection
            .remoteHandle()
            .call("checkLogin", this.pendingPermissions);
        // Save granted and failed permissions.
        const { grantedPermissions, failedPermissions } = permissionsResponse;
        this.grantedPermissions = grantedPermissions;
        this.pendingPermissions = failedPermissions;
        const loggedIn = seedFound && failedPermissions.length === 0;
        this.handleLogin(loggedIn);
        return loggedIn;
    }
    /**
     * Destroys the mysky connection by:
     *
     * 1. Destroying the connected DACs,
     *
     * 2. Closing the connection,
     *
     * 3. Closing the child iframe
     */
    async destroy() {
        // TODO: For all connected dacs, send a destroy call.
        // TODO: Delete all connected dacs.
        // Close the connection.
        this.connector.connection.close();
        // Close the child iframe.
        if (this.connector.childFrame) {
            this.connector.childFrame.parentNode.removeChild(this.connector.childFrame);
        }
    }
    async logout() {
        return await this.connector.connection.remoteHandle().call("logout");
    }
    async requestLoginAccess() {
        let uiWindow;
        let uiConnection;
        let seedFound = false;
        // Add error listener.
        const { promise: promiseError, controller: controllerError } = skynet_mysky_utils_1.monitorWindowError();
        // eslint-disable-next-line no-async-promise-executor
        const promise = new Promise(async (resolve, reject) => {
            // Make this promise run in the background and reject on window close or any errors.
            promiseError.catch((err) => {
                if (err === skynet_mysky_utils_1.errorWindowClosed) {
                    // Resolve without updating the pending permissions.
                    resolve();
                    return;
                }
                reject(err);
            });
            try {
                // Launch the UI.
                uiWindow = await this.launchUI();
                uiConnection = await this.connectUi(uiWindow);
                // Send the UI the list of required permissions.
                // TODO: This should be a dual-promise that also calls ping() on an interval and rejects if no response was found in a given amount of time.
                const [seedFoundResponse, permissionsResponse] = await uiConnection
                    .remoteHandle()
                    .call("requestLoginAccess", this.pendingPermissions);
                seedFound = seedFoundResponse;
                // Save failed permissions.
                const { grantedPermissions, failedPermissions } = permissionsResponse;
                this.grantedPermissions = grantedPermissions;
                this.pendingPermissions = failedPermissions;
                resolve();
            }
            catch (err) {
                reject(err);
            }
        });
        await promise
            .catch((err) => {
            throw err;
        })
            .finally(() => {
            // Close the window.
            if (uiWindow) {
                uiWindow.close();
            }
            // Close the connection.
            if (uiConnection) {
                uiConnection.close();
            }
            // Clean up the event listeners and promises.
            controllerError.cleanup();
        });
        const loggedIn = seedFound && this.pendingPermissions.length === 0;
        this.handleLogin(loggedIn);
        return loggedIn;
    }
    async userID(opts) {
        return await this.connector.connection.remoteHandle().call("userID", opts);
    }
    /**
     * Gets Discoverable JSON at the given path through MySky, if the user has given Read permissions to do so.
     *
     * @param path - The data path.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An object containing the json data as well as the skylink for the data.
     */
    async getJSON(path, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultGetJSONOptions);
        const opts = {
            ...skydb_1.defaultGetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        return await this.connector.client.db.getJSON(publicKey, dataKey, opts);
    }
    /**
     * Gets the entry link for the entry at the given path. This is a v2 skylink.
     * This link stays the same even if the content at the entry changes.
     *
     * @param path - The data path.
     * @returns - The entry link.
     */
    async getEntryLink(path) {
        validation_1.validateString("path", path, "parameter");
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        const opts = registry_1.defaultGetEntryOptions;
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        return await this.connector.client.registry.getEntryLink(publicKey, dataKey, opts);
    }
    /**
     * Sets Discoverable JSON at the given path through MySky, if the user has given Write permissions to do so.
     *
     * @param path - The data path.
     * @param json - The json to set.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An object containing the json data as well as the skylink for the data.
     */
    async setJSON(path, json, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateObject("json", json, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultSetJSONOptions);
        const opts = {
            ...skydb_1.defaultSetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const [entry, dataLink] = await skydb_1.getOrCreateRegistryEntry(this.connector.client, publicKey, dataKey, json, opts);
        const signature = await this.signRegistryEntry(entry, path);
        const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
        await this.connector.client.registry.postSignedEntry(publicKey, entry, signature, setEntryOpts);
        return { data: json, dataLink };
    }
    /**
     * Sets entry at the given path to point to the data link. Like setJSON, but it doesn't upload a file.
     *
     * @param path - The data path.
     * @param dataLink - The data link to set at the path.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An empty promise.
     */
    async setDataLink(path, dataLink, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateString("dataLink", dataLink, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultSetJSONOptions);
        const opts = {
            ...skydb_1.defaultSetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
        const entry = await skydb_1.getNextRegistryEntry(this.connector.client, publicKey, dataKey, sia_1.decodeSkylink(dataLink), getEntryOpts);
        const signature = await this.signRegistryEntry(entry, path);
        const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
        await this.connector.client.registry.postSignedEntry(publicKey, entry, signature, setEntryOpts);
    }
    /**
     * Deletes Discoverable JSON at the given path through MySky, if the user has given Write permissions to do so.
     *
     * @param path - The data path.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - An empty promise.
     * @throws - Will throw if the revision is already the maximum value.
     */
    async deleteJSON(path, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", skydb_1.defaultSetJSONOptions);
        const opts = {
            ...skydb_1.defaultSetJSONOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
        const entry = await skydb_1.getNextRegistryEntry(this.connector.client, publicKey, dataKey, new Uint8Array(sia_1.RAW_SKYLINK_SIZE), getEntryOpts);
        const signature = await this.signRegistryEntry(entry, path);
        const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
        await this.connector.client.registry.postSignedEntry(publicKey, entry, signature, setEntryOpts);
    }
    /**
     * Gets the raw registry entry data for the given path, if the user has given READ permissions.
     *
     * @param path - The data path.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - The entry data.
     */
    async getEntryData(path, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", registry_1.defaultGetEntryOptions);
        const opts = {
            ...registry_1.defaultGetEntryOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const { entry } = await this.connector.client.registry.getEntry(publicKey, dataKey, opts);
        if (!entry) {
            return { data: null };
        }
        return { data: entry.data };
    }
    /**
     * Sets the entry data at the given path, if the user has given WRITE permissions.
     *
     * @param path - The data path.
     * @param data - The raw entry data to set.
     * @param [customOptions] - Additional settings that can optionally be set.
     * @returns - The entry data.
     * @throws - Will throw if the length of the data is > 70 bytes.
     */
    async setEntryData(path, data, customOptions) {
        validation_1.validateString("path", path, "parameter");
        validation_1.validateUint8Array("data", data, "parameter");
        validation_1.validateOptionalObject("customOptions", customOptions, "parameter", registry_1.defaultGetEntryOptions);
        if (data.length > exports.MAX_ENTRY_LENGTH) {
            validation_1.throwValidationError("data", data, "parameter", `'Uint8Array' of length <= ${exports.MAX_ENTRY_LENGTH}, was length ${data.length}`);
        }
        const opts = {
            ...registry_1.defaultSetEntryOptions,
            ...this.connector.client.customOptions,
            ...customOptions,
        };
        const publicKey = await this.userID();
        const dataKey = tweak_1.deriveDiscoverableTweak(path);
        opts.hashedDataKeyHex = true; // Do not hash the tweak anymore.
        const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
        const entry = await skydb_1.getNextRegistryEntry(this.connector.client, publicKey, dataKey, data, getEntryOpts);
        const signature = await this.signRegistryEntry(entry, path);
        await this.connector.client.registry.postSignedEntry(publicKey, entry, signature, opts);
        return { data: entry.data };
    }
    // ================
    // Internal Methods
    // ================
    async catchError(errorMsg) {
        const event = new CustomEvent(skynet_mysky_utils_1.dispatchedErrorEvent, { detail: errorMsg });
        window.dispatchEvent(event);
    }
    async launchUI() {
        const mySkyUrl = new URL(this.connector.url);
        mySkyUrl.pathname = mySkyUiRelativeUrl;
        const uiUrl = mySkyUrl.toString();
        // Open the window.
        const childWindow = utils_1.popupCenter(uiUrl, mySkyUiTitle, mySkyUiW, mySkyUiH);
        if (!childWindow) {
            throw new Error(`Could not open window at '${uiUrl}'`);
        }
        return childWindow;
    }
    async connectUi(childWindow) {
        const options = this.connector.options;
        // Complete handshake with UI window.
        const messenger = new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: childWindow,
            remoteOrigin: "*",
        });
        const methods = {
            catchError: this.catchError,
        };
        const connection = await post_me_1.ParentHandshake(messenger, methods, options.handshakeMaxAttempts, options.handshakeAttemptsInterval);
        return connection;
    }
    async loadDac(dac) {
        // Initialize DAC.
        await dac.init(this.connector.client, this.connector.options);
        // Add DAC permissions.
        const perms = dac.getPermissions();
        this.addPermissions(...perms);
    }
    handleLogin(loggedIn) {
        if (loggedIn) {
            for (const dac of this.dacs) {
                dac.onUserLogin();
            }
        }
    }
    async signRegistryEntry(entry, path) {
        return await this.connector.connection.remoteHandle().call("signRegistryEntry", entry, path);
    }
}
exports.MySky = MySky;
MySky.instance = null;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/tweak.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/tweak.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deriveDiscoverableTweak = exports.hashPathComponent = exports.splitPath = exports.DiscoverableBucketTweak = void 0;
const crypto_1 = __webpack_require__(/*! ../crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const discoverableBucketTweakVersion = 1;
class DiscoverableBucketTweak {
    constructor(path) {
        const paths = splitPath(path);
        const pathHashes = paths.map(hashPathComponent);
        this.version = discoverableBucketTweakVersion;
        this.path = pathHashes;
    }
    encode() {
        const size = 1 + 32 * this.path.length;
        const buf = new Uint8Array(size);
        buf.set([this.version]);
        let offset = 1;
        for (const pathLevel of this.path) {
            buf.set(pathLevel, offset);
            offset += 32;
        }
        return buf;
    }
    getHash() {
        const encoding = this.encode();
        return crypto_1.hashAll(encoding);
    }
}
exports.DiscoverableBucketTweak = DiscoverableBucketTweak;
function splitPath(path) {
    return path.split("/");
}
exports.splitPath = splitPath;
function hashPathComponent(component) {
    return crypto_1.hashAll(string_1.stringToUint8ArrayUtf8(component));
}
exports.hashPathComponent = hashPathComponent;
function deriveDiscoverableTweak(path) {
    const dbt = new DiscoverableBucketTweak(path);
    const bytes = dbt.getHash();
    return string_1.toHexString(bytes);
}
exports.deriveDiscoverableTweak = deriveDiscoverableTweak;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/mysky/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/mysky/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.popupCenter = exports.extractDomain = exports.getFullDomainUrl = void 0;
const skynet_mysky_utils_1 = __webpack_require__(/*! skynet-mysky-utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
/**
 * Constructs the full URL for the given component domain,
 * e.g. "dac.hns" => "https://dac.hns.siasky.net"
 *
 * @param this - SkynetClient
 * @param domain - Component domain.
 * @returns - The full URL for the component.
 */
async function getFullDomainUrl(domain) {
    const portalUrl = await this.portalUrl();
    return url_1.getFullDomainUrlForPortal(portalUrl, domain);
}
exports.getFullDomainUrl = getFullDomainUrl;
/**
 * Extracts the domain from the current portal URL,
 * e.g. ("dac.hns.siasky.net") => "dac.hns"
 *
 * @param this - SkynetClient
 * @param fullDomain - Full URL.
 * @returns - The extracted domain.
 */
async function extractDomain(fullDomain) {
    const portalUrl = await this.portalUrl();
    return url_1.extractDomainForPortal(portalUrl, fullDomain);
}
exports.extractDomain = extractDomain;
/**
 * Create a new popup window. From SkyID.
 *
 * @param url - The URL to open.
 * @param title - The title of the popup window.
 * @param w - The width of the popup window.
 * @param h - the height of the popup window.
 * @returns - The window.
 */
/* istanbul ignore next */
function popupCenter(url, title, w, h) {
    url = skynet_mysky_utils_1.ensureUrl(url);
    // Fixes dual-screen position                             Most browsers      Firefox
    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
    const width = window.innerWidth
        ? window.innerWidth
        : document.documentElement.clientWidth
            ? document.documentElement.clientWidth
            : screen.width;
    const height = window.innerHeight
        ? window.innerHeight
        : document.documentElement.clientHeight
            ? document.documentElement.clientHeight
            : screen.height;
    const systemZoom = width / window.screen.availWidth;
    const left = (width - w) / 2 / systemZoom + dualScreenLeft;
    const top = (height - h) / 2 / systemZoom + dualScreenTop;
    const newWindow = window.open(url, title, `
scrollbars=yes,
width=${w / systemZoom},
height=${h / systemZoom},
top=${top},
left=${left}
`);
    if (!newWindow) {
        throw new Error("could not open window");
    }
    if (newWindow.focus) {
        newWindow.focus();
    }
    return newWindow;
}
exports.popupCenter = popupCenter;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/registry.js":
/*!*****************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/registry.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateRegistryEntry = exports.postSignedEntry = exports.signEntry = exports.setEntry = exports.getEntryLink = exports.getEntryUrlForPortal = exports.getEntryUrl = exports.getEntry = exports.regexRevisionNoQuotes = exports.DEFAULT_GET_ENTRY_TIMEOUT = exports.defaultSetEntryOptions = exports.defaultGetEntryOptions = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/skynet-js/node_modules/buffer/index.js");
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/skynet-js/node_modules/tweetnacl/nacl-fast.js");
const number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const crypto_1 = __webpack_require__(/*! ./crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const sia_1 = __webpack_require__(/*! ./skylink/sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
exports.defaultGetEntryOptions = {
    ...options_1.defaultBaseOptions,
    endpointGetEntry: "/skynet/registry",
    hashedDataKeyHex: false,
};
exports.defaultSetEntryOptions = {
    ...options_1.defaultBaseOptions,
    endpointSetEntry: "/skynet/registry",
    hashedDataKeyHex: false,
};
exports.DEFAULT_GET_ENTRY_TIMEOUT = 5; // 5 seconds
/**
 * Regex for JSON revision value without quotes.
 */
exports.regexRevisionNoQuotes = /"revision":\s*([0-9]+)/;
/**
 * Regex for JSON revision value with quotes.
 */
const regexRevisionWithQuotes = /"revision":\s*"([0-9]+)"/;
/**
 * Gets the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The signed registry entry.
 * @throws - Will throw if the returned signature does not match the returned entry or the provided timeout is invalid or the given key is not valid.
 */
async function getEntry(publicKey, dataKey, customOptions) {
    // Validation is done in `getEntryUrl`.
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const url = await this.registry.getEntryUrl(publicKey, dataKey, opts);
    let response;
    try {
        response = await this.executeRequest({
            ...opts,
            endpointPath: opts.endpointGetEntry,
            url,
            method: "get",
            // Transform the response to add quotes, since uint64 cannot be accurately
            // read by JS so the revision needs to be parsed as a string.
            transformResponse: function (data) {
                if (data === undefined) {
                    return {};
                }
                // Change the revision value from a JSON integer to a string.
                data = data.replace(exports.regexRevisionNoQuotes, '"revision":"$1"');
                // Try converting the JSON data to an object.
                try {
                    return JSON.parse(data);
                }
                catch {
                    // The data is not JSON, it's likely an HTML error response.
                    return data;
                }
            },
        });
    }
    catch (err) {
        return handleGetEntryErrResponse(err);
    }
    // Sanity check.
    try {
        validation_1.validateString("response.data.data", response.data.data, "entry response field");
        validation_1.validateString("response.data.revision", response.data.revision, "entry response field");
        validation_1.validateString("response.data.signature", response.data.signature, "entry response field");
    }
    catch (err) {
        throw new Error(`Did not get a complete entry response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
    // Convert the revision from a string to bigint.
    const revision = BigInt(response.data.revision);
    const signature = buffer_1.Buffer.from(string_1.hexToUint8Array(response.data.signature));
    // Use empty array if the data is empty.
    let data = new Uint8Array([]);
    if (response.data.data) {
        data = string_1.hexToUint8Array(response.data.data);
    }
    const signedEntry = {
        entry: {
            dataKey,
            data,
            revision,
        },
        signature,
    };
    // Try verifying the returned data.
    if (tweetnacl_1.sign.detached.verify(crypto_1.hashRegistryEntry(signedEntry.entry, opts.hashedDataKeyHex), new Uint8Array(signedEntry.signature), string_1.hexToUint8Array(publicKey))) {
        return signedEntry;
    }
    // The response could not be verified.
    throw new Error("could not verify signature from retrieved, signed registry entry -- possible corrupted entry");
}
exports.getEntry = getEntry;
/**
 * Gets the registry entry URL corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full get entry URL.
 * @throws - Will throw if the provided timeout is invalid or the given key is not valid.
 */
async function getEntryUrl(publicKey, dataKey, customOptions) {
    // Validation is done in `getEntryUrlForPortal`.
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const portalUrl = await this.portalUrl();
    return getEntryUrlForPortal(portalUrl, publicKey, dataKey, opts);
}
exports.getEntryUrl = getEntryUrl;
/**
 * Gets the registry entry URL without an initialized client.
 *
 * @param portalUrl - The portal URL.
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The full get entry URL.
 * @throws - Will throw if the given key is not valid.
 */
function getEntryUrlForPortal(portalUrl, publicKey, dataKey, customOptions) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("publicKey", publicKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetEntryOptions);
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...customOptions,
    };
    // Trim the prefix if it was passed in.
    publicKey = string_1.trimPrefix(publicKey, "ed25519:");
    validateTrimmedPublicKey("publicKey", publicKey, "parameter");
    // Hash and hex encode the given data key if it is not a hash already.
    let dataKeyHashHex = dataKey;
    if (!opts.hashedDataKeyHex) {
        dataKeyHashHex = string_1.toHexString(crypto_1.hashDataKey(dataKey));
    }
    const query = {
        publickey: `ed25519:${publicKey}`,
        datakey: dataKeyHashHex,
        timeout: exports.DEFAULT_GET_ENTRY_TIMEOUT,
    };
    let url = url_1.makeUrl(portalUrl, opts.endpointGetEntry);
    url = url_1.addUrlQuery(url, query);
    return url;
}
exports.getEntryUrlForPortal = getEntryUrlForPortal;
/**
 * Gets the entry link for the entry at the given public key and data key. This link stays the same even if the content at the entry changes.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The entry link.
 * @throws - Will throw if the given key is not valid.
 */
async function getEntryLink(publicKey, dataKey, customOptions) {
    validation_1.validateString("publicKey", publicKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetEntryOptions);
    const opts = {
        ...exports.defaultGetEntryOptions,
        ...customOptions,
    };
    // Trim the prefix if it was passed in.
    publicKey = string_1.trimPrefix(publicKey, "ed25519:");
    validateTrimmedPublicKey("publicKey", publicKey, "parameter");
    const siaPublicKey = sia_1.newEd25519PublicKey(publicKey);
    let tweak;
    if (opts.hashedDataKeyHex) {
        tweak = string_1.hexToUint8Array(dataKey);
    }
    else {
        tweak = crypto_1.hashDataKey(dataKey);
    }
    const skylink = sia_1.newSkylinkV2(siaPublicKey, tweak).toString();
    return format_1.formatSkylink(skylink);
}
exports.getEntryLink = getEntryLink;
/**
 * Sets the registry entry.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param entry - The entry to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An empty promise.
 * @throws - Will throw if the entry revision does not fit in 64 bits or the given key is not valid.
 */
async function setEntry(privateKey, entry, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validateRegistryEntry("entry", entry, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetEntryOptions);
    // Assert the input is 64 bits.
    number_1.assertUint64(entry.revision);
    const opts = {
        ...exports.defaultSetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const privateKeyArray = string_1.hexToUint8Array(privateKey);
    const signature = await signEntry(privateKey, entry, opts.hashedDataKeyHex);
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(privateKeyArray);
    return await this.registry.postSignedEntry(string_1.toHexString(publicKeyArray), entry, signature, opts);
}
exports.setEntry = setEntry;
/**
 * Signs the entry with the given private key.
 *
 * @param privateKey - The user private key.
 * @param entry - The entry to sign.
 * @param hashedDataKeyHex - Whether the data key is already hashed and in hex format. If not, we hash the data key.
 * @returns - The signature.
 */
async function signEntry(privateKey, entry, hashedDataKeyHex) {
    // TODO: Publicly available, validate input.
    const privateKeyArray = string_1.hexToUint8Array(privateKey);
    // Sign the entry.
    // TODO: signature type should be Signature?
    return tweetnacl_1.sign(crypto_1.hashRegistryEntry(entry, hashedDataKeyHex), privateKeyArray);
}
exports.signEntry = signEntry;
/**
 * Posts the entry with the given public key and signature to Skynet.
 *
 * @param this - The Skynet client.
 * @param publicKey - The user public key.
 * @param entry - The entry to set.
 * @param signature - The signature.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - An empty promise.
 */
async function postSignedEntry(publicKey, entry, signature, customOptions) {
    validation_1.validateHexString("publicKey", publicKey, "parameter");
    // TODO: Validate entry and signature
    validation_1.validateString("entry.dataKey", entry.dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetEntryOptions);
    const opts = {
        ...exports.defaultSetEntryOptions,
        ...this.customOptions,
        ...customOptions,
    };
    // Hash and hex encode the given data key if it is not a hash already.
    let datakey = entry.dataKey;
    if (!opts.hashedDataKeyHex) {
        datakey = string_1.toHexString(crypto_1.hashDataKey(datakey));
    }
    // Convert the entry data to an array from raw bytes.
    const entryData = Array.from(entry.data);
    const data = {
        publickey: {
            algorithm: "ed25519",
            key: Array.from(string_1.hexToUint8Array(publicKey)),
        },
        datakey,
        // Set the revision as a string here. The value may be up to 64 bits and the limit for a JS number is 53 bits.
        // We remove the quotes later in transformRequest, as JSON does support 64 bit numbers.
        revision: entry.revision.toString(),
        data: entryData,
        signature: Array.from(signature),
    };
    await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointSetEntry,
        method: "post",
        data,
        // Transform the request to remove quotes, since the revision needs to be
        // parsed as a uint64 on the Go side.
        transformRequest: function (data) {
            // Convert the object data to JSON.
            const json = JSON.stringify(data);
            // Change the revision value from a string to a JSON integer.
            return json.replace(regexRevisionWithQuotes, '"revision":$1');
        },
    });
}
exports.postSignedEntry = postSignedEntry;
/**
 * Validates the given registry entry.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 */
function validateRegistryEntry(name, value, valueKind) {
    validation_1.validateObject(name, value, valueKind);
    validation_1.validateString(`${name}.dataKey`, value.dataKey, `${valueKind} field`);
    validation_1.validateUint8Array(`${name}.data`, value.data, `${valueKind} field`);
    validation_1.validateBigint(`${name}.revision`, value.revision, `${valueKind} field`);
}
exports.validateRegistryEntry = validateRegistryEntry;
/**
 * Handles error responses returned in getEntry.
 *
 * @param err - The Axios error.
 * @returns - An empty signed registry entry if the status code is 404.
 * @throws - Will throw if the status code is not 404.
 */
function handleGetEntryErrResponse(err) {
    /* istanbul ignore next */
    if (!err.response) {
        throw new Error(`Error response field not found, incomplete Axios error. Full error: ${err}`);
    }
    /* istanbul ignore next */
    if (!err.response.status) {
        throw new Error(`Error response did not contain expected field 'status'. Full error: ${err}`);
    }
    // Check if status was 404 "not found" and return null if so.
    if (err.response.status === 404) {
        return { entry: null, signature: null };
    }
    throw err;
}
/**
 * Validates the given value as a hex-encoded public key.
 *
 * @param name - The name of the value.
 * @param publicKey - The public key.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid hex-encoded public key.
 */
function validateTrimmedPublicKey(name, publicKey, valueKind) {
    if (!string_1.isHexString(publicKey)) {
        validation_1.throwValidationError(name, publicKey, valueKind, "a hex-encoded string with a valid prefix");
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skydb.js":
/*!**************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skydb.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNextRevisionFromEntry = exports.getOrCreateRegistryEntry = exports.getNextRegistryEntry = exports.setDataLink = exports.deleteJSON = exports.setJSON = exports.getJSON = exports.defaultSetJSONOptions = exports.defaultGetJSONOptions = void 0;
const tweetnacl_1 = __webpack_require__(/*! tweetnacl */ "./node_modules/skynet-js/node_modules/tweetnacl/nacl-fast.js");
const download_1 = __webpack_require__(/*! ./download */ "./node_modules/skynet-js/dist/cjs/download.js");
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/skynet-js/dist/cjs/registry.js");
const sia_1 = __webpack_require__(/*! ./skylink/sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
const number_1 = __webpack_require__(/*! ./utils/number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const string_1 = __webpack_require__(/*! ./utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
const parse_1 = __webpack_require__(/*! ./skylink/parse */ "./node_modules/skynet-js/dist/cjs/skylink/parse.js");
const upload_1 = __webpack_require__(/*! ./upload */ "./node_modules/skynet-js/dist/cjs/upload.js");
const encoding_1 = __webpack_require__(/*! ./utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const array_1 = __webpack_require__(/*! ./utils/array */ "./node_modules/skynet-js/dist/cjs/utils/array.js");
const JSON_RESPONSE_VERSION = 2;
exports.defaultGetJSONOptions = {
    ...options_1.defaultBaseOptions,
    ...registry_1.defaultGetEntryOptions,
    ...download_1.defaultDownloadOptions,
    cachedDataLink: undefined,
};
exports.defaultSetJSONOptions = {
    ...options_1.defaultBaseOptions,
    ...exports.defaultGetJSONOptions,
    ...registry_1.defaultSetEntryOptions,
    ...upload_1.defaultUploadOptions,
};
/**
 * Gets the JSON object corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param publicKey - The user public key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The returned JSON and revision number.
 * @throws - Will throw if the returned signature does not match the returned entry, or if the skylink in the entry is invalid.
 */
async function getJSON(publicKey, dataKey, customOptions) {
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultGetJSONOptions);
    // Rest of validation is done in `getEntry`.
    const opts = {
        ...exports.defaultGetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    // Lookup the registry entry.
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const { entry } = await this.registry.getEntry(publicKey, dataKey, getEntryOpts);
    if (entry === null || array_1.areEqualUint8Arrays(entry.data, sia_1.EMPTY_SKYLINK)) {
        return { data: null, dataLink: null };
    }
    // Determine the data link.
    // TODO: Can this still be an entry link which hasn't yet resolved to a data link?
    if (typeof entry.data === "string") {
        throw new Error("Expected returned entry data to be bytes");
    }
    let rawDataLink;
    if (entry.data.length === 46) {
        // Legacy data, convert to string.
        rawDataLink = string_1.uint8ArrayToStringUtf8(entry.data);
    }
    else if (entry.data.length === sia_1.RAW_SKYLINK_SIZE) {
        // Convert the bytes to a base64 skylink.
        rawDataLink = encoding_1.encodeSkylinkBase64(entry.data);
    }
    else {
        throw new Error(`Bytes entry.data response was not ${sia_1.RAW_SKYLINK_SIZE} bytes: ${entry.data}"`);
    }
    const dataLink = format_1.formatSkylink(rawDataLink);
    // If a cached data link is provided and the data link hasn't changed, return.
    if (opts.cachedDataLink && rawDataLink === parse_1.parseSkylink(opts.cachedDataLink)) {
        return { data: null, dataLink };
    }
    // Download the data in the returned data link.
    const downloadOpts = options_1.extractOptions(opts, download_1.defaultDownloadOptions);
    const { data } = await this.getFileContent(dataLink, downloadOpts);
    if (typeof data !== "object" || data === null) {
        throw new Error(`File data for the entry at data key '${dataKey}' is not JSON.`);
    }
    if (!(data["_data"] && data["_v"])) {
        // Legacy data prior to v4, return as-is.
        return { data, dataLink };
    }
    const actualData = data["_data"];
    if (typeof actualData !== "object" || data === null) {
        throw new Error(`File data '_data' for the entry at data key '${dataKey}' is not JSON.`);
    }
    return { data: actualData, dataLink };
}
exports.getJSON = getJSON;
/**
 * Sets a JSON object at the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param json - The JSON data to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The returned JSON and revision number.
 * @throws - Will throw if the input keys are not valid strings.
 */
async function setJSON(privateKey, dataKey, json, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateObject("json", json, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetJSONOptions);
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(string_1.hexToUint8Array(privateKey));
    const [entry, dataLink] = await getOrCreateRegistryEntry(this, string_1.toHexString(publicKeyArray), dataKey, json, opts);
    // Update the registry.
    const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
    await this.registry.setEntry(privateKey, entry, setEntryOpts);
    return { data: json, dataLink: format_1.formatSkylink(dataLink) };
}
exports.setJSON = setJSON;
/**
 * Deletes a JSON object at the registry entry corresponding to the publicKey and dataKey.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @throws - Will throw if the input keys are not valid strings.
 */
async function deleteJSON(privateKey, dataKey, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetJSONOptions);
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(string_1.hexToUint8Array(privateKey));
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const entry = await getNextRegistryEntry(this, string_1.toHexString(publicKeyArray), dataKey, new Uint8Array(sia_1.RAW_SKYLINK_SIZE), getEntryOpts);
    // Update the registry.
    const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
    await this.registry.setEntry(privateKey, entry, setEntryOpts);
}
exports.deleteJSON = deleteJSON;
/**
 * Sets the datalink for the entry at the given private key and data key.
 *
 * @param this - SkynetClient
 * @param privateKey - The user private key.
 * @param dataKey - The key of the data to fetch for the given user.
 * @param dataLink - The data link to set at the entry.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @throws - Will throw if the input keys are not valid strings
 */
async function setDataLink(privateKey, dataKey, dataLink, customOptions) {
    validation_1.validateHexString("privateKey", privateKey, "parameter");
    validation_1.validateString("dataKey", dataKey, "parameter");
    validation_1.validateString("dataLink", dataLink, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultSetJSONOptions);
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...this.customOptions,
        ...customOptions,
    };
    const { publicKey: publicKeyArray } = tweetnacl_1.sign.keyPair.fromSecretKey(string_1.hexToUint8Array(privateKey));
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const entry = await getNextRegistryEntry(this, string_1.toHexString(publicKeyArray), dataKey, sia_1.decodeSkylink(dataLink), getEntryOpts);
    // Update the registry.
    const setEntryOpts = options_1.extractOptions(opts, registry_1.defaultSetEntryOptions);
    await this.registry.setEntry(privateKey, entry, setEntryOpts);
}
exports.setDataLink = setDataLink;
/**
 * Gets the next entry for the given public key and data key, setting the data to be the given data and the revision number accordingly.
 *
 * @param client - The Skynet client.
 * @param publicKey - The user public key.
 * @param dataKey - The dat akey.
 * @param data - The data to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The registry entry and corresponding data link.
 * @throws - Will throw if the revision is already the maximum value.
 */
async function getNextRegistryEntry(client, publicKey, dataKey, data, customOptions) {
    // Not publicly available, don't validate input.
    const opts = {
        ...registry_1.defaultGetEntryOptions,
        ...client.customOptions,
        ...customOptions,
    };
    // Get the latest entry.
    // TODO: Can remove this once we start caching the latest revision.
    const signedEntry = await client.registry.getEntry(publicKey, dataKey, opts);
    const revision = getNextRevisionFromEntry(signedEntry.entry);
    // Build the registry entry.
    const entry = {
        dataKey,
        data,
        revision,
    };
    return entry;
}
exports.getNextRegistryEntry = getNextRegistryEntry;
/**
 * Gets the registry entry and data link or creates the entry if it doesn't exist.
 *
 * @param client - The Skynet client.
 * @param publicKey - The user public key.
 * @param dataKey - The dat akey.
 * @param json - The JSON to set.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The registry entry and corresponding data link.
 * @throws - Will throw if the revision is already the maximum value.
 */
async function getOrCreateRegistryEntry(client, publicKey, dataKey, json, customOptions) {
    // Not publicly available, don't validate input.
    const opts = {
        ...exports.defaultSetJSONOptions,
        ...client.customOptions,
        ...customOptions,
    };
    // Set the hidden _data and _v fields.
    const fullData = { _data: json, _v: JSON_RESPONSE_VERSION };
    // Create the data to upload to acquire its skylink.
    let dataKeyHex = dataKey;
    if (!opts.hashedDataKeyHex) {
        dataKeyHex = string_1.toHexString(string_1.stringToUint8ArrayUtf8(dataKey));
    }
    const file = new File([JSON.stringify(fullData)], `dk:${dataKeyHex}`, { type: "application/json" });
    // Start file upload, do not block.
    const uploadOpts = options_1.extractOptions(opts, upload_1.defaultUploadOptions);
    const skyfilePromise = client.uploadFile(file, uploadOpts);
    // Fetch the current value to find out the revision.
    //
    // Start getEntry, do not block.
    const getEntryOpts = options_1.extractOptions(opts, registry_1.defaultGetEntryOptions);
    const entryPromise = client.registry.getEntry(publicKey, dataKey, getEntryOpts);
    // Block until both getEntry and uploadFile are finished.
    const [signedEntry, skyfile] = await Promise.all([
        entryPromise,
        skyfilePromise,
    ]);
    const revision = getNextRevisionFromEntry(signedEntry.entry);
    // Build the registry entry.
    const dataLink = string_1.trimUriPrefix(skyfile.skylink, url_1.uriSkynetPrefix);
    const data = encoding_1.decodeSkylinkBase64(dataLink);
    validation_1.validateUint8ArrayLen("data", data, "skylink byte array", sia_1.RAW_SKYLINK_SIZE);
    const entry = {
        dataKey,
        data,
        revision,
    };
    return [entry, format_1.formatSkylink(dataLink)];
}
exports.getOrCreateRegistryEntry = getOrCreateRegistryEntry;
/**
 * Gets the next revision from a returned entry (or 0 if the entry was not found).
 *
 * @param entry - The returned registry entry.
 * @returns - The revision.
 * @throws - Will throw if the next revision would be beyond the maximum allowed value.
 */
function getNextRevisionFromEntry(entry) {
    let revision;
    if (entry === null) {
        revision = BigInt(0);
    }
    else {
        revision = entry.revision + BigInt(1);
    }
    // Throw if the revision is already the maximum value.
    if (revision > number_1.MAX_REVISION) {
        throw new Error("Current entry already has maximum allowed revision, could not update the entry");
    }
    return revision;
}
exports.getNextRevisionFromEntry = getNextRevisionFromEntry;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/format.js":
/*!***********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/format.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatSkylink = exports.convertSkylinkToBase64 = exports.convertSkylinkToBase32 = void 0;
const sia_1 = __webpack_require__(/*! ./sia */ "./node_modules/skynet-js/dist/cjs/skylink/sia.js");
const encoding_1 = __webpack_require__(/*! ../utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * Converts the given base64 skylink to base32.
 *
 * @param skylink - The base64 skylink.
 * @returns - The converted base32 skylink.
 */
function convertSkylinkToBase32(skylink) {
    skylink = string_1.trimUriPrefix(skylink, url_1.uriSkynetPrefix);
    validation_1.validateStringLen("skylink", skylink, "parameter", sia_1.BASE64_ENCODED_SKYLINK_SIZE);
    const bytes = encoding_1.decodeSkylinkBase64(skylink);
    return encoding_1.encodeSkylinkBase32(bytes);
}
exports.convertSkylinkToBase32 = convertSkylinkToBase32;
/**
 * Converts the given base32 skylink to base64.
 *
 * @param skylink - The base32 skylink.
 * @returns - The converted base64 skylink.
 */
function convertSkylinkToBase64(skylink) {
    skylink = string_1.trimUriPrefix(skylink, url_1.uriSkynetPrefix);
    validation_1.validateStringLen("skylink", skylink, "parameter", sia_1.BASE32_ENCODED_SKYLINK_SIZE);
    const bytes = encoding_1.decodeSkylinkBase32(skylink);
    return encoding_1.encodeSkylinkBase64(bytes);
}
exports.convertSkylinkToBase64 = convertSkylinkToBase64;
/**
 * Formats the skylink by adding the sia: prefix.
 *
 * @param skylink - The skylink.
 * @returns - The formatted skylink.
 */
function formatSkylink(skylink) {
    if (skylink === "") {
        return skylink;
    }
    if (!skylink.startsWith(url_1.uriSkynetPrefix)) {
        skylink = `${url_1.uriSkynetPrefix}${skylink}`;
    }
    return skylink;
}
exports.formatSkylink = formatSkylink;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/parse.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSkylinkBase32 = exports.parseSkylink = void 0;
const url_parse_1 = __importDefault(__webpack_require__(/*! url-parse */ "./node_modules/skynet-js/node_modules/url-parse/index.js"));
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
const defaultParseSkylinkOptions = {
    fromSubdomain: false,
    includePath: false,
    onlyPath: false,
};
const SKYLINK_MATCHER = "([a-zA-Z0-9_-]{46})";
const SKYLINK_MATCHER_SUBDOMAIN = "([a-z0-9_-]{55})";
const SKYLINK_DIRECT_REGEX = new RegExp(`^${SKYLINK_MATCHER}$`);
const SKYLINK_PATHNAME_REGEX = new RegExp(`^/?${SKYLINK_MATCHER}((/.*)?)$`);
const SKYLINK_SUBDOMAIN_REGEX = new RegExp(`^${SKYLINK_MATCHER_SUBDOMAIN}(\\..*)?$`);
const SKYLINK_DIRECT_MATCH_POSITION = 1;
const SKYLINK_PATH_MATCH_POSITION = 2;
/**
 * Parses the given string for a base64 skylink, or base32 if opts.fromSubdomain is given. If the given string is prefixed with sia:, sia://, or a portal URL, those will be removed and the raw skylink returned.
 *
 * @param skylinkUrl - Plain skylink, skylink with URI prefix, or URL with skylink as the first path element.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The base64 (or base32) skylink, optionally with the path included.
 * @throws - Will throw on invalid combination of options.
 */
function parseSkylink(skylinkUrl, customOptions) {
    validation_1.validateString("skylinkUrl", skylinkUrl, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", defaultParseSkylinkOptions);
    const opts = { ...defaultParseSkylinkOptions, ...customOptions };
    if (opts.includePath && opts.onlyPath) {
        throw new Error("The includePath and onlyPath options cannot both be set");
    }
    if (opts.includePath && opts.fromSubdomain) {
        throw new Error("The includePath and fromSubdomain options cannot both be set");
    }
    if (opts.fromSubdomain) {
        return parseSkylinkBase32(skylinkUrl, opts);
    }
    // Check for skylink prefixed with sia: or sia:// and extract it.
    // Example: sia:XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    // Example: sia://XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    skylinkUrl = string_1.trimUriPrefix(skylinkUrl, url_1.uriSkynetPrefix);
    // Check for direct base64 skylink match.
    const matchDirect = skylinkUrl.match(SKYLINK_DIRECT_REGEX);
    if (matchDirect) {
        if (opts.onlyPath) {
            return "";
        }
        return matchDirect[SKYLINK_DIRECT_MATCH_POSITION];
    }
    // Check for skylink passed in an url and extract it.
    // Example: https://siasky.net/XABvi7JtJbQSMAcDwnUnmp2FKDPjg8_tTTFP4BwMSxVdEg
    // Example: https://bg06v2tidkir84hg0s1s4t97jaeoaa1jse1svrad657u070c9calq4g.siasky.net (if opts.fromSubdomain = true)
    // Pass empty object as second param to disable using location as base url
    // when parsing in browser.
    const parsed = url_parse_1.default(skylinkUrl, {});
    const skylinkAndPath = string_1.trimSuffix(parsed.pathname, "/");
    const matchPathname = skylinkAndPath.match(SKYLINK_PATHNAME_REGEX);
    if (!matchPathname)
        return null;
    const path = matchPathname[SKYLINK_PATH_MATCH_POSITION];
    if (opts.includePath)
        return string_1.trimForwardSlash(skylinkAndPath);
    else if (opts.onlyPath)
        return path;
    else
        return matchPathname[SKYLINK_DIRECT_MATCH_POSITION];
}
exports.parseSkylink = parseSkylink;
/**
 * Helper function that parses the given string for a base32 skylink.
 *
 * @param skylinkUrl - Base32 skylink.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @returns - The base32 skylink.
 */
function parseSkylinkBase32(skylinkUrl, customOptions) {
    // Do not validate, this helper function should only be called from parseSkylink.
    const opts = { ...defaultParseSkylinkOptions, ...customOptions };
    // Pass empty object as second param to disable using location as base url
    // when parsing in browser.
    const parsed = url_parse_1.default(skylinkUrl, {});
    // Check if the hostname contains a skylink subdomain.
    const matchHostname = parsed.hostname.match(SKYLINK_SUBDOMAIN_REGEX);
    if (matchHostname) {
        if (opts.onlyPath) {
            return string_1.trimSuffix(parsed.pathname, "/");
        }
        return matchHostname[SKYLINK_DIRECT_MATCH_POSITION];
    }
    return null;
}
exports.parseSkylinkBase32 = parseSkylinkBase32;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/skylink/sia.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/skylink/sia.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeSkylink = exports.newSkylinkV2 = exports.newEd25519PublicKey = exports.newSpecifier = exports.isSkylinkV2 = exports.isSkylinkV1 = exports.SiaSkylink = exports.EMPTY_SKYLINK = exports.RAW_SKYLINK_SIZE = exports.BASE64_ENCODED_SKYLINK_SIZE = exports.BASE32_ENCODED_SKYLINK_SIZE = void 0;
const crypto_1 = __webpack_require__(/*! ../crypto */ "./node_modules/skynet-js/dist/cjs/crypto.js");
const encoding_1 = __webpack_require__(/*! ../utils/encoding */ "./node_modules/skynet-js/dist/cjs/utils/encoding.js");
const string_1 = __webpack_require__(/*! ../utils/string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const url_1 = __webpack_require__(/*! ../utils/url */ "./node_modules/skynet-js/dist/cjs/utils/url.js");
const validation_1 = __webpack_require__(/*! ../utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * The string length of the Skylink after it has been encoded using base32.
 */
exports.BASE32_ENCODED_SKYLINK_SIZE = 55;
/**
 * The string length of the Skylink after it has been encoded using base64.
 */
exports.BASE64_ENCODED_SKYLINK_SIZE = 46;
/**
 * Returned when a string could not be decoded into a Skylink due to it having
 * an incorrect size.
 */
const ERR_SKYLINK_INCORRECT_SIZE = "skylink has incorrect size";
/**
 * The raw size in bytes of the data that gets put into a link.
 */
exports.RAW_SKYLINK_SIZE = 34;
/**
 * An empty skylink.
 */
exports.EMPTY_SKYLINK = new Uint8Array(exports.RAW_SKYLINK_SIZE);
class SiaSkylink {
    constructor(bitfield, merkleRoot) {
        this.bitfield = bitfield;
        this.merkleRoot = merkleRoot;
        validation_1.validateNumber("bitfield", bitfield, "constructor parameter");
        validation_1.validateUint8ArrayLen("merkleRoot", merkleRoot, "constructor parameter", 32);
    }
    toBytes() {
        const buf = new ArrayBuffer(exports.RAW_SKYLINK_SIZE);
        const view = new DataView(buf);
        view.setUint16(0, this.bitfield, true);
        const uint8Bytes = new Uint8Array(buf);
        uint8Bytes.set(this.merkleRoot, 2);
        return uint8Bytes;
    }
    toString() {
        return encoding_1.encodeSkylinkBase64(this.toBytes());
    }
}
exports.SiaSkylink = SiaSkylink;
/**
 * Checks if the given string is a v1 skylink.
 *
 * @param s
 */
function isSkylinkV1(s) {
    const raw = decodeSkylink(s);
    // Load and check the bitfield.
    const view = new DataView(raw.buffer);
    const bitfield = view.getUint16(0, true);
    return isBitfieldSkylinkV1(bitfield);
}
exports.isSkylinkV1 = isSkylinkV1;
/**
 * Checks if the given string is a v2 skylink.
 *
 * @param s
 */
function isSkylinkV2(s) {
    // Decode the base into raw data.
    const raw = decodeSkylink(s);
    // Load and check the bitfield.
    const view = new DataView(raw.buffer);
    const bitfield = view.getUint16(0, true);
    return isBitfieldSkylinkV2(bitfield);
}
exports.isSkylinkV2 = isSkylinkV2;
/**
 * Returns a boolean indicating if the Skylink is a V1 skylink
 *
 * @param bitfield
 */
function isBitfieldSkylinkV1(bitfield) {
    return (bitfield & 3) === 0;
}
/**
 * Returns a boolean indicating if the Skylink is a V2 skylink
 *
 * @param bitfield
 */
function isBitfieldSkylinkV2(bitfield) {
    // We compare against 1 here because a V2 skylink only uses the version
    // bits. All other bits should be set to 0.
    return bitfield == 1;
}
const SPECIFIER_LEN = 16;
/**
 * Returns a specifier for given name, a specifier can only be 16 bytes so we
 * panic if the given name is too long.
 *
 * @param name - The name.
 * @returns - The specifier, if valid.
 */
function newSpecifier(name) {
    validation_1.validateString("name", name, "parameter");
    const specifier = new Uint8Array(SPECIFIER_LEN);
    specifier.set(string_1.stringToUint8ArrayUtf8(name));
    return specifier;
}
exports.newSpecifier = newSpecifier;
const PUBLIC_KEY_SIZE = 32;
class SiaPublicKey {
    constructor(algorithm, key) {
        this.algorithm = algorithm;
        this.key = key;
    }
    marshalSia() {
        const bytes = new Uint8Array(SPECIFIER_LEN + 8 + PUBLIC_KEY_SIZE);
        bytes.set(this.algorithm);
        bytes.set(encoding_1.encodePrefixedBytes(this.key), SPECIFIER_LEN);
        return bytes;
    }
}
/**
 * Creates a new sia public key. Matches Ed25519PublicKey in sia.
 *
 * @param publicKey - The hex-encoded public key.
 * @returns - The SiaPublicKey.
 */
function newEd25519PublicKey(publicKey) {
    validation_1.validateHexString("publicKey", publicKey, "parameter");
    const algorithm = newSpecifier("ed25519");
    const publicKeyBytes = string_1.hexToUint8Array(publicKey);
    validation_1.validateUint8ArrayLen("publicKeyBytes", publicKeyBytes, "converted publicKey", PUBLIC_KEY_SIZE);
    return new SiaPublicKey(algorithm, publicKeyBytes);
}
exports.newEd25519PublicKey = newEd25519PublicKey;
/**
 * Creates a new v2 skylink. Matches NewSkylinkV2 in skyd.
 *
 * @param siaPublicKey - The public key as a SiaPublicKey.
 * @param tweak - The hashed tweak.
 * @returns - The v2 skylink.
 */
function newSkylinkV2(siaPublicKey, tweak) {
    const version = 2;
    const bitfield = version - 1;
    const merkleRoot = deriveRegistryEntryID(siaPublicKey, tweak);
    return new SiaSkylink(bitfield, merkleRoot);
}
exports.newSkylinkV2 = newSkylinkV2;
/**
 * A helper function that decodes the given string representation of a skylink
 * into raw bytes. It either performs a base32 decoding, or base64 decoding,
 * depending on the length.
 *
 * @param encoded - The encoded string.
 * @returns - The decoded raw bytes.
 */
function decodeSkylink(encoded) {
    encoded = string_1.trimUriPrefix(encoded, url_1.uriSkynetPrefix);
    let bytes;
    if (encoded.length === exports.BASE32_ENCODED_SKYLINK_SIZE) {
        bytes = encoding_1.decodeSkylinkBase32(encoded);
    }
    else if (encoded.length === exports.BASE64_ENCODED_SKYLINK_SIZE) {
        bytes = encoding_1.decodeSkylinkBase64(encoded);
    }
    else {
        throw new Error(ERR_SKYLINK_INCORRECT_SIZE);
    }
    // Sanity check the size of the given data.
    if (bytes.length != exports.RAW_SKYLINK_SIZE) {
        throw new Error("failed to load skylink data");
    }
    return bytes;
}
exports.decodeSkylink = decodeSkylink;
/**
 * A helper to derive an entry id for a registry key value pair. Matches `DeriveRegistryEntryID` in sia.
 *
 * @param pubKey - The sia public key.
 * @param tweak - The tweak.
 * @returns - The entry ID as a hash of the inputs.
 */
function deriveRegistryEntryID(pubKey, tweak) {
    return crypto_1.hashAll(pubKey.marshalSia(), tweak);
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/upload.js":
/*!***************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/upload.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uploadDirectoryRequest = exports.uploadDirectory = exports.uploadFileRequest = exports.uploadFile = exports.defaultUploadOptions = void 0;
const file_1 = __webpack_require__(/*! ./utils/file */ "./node_modules/skynet-js/dist/cjs/utils/file.js");
const options_1 = __webpack_require__(/*! ./utils/options */ "./node_modules/skynet-js/dist/cjs/utils/options.js");
const format_1 = __webpack_require__(/*! ./skylink/format */ "./node_modules/skynet-js/dist/cjs/skylink/format.js");
const validation_1 = __webpack_require__(/*! ./utils/validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultUploadOptions = {
    ...options_1.defaultBaseOptions,
    endpointUpload: "/skynet/skyfile",
    portalFileFieldname: "file",
    portalDirectoryFileFieldname: "files[]",
    customFilename: "",
    query: undefined,
};
/**
 * Uploads a file to Skynet.
 *
 * @param this - SkynetClient
 * @param file - The file to upload.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The returned skylink.
 * @throws - Will throw if the request is successful but the upload response does not contain a complete response.
 */
async function uploadFile(file, customOptions) {
    // Validation is done in `uploadDirectoryRequest`.
    const response = await this.uploadFileRequest(file, customOptions);
    // Sanity check.
    validateUploadResponse(response);
    const skylink = format_1.formatSkylink(response.data.skylink);
    const merkleroot = response.data.merkleroot;
    const bitfield = response.data.bitfield;
    return { skylink, merkleroot, bitfield };
}
exports.uploadFile = uploadFile;
/**
 * Makes a request to upload a file to Skynet.
 *
 * @param this - SkynetClient
 * @param file - The file to upload.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The upload response.
 */
async function uploadFileRequest(file, customOptions) {
    validateFile("file", file, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultUploadOptions);
    const opts = { ...exports.defaultUploadOptions, ...this.customOptions, ...customOptions };
    const formData = new FormData();
    file = ensureFileObjectConsistency(file);
    if (opts.customFilename) {
        formData.append(opts.portalFileFieldname, file, opts.customFilename);
    }
    else {
        formData.append(opts.portalFileFieldname, file);
    }
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointUpload,
        method: "post",
        data: formData,
    });
    return response;
}
exports.uploadFileRequest = uploadFileRequest;
/**
 * Uploads a directory to Skynet.
 *
 * @param this - SkynetClient
 * @param directory - File objects to upload, indexed by their path strings.
 * @param filename - The name of the directory.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The returned skylink.
 * @throws - Will throw if the request is successful but the upload response does not contain a complete response.
 */
async function uploadDirectory(directory, filename, customOptions) {
    // Validation is done in `uploadDirectoryRequest`.
    const response = await this.uploadDirectoryRequest(directory, filename, customOptions);
    // Sanity check.
    validateUploadResponse(response);
    const skylink = format_1.formatSkylink(response.data.skylink);
    const merkleroot = response.data.merkleroot;
    const bitfield = response.data.bitfield;
    return { skylink, merkleroot, bitfield };
}
exports.uploadDirectory = uploadDirectory;
/**
 * Makes a request to upload a directory to Skynet.
 *
 * @param this - SkynetClient
 * @param directory - File objects to upload, indexed by their path strings.
 * @param filename - The name of the directory.
 * @param [customOptions] - Additional settings that can optionally be set.
 * @param [customOptions.endpointPath="/skynet/skyfile"] - The relative URL path of the portal endpoint to contact.
 * @returns - The upload response.
 * @throws - Will throw if the input filename is not a string.
 */
async function uploadDirectoryRequest(directory, filename, customOptions) {
    validation_1.validateObject("directory", directory, "parameter");
    validation_1.validateString("filename", filename, "parameter");
    validation_1.validateOptionalObject("customOptions", customOptions, "parameter", exports.defaultUploadOptions);
    const opts = { ...exports.defaultUploadOptions, ...this.customOptions, ...customOptions };
    const formData = new FormData();
    Object.entries(directory).forEach(([path, file]) => {
        file = ensureFileObjectConsistency(file);
        formData.append(opts.portalDirectoryFileFieldname, file, path);
    });
    const response = await this.executeRequest({
        ...opts,
        endpointPath: opts.endpointUpload,
        method: "post",
        data: formData,
        query: { filename },
    });
    return response;
}
exports.uploadDirectoryRequest = uploadDirectoryRequest;
/**
 * Sometimes file object might have had the type property defined manually with
 * Object.defineProperty and some browsers (namely firefox) can have problems
 * reading it after the file has been appended to form data. To overcome this,
 * we recreate the file object using native File constructor with a type defined
 * as a constructor argument.
 *
 * @param file - The input file.
 * @returns - The processed file.
 * @see {@link https://github.com/NebulousLabs/skynet-webportal/issues/290| Related Issue}
 */
function ensureFileObjectConsistency(file) {
    return new File([file], file.name, { type: file_1.getFileMimeType(file) });
}
/**
 * Validates the given value as a file.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid file.
 */
function validateFile(name, value, valueKind) {
    if (!(value instanceof File)) {
        validation_1.throwValidationError(name, value, valueKind, "'File'");
    }
}
/**
 * Validates the upload response.
 *
 * @param response - The upload response.
 * @throws - Will throw if not a valid upload response.
 */
function validateUploadResponse(response) {
    try {
        if (!response.data) {
            throw new Error("response.data field missing");
        }
        validation_1.validateString("skylink", response.data.skylink, "upload response field");
        validation_1.validateString("merkleroot", response.data.merkleroot, "upload response field");
        validation_1.validateNumber("bitfield", response.data.bitfield, "upload response field");
    }
    catch (err) {
        throw new Error(`Did not get a complete upload response despite a successful request. Please try again and report this issue to the devs if it persists. Error: ${err}`);
    }
}


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/array.js":
/*!********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.areEqualUint8Arrays = void 0;
/**
 * Returns true if the two uint8 arrays are equal. From
 * https://stackoverflow.com/a/60818105/6085242
 *
 * @param array1 - The first uint8 array.
 * @param array2 - The second uint8 array.
 * @returns - Whether the arrays are equal.
 */
function areEqualUint8Arrays(array1, array2) {
    if (array1.length != array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] != array2[i]) {
            return false;
        }
    }
    return true;
}
exports.areEqualUint8Arrays = areEqualUint8Arrays;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/encoding.js":
/*!***********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/encoding.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeUtf8String = exports.encodePrefixedBytes = exports.encodeBigintAsUint64 = exports.encodeNumber = exports.encodeSkylinkBase64 = exports.decodeSkylinkBase64 = exports.encodeSkylinkBase32 = exports.decodeSkylinkBase32 = void 0;
const base32_decode_1 = __importDefault(__webpack_require__(/*! base32-decode */ "./node_modules/skynet-js/node_modules/base32-decode/index.js"));
const base32_encode_1 = __importDefault(__webpack_require__(/*! base32-encode */ "./node_modules/skynet-js/node_modules/base32-encode/index.js"));
const base64_js_1 = __webpack_require__(/*! base64-js */ "./node_modules/skynet-js/node_modules/base64-js/index.js");
const number_1 = __webpack_require__(/*! ./number */ "./node_modules/skynet-js/dist/cjs/utils/number.js");
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const BASE32_ENCODING_VARIANT = "RFC4648-HEX";
/**
 * Decodes the skylink encoded using base32 encoding to bytes.
 *
 * @param s - The encoded skylink.
 * @returns - The decoded bytes.
 */
function decodeSkylinkBase32(skylink) {
    skylink = skylink.toUpperCase();
    const bytes = base32_decode_1.default(skylink, BASE32_ENCODING_VARIANT);
    return new Uint8Array(bytes);
}
exports.decodeSkylinkBase32 = decodeSkylinkBase32;
/**
 * Encodes the bytes to a skylink encoded using base32 encoding.
 *
 * @param bytes - The bytes to encode.
 * @returns - The encoded skylink.
 */
function encodeSkylinkBase32(bytes) {
    return base32_encode_1.default(bytes, BASE32_ENCODING_VARIANT, { padding: false }).toLowerCase();
}
exports.encodeSkylinkBase32 = encodeSkylinkBase32;
/**
 * Decodes the skylink encoded using base64 raw URL encoding to bytes.
 *
 * @param s - The encoded skylink.
 * @returns - The decoded bytes.
 */
function decodeSkylinkBase64(skylink) {
    // Add padding.
    skylink = `${skylink}==`;
    // Convert from URL encoding.
    skylink = skylink.replace(/-/g, "+").replace(/_/g, "/");
    return base64_js_1.toByteArray(skylink);
}
exports.decodeSkylinkBase64 = decodeSkylinkBase64;
/**
 * Encodes the bytes to a skylink encoded using base64 raw URL encoding.
 *
 * @param bytes - The bytes to encode.
 * @returns - The encoded skylink.
 */
function encodeSkylinkBase64(bytes) {
    let base64 = base64_js_1.fromByteArray(bytes);
    // Convert to URL encoding.
    base64 = base64.replace(/\+/g, "-").replace(/\//g, "_");
    // Remove trailing "==". This will always be present as the skylink encoding
    // gets padded so that the string is a multiple of 4 characters in length.
    return base64.slice(0, -2);
}
exports.encodeSkylinkBase64 = encodeSkylinkBase64;
/**
 * Converts the given number into a uint8 array
 *
 * @param num - Number to encode.
 * @returns - Number encoded as a byte array.
 */
function encodeNumber(num) {
    const encoded = new Uint8Array(8);
    for (let index = 0; index < encoded.length; index++) {
        const byte = num & 0xff;
        encoded[index] = byte;
        num = num >> 8;
    }
    return encoded;
}
exports.encodeNumber = encodeNumber;
/**
 * Encodes the given bigint into a uint8 array.
 *
 * @param int - Bigint to encode.
 * @returns - Bigint encoded as a byte array.
 * @throws - Will throw if the int does not fit in 64 bits.
 */
function encodeBigintAsUint64(int) {
    // Assert the input is 64 bits.
    number_1.assertUint64(int);
    const encoded = new Uint8Array(8);
    for (let index = 0; index < encoded.length; index++) {
        const byte = int & BigInt(0xff);
        encoded[index] = Number(byte);
        int = int >> BigInt(8);
    }
    return encoded;
}
exports.encodeBigintAsUint64 = encodeBigintAsUint64;
/**
 * Encodes the uint8array, prefixed by its length.
 *
 * @param bytes - The input array.
 * @returns - The encoded byte array.
 */
function encodePrefixedBytes(bytes) {
    const len = bytes.length;
    const buf = new ArrayBuffer(8 + len);
    const view = new DataView(buf);
    // Sia uses setUint64 which is unavailable in JS.
    view.setUint32(0, len, true);
    const uint8Bytes = new Uint8Array(buf);
    uint8Bytes.set(bytes, 8);
    return uint8Bytes;
}
exports.encodePrefixedBytes = encodePrefixedBytes;
/**
 * Encodes the given UTF-8 string into a uint8 array containing the string length and the string.
 *
 * @param str - String to encode.
 * @returns - String encoded as a byte array.
 */
function encodeUtf8String(str) {
    const byteArray = string_1.stringToUint8ArrayUtf8(str);
    const encoded = new Uint8Array(8 + byteArray.length);
    encoded.set(encodeNumber(byteArray.length));
    encoded.set(byteArray, 8);
    return encoded;
}
exports.encodeUtf8String = encodeUtf8String;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/file.js":
/*!*******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/file.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFileMimeType = exports.getRootDirectory = exports.getRelativeFilePath = void 0;
const lite_1 = __importDefault(__webpack_require__(/*! mime/lite */ "./node_modules/skynet-js/node_modules/mime/lite.js"));
const path_browserify_1 = __importDefault(__webpack_require__(/*! path-browserify */ "./node_modules/skynet-js/node_modules/path-browserify/index.js"));
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * Gets the path for the file.
 *
 * @param file - The file.
 * @returns - The path.
 */
function getFilePath(file) {
    /* istanbul ignore next */
    return file.webkitRelativePath || file.path || file.name;
}
/**
 * Gets the file path relative to the root directory of the path, e.g. `bar` in `/foo/bar`.
 *
 * @param file - The input file.
 * @returns - The relative file path.
 */
function getRelativeFilePath(file) {
    const filePath = getFilePath(file);
    const { root, dir, base } = path_browserify_1.default.parse(filePath);
    const relative = path_browserify_1.default.normalize(dir).slice(root.length).split(path_browserify_1.default.sep).slice(1);
    return path_browserify_1.default.join(...relative, base);
}
exports.getRelativeFilePath = getRelativeFilePath;
/**
 * Gets the root directory of the file path, e.g. `foo` in `/foo/bar`.
 *
 * @param file - The input file.
 * @returns - The root directory.
 */
function getRootDirectory(file) {
    const filePath = getFilePath(file);
    const { root, dir } = path_browserify_1.default.parse(filePath);
    return path_browserify_1.default.normalize(dir).slice(root.length).split(path_browserify_1.default.sep)[0];
}
exports.getRootDirectory = getRootDirectory;
/**
 * Get the file mime type. In case the type is not provided, use mime-db and try
 * to guess the file type based on the extension.
 *
 * @param file - The file.
 * @returns - The mime type.
 */
function getFileMimeType(file) {
    if (file.type)
        return file.type;
    let { ext } = path_browserify_1.default.parse(file.name);
    ext = string_1.trimPrefix(ext, ".");
    if (ext !== "") {
        const mimeType = lite_1.default.getType(ext);
        if (mimeType) {
            return mimeType;
        }
    }
    return "";
}
exports.getFileMimeType = getFileMimeType;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/number.js":
/*!*********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/number.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertUint64 = exports.MAX_REVISION = void 0;
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * The maximum allowed value for an entry revision. Setting an entry revision to this value prevents it from being updated further.
 */
exports.MAX_REVISION = BigInt("18446744073709551615"); // max uint64
/**
 * Checks if the provided bigint can fit in a 64-bit unsigned integer.
 *
 * @param int - The provided integer.
 * @throws - Will throw if the int does not fit in 64 bits.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN | MDN Demo}
 */
function assertUint64(int) {
    validation_1.validateBigint("int", int, "parameter");
    if (int < BigInt(0)) {
        throw new Error(`Argument ${int} must be an unsigned 64-bit integer; was negative`);
    }
    if (int > exports.MAX_REVISION) {
        throw new Error(`Argument ${int} does not fit in a 64-bit unsigned integer; exceeds 2^64-1`);
    }
}
exports.assertUint64 = assertUint64;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/options.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/options.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractOptions = exports.defaultBaseOptions = void 0;
/**
 * The default base custom options.
 */
exports.defaultBaseOptions = {
    APIKey: "",
    customUserAgent: "",
    customCookie: "",
    onUploadProgress: undefined,
};
/**
 * Extract only the model's custom options from the given options.
 *
 * @param opts - The given options.
 * @param model - The model options.
 * @returns - The extracted custom options.
 */
function extractOptions(opts, model) {
    const result = {};
    for (const property in model) {
        if (Object.prototype.hasOwnProperty.call(model, property)) {
            result[property] = opts[property];
        }
    }
    return result;
}
exports.extractOptions = extractOptions;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/string.js":
/*!*********************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHexString = exports.isHexString = exports.hexToUint8Array = exports.uint8ArrayToStringUtf8 = exports.stringToUint8ArrayUtf8 = exports.trimUriPrefix = exports.trimSuffix = exports.trimPrefix = exports.trimForwardSlash = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/skynet-js/node_modules/buffer/index.js");
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
/**
 * Removes slashes from the beginning and end of the string.
 *
 * @param str - The string to process.
 * @returns - The processed string.
 */
function trimForwardSlash(str) {
    return trimPrefix(trimSuffix(str, "/"), "/");
}
exports.trimForwardSlash = trimForwardSlash;
// TODO: Move to mysky-utils
/**
 * Removes a prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimPrefix(str, prefix, limit) {
    while (str.startsWith(prefix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.slice(prefix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimPrefix = trimPrefix;
// TODO: Move to mysky-utils
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimSuffix(str, suffix, limit) {
    while (str.endsWith(suffix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.substring(0, str.length - suffix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimSuffix = trimSuffix;
/**
 * Removes a URI prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @returns - The processed string.
 */
function trimUriPrefix(str, prefix) {
    const shortPrefix = trimSuffix(prefix, "/");
    if (str.startsWith(prefix)) {
        // longPrefix is exactly at the beginning
        return str.slice(prefix.length);
    }
    if (str.startsWith(shortPrefix)) {
        // else prefix is exactly at the beginning
        return str.slice(shortPrefix.length);
    }
    return str;
}
exports.trimUriPrefix = trimUriPrefix;
/**
 * Converts a UTF-8 string to a uint8 array containing valid UTF-8 bytes.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a string.
 */
function stringToUint8ArrayUtf8(str) {
    validation_1.validateString("str", str, "parameter");
    return Uint8Array.from(buffer_1.Buffer.from(str, "utf-8"));
}
exports.stringToUint8ArrayUtf8 = stringToUint8ArrayUtf8;
/**
 * Converts a uint8 array containing valid utf-8 bytes to a string.
 *
 * @param array - The uint8 array to convert.
 * @returns - The string.
 */
function uint8ArrayToStringUtf8(array) {
    return buffer_1.Buffer.from(array).toString("utf-8");
}
exports.uint8ArrayToStringUtf8 = uint8ArrayToStringUtf8;
/**
 * Converts a hex encoded string to a uint8 array.
 *
 * @param str - The string to convert.
 * @returns - The uint8 array.
 * @throws - Will throw if the input is not a valid hex-encoded string or is an empty string.
 */
function hexToUint8Array(str) {
    validation_1.validateHexString("str", str, "parameter");
    const matches = str.match(/.{1,2}/g);
    if (matches === null) {
        throw validation_1.throwValidationError("str", str, "parameter", "a hex-encoded string");
    }
    return new Uint8Array(matches.map((byte) => parseInt(byte, 16)));
}
exports.hexToUint8Array = hexToUint8Array;
/**
 * Returns true if the input is a valid hex-encoded string.
 *
 * @param str - The input string.
 * @returns - True if the input is hex-encoded.
 * @throws - Will throw if the input is not a string.
 */
function isHexString(str) {
    validation_1.validateString("str", str, "parameter");
    return /^[0-9A-Fa-f]*$/g.test(str);
}
exports.isHexString = isHexString;
/**
 * Convert a byte array to a hex string.
 *
 * @param byteArray - The byte array to convert.
 * @returns - The hex string.
 * @see {@link https://stackoverflow.com/a/44608819|Stack Overflow}
 */
function toHexString(byteArray) {
    let s = "";
    byteArray.forEach(function (byte) {
        s += ("0" + (byte & 0xff).toString(16)).slice(-2);
    });
    return s;
}
exports.toHexString = toHexString;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/url.js":
/*!******************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/url.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractDomainForPortal = exports.getFullDomainUrlForPortal = exports.makeUrl = exports.addUrlQuery = exports.addSubdomain = exports.addPath = exports.defaultPortalUrl = exports.uriSkynetPrefix = exports.uriHandshakePrefix = exports.defaultSkynetPortalUrl = void 0;
const url_parse_1 = __importDefault(__webpack_require__(/*! url-parse */ "./node_modules/skynet-js/node_modules/url-parse/index.js"));
const url_join_1 = __importDefault(__webpack_require__(/*! url-join */ "./node_modules/skynet-js/node_modules/url-join/lib/url-join.js"));
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
const validation_1 = __webpack_require__(/*! ./validation */ "./node_modules/skynet-js/dist/cjs/utils/validation.js");
exports.defaultSkynetPortalUrl = "https://siasky.net";
exports.uriHandshakePrefix = "hns://";
exports.uriSkynetPrefix = "sia://";
// TODO: This will be smarter. See
// https://github.com/NebulousLabs/skynet-docs/issues/21.
/**
 * Returns the default portal URL.
 *
 * @returns - The portal URL.
 */
function defaultPortalUrl() {
    /* istanbul ignore next */
    if (typeof window === "undefined")
        return "/"; // default to path root on ssr
    return window.location.origin;
}
exports.defaultPortalUrl = defaultPortalUrl;
/**
 * Adds a path to the given URL.
 *
 * @param url - The URL.
 * @param path - The given path.
 * @returns - The final URL.
 */
function addPath(url, path) {
    validation_1.validateString("url", url, "parameter");
    validation_1.validateString("path", path, "parameter");
    path = string_1.trimForwardSlash(path);
    let str;
    if (url === "localhost") {
        // Special handling for localhost.
        str = `localhost/${path}`;
    }
    else {
        // Construct a URL object and set the pathname property.
        const urlObj = new URL(url);
        urlObj.pathname = path;
        str = urlObj.toString();
    }
    return string_1.trimSuffix(str, "/");
}
exports.addPath = addPath;
/**
 * Adds a subdomain to the given URL.
 *
 * @param url - The URL.
 * @param subdomain - The subdomain to add.
 * @returns - The final URL.
 */
function addSubdomain(url, subdomain) {
    const urlObj = new URL(url);
    urlObj.hostname = `${subdomain}.${urlObj.hostname}`;
    const str = urlObj.toString();
    return string_1.trimSuffix(str, "/");
}
exports.addSubdomain = addSubdomain;
/**
 * Adds a query to the given URL.
 *
 * @param url - The URL.
 * @param query - The query parameters.
 * @returns - The final URL.
 */
function addUrlQuery(url, query) {
    const parsed = url_parse_1.default(url, true);
    // Combine the desired query params with the already existing ones.
    query = { ...parsed.query, ...query };
    parsed.set("query", query);
    return parsed.toString();
}
exports.addUrlQuery = addUrlQuery;
/**
 * Properly joins paths together to create a URL. Takes a variable number of
 * arguments.
 *
 * @param args - Array of URL parts to join.
 * @returns - Final URL constructed from the input parts.
 */
function makeUrl(...args) {
    if (args.length === 0) {
        validation_1.throwValidationError("args", args, "parameter", "non-empty");
    }
    return args.reduce((acc, cur) => url_join_1.default(acc, cur));
}
exports.makeUrl = makeUrl;
/**
 * Constructs the full URL for the given domain,
 * e.g. ("https://siasky.net", "dac.hns/path/file") => "https://dac.hns.siasky.net/path/file"
 *
 * @param portalUrl - The portal URL.
 * @param domain - Domain.
 * @returns - The full URL for the given domain.
 */
function getFullDomainUrlForPortal(portalUrl, domain) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("domain", domain, "parameter");
    domain = string_1.trimUriPrefix(domain, exports.uriSkynetPrefix);
    domain = string_1.trimForwardSlash(domain);
    // Split on first / to get the path.
    let path;
    [domain, path] = domain.split(/\/(.+)/);
    // Add to subdomain.
    let url;
    if (domain === "localhost") {
        // Special handling for localhost.
        url = "localhost";
    }
    else {
        url = addSubdomain(portalUrl, domain);
    }
    // Add back the path if there was one.
    if (path) {
        url = addPath(url, path);
    }
    return url;
}
exports.getFullDomainUrlForPortal = getFullDomainUrlForPortal;
/**
 * Extracts the domain from the given portal URL,
 * e.g. ("https://siasky.net", "dac.hns.siasky.net/path/file") => "dac.hns/path/file"
 *
 * @param portalUrl - The portal URL.
 * @param fullDomain - Full URL.
 * @returns - The extracted domain.
 */
function extractDomainForPortal(portalUrl, fullDomain) {
    validation_1.validateString("portalUrl", portalUrl, "parameter");
    validation_1.validateString("fullDomain", fullDomain, "parameter");
    let path;
    try {
        // Try to extract the domain from the fullDomain.
        const fullDomainObj = new URL(fullDomain);
        fullDomain = fullDomainObj.hostname;
        path = fullDomainObj.pathname;
        path = string_1.trimForwardSlash(path);
    }
    catch {
        // If fullDomain is not a URL, ignore the error and use it as-is.
        //
        // Trim any slashes from the input URL.
        fullDomain = string_1.trimForwardSlash(fullDomain);
        // Split on first / to get the path.
        [fullDomain, path] = fullDomain.split(/\/(.+)/);
    }
    // Get the portal domain.
    const portalUrlObj = new URL(portalUrl);
    const portalDomain = string_1.trimForwardSlash(portalUrlObj.hostname);
    // Remove the portal domain from the domain.
    let domain = string_1.trimSuffix(fullDomain, portalDomain, 1);
    domain = string_1.trimSuffix(domain, ".");
    // Add back the path if there is one.
    if (path && path !== "") {
        path = string_1.trimForwardSlash(path);
        domain = `${domain}/${path}`;
    }
    return domain;
}
exports.extractDomainForPortal = extractDomainForPortal;


/***/ }),

/***/ "./node_modules/skynet-js/dist/cjs/utils/validation.js":
/*!*************************************************************!*\
  !*** ./node_modules/skynet-js/dist/cjs/utils/validation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwValidationError = exports.validateUint8ArrayLen = exports.validateUint8Array = exports.validateHexString = exports.validateStringLen = exports.validateString = exports.validateNumber = exports.validateOptionalObject = exports.validateObject = exports.validateBigint = void 0;
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/skynet-js/dist/cjs/utils/string.js");
/**
 * Validates the given value as a bigint.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid bigint.
 */
function validateBigint(name, value, valueKind) {
    if (typeof value !== "bigint") {
        throwValidationError(name, value, valueKind, "type 'bigint'");
    }
}
exports.validateBigint = validateBigint;
/**
 * Validates the given value as an object.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid object.
 */
function validateObject(name, value, valueKind) {
    if (typeof value !== "object") {
        throwValidationError(name, value, valueKind, "type 'object'");
    }
    if (value === null) {
        throwValidationError(name, value, valueKind, "non-null");
    }
}
exports.validateObject = validateObject;
/**
 * Validates the given value as an optional object.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param model - A model object that contains all possible fields. 'value' does not need to have all fields, but it may not have any fields not contained in 'model'.
 * @throws - Will throw if not a valid optional object.
 */
function validateOptionalObject(name, value, valueKind, model) {
    if (!value) {
        // This is okay, the object is optional.
        return;
    }
    validateObject(name, value, valueKind);
    // Check if all given properties of value also exist in the model.
    for (const property in value) {
        if (!(property in model)) {
            throw new Error(`Object ${valueKind} '${name}' contains unexpected property '${property}'`);
        }
    }
}
exports.validateOptionalObject = validateOptionalObject;
/**
 * Validates the given value as a number.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid number.
 */
function validateNumber(name, value, valueKind) {
    if (typeof value !== "number") {
        throwValidationError(name, value, valueKind, "type 'number'");
    }
}
exports.validateNumber = validateNumber;
/**
 * Validates the given value as a string.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid string.
 */
function validateString(name, value, valueKind) {
    if (typeof value !== "string") {
        throwValidationError(name, value, valueKind, "type 'string'");
    }
}
exports.validateString = validateString;
/**
 * Validates the given value as a string of the given length.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param len - The length to check.
 * @throws - Will throw if not a valid string of the given length.
 */
function validateStringLen(name, value, valueKind, len) {
    validateString(name, value, valueKind);
    const actualLen = value.length;
    if (actualLen !== len) {
        throwValidationError(name, value, valueKind, `'string' of length ${len}, was length ${actualLen}`);
    }
}
exports.validateStringLen = validateStringLen;
/**
 * Validates the given value as a hex-encoded string.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid hex-encoded string.
 */
function validateHexString(name, value, valueKind) {
    validateString(name, value, valueKind);
    if (!string_1.isHexString(value)) {
        throwValidationError(name, value, valueKind, "a hex-encoded string");
    }
}
exports.validateHexString = validateHexString;
/**
 * Validates the given value as a uint8array.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @throws - Will throw if not a valid uint8array.
 */
function validateUint8Array(name, value, valueKind) {
    if (!(value instanceof Uint8Array)) {
        throwValidationError(name, value, valueKind, "'Uint8Array'");
    }
}
exports.validateUint8Array = validateUint8Array;
/**
 * Validates the given value as a uint8array of the given length.
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param len - The length to check.
 * @throws - Will throw if not a valid uint8array of the given length.
 */
function validateUint8ArrayLen(name, value, valueKind, len) {
    validateUint8Array(name, value, valueKind);
    const actualLen = value.length;
    if (actualLen !== len) {
        throwValidationError(name, value, valueKind, `'Uint8Array' of length ${len}, was length ${actualLen}`);
    }
}
exports.validateUint8ArrayLen = validateUint8ArrayLen;
/**
 * Throws an error for the given value
 *
 * @param name - The name of the value.
 * @param value - The actual value.
 * @param valueKind - The kind of value that is being checked (e.g. "parameter", "response field", etc.)
 * @param expected - The expected aspect of the value that could not be validated (e.g. "type 'string'" or "non-null").
 * @throws - Will always throw.
 */
function throwValidationError(name, value, valueKind, expected) {
    throw new Error(`Expected ${valueKind} '${name}' to be ${expected}, was '${value}'`);
}
exports.throwValidationError = throwValidationError;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/index.js":
/*!************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/skynet-js/node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/adapters/xhr.js":
/*!***********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/adapters/xhr.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/skynet-js/node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/skynet-js/node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/skynet-js/node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/axios.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/axios.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/skynet-js/node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/skynet-js/node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/skynet-js/node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/skynet-js/node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/skynet-js/node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/skynet-js/node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/cancel/Cancel.js":
/*!************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/cancel/Cancel.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/cancel/CancelToken.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/cancel/CancelToken.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/skynet-js/node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/cancel/isCancel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/cancel/isCancel.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/Axios.js":
/*!*********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/Axios.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/skynet-js/node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/skynet-js/node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/skynet-js/node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/InterceptorManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/InterceptorManager.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/buildFullPath.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/buildFullPath.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/createError.js":
/*!***************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/createError.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/skynet-js/node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/dispatchRequest.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/dispatchRequest.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/skynet-js/node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/skynet-js/node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/skynet-js/node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/enhanceError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/enhanceError.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/mergeConfig.js":
/*!***************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/mergeConfig.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/settle.js":
/*!**********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/settle.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/skynet-js/node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/core/transformData.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/core/transformData.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/defaults.js":
/*!*******************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/defaults.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/skynet-js/node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/skynet-js/node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/bind.js":
/*!***********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/bind.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/buildURL.js":
/*!***************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/buildURL.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/combineURLs.js":
/*!******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/combineURLs.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/cookies.js":
/*!**************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/cookies.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!********************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isAxiosError.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/isAxiosError.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/parseHeaders.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/parseHeaders.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/skynet-js/node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/helpers/spread.js":
/*!*************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/helpers/spread.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/axios/lib/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/axios/lib/utils.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/skynet-js/node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/base32-decode/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/base32-decode/index.js ***!
  \********************************************************************/
/***/ ((module) => {

var RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
var RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
var CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

function readChar (alphabet, char) {
  var idx = alphabet.indexOf(char)

  if (idx === -1) {
    throw new Error('Invalid character found: ' + char)
  }

  return idx
}

module.exports = function base32Decode (input, variant) {
  var alphabet

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      input = input.replace(/=+$/, '')
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      input = input.replace(/=+$/, '')
      break
    case 'Crockford':
      alphabet = CROCKFORD
      input = input.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  var length = input.length

  var bits = 0
  var value = 0

  var index = 0
  var output = new Uint8Array((length * 5 / 8) | 0)

  for (var i = 0; i < length; i++) {
    value = (value << 5) | readChar(alphabet, input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/base32-encode/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/base32-encode/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toDataView = __webpack_require__(/*! to-data-view */ "./node_modules/skynet-js/node_modules/to-data-view/index.js")

var RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
var RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
var CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

module.exports = function base32Encode (data, variant, options) {
  options = options || {}
  var alphabet, defaultPadding

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  var padding = (options.padding !== undefined ? options.padding : defaultPadding)
  var view = toDataView(data)

  var bits = 0
  var value = 0
  var output = ''

  for (var i = 0; i < view.byteLength; i++) {
    value = (value << 8) | view.getUint8(i)
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/base64-js/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/base64-js/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/blakejs/blake2b.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/blakejs/blake2b.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = __webpack_require__(/*! ./util */ "./node_modules/skynet-js/node_modules/blakejs/util.js")

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  var o0 = v[a] + v[b]
  var o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  var o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  var o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return (arr[i] ^
  (arr[i + 1] << 8) ^
  (arr[i + 2] << 16) ^
  (arr[i + 3] << 24))
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  var x0 = m[ix]
  var x1 = m[ix + 1]
  var y0 = m[iy]
  var y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  var xor0 = v[d] ^ v[a]
  var xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,
  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,
  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,
  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19
])

var SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32)
var m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  var i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function blake2bInit (outlen, key) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }

  // state, 'param block'
  var ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize hash state
  for (var i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i]
  }
  var keylen = key ? key.length : 0
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2b (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2bInit(outlen, key)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2bHex (input, key, outlen) {
  var output = blake2b(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/blakejs/blake2s.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/blakejs/blake2s.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// BLAKE2s hash function in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = __webpack_require__(/*! ./util */ "./node_modules/skynet-js/node_modules/blakejs/util.js")

// Little-endian byte access.
// Expects a Uint8Array and an index
// Returns the little-endian uint32 at v[i..i+3]
function B2S_GET32 (v, i) {
  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
}

// Mixing function G.
function B2S_G (a, b, c, d, x, y) {
  v[a] = v[a] + v[b] + x
  v[d] = ROTR32(v[d] ^ v[a], 16)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 12)
  v[a] = v[a] + v[b] + y
  v[d] = ROTR32(v[d] ^ v[a], 8)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 7)
}

// 32-bit right rotation
// x should be a uint32
// y must be between 1 and 31, inclusive
function ROTR32 (x, y) {
  return (x >>> y) ^ (x << (32 - y))
}

// Initialization Vector.
var BLAKE2S_IV = new Uint32Array([
  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19])

var SIGMA = new Uint8Array([
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])

// Compression function. "last" flag indicates last block
var v = new Uint32Array(16)
var m = new Uint32Array(16)
function blake2sCompress (ctx, last) {
  var i = 0
  for (i = 0; i < 8; i++) { // init work variables
    v[i] = ctx.h[i]
    v[i + 8] = BLAKE2S_IV[i]
  }

  v[12] ^= ctx.t // low 32 bits of offset
  v[13] ^= (ctx.t / 0x100000000) // high 32 bits
  if (last) { // last block flag set ?
    v[14] = ~v[14]
  }

  for (i = 0; i < 16; i++) { // get little-endian words
    m[i] = B2S_GET32(ctx.b, 4 * i)
  }

  // ten rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 32)
  for (i = 0; i < 10; i++) {
    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])
    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])
    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])
    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])
    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])
    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])
    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])
    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])
  }
  // util.debugPrint('   (i=10) v[16]', v, 32)

  for (i = 0; i < 8; i++) {
    ctx.h[i] ^= v[i] ^ v[i + 8]
  }
  // util.debugPrint('h[8]', ctx.h, 32)
}

// Creates a BLAKE2s hashing context
// Requires an output length between 1 and 32 bytes
// Takes an optional Uint8Array key
function blake2sInit (outlen, key) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error('Incorrect output length, should be in [1, 32]')
  }
  var keylen = key ? key.length : 0
  if (key && !(keylen > 0 && keylen <= 32)) {
    throw new Error('Incorrect key length, should be in [1, 32]')
  }

  var ctx = {
    h: new Uint32Array(BLAKE2S_IV), // hash state
    b: new Uint32Array(64), // input block
    c: 0, // pointer within block
    t: 0, // input count
    outlen: outlen // output length in bytes
  }
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  if (keylen > 0) {
    blake2sUpdate(ctx, key)
    ctx.c = 64 // at the end
  }

  return ctx
}

// Updates a BLAKE2s streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2sUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 64) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2sCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2s streaming hash
// Returns a Uint8Array containing the message digest
function blake2sFinal (ctx) {
  ctx.t += ctx.c // mark last block offset
  while (ctx.c < 64) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2sCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xFF
  }
  return out
}

// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2s (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 32
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2sInit(outlen, key)
  blake2sUpdate(ctx, input)
  return blake2sFinal(ctx)
}

// Computes the BLAKE2S hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2sHex (input, key, outlen) {
  var output = blake2s(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2s: blake2s,
  blake2sHex: blake2sHex,
  blake2sInit: blake2sInit,
  blake2sUpdate: blake2sUpdate,
  blake2sFinal: blake2sFinal
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/blakejs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/blakejs/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var b2b = __webpack_require__(/*! ./blake2b */ "./node_modules/skynet-js/node_modules/blakejs/blake2b.js")
var b2s = __webpack_require__(/*! ./blake2s */ "./node_modules/skynet-js/node_modules/blakejs/blake2s.js")

module.exports = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/blakejs/util.js":
/*!*************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/blakejs/util.js ***!
  \*************************************************************/
/***/ ((module) => {

var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  var ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (input instanceof Buffer) {
    ret = new Uint8Array(input)
  } else if (typeof (input) === 'string') {
    ret = new Uint8Array(Buffer.from(input, 'utf8'))
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map.call(bytes, function (n) {
    return (n < 16 ? '0' : '') + n.toString(16)
  }).join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  var msg = '\n' + label + ' = '
  for (var i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  var startMs = new Date().getTime()

  var input = new Uint8Array(N)
  for (var i = 0; i < N; i++) {
    input[i] = i % 256
  }
  var genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (i = 0; i < M; i++) {
    var hashHex = hashFn(input)
    var hashMs = new Date().getTime()
    var ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND')
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/buffer/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/buffer/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/skynet-js/node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/skynet-js/node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/ieee754/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/ieee754/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/Mime.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/Mime.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/lite.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/lite.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Mime = __webpack_require__(/*! ./Mime */ "./node_modules/skynet-js/node_modules/mime/Mime.js");
module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "./node_modules/skynet-js/node_modules/mime/types/standard.js"));


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/mime/types/standard.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/mime/types/standard.js ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/path-browserify/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/path-browserify/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/post-me/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/post-me/dist/index.js ***!
  \*******************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ChildHandshake = ChildHandshake;
  _exports.DebugMessenger = DebugMessenger;
  _exports.ParentHandshake = ParentHandshake;
  _exports.debug = debug;
  _exports.WorkerMessenger = _exports.WindowMessenger = _exports.PortMessenger = _exports.ConcreteEmitter = _exports.BareMessenger = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var MARKER = '@post-me';

  function createUniqueIdFn() {
    var __id = 0;
    return function () {
      var id = __id;
      __id += 1;
      return id;
    };
  }
  /**
   * A concrete implementation of the {@link Emitter} interface
   *
   * @public
   */


  var ConcreteEmitter = /*#__PURE__*/function () {
    function ConcreteEmitter() {
      _classCallCheck(this, ConcreteEmitter);

      this._listeners = {};
    }
    /** {@inheritDoc Emitter.addEventListener} */


    _createClass(ConcreteEmitter, [{
      key: "addEventListener",
      value: function addEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          listeners = new Set();
          this._listeners[eventName] = listeners;
        }

        listeners.add(listener);
      }
      /** {@inheritDoc Emitter.removeEventListener} */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(eventName, listener) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners["delete"](listener);
      }
      /** {@inheritDoc Emitter.once} */

    }, {
      key: "once",
      value: function once(eventName) {
        var _this = this;

        return new Promise(function (resolve) {
          var listener = function listener(data) {
            _this.removeEventListener(eventName, listener);

            resolve(data);
          };

          _this.addEventListener(eventName, listener);
        });
      }
      /** @internal */

    }, {
      key: "emit",
      value: function emit(eventName, data) {
        var listeners = this._listeners[eventName];

        if (!listeners) {
          return;
        }

        listeners.forEach(function (listener) {
          listener(data);
        });
      }
      /** @internal */

    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        Object.values(this._listeners).forEach(function (listeners) {
          if (listeners) {
            listeners.clear();
          }
        });
      }
    }]);

    return ConcreteEmitter;
  }();

  _exports.ConcreteEmitter = ConcreteEmitter;
  var MessageType;

  (function (MessageType) {
    MessageType["HandshakeRequest"] = "handshake-request";
    MessageType["HandshakeResponse"] = "handshake-response";
    MessageType["Call"] = "call";
    MessageType["Response"] = "response";
    MessageType["Error"] = "error";
    MessageType["Event"] = "event";
    MessageType["Callback"] = "callback";
  })(MessageType || (MessageType = {})); // Message Creators


  function createHandshakeRequestMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeRequest,
      sessionId: sessionId
    };
  }

  function createHandshakeResponseMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeResponse,
      sessionId: sessionId
    };
  }

  function createCallMessage(sessionId, requestId, methodName, args) {
    return {
      type: MARKER,
      action: MessageType.Call,
      sessionId: sessionId,
      requestId: requestId,
      methodName: methodName,
      args: args
    };
  }

  function createResponsMessage(sessionId, requestId, result, error) {
    var message = {
      type: MARKER,
      action: MessageType.Response,
      sessionId: sessionId,
      requestId: requestId
    };

    if (result !== undefined) {
      message.result = result;
    }

    if (error !== undefined) {
      message.error = error;
    }

    return message;
  }

  function createCallbackMessage(sessionId, requestId, callbackId, args) {
    return {
      type: MARKER,
      action: MessageType.Callback,
      sessionId: sessionId,
      requestId: requestId,
      callbackId: callbackId,
      args: args
    };
  }

  function createEventMessage(sessionId, eventName, payload) {
    return {
      type: MARKER,
      action: MessageType.Event,
      sessionId: sessionId,
      eventName: eventName,
      payload: payload
    };
  } // Type Guards


  function isMessage(m) {
    return m && m.type === MARKER;
  }

  function isHandshakeRequestMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeRequest;
  }

  function isHandshakeResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeResponse;
  }

  function isCallMessage(m) {
    return isMessage(m) && m.action === MessageType.Call;
  }

  function isResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.Response;
  }

  function isCallbackMessage(m) {
    return isMessage(m) && m.action === MessageType.Callback;
  }

  function isEventMessage(m) {
    return isMessage(m) && m.action === MessageType.Event;
  }

  function makeCallbackEvent(requestId) {
    return "callback_".concat(requestId);
  }

  function makeResponseEvent(requestId) {
    return "response_".concat(requestId);
  }

  var Dispatcher = /*#__PURE__*/function (_ConcreteEmitter) {
    _inherits(Dispatcher, _ConcreteEmitter);

    var _super = _createSuper(Dispatcher);

    function Dispatcher(messenger, sessionId) {
      var _this2;

      _classCallCheck(this, Dispatcher);

      _this2 = _super.call(this);
      _this2.uniqueId = createUniqueIdFn();
      _this2.messenger = messenger;
      _this2.sessionId = sessionId;
      _this2.removeMessengerListener = _this2.messenger.addMessageListener(_this2.messengerListener.bind(_assertThisInitialized(_this2)));
      return _this2;
    }

    _createClass(Dispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isCallMessage(data)) {
          this.emit(MessageType.Call, data);
        } else if (isResponseMessage(data)) {
          this.emit(makeResponseEvent(data.requestId), data);
        } else if (isEventMessage(data)) {
          this.emit(MessageType.Event, data);
        } else if (isCallbackMessage(data)) {
          this.emit(makeCallbackEvent(data.requestId), data);
        }
      }
    }, {
      key: "callOnRemote",
      value: function callOnRemote(methodName, args, transfer) {
        var requestId = this.uniqueId();
        var callbackEvent = makeCallbackEvent(requestId);
        var responseEvent = makeResponseEvent(requestId);
        var message = createCallMessage(this.sessionId, requestId, methodName, args);
        this.messenger.postMessage(message, transfer);
        return {
          callbackEvent: callbackEvent,
          responseEvent: responseEvent
        };
      }
    }, {
      key: "respondToRemote",
      value: function respondToRemote(requestId, value, error, transfer) {
        if (error instanceof Error) {
          error = {
            name: error.name,
            message: error.message
          };
        }

        var message = createResponsMessage(this.sessionId, requestId, value, error);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "callbackToRemote",
      value: function callbackToRemote(requestId, callbackId, args) {
        var message = createCallbackMessage(this.sessionId, requestId, callbackId, args);
        this.messenger.postMessage(message);
      }
    }, {
      key: "emitToRemote",
      value: function emitToRemote(eventName, payload, transfer) {
        var message = createEventMessage(this.sessionId, eventName, payload);
        this.messenger.postMessage(message, transfer);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return Dispatcher;
  }(ConcreteEmitter);

  var ParentHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter2) {
    _inherits(ParentHandshakeDispatcher, _ConcreteEmitter2);

    var _super2 = _createSuper(ParentHandshakeDispatcher);

    function ParentHandshakeDispatcher(messenger, sessionId) {
      var _this3;

      _classCallCheck(this, ParentHandshakeDispatcher);

      _this3 = _super2.call(this);
      _this3.messenger = messenger;
      _this3.sessionId = sessionId;
      _this3.removeMessengerListener = _this3.messenger.addMessageListener(_this3.messengerListener.bind(_assertThisInitialized(_this3)));
      return _this3;
    }

    _createClass(ParentHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (!isMessage(data)) {
          return;
        }

        if (this.sessionId !== data.sessionId) {
          return;
        }

        if (isHandshakeResponseMessage(data)) {
          this.emit(data.sessionId, data);
        }
      }
    }, {
      key: "initiateHandshake",
      value: function initiateHandshake() {
        var message = createHandshakeRequestMessage(this.sessionId);
        this.messenger.postMessage(message);
        return this.sessionId;
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ParentHandshakeDispatcher;
  }(ConcreteEmitter);

  var ChildHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter3) {
    _inherits(ChildHandshakeDispatcher, _ConcreteEmitter3);

    var _super3 = _createSuper(ChildHandshakeDispatcher);

    function ChildHandshakeDispatcher(messenger) {
      var _this4;

      _classCallCheck(this, ChildHandshakeDispatcher);

      _this4 = _super3.call(this);
      _this4.messenger = messenger;
      _this4.removeMessengerListener = _this4.messenger.addMessageListener(_this4.messengerListener.bind(_assertThisInitialized(_this4)));
      return _this4;
    }

    _createClass(ChildHandshakeDispatcher, [{
      key: "messengerListener",
      value: function messengerListener(event) {
        var data = event.data;

        if (isHandshakeRequestMessage(data)) {
          this.emit(MessageType.HandshakeRequest, data);
        }
      }
    }, {
      key: "acceptHandshake",
      value: function acceptHandshake(sessionId) {
        var message = createHandshakeResponseMessage(sessionId);
        this.messenger.postMessage(message);
      }
    }, {
      key: "close",
      value: function close() {
        this.removeMessengerListener();
        this.removeAllListeners();
      }
    }]);

    return ChildHandshakeDispatcher;
  }(ConcreteEmitter);

  var ProxyType;

  (function (ProxyType) {
    ProxyType["Callback"] = "callback";
  })(ProxyType || (ProxyType = {}));

  function createCallbackProxy(callbackId) {
    return {
      type: MARKER,
      proxy: ProxyType.Callback,
      callbackId: callbackId
    };
  }

  function isCallbackProxy(p) {
    return p && p.type === MARKER && p.proxy === ProxyType.Callback;
  }

  var ConcreteRemoteHandle = /*#__PURE__*/function (_ConcreteEmitter4) {
    _inherits(ConcreteRemoteHandle, _ConcreteEmitter4);

    var _super4 = _createSuper(ConcreteRemoteHandle);

    function ConcreteRemoteHandle(dispatcher) {
      var _this5;

      _classCallCheck(this, ConcreteRemoteHandle);

      _this5 = _super4.call(this);
      _this5._dispatcher = dispatcher;
      _this5._callTransfer = {};

      _this5._dispatcher.addEventListener(MessageType.Event, _this5._handleEvent.bind(_assertThisInitialized(_this5)));

      return _this5;
    }

    _createClass(ConcreteRemoteHandle, [{
      key: "close",
      value: function close() {
        this.removeAllListeners();
      }
    }, {
      key: "setCallTransfer",
      value: function setCallTransfer(methodName, transfer) {
        this._callTransfer[methodName] = transfer;
      }
    }, {
      key: "call",
      value: function call(methodName) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return this.customCall(methodName, args);
      }
    }, {
      key: "customCall",
      value: function customCall(methodName, args) {
        var _this6 = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return new Promise(function (resolve, reject) {
          var sanitizedArgs = [];
          var callbacks = [];
          var callbackId = 0;
          args.forEach(function (arg) {
            if (typeof arg === 'function') {
              callbacks.push(arg);
              sanitizedArgs.push(createCallbackProxy(callbackId));
              callbackId += 1;
            } else {
              sanitizedArgs.push(arg);
            }
          });
          var hasCallbacks = callbacks.length > 0;
          var callbackListener = undefined;

          if (hasCallbacks) {
            callbackListener = function callbackListener(data) {
              var callbackId = data.callbackId,
                  args = data.args;
              callbacks[callbackId].apply(callbacks, _toConsumableArray(args));
            };
          }

          var transfer = options.transfer;

          if (transfer === undefined && _this6._callTransfer[methodName]) {
            var _this6$_callTransfer;

            transfer = (_this6$_callTransfer = _this6._callTransfer)[methodName].apply(_this6$_callTransfer, sanitizedArgs);
          }

          var _this6$_dispatcher$ca = _this6._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer),
              callbackEvent = _this6$_dispatcher$ca.callbackEvent,
              responseEvent = _this6$_dispatcher$ca.responseEvent;

          if (hasCallbacks) {
            _this6._dispatcher.addEventListener(callbackEvent, callbackListener);
          }

          _this6._dispatcher.once(responseEvent).then(function (response) {
            if (callbackListener) {
              _this6._dispatcher.removeEventListener(callbackEvent, callbackListener);
            }

            var result = response.result,
                error = response.error;

            if (error !== undefined) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        });
      }
    }, {
      key: "_handleEvent",
      value: function _handleEvent(data) {
        var eventName = data.eventName,
            payload = data.payload;
        this.emit(eventName, payload);
      }
    }]);

    return ConcreteRemoteHandle;
  }(ConcreteEmitter);

  var ConcreteLocalHandle = /*#__PURE__*/function () {
    function ConcreteLocalHandle(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteLocalHandle);

      this._dispatcher = dispatcher;
      this._methods = localMethods;
      this._returnTransfer = {};
      this._emitTransfer = {};

      this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));
    }

    _createClass(ConcreteLocalHandle, [{
      key: "emit",
      value: function emit(eventName, payload) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var transfer = options.transfer;

        if (transfer === undefined && this._emitTransfer[eventName]) {
          transfer = this._emitTransfer[eventName](payload);
        }

        this._dispatcher.emitToRemote(eventName, payload, transfer);
      }
    }, {
      key: "setMethods",
      value: function setMethods(methods) {
        this._methods = methods;
      }
    }, {
      key: "setMethod",
      value: function setMethod(methodName, method) {
        this._methods[methodName] = method;
      }
    }, {
      key: "setReturnTransfer",
      value: function setReturnTransfer(methodName, transfer) {
        this._returnTransfer[methodName] = transfer;
      }
    }, {
      key: "setEmitTransfer",
      value: function setEmitTransfer(eventName, transfer) {
        this._emitTransfer[eventName] = transfer;
      }
    }, {
      key: "_handleCall",
      value: function _handleCall(data) {
        var _this7 = this;

        var requestId = data.requestId,
            methodName = data.methodName,
            args = data.args;
        var callMethod = new Promise(function (resolve, reject) {
          var _this7$_methods;

          var method = _this7._methods[methodName];

          if (typeof method !== 'function') {
            reject(new Error("The method \"".concat(methodName, "\" has not been implemented.")));
            return;
          }

          var desanitizedArgs = args.map(function (arg) {
            if (isCallbackProxy(arg)) {
              var callbackId = arg.callbackId;
              return function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this7._dispatcher.callbackToRemote(requestId, callbackId, args);
              };
            } else {
              return arg;
            }
          });
          Promise.resolve((_this7$_methods = _this7._methods)[methodName].apply(_this7$_methods, _toConsumableArray(desanitizedArgs))).then(resolve)["catch"](reject);
        });
        callMethod.then(function (result) {
          var transfer;

          if (_this7._returnTransfer[methodName]) {
            transfer = _this7._returnTransfer[methodName](result);
          }

          _this7._dispatcher.respondToRemote(requestId, result, undefined, transfer);
        })["catch"](function (error) {
          _this7._dispatcher.respondToRemote(requestId, undefined, error);
        });
      }
    }]);

    return ConcreteLocalHandle;
  }();

  var ConcreteConnection = /*#__PURE__*/function () {
    function ConcreteConnection(dispatcher, localMethods) {
      _classCallCheck(this, ConcreteConnection);

      this._dispatcher = dispatcher;
      this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);
      this._remoteHandle = new ConcreteRemoteHandle(dispatcher);
    }

    _createClass(ConcreteConnection, [{
      key: "close",
      value: function close() {
        this._dispatcher.close();

        this.remoteHandle().close();
      }
    }, {
      key: "localHandle",
      value: function localHandle() {
        return this._localHandle;
      }
    }, {
      key: "remoteHandle",
      value: function remoteHandle() {
        return this._remoteHandle;
      }
    }]);

    return ConcreteConnection;
  }();

  var uniqueSessionId = createUniqueIdFn();

  var runUntil = function runUntil(worker, condition, unfulfilled, maxAttempts, attemptInterval) {
    var attempt = 0;

    var fn = function fn() {
      if (!condition() && (attempt < maxAttempts || maxAttempts < 1)) {
        worker();
        attempt += 1;
        setTimeout(fn, attemptInterval);
      } else if (!condition() && attempt >= maxAttempts && maxAttempts >= 1) {
        unfulfilled();
      }
    };

    fn();
  };
  /**
   * Initiate the handshake from the Parent side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @param maxAttempts - The maximum number of handshake attempts
   * @param attemptsInterval - The interval between handshake attempts
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ParentHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
    var attemptsInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
    var thisSessionId = uniqueSessionId();
    var connected = false;
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ParentHandshakeDispatcher(messenger, thisSessionId);
      handshakeDispatcher.once(thisSessionId).then(function (response) {
        connected = true;
        handshakeDispatcher.close();
        var sessionId = response.sessionId;
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
      runUntil(function () {
        return handshakeDispatcher.initiateHandshake();
      }, function () {
        return connected;
      }, function () {
        return reject(new Error("Handshake failed, reached maximum number of attempts"));
      }, maxAttempts, attemptsInterval);
    });
  }
  /**
   * Initiate the handshake from the Child side
   *
   * @param messenger - The Messenger used to send and receive messages from the other end
   * @param localMethods - The methods that will be exposed to the other end
   * @returns A Promise to an active {@link Connection} to the other end
   *
   * @public
   */


  function ChildHandshake(messenger) {
    var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var handshakeDispatcher = new ChildHandshakeDispatcher(messenger);
      handshakeDispatcher.once(MessageType.HandshakeRequest).then(function (response) {
        var sessionId = response.sessionId;
        handshakeDispatcher.acceptHandshake(sessionId);
        handshakeDispatcher.close();
        var dispatcher = new Dispatcher(messenger, sessionId);
        var connection = new ConcreteConnection(dispatcher, localMethods);
        resolve(connection);
      });
    });
  }

  var acceptableMessageEvent = function acceptableMessageEvent(event, remoteWindow, acceptedOrigin) {
    var source = event.source,
        origin = event.origin;

    if (source !== remoteWindow) {
      return false;
    }

    if (origin !== acceptedOrigin && acceptedOrigin !== '*') {
      return false;
    }

    return true;
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with another Window.
   *
   * @public
   *
   */


  var WindowMessenger = function WindowMessenger(_ref) {
    var localWindow = _ref.localWindow,
        remoteWindow = _ref.remoteWindow,
        remoteOrigin = _ref.remoteOrigin;

    _classCallCheck(this, WindowMessenger);

    localWindow = localWindow || window;

    this.postMessage = function (message, transfer) {
      remoteWindow.postMessage(message, remoteOrigin, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        if (acceptableMessageEvent(event, remoteWindow, remoteOrigin)) {
          listener(event);
        }
      };

      localWindow.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        localWindow.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /** @public */


  _exports.WindowMessenger = WindowMessenger;

  var BareMessenger = function BareMessenger(postable) {
    _classCallCheck(this, BareMessenger);

    this.postMessage = function (message) {
      var transfer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      postable.postMessage(message, transfer);
    };

    this.addMessageListener = function (listener) {
      var outerListener = function outerListener(event) {
        listener(event);
      };

      postable.addEventListener('message', outerListener);

      var removeListener = function removeListener() {
        postable.removeEventListener('message', outerListener);
      };

      return removeListener;
    };
  };
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a Worker.
   *
   * Takes a {@link Postable} representing the `Worker` (when calling from
   * the parent context) or the `self` `DedicatedWorkerGlobalScope` object
   * (when calling from the child context).
   *
   * @public
   *
   */


  _exports.BareMessenger = BareMessenger;

  var WorkerMessenger = /*#__PURE__*/function (_BareMessenger) {
    _inherits(WorkerMessenger, _BareMessenger);

    var _super5 = _createSuper(WorkerMessenger);

    function WorkerMessenger(_ref2) {
      var worker = _ref2.worker;

      _classCallCheck(this, WorkerMessenger);

      return _super5.call(this, worker);
    }

    return WorkerMessenger;
  }(BareMessenger);
  /**
   * A concrete implementation of {@link Messenger} used to communicate with a MessagePort.
   *
   * @public
   *
   */


  _exports.WorkerMessenger = WorkerMessenger;

  var PortMessenger = /*#__PURE__*/function (_BareMessenger2) {
    _inherits(PortMessenger, _BareMessenger2);

    var _super6 = _createSuper(PortMessenger);

    function PortMessenger(_ref3) {
      var port = _ref3.port;

      _classCallCheck(this, PortMessenger);

      port.start();
      return _super6.call(this, port);
    }

    return PortMessenger;
  }(BareMessenger);
  /**
   * Create a logger function with a specific namespace
   *
   * @param namespace - The namespace will be prepended to all the arguments passed to the logger function
   * @param log - The underlying logger (`console.log` by default)
   *
   * @public
   *
   */


  _exports.PortMessenger = PortMessenger;

  function debug(namespace, log) {
    log = log || console.debug || console.log || function () {};

    return function () {
      for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        data[_key3] = arguments[_key3];
      }

      log.apply(void 0, [namespace].concat(data));
    };
  }
  /**
   * Decorate a {@link Messenger} so that it will log any message exchanged
   * @param messenger - The Messenger that will be decorated
   * @param log - The logger function that will receive each message
   * @returns A decorated Messenger
   *
   * @public
   *
   */


  function DebugMessenger(messenger, log) {
    log = log || debug('post-me');

    var debugListener = function debugListener(event) {
      var data = event.data;
      log('⬅️ received message', data);
    };

    messenger.addMessageListener(debugListener);
    return {
      postMessage: function postMessage(message, transfer) {
        log('➡️ sending message', message);
        messenger.postMessage(message, transfer);
      },
      addMessageListener: function addMessageListener(listener) {
        return messenger.addMessageListener(listener);
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/querystringify/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/querystringify/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/randombytes/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/randombytes/browser.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/skynet-js/node_modules/safe-buffer/index.js").Buffer
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/requires-port/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/requires-port/index.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/safe-buffer/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/safe-buffer/index.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/skynet-js/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/sjcl/sjcl.js":
/*!**********************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/sjcl/sjcl.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid("invalid aes key size");this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100>e;e++)k[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g<<1^g<<2^g<<3^g<<4,m=m>>8^m&255^99,c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][m]=p=p<<24^p>>>8;for(e=
0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid("invalid aes block size");var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],x=h[4];for(m=0;m<n;m++)h=a[e>>>24]^q[f>>16&255]^v[g>>8&255]^w[b&255]^d[p],k=a[f>>>24]^q[g>>16&255]^v[b>>8&255]^w[e&255]^d[p+1],l=a[g>>>24]^q[b>>16&255]^v[e>>8&255]^w[f&255]^d[p+2],b=a[b>>>24]^q[e>>16&255]^v[f>>8&255]^w[g&255]^d[p+3],p+=4,e=h,f=k,g=l;for(m=
0;4>m;m++)r[c?3&-m:m]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b=b&31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]},byteswapM:function(a){var b,c;for(b=0;b<a.length;++b)c=a[b],a[b]=c>>>24|c>>>8&0xff00|(c&0xff00)<<8|c<<24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>8>>>8>>>8),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a=a+"00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",X:"0123456789ABCDEFGHIJKLMNOPQRSTUV",BITS:32,BASE:5,REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f="",g=0,h=sjcl.codec.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&&(h=sjcl.codec.base32.X);for(c=0;f.length*d<l;)f+=h.charAt((k^a[c]>>>g)>>>e),g<d?(k=a[c]<<d-g,g+=e,c++):(k<<=d,g-=d);for(;f.length&7&&!b;)f+="=";return f},toBits:function(a,b){a=a.replace(/\s|=/g,"").toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m="base32";b&&(k=sjcl.codec.base32.X,m="base32hex");for(g=0;g<a.length;g++){n=k.indexOf(a.charAt(g));if(0>n){if(!b)try{return sjcl.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid("this isn't "+m+"!");}h>e?(h-=e,f.push(l^n>>>h),l=n<<c-h):(h+=d,l^=n<<c-h)}h&56&&f.push(sjcl.bitArray.partial(h&56,l,1));return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32.toBits(a,1)}};
sjcl.codec.base64={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&&(f=f.substr(0,62)+"-_");for(c=0;6*d.length<h;)d+=f.charAt((g^a[c]>>>e)>>>26),6>e?(g=a[c]<<6-e,e+=26,c++):(g<<=6,e-=6);for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&&(f=f.substr(0,62)+"-_");for(d=0;d<a.length;d++){h=f.indexOf(a.charAt(d));
if(0>h)throw new sjcl.exception.invalid("this isn't base64!");26<e?(e-=26,c.push(g^h>>>e),g=h<<32-e):(e+=6,g^=h<<32-e)}e&56&&c.push(sjcl.bitArray.partial(e&56,g,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff<a)throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");if("undefined"!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,c.splice(0,16));return this},finalize:function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64>b;c++){e=!0;for(d=2;d*d<=c;d++)if(0===c%d){e=
!1;break}e&&(8>b&&(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64>c;c++)16>c?d=b[c]:(d=b[c+1&15],e=b[c+14&15],d=b[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+b[c&15]+b[c+9&15]|0),d=d+q+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(r^m&(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&l^n&(k^l))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:"ccm",G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl.mode.ccm.G.indexOf(a);-1<a&&sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c<b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e||64;d=d||[];if(7>k)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(f=2;4>f&&l>>>8*f;f++);f<15-k&&(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7>g)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(b=2;4>b&&h>>>8*b;b++);b<15-g&&(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal(k.tag,a))throw new sjcl.exception.corrupt("ccm: tag doesn't match");
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2<<2|f-1)];d=h.concat(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279>=c?g=[h.partial(16,c)]:0xffffffff>=c&&(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b<g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4>e||16<e)throw new sjcl.exception.invalid("ccm: invalid tag length");
if(0xffffffff<d.length||0xffffffff<b.length)throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d<b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g<k;g+=4)g>n&&(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m,p=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l(n,l(c,h(c))));
d.length&&(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");e=e||64;var g=sjcl.mode.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4<r/32;c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&&(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice(b,r)))throw new sjcl.exception.corrupt("ocb: tag doesn't match");return q.concat(h.clamp(m,p))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128>e.bitLength(c)&&(h=f(h,d(h)),c=e.concat(c,[-2147483648,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^135*(a[0]>>>31)]}};
sjcl.mode.gcm={name:"gcm",encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||128;d=d||[];e<=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))throw new sjcl.exception.corrupt("gcm: tag doesn't match");return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128>c;c++){(d=0!==(a[Math.floor(c/32)]&1<<31-c%32))&&(e=h(e,f));g=0!==(f[3]&1);for(d=3;0<d;d--)f[d]=f[d]>>>1|(f[d-1]&1)<<31;f[0]>>>=1;g&&(f[0]^=-0x1f000000)}return e},j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d<e;d+=4)b[0]^=0xffffffff&c[d],b[1]^=0xffffffff&c[d+1],b[2]^=0xffffffff&c[d+2],b[3]^=0xffffffff&c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math.floor(h/0x100000000),h&0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c));for(l=0;l<m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&&(d=sjcl.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&0xffffffff,Math.floor(p/0x100000000),p&0xffffffff];d=sjcl.mode.gcm.j(g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid("encrypt on already updated hmac called!");this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0>d||0>c)throw new sjcl.exception.invalid("invalid params to pbkdf2");"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length<(d||1);k++){e=f=a.encrypt(n.concat(b,[k]));for(g=1;g<c;g++)for(f=a.encrypt(f),h=0;h<f.length;h++)e[h]^=f[h];l=l.concat(e)}d&&(l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady("generator isn't seeded");if(d&this.J){d=!(d&this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this.da;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.c.length&&(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&1<<g));g++);this.P>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f>this.o&&(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4>d&&(this.h[d]=this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.ca&&y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b)throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");this.M=a},addEntropy:function(a,
b,c){c=c||"user";var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&&(d=this.U[c]=this.ha++);void 0===g&&(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case "number":void 0===b&&(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else for("[object Array]"!==c&&(k=1),c=0;c<a.length&&!k;c++)"number"!==typeof a[c]&&
(k=1);if(!k){if(void 0===b)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,e=e>>>1;this.c[g].update([d,this.N++,2,b,f,a.length].concat(a))}break;case "string":void 0===b&&(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.m[g]+=b;this.f+=b;h===this.u&&(this.isReady()!==this.u&&A("seeded",Math.max(this.o,this.f)),A("progress",this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&&this.o>=a?this.m[0]>this.ba&&(new Date).valueOf()>this.Z?this.J|this.I:this.I:this.f>=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o>=a?1:this.f>a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window.addEventListener)window.addEventListener("load",
this.a.loadTimeCollector,!1),window.addEventListener("mousemove",this.a.mouseCollector,!1),window.addEventListener("keypress",this.a.keyboardCollector,!1),window.addEventListener("devicemotion",this.a.accelerometerCollector,!1),window.addEventListener("touchmove",this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector);else throw new sjcl.exception.bug("can't attach event");
this.D=!0}},stopCollectors:function(){this.D&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,!1),window.removeEventListener("mousemove",this.a.mouseCollector,!1),window.removeEventListener("keypress",this.a.keyboardCollector,!1),window.removeEventListener("devicemotion",this.a.accelerometerCollector,!1),window.removeEventListener("touchmove",this.a.touchCollector,!1)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",
this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.D=!1)},addEventListener:function(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&&e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&&0!=c&&this.addEntropy([b,c],2,"mouse");C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,"touch");C(this,0)},ma:function(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&this.addEntropy(b,1,"accelerometer")}a&&this.addEntropy(a,2,"accelerometer");C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function C(a,b){"undefined"!==typeof window&&window.performance&&"function"===typeof window.performance.now?a.addEntropy(window.performance.now(),b,"loadtime"):a.addEntropy((new Date).valueOf(),b,"loadtime")}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4>b&&(a.h[b]=a.h[b]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G= true&&module.exports){var H;try{H=__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))}catch(a){H=null}G=E=H}if(G&&E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy(D,1024,"crypto['randomBytes']");else if("undefined"!==typeof window&&"undefined"!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(F);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,"crypto['getRandomValues']")}}catch(a){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},ja:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;"string"===typeof f.salt&&(f.salt=sjcl.codec.base64.toBits(f.salt));"string"===typeof f.iv&&(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||"string"===typeof a&&100>=f.iter||64!==f.ts&&96!==f.ts&&128!==f.ts||128!==f.ks&&192!==f.ks&&0x100!==f.ks||2>f.iv.length||
4<f.iv.length)throw new sjcl.exception.invalid("json encrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.publicKey&&(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));"string"===typeof c&&(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);d.key=a;f.ct="ccm"===f.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;"string"===typeof b.salt&&(b.salt=sjcl.codec.base64.toBits(b.salt));"string"===typeof b.iv&&(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||"string"===
typeof a&&100>=b.iter||64!==b.ts&&96!==b.ts&&128!==b.ts||128!==b.ks&&192!==b.ks&&0x100!==b.ks||!b.iv||2>b.iv.length||4<b.iv.length)throw new sjcl.exception.invalid("json decrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.secretKey&&(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));"string"===typeof f&&(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f="ccm"===
b.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c="{",d="";for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid("json encode: invalid property name");c+=d+'"'+
b+'":';d=",";switch(typeof a[b]){case "number":case "boolean":c+=a[b];break;case "string":c+='"'+escape(a[b])+'"';break;case "object":c+='"'+sjcl.codec.base64.fromBits(a[b],0)+'"';break;default:throw new sjcl.exception.bug("json encode: unsupported type");}}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid("json decode: this isn't json!");a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++){if(!(d=a[c].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))throw new sjcl.exception.invalid("json decode: this isn't json!");
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4]):null!=d[5]&&(b[d[2]]="true"===d[5])}return b},g:function(a,b,c){void 0===a&&(a={});if(void 0===b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&&void 0!==a[d]&&a[d]!==b[d])throw new sjcl.exception.invalid("required parameter overridden");a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&&a[d]!==b[d]&&(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d<b.length;d++)void 0!==a[b[d]]&&(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
 true&&module.exports&&(module.exports=sjcl); true&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return sjcl}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
exports.__esModule = true;
exports.defaultHandshakeAttemptsInterval = exports.defaultHandshakeMaxAttempts = exports.monitorWindowError = exports.errorWindowClosed = exports.dispatchedErrorEvent = exports.trimSuffix = exports.removeAdjacentChars = exports.ensureUrl = exports.createIframe = exports.createFullScreenIframe = exports.PermWrite = exports.PermRead = exports.PermLegacySkyID = exports.PermHidden = exports.PermDiscoverable = exports.permTypeToString = exports.permCategoryToString = exports.PermType = exports.PermCategory = exports.Permission = exports.sanitizePath = exports.getParentPath = exports.getPathDomain = void 0;
var paths_1 = __webpack_require__(/*! ./paths */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/paths.js");
__createBinding(exports, paths_1, "getPathDomain");
__createBinding(exports, paths_1, "getParentPath");
__createBinding(exports, paths_1, "sanitizePath");
var permissions_1 = __webpack_require__(/*! ./permissions */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/permissions.js");
__createBinding(exports, permissions_1, "Permission");
__createBinding(exports, permissions_1, "PermCategory");
__createBinding(exports, permissions_1, "PermType");
__createBinding(exports, permissions_1, "permCategoryToString");
__createBinding(exports, permissions_1, "permTypeToString");
// Constants
__createBinding(exports, permissions_1, "PermDiscoverable");
__createBinding(exports, permissions_1, "PermHidden");
__createBinding(exports, permissions_1, "PermLegacySkyID");
__createBinding(exports, permissions_1, "PermRead");
__createBinding(exports, permissions_1, "PermWrite");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/utils.js");
__createBinding(exports, utils_1, "createFullScreenIframe");
__createBinding(exports, utils_1, "createIframe");
__createBinding(exports, utils_1, "ensureUrl");
__createBinding(exports, utils_1, "removeAdjacentChars");
__createBinding(exports, utils_1, "trimSuffix");
var window_listener_1 = __webpack_require__(/*! ./window-listener */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/window-listener.js");
__createBinding(exports, window_listener_1, "dispatchedErrorEvent");
__createBinding(exports, window_listener_1, "errorWindowClosed");
__createBinding(exports, window_listener_1, "monitorWindowError");
exports.defaultHandshakeMaxAttempts = 150;
exports.defaultHandshakeAttemptsInterval = 100;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/paths.js":
/*!******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/paths.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.sanitizePath = exports.getParentPath = exports.getPathDomain = void 0;
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/utils.js");
/**
 * Gets the root path domain for the given path.
 *
 * @param path - The given path.
 * @returns - The path domain.
 */
function getPathDomain(path) {
    return path.split("/")[0];
}
exports.getPathDomain = getPathDomain;
/**
 * Gets the parent path for the given path.
 *
 * @param path - The given path.
 * @returns - The parent path, or null if no parent.
 */
function getParentPath(path) {
    path = sanitizePath(path);
    var pathArray = path.split("/");
    if (pathArray.length <= 1) {
        return null;
    }
    pathArray.pop();
    path = pathArray.join("/");
    return path;
}
exports.getParentPath = getParentPath;
/**
 * Sanitizes the path by removing trailing slashes and removing repeating adjacent slashes.
 *
 * @param path - The given path
 * @returns - The sanitized path.
 */
function sanitizePath(path) {
    // Remove trailing slashes.
    path = utils_1.trimSuffix(path, "/");
    // Remove duplicate adjacent slashes.
    path = utils_1.removeAdjacentChars(path, "/");
    return path;
}
exports.sanitizePath = sanitizePath;
//# sourceMappingURL=paths.js.map

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/permissions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/permissions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.permTypeToString = exports.permCategoryToString = exports.PermType = exports.PermWrite = exports.PermRead = exports.PermCategory = exports.PermLegacySkyID = exports.PermHidden = exports.PermDiscoverable = exports.Permission = void 0;
var Permission = /** @class */ (function () {
    function Permission(requestor, path, category, permType) {
        this.requestor = requestor;
        this.path = path;
        this.category = category;
        this.permType = permType;
        if (typeof category !== "number" || !(category in PermCategory)) {
            throw new Error("Invalid 'category' enum value " + category);
        }
        if (typeof permType !== "number" || !(permType in PermType)) {
            throw new Error("Invalid 'permType' enum value " + permType);
        }
    }
    return Permission;
}());
exports.Permission = Permission;
// Define category constants for non-TS users.
exports.PermDiscoverable = 1;
exports.PermHidden = 2;
exports.PermLegacySkyID = 3;
/**
 * Defines what type of file is being requested. Discoverable files are visible
 * to the entire world, hidden files are only visible to the user (unless
 * shared), and LegacySkyID files are supported files from the legacy SkyID
 * login system.
 */
var PermCategory;
(function (PermCategory) {
    PermCategory[PermCategory["Discoverable"] = exports.PermDiscoverable] = "Discoverable";
    PermCategory[PermCategory["Hidden"] = exports.PermHidden] = "Hidden";
    PermCategory[PermCategory["LegacySkyID"] = exports.PermLegacySkyID] = "LegacySkyID";
})(PermCategory = exports.PermCategory || (exports.PermCategory = {}));
// Define type constants for non-TS users.
exports.PermRead = 4;
exports.PermWrite = 5;
var PermType;
(function (PermType) {
    PermType[PermType["Read"] = exports.PermRead] = "Read";
    PermType[PermType["Write"] = exports.PermWrite] = "Write";
})(PermType = exports.PermType || (exports.PermType = {}));
/**
 * Converts the given permission category to a human-readable string.
 *
 * @param category - The given category.
 * @returns - The string.
 * @throws - Will throw if the category is not valid.
 */
function permCategoryToString(category) {
    if (category === PermCategory.Discoverable) {
        return "Discoverable";
    }
    else if (category === PermCategory.Hidden) {
        return "Hidden";
    }
    else if (category === PermCategory.LegacySkyID) {
        return "LegacySkyID";
    }
    else {
        throw new Error("Invalid permission category " + category);
    }
}
exports.permCategoryToString = permCategoryToString;
/**
 * Converts the given permission type to a human-readable string.
 *
 * @param permType - The given type.
 * @returns - The string.
 * @throws - Will throw if the type is not valid.
 */
function permTypeToString(permType) {
    if (permType === PermType.Read) {
        return "Read";
    }
    else if (permType === PermType.Write) {
        return "Write";
    }
    else {
        throw new Error("Invalid permission type " + permType);
    }
}
exports.permTypeToString = permTypeToString;
//# sourceMappingURL=permissions.js.map

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.trimSuffix = exports.removeAdjacentChars = exports.ensureUrl = exports.createFullScreenIframe = exports.createIframe = void 0;
/**
 * Creates an invisible iframe with the given src and adds it to the page.
 */
function createIframe(srcUrl, name) {
    srcUrl = ensureUrl(srcUrl);
    var childFrame = document.createElement("iframe");
    childFrame.src = srcUrl;
    childFrame.name = name;
    childFrame.style.display = "none";
    // Set sandbox permissions.
    // TODO: Enable sandboxing?
    // childFrame.sandbox.add("allow-same-origin");
    // childFrame.sandbox.add("allow-scripts");
    document.body.appendChild(childFrame);
    return childFrame;
}
exports.createIframe = createIframe;
/**
 * Creates a full-screen iframe with the given src and adds it to the page.
 */
function createFullScreenIframe(srcUrl, name) {
    srcUrl = ensureUrl(srcUrl);
    var childFrame = document.createElement("iframe");
    childFrame.src = srcUrl;
    childFrame.name = name;
    // Set properties to make the iframe full-screen.
    childFrame.style.position = "fixed";
    childFrame.style.top = "0";
    childFrame.style.left = "0";
    childFrame.style.bottom = "0";
    childFrame.style.right = "0";
    childFrame.style.width = "100%";
    childFrame.style.height = "100%";
    childFrame.style.border = "none";
    childFrame.style.margin = "0";
    childFrame.style.padding = "0";
    childFrame.style.overflow = "hidden";
    childFrame.style.zIndex = "999999";
    // Set sandbox permissions.
    // TODO: Enable sandboxing?
    // childFrame.sandbox.add("allow-same-origin");
    // childFrame.sandbox.add("allow-scripts");
    document.body.appendChild(childFrame);
    return childFrame;
}
exports.createFullScreenIframe = createFullScreenIframe;
function ensureUrl(url) {
    return ensurePrefix(url, "https://");
}
exports.ensureUrl = ensureUrl;
function removeAdjacentChars(str, char) {
    var pathArray = Array.from(str);
    for (var i = 0; i < pathArray.length - 1;) {
        if (pathArray[i] === char && pathArray[i + 1] === char) {
            pathArray.splice(i, 1);
        }
        else {
            i++;
        }
    }
    return pathArray.join("");
}
exports.removeAdjacentChars = removeAdjacentChars;
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimSuffix(str, suffix, limit) {
    while (str.endsWith(suffix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.substring(0, str.length - suffix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimSuffix = trimSuffix;
function ensurePrefix(s, prefix) {
    if (!s.startsWith(prefix)) {
        s = "" + prefix + s;
    }
    return s;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/window-listener.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/skynet-mysky-utils/dist/window-listener.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.monitorWindowError = exports.PromiseController = exports.dispatchedErrorEvent = exports.errorWindowClosed = void 0;
exports.errorWindowClosed = "window-closed";
exports.dispatchedErrorEvent = "catchError";
var PromiseController = /** @class */ (function () {
    function PromiseController() {
    }
    PromiseController.prototype.cleanup = function () {
        // Empty until implemented in monitorWindowError.
    };
    return PromiseController;
}());
exports.PromiseController = PromiseController;
/**
 * Checks if there has been an error from the window on an interval.
 */
function monitorWindowError() {
    var controller = new PromiseController();
    var abortController = new AbortController();
    var promise = new Promise(function (resolve, reject) {
        var handleEvent = function (e) {
            window.removeEventListener(exports.dispatchedErrorEvent, handleEvent);
            var err = e.detail;
            reject(err);
        };
        // @ts-expect-error doesn't recognize signal option.
        window.addEventListener(exports.dispatchedErrorEvent, handleEvent, {
            signal: abortController.signal
        });
        // Initialize cleanup function.
        controller.cleanup = function () {
            // Abort the event listener.
            abortController.abort();
            // Cleanup the promise.
            resolve();
        };
    });
    return { promise: promise, controller: controller };
}
exports.monitorWindowError = monitorWindowError;
//# sourceMappingURL=window-listener.js.map

/***/ }),

/***/ "./node_modules/skynet-js/node_modules/to-data-view/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/to-data-view/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

module.exports = function toDataView (data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength)
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data)
  }

  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
}


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/tweetnacl/nacl-fast.js":
/*!********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/tweetnacl/nacl-fast.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "?8396");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/url-join/lib/url-join.js":
/*!**********************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/url-join/lib/url-join.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {
  if ( true && module.exports) module.exports = definition();
  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  else {}
})('urljoin', this, function () {

  function normalize (strArray) {
    var resultArray = [];
    if (strArray.length === 0) { return ''; }

    if (typeof strArray[0] !== 'string') {
      throw new TypeError('Url must be a string. Received ' + strArray[0]);
    }

    // If the first part is a plain protocol, we combine it with the next part.
    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
      var first = strArray.shift();
      strArray[0] = first + strArray[0];
    }

    // There must be two or three slashes in the file protocol, two slashes in anything else.
    if (strArray[0].match(/^file:\/\/\//)) {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
    } else {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
    }

    for (var i = 0; i < strArray.length; i++) {
      var component = strArray[i];

      if (typeof component !== 'string') {
        throw new TypeError('Url must be a string. Received ' + component);
      }

      if (component === '') { continue; }

      if (i > 0) {
        // Removing the starting slashes for each component but the first.
        component = component.replace(/^[\/]+/, '');
      }
      if (i < strArray.length - 1) {
        // Removing the ending slashes for each component but the last.
        component = component.replace(/[\/]+$/, '');
      } else {
        // For the last component we will combine multiple slashes to a single one.
        component = component.replace(/[\/]+$/, '/');
      }

      resultArray.push(component);

    }

    var str = resultArray.join('/');
    // Each input component is now separated by a single slash except the possible first plain protocol part.

    // remove trailing slash before parameters or hash
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

    // replace ? in parameters with &
    var parts = str.split('?');
    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

    return str;
  }

  return function () {
    var input;

    if (typeof arguments[0] === 'object') {
      input = arguments[0];
    } else {
      input = [].slice.call(arguments);
    }

    return normalize(input);
  };

});


/***/ }),

/***/ "./node_modules/skynet-js/node_modules/url-parse/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/skynet-js/node_modules/url-parse/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/skynet-js/node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/skynet-js/node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./src/dac.ts":
/*!********************!*\
  !*** ./src/dac.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const skynet_js_1 = __webpack_require__(/*! skynet-js */ "./node_modules/skynet-js/dist/cjs/index.js");
const util_1 = __webpack_require__(/*! ./util */ "./src/util.ts");
const post_me_1 = __webpack_require__(/*! post-me */ "./node_modules/post-me/dist/index.js");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
// DAC consts
const DATA_DOMAIN = "skapp-dac.hns";
const DAC_VERSION = "0.1.6-beta";
//const urlParams = new URLSearchParams(window.location.search);
const DEBUG_ENABLED = true;
const DEV_ENABLED = false;
class SkappDAC {
    constructor() {
        this.skappDict = {};
        // create client
        this.client = new skynet_js_1.SkynetClient();
        // define API
        const methods = {
            init: this.init.bind(this),
            onUserLogin: this.onUserLogin.bind(this),
            setDeployment: this.setDeployment.bind(this),
            getDeployments: this.getDeployments.bind(this),
            setPublishedApp: this.setPublishedApp.bind(this),
            getPublishedApps: this.getPublishedApps.bind(this),
            getPublishedAppIds: this.getPublishedAppIds.bind(this),
            skappAction: this.skappAction.bind(this),
            getStats: this.getStats.bind(this),
            //getSkappComments: this.getSkappComments.bind(this),
        };
        // create connection
        this.connection = post_me_1.ChildHandshake(new post_me_1.WindowMessenger({
            localWindow: window,
            remoteWindow: window.parent,
            remoteOrigin: "*",
        }), methods);
    }
    async init() {
        try {
            // extract the skappname and use it to set the filepaths
            const hostname = new URL(document.referrer).hostname;
            const skapp = await this.client.extractDomain(hostname);
            this.log("loaded from skapp", skapp);
            this.skapp = skapp;
            this.paths = {
                // Deploy
                DD_DEPLOYED_APPS_INDEX_PATH: `${DATA_DOMAIN}/deployed/index.json`,
                DD_DEPLOYED_APP_PATH: `${DATA_DOMAIN}/deployed/$APP_ID/$LATEST/deploymentRecord.json`,
                SD_DEPLOYED_APPS_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/deployed/index.json`,
                SD_DEPLOYED_APP_PATH: `${DATA_DOMAIN}/${skapp}/deployed/$APP_ID/$LATEST/deploymentRecord.json`,
                // Publish
                DD_PUBLISHED_APPS_INDEX_PATH: `${DATA_DOMAIN}/published/index.json`,
                DD_PUBLISHED_APP_PATH: `${DATA_DOMAIN}/published/$APP_ID/$LATEST/publishedAppRecord.json`,
                SD_PUBLISHED_APPS_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/published/index.json`,
                SD_PUBLISHED_APP_PATH: `${DATA_DOMAIN}/${skapp}/published/$APP_ID/$LATEST/publishedAppRecord.json`,
                // User Interactions / stats
                DD_PUBLISHED_APPS_STATS_INDEX_PATH: `${DATA_DOMAIN}/published/stats/index.json`,
                DD_PUBLISHED_APP_STATS_PATH: `${DATA_DOMAIN}/published/stats/$APP_ID/$LATEST/publishedAppStatsRecord.json`,
                SD_PUBLISHED_APPS_STATS_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/published/stats/index.json`,
                SD_PUBLISHED_APP_STATS_PATH: `${DATA_DOMAIN}/${skapp}/published/stats/$APP_ID/$LATEST/publishedAppStatsRecord.json`, //IPublishedAppStatsRecord
                // Publish App : User Action -> Comments
                // DD_PUBLISHED_APPS_COMMENTS_INDEX_PATH: `${DATA_DOMAIN}/published/comments/index.json`,// IPublishedAppsComments
                // SD_PUBLISHED_APP_COMMENTS_INDEX_PATH: `${DATA_DOMAIN}/${skapp}/published/comments/index.json`, // ISkappPublishedAppsCommentsIndex
                // SD_PUBLISHED_APP_COMMENTS_PATH: `${DATA_DOMAIN}/${skapp}/published/$APP_ID/comments/$LATEST/publishedAppCommentRecords.json`, //ISkappPublishedAppsComments
            };
            // load mysky
            const opts = { dev: DEV_ENABLED };
            this.mySky = await this.client.loadMySky(DATA_DOMAIN, opts);
        }
        catch (error) {
            this.log('Failed to load MySky, err: ', error);
            throw error;
        }
        try {
            //this.skappDict= await this.downloadFile(this.paths.SKAPPS_DICT_PATH)
        }
        catch (error) {
            this.log('Failed to load skappDict, err: ', error);
            this.skappDict[this.skapp] = true;
            //this.mySky.setJSON(this.paths.SKAPPS_DICT_PATH,this.skappDict);
            this.log('updated current skapp to skapp dict');
        }
    }
    // onUserLogin is called by MySky when the user has logged in successfully
    async onUserLogin() {
        this.log(`>>>>>>>> SKAPP DAC : VRESION : ${DAC_VERSION} <<<<<<<<<<<<<<<<`);
        const promises = [];
        promises.push(this.ensureDDDeployedAppsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.DD_DEPLOYED_APPS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure Deployment DataDomain index.json, err: ', err); }));
        promises.push(this.ensureSDDeployedAppsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.SD_DEPLOYED_APPS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure Deployment SkappDomain index.json, err: ', err); }));
        promises.push(this.ensureDDPublishedAppsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.DD_PUBLISHED_APPS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure PublishedApp DataDomain index.json, err: ', err); }));
        promises.push(this.ensureSDPublishedAppsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.SD_PUBLISHED_APPS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure PublishedApp SkappDomain index.json, err: ', err); }));
        promises.push(this.ensureDDPublishedAppsStatsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.DD_PUBLISHED_APPS_STATS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure PublishedAppStats DataDomain index.json, err: ', err); }));
        promises.push(this.ensureSDPublishedAppsStatsIndexPresent()
            .then(() => { this.log(`Successfully ensured ${this.paths.SD_PUBLISHED_APPS_STATS_INDEX_PATH} present`); })
            .catch(err => { this.log('Failed to ensure PublishedAppStats SkappDomain index.json, err: ', err); }));
        Promise.all(promises).then(() => { this.fileHierarchyEnsured = true; });
    }
    async ensureDDDeployedAppsIndexPresent() {
        const { DD_DEPLOYED_APPS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_DD_DEPLOYED_APPS_INDEX); // default index
        }
    }
    async ensureSDDeployedAppsIndexPresent() {
        const { SD_DEPLOYED_APPS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_SD_DEPLOYED_APPS_INDEX); // default index
        }
    }
    async ensureDDPublishedAppsIndexPresent() {
        const { DD_PUBLISHED_APPS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_DD_PUBLISHED_APPS_INDEX); // default index
        }
    }
    async ensureSDPublishedAppsIndexPresent() {
        const { SD_PUBLISHED_APPS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_SD_PUBLISHED_APPS_INDEX); // default index
        }
    }
    async ensureDDPublishedAppsStatsIndexPresent() {
        const { DD_PUBLISHED_APPS_STATS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_DD_PUBLISHED_APPS_INDEX); // default index
        }
    }
    async ensureSDPublishedAppsStatsIndexPresent() {
        const { SD_PUBLISHED_APPS_STATS_INDEX_PATH: path } = this.paths;
        const index = await this.downloadFile(path);
        if (!index) {
            await this.updateFile(path, types_1.DEFAULT_SD_PUBLISHED_APPS_INDEX); // default index
        }
    }
    // #####################################################################################
    // ###################### Deployment Methods ###########################################
    // #####################################################################################
    async setDeployment(data) {
        if (!await this.waitUntilFilesArePresent()) {
            return this.fail('Could not initialize Deployment Files, initialization timeout');
        }
        let result = { submitted: false, };
        // TODO: Add "Validation" call here
        let promises = [];
        const timestamp = (new Date()).valueOf();
        const { DD_DEPLOYED_APPS_INDEX_PATH, DD_DEPLOYED_APP_PATH, SD_DEPLOYED_APPS_INDEX_PATH, SD_DEPLOYED_APP_PATH } = this.paths;
        const DD_DEPLOYED_APP_PATH_UPDATED = DD_DEPLOYED_APP_PATH.replace("$APP_ID", data.appId);
        const SD_DEPLOYED_APP_PATH_UPDATED = SD_DEPLOYED_APP_PATH.replace("$APP_ID", data.appId);
        this.log(' DD_DEPLOYED_APP_PATH_UPDATED : ', DD_DEPLOYED_APP_PATH_UPDATED);
        this.log(' SD_DEPLOYED_APP_PATH_UPDATED : ', SD_DEPLOYED_APP_PATH_UPDATED);
        try {
            // ####### Step 1: Read DataDomain and SkappDomain Indexes and update Index variable, dont write yet. Index File write will be in last step
            let ddDeployedAppsIndex = null; // at Data Domain Level
            let sdDeployedAppsIndex = null; // at Skapp Domain Level
            let ddCounter = 0;
            let sdCounter = 0;
            let deployedAppRecordDataLink = null;
            try {
                let promises = [];
                promises.push(this.downloadFile(DD_DEPLOYED_APPS_INDEX_PATH));
                promises.push(this.downloadFile(SD_DEPLOYED_APPS_INDEX_PATH));
                const promiseResult = await Promise.all(promises);
                ddDeployedAppsIndex = promiseResult[0];
                sdDeployedAppsIndex = promiseResult[1];
                if (ddDeployedAppsIndex == undefined || ddDeployedAppsIndex == null) {
                    result.error = `Error Downloading DataDomain Index File`;
                    return result;
                }
                if (sdDeployedAppsIndex == undefined || sdDeployedAppsIndex == null) {
                    result.error = `Error Downloading SkappDomain Index File`;
                    return result;
                }
            }
            catch (error) {
                result.error = `Error Downloading DataDomain and/or SkappDomain Index File`;
                return result;
            }
            // --> DataDomain Index File
            if (ddDeployedAppsIndex.appsIndex == null) { // first time deploying
                const deployedAppsDDIDXRecord = {
                    appId: data.appId,
                    ddCounter: 0,
                    latestDataLink: "",
                    lastUpdatedBy: this.skapp,
                    skapps: [this.skapp]
                };
                ddDeployedAppsIndex.appsIndex = {
                    [data.appId]: deployedAppsDDIDXRecord
                };
            }
            else { //Not FirstTime 
                const ddAppIds = Object.keys(ddDeployedAppsIndex.appsIndex);
                if (!ddAppIds.includes(data.appId)) { // "New App" Deployment !
                    const deployedAppsDDIDXRecord = {
                        appId: data.appId,
                        ddCounter: 0,
                        latestDataLink: "",
                        lastUpdatedBy: this.skapp,
                        skapps: [this.skapp]
                    };
                    ddDeployedAppsIndex.appsIndex[data.appId] = deployedAppsDDIDXRecord;
                }
                else { // "Existing App" Deployment !
                    ddCounter = ddDeployedAppsIndex.appsIndex[data.appId].ddCounter + 1;
                    ddDeployedAppsIndex.appsIndex[data.appId].ddCounter = ddCounter;
                    ddDeployedAppsIndex.appsIndex[data.appId].lastUpdatedBy = this.skapp;
                    if (!ddDeployedAppsIndex.appsIndex[data.appId].skapps.includes(this.skapp))
                        ddDeployedAppsIndex.appsIndex[data.appId].skapps.push(this.skapp);
                    const lastDeploymentDataLink = ddDeployedAppsIndex.appsIndex[data.appId].latestDataLink;
                    const historyPath = DD_DEPLOYED_APP_PATH_UPDATED.replace("$LATEST", ddCounter.toString());
                    // set Entry with (lastDeploymentDataLink)
                    await this.setDataLink(historyPath, lastDeploymentDataLink);
                }
            }
            // --> SkappDomain Index File
            if (sdDeployedAppsIndex.appsIndex == null) { //first time
                // first time deploying
                const deployedAppsSDIDXRecord = {
                    appId: data.appId,
                    sdCounter: 0,
                    latestDataLink: "", // value will be set here later on.
                };
                sdDeployedAppsIndex.appsIndex = {
                    [data.appId]: deployedAppsSDIDXRecord
                };
            }
            else { //Not FirstTime 
                const sdAppIds = Object.keys(sdDeployedAppsIndex.appsIndex);
                if (!sdAppIds.includes(data.appId)) { // "New App" Deployment !
                    const deployedAppsSDIDXRecord = {
                        appId: data.appId,
                        sdCounter: 0,
                        latestDataLink: "", // value will be set here later on.
                    };
                    sdDeployedAppsIndex.appsIndex[data.appId] = deployedAppsSDIDXRecord;
                }
                else { // "Existing App" Deployment !
                    sdCounter = sdDeployedAppsIndex.appsIndex[data.appId].sdCounter + 1;
                    sdDeployedAppsIndex.appsIndex[data.appId].sdCounter = sdCounter;
                    const lastDeploymentDataLink = sdDeployedAppsIndex.appsIndex[data.appId].latestDataLink;
                    const historyPath = SD_DEPLOYED_APP_PATH_UPDATED.replace("$LATEST", sdCounter.toString());
                    // set Entry with (lastDeploymentDataLink)
                    await this.setDataLink(historyPath, lastDeploymentDataLink);
                }
            }
            // ####### Step 2: Actual Data Write
            // update DeploymentRecord and update File
            data.ddCounter = ddCounter;
            data.timestamp = timestamp;
            const sdUpdateFileResult = await this.updateFile(SD_DEPLOYED_APP_PATH_UPDATED, data);
            deployedAppRecordDataLink = sdUpdateFileResult.dataLink ?? "";
            // update DD $Latest pointer to new dataLink
            if (deployedAppRecordDataLink != "") // this is to avoid pointing to incorrect deployment
             {
                await this.setDataLink(DD_DEPLOYED_APP_PATH_UPDATED, deployedAppRecordDataLink); // this REG-Write can be eliminated in specific senarios if we get SkylinkV2 to SkyLinkV2 resolution in sdk. 
            }
            // ####### Step 3: update IndexRecord objects and update DD & SD index files
            ddDeployedAppsIndex.appsIndex[data.appId].latestDataLink = deployedAppRecordDataLink;
            sdDeployedAppsIndex.appsIndex[data.appId].latestDataLink = deployedAppRecordDataLink;
            await this.updateFile(DD_DEPLOYED_APPS_INDEX_PATH, ddDeployedAppsIndex);
            await this.updateFile(SD_DEPLOYED_APPS_INDEX_PATH, sdDeployedAppsIndex);
            result.submitted = true;
        }
        catch (error) {
            result.error = error;
        }
        return result;
    }
    // If null will return all deployments
    async getDeployments(appIds) {
        let response = { status: "failure", result: null, error: null };
        let deployedApps = null;
        const { DD_DEPLOYED_APP_PATH, DD_DEPLOYED_APPS_INDEX_PATH } = this.paths;
        try {
            if (appIds) // If appIds are provided
             {
                const promises = appIds.map((appId) => {
                    const DD_DEPLOYED_APP_PATH_UPDATED = DD_DEPLOYED_APP_PATH.replace("$APP_ID", appId);
                    return this.downloadFile(DD_DEPLOYED_APP_PATH_UPDATED);
                });
                deployedApps = await Promise.all(promises);
            }
            else // If No AppIds are provided, then fetch all apps deployment record
             {
                // step1: read DD Index File
                const deployedAppsIndex = await this.downloadFile(DD_DEPLOYED_APPS_INDEX_PATH);
                if (deployedAppsIndex != null && deployedAppsIndex.appsIndex != null) {
                    const appIds = Object.keys(deployedAppsIndex.appsIndex);
                    const promises = appIds.map((appId) => {
                        const DD_DEPLOYED_APP_PATH_UPDATED = DD_DEPLOYED_APP_PATH.replace("$APP_ID", appId);
                        return this.downloadFile(DD_DEPLOYED_APP_PATH_UPDATED);
                    });
                    deployedApps = await Promise.all(promises);
                }
            }
            return deployedApps;
        }
        catch (error) {
            this.log('Error in getDeployments :', error);
            response.error = `Error fetching deployment data, error : ${error}`;
        }
        return response;
    }
    // #####################################################################################
    // ###################### PublishApp Methods ###########################################
    // #####################################################################################
    async setPublishedApp(data) {
        if (!await this.waitUntilFilesArePresent()) {
            return this.fail('Could not initialize PublishedApp Files, initialization timeout');
        }
        let result = { submitted: false, };
        // TODO: Add "Validation" call here
        let promises = [];
        const timestamp = (new Date()).valueOf();
        const { DD_PUBLISHED_APPS_INDEX_PATH, DD_PUBLISHED_APP_PATH, SD_PUBLISHED_APPS_INDEX_PATH, SD_PUBLISHED_APP_PATH } = this.paths;
        const DD_PUBLISHED_APP_PATH_UPDATED = DD_PUBLISHED_APP_PATH.replace("$APP_ID", data.appId);
        const SD_PUBLISHED_APP_PATH_UPDATED = SD_PUBLISHED_APP_PATH.replace("$APP_ID", data.appId);
        this.log(' DD_PUBLISHED_APP_PATH_UPDATED : ', DD_PUBLISHED_APP_PATH_UPDATED);
        this.log(' SD_PUBLISHED_APP_PATH_UPDATED : ', SD_PUBLISHED_APP_PATH_UPDATED);
        try {
            // ####### Step 1: Read DataDomain and SkappDomain Indexes and update Index variable, dont write yet. Index File write will be in last step
            let ddPublishedAppsIndex = null; // at Data Domain Level
            let sdPublishedAppsIndex = null; // at Skapp Domain Level
            let ddCounter = 0;
            let sdCounter = 0;
            let publishedAppRecordDataLink = null;
            try {
                let promises = [];
                promises.push(this.downloadFile(DD_PUBLISHED_APPS_INDEX_PATH));
                promises.push(this.downloadFile(SD_PUBLISHED_APPS_INDEX_PATH));
                const promiseResult = await Promise.all(promises);
                ddPublishedAppsIndex = promiseResult[0];
                sdPublishedAppsIndex = promiseResult[1];
                if (ddPublishedAppsIndex == undefined || ddPublishedAppsIndex == null) {
                    result.error = `Error Downloading DataDomain Index File`;
                    return result;
                }
                if (sdPublishedAppsIndex == undefined || sdPublishedAppsIndex == null) {
                    result.error = `Error Downloading SkappDomain Index File`;
                    return result;
                }
            }
            catch (error) {
                result.error = `Error Downloading DataDomain and/or SkappDomain Index File`;
                return result;
            }
            // --> DataDomain Index File
            if (ddPublishedAppsIndex.appsIndex == null) { // first time deploying
                const publishedAppsDDIDXRecord = {
                    appId: data.appId,
                    ddCounter: 0,
                    latestDataLink: "",
                    lastUpdatedBy: this.skapp,
                    skapps: [this.skapp]
                };
                ddPublishedAppsIndex.appsIndex = {
                    [data.appId]: publishedAppsDDIDXRecord
                };
            }
            else { //Not FirstTime 
                const ddAppIds = Object.keys(ddPublishedAppsIndex.appsIndex);
                if (!ddAppIds.includes(data.appId)) { // "New App" Published App !
                    const publishedAppsDDIDXRecord = {
                        appId: data.appId,
                        ddCounter: 0,
                        latestDataLink: "",
                        lastUpdatedBy: this.skapp,
                        skapps: [this.skapp]
                    };
                    ddPublishedAppsIndex.appsIndex[data.appId] = publishedAppsDDIDXRecord;
                }
                else { // "Existing App" Published App !
                    ddCounter = ddPublishedAppsIndex.appsIndex[data.appId].ddCounter + 1;
                    ddPublishedAppsIndex.appsIndex[data.appId].ddCounter = ddCounter;
                    ddPublishedAppsIndex.appsIndex[data.appId].lastUpdatedBy = this.skapp;
                    if (!ddPublishedAppsIndex.appsIndex[data.appId].skapps.includes(this.skapp))
                        ddPublishedAppsIndex.appsIndex[data.appId].skapps.push(this.skapp);
                    const lastPublishedAppDataLink = ddPublishedAppsIndex.appsIndex[data.appId].latestDataLink;
                    const historyPath = DD_PUBLISHED_APP_PATH_UPDATED.replace("$LATEST", ddCounter.toString());
                    // set Entry with (lastPublishedAppDataLink)
                    await this.setDataLink(historyPath, lastPublishedAppDataLink);
                }
            }
            // --> SkappDomain Index File
            if (sdPublishedAppsIndex.appsIndex == null) { //first time
                // first time deploying
                const publishedAppsSDIDXRecord = {
                    appId: data.appId,
                    sdCounter: 0,
                    latestDataLink: "", // value will be set here later on.
                };
                sdPublishedAppsIndex.appsIndex = {
                    [data.appId]: publishedAppsSDIDXRecord
                };
            }
            else { //Not FirstTime 
                const sdAppIds = Object.keys(sdPublishedAppsIndex.appsIndex);
                if (!sdAppIds.includes(data.appId)) { // "New App" PublishedApp !
                    const publishedAppsSDIDXRecord = {
                        appId: data.appId,
                        sdCounter: 0,
                        latestDataLink: "", // value will be set here later on.
                    };
                    sdPublishedAppsIndex.appsIndex[data.appId] = publishedAppsSDIDXRecord;
                }
                else { // "Existing App" PublishedApp !
                    sdCounter = sdPublishedAppsIndex.appsIndex[data.appId].sdCounter + 1;
                    sdPublishedAppsIndex.appsIndex[data.appId].sdCounter = sdCounter;
                    const lastPublishedAppDataLink = sdPublishedAppsIndex.appsIndex[data.appId].latestDataLink;
                    const historyPath = SD_PUBLISHED_APP_PATH_UPDATED.replace("$LATEST", sdCounter.toString());
                    // set Entry with (lastPublishedAppDataLink)
                    await this.setDataLink(historyPath, lastPublishedAppDataLink);
                }
            }
            // ####### Step 2: Actual Data Write
            // update PublishedAppRecord and update File
            data.ddCounter = ddCounter;
            data.timestamp = timestamp;
            const sdUpdateFileResult = await this.updateFile(SD_PUBLISHED_APP_PATH_UPDATED, data);
            publishedAppRecordDataLink = sdUpdateFileResult.dataLink ?? "";
            // update DD $Latest pointer to new dataLink
            if (publishedAppRecordDataLink != "") // this is to avoid pointing to incorrect publishedApp
             {
                await this.setDataLink(DD_PUBLISHED_APP_PATH_UPDATED, publishedAppRecordDataLink); // this REG-Write can be eliminated in specific senarios if we get SkylinkV2 to SkyLinkV2 resolution in sdk. 
            }
            // ####### Step 3: update IndexRecord objects and update DD & SD index files
            ddPublishedAppsIndex.appsIndex[data.appId].latestDataLink = publishedAppRecordDataLink;
            sdPublishedAppsIndex.appsIndex[data.appId].latestDataLink = publishedAppRecordDataLink;
            await this.updateFile(DD_PUBLISHED_APPS_INDEX_PATH, ddPublishedAppsIndex);
            await this.updateFile(SD_PUBLISHED_APPS_INDEX_PATH, sdPublishedAppsIndex);
            result.submitted = true;
        }
        catch (error) {
            result.error = error;
        }
        return result;
    }
    async getPublishedApps(appIds, userId) {
        let response = { status: "failure", result: null, error: null };
        let publishedApps = null;
        const { DD_PUBLISHED_APP_PATH, DD_PUBLISHED_APPS_INDEX_PATH } = this.paths;
        try {
            if (appIds) // If appIds are provided
             {
                const promises = appIds.map((appId) => {
                    const DD_PUBLISHED_APP_PATH_UPDATED = DD_PUBLISHED_APP_PATH.replace("$APP_ID", appId);
                    return this.downloadFile(DD_PUBLISHED_APP_PATH_UPDATED);
                });
                publishedApps = await Promise.all(promises);
            }
            else // If No AppIds are provided, then fetch all apps deployment record
             {
                // step1: read DD Index File
                const publishedAppsIndex = await this.downloadFile(DD_PUBLISHED_APPS_INDEX_PATH);
                if (publishedAppsIndex != null && publishedAppsIndex.appsIndex != null) {
                    const appIds = Object.keys(publishedAppsIndex.appsIndex);
                    const promises = appIds.map((appId) => {
                        const DD_PUBLISHED_APP_PATH_UPDATED = DD_PUBLISHED_APP_PATH.replace("$APP_ID", appId);
                        return this.downloadFile(DD_PUBLISHED_APP_PATH_UPDATED);
                    });
                    publishedApps = await Promise.all(promises);
                }
            }
            return publishedApps;
        }
        catch (error) {
            this.log('Error in getPublishedApps :', error);
            response.error = `Error fetching Published Apps data, error : ${error}`;
        }
        return response;
    }
    async getPublishedAppIds(userId) {
        // TODO: Pending Implementation
        const { DD_PUBLISHED_APPS_INDEX_PATH } = this.paths;
        const publishedAppsIndex = await this.downloadFile(DD_PUBLISHED_APPS_INDEX_PATH);
        if (publishedAppsIndex != null && publishedAppsIndex.appsIndex != null) {
            const appIds = Object.keys(publishedAppsIndex.appsIndex);
            return appIds;
        }
        return null;
    }
    // #####################################################################################
    // ###################### PublishApp Stats / Interactions Methods ######################
    // #####################################################################################
    async skappAction(action, appId, data) {
        if (!await this.waitUntilFilesArePresent()) {
            return this.fail('Could not initialize PublishedApp Stats Files, initialization timeout');
        }
        let result = { submitted: false, };
        // TODO: Add "Validation" call here
        let promises = [];
        const timestamp = (new Date()).valueOf();
        const { DD_PUBLISHED_APPS_STATS_INDEX_PATH, SD_PUBLISHED_APPS_STATS_INDEX_PATH } = this.paths;
        try {
            // ####### Step 1: Read DataDomain and SkappDomain Indexes and update Index variable, dont write yet. Index File write will be in last step
            let ddPublishedAppsStatsIndex = null; // at Data Domain Level
            let sdPublishedAppsStatsIndex = null; // at Skapp Domain Level
            let ddCounter = 0;
            let sdCounter = 0;
            try {
                let promises = [];
                promises.push(this.downloadFile(DD_PUBLISHED_APPS_STATS_INDEX_PATH));
                promises.push(this.downloadFile(SD_PUBLISHED_APPS_STATS_INDEX_PATH));
                const promiseResult = await Promise.all(promises);
                ddPublishedAppsStatsIndex = promiseResult[0];
                sdPublishedAppsStatsIndex = promiseResult[1];
                if (ddPublishedAppsStatsIndex == undefined || ddPublishedAppsStatsIndex == null) {
                    result.error = `Error Downloading DataDomain Index File`;
                    return result;
                }
                if (sdPublishedAppsStatsIndex == undefined || sdPublishedAppsStatsIndex == null) {
                    result.error = `Error Downloading SkappDomain Index File`;
                    return result;
                }
            }
            catch (error) {
                result.error = `Error Downloading DataDomain and/or SkappDomain Index File`;
                return result;
            }
            // --> DataDomain Index File
            if (ddPublishedAppsStatsIndex.appsIndex == null) { // first time 
                const publishedAppsStatsDDIDXRecord = {
                    appId: data.appId,
                    ddCounter: 0,
                    //latestDataLink: "",// value will be set here later on.
                    publishedAppStatsRecord: null,
                    lastUpdatedBy: this.skapp,
                    skapps: [this.skapp]
                };
                let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD);
                publishedAppsStatsDDIDXRecord.publishedAppStatsRecord = publishedAppStatsRecord;
                ddPublishedAppsStatsIndex.appsIndex = {
                    [data.appId]: publishedAppsStatsDDIDXRecord
                };
            }
            else { //Not FirstTime 
                const ddAppIds = Object.keys(ddPublishedAppsStatsIndex.appsIndex);
                if (!ddAppIds.includes(data.appId)) { // "New App" Published App !
                    const publishedAppsStatsDDIDXRecord = {
                        appId: data.appId,
                        ddCounter: 0,
                        //latestDataLink: "",// value will be set here later on.
                        publishedAppStatsRecord: null,
                        lastUpdatedBy: this.skapp,
                        skapps: [this.skapp]
                    };
                    let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD);
                    publishedAppsStatsDDIDXRecord.publishedAppStatsRecord = publishedAppStatsRecord;
                    ddPublishedAppsStatsIndex.appsIndex[data.appId] = publishedAppsStatsDDIDXRecord;
                }
                else { // "Existing App" Published App !
                    ddCounter = ddPublishedAppsStatsIndex.appsIndex[data.appId].ddCounter + 1;
                    ddPublishedAppsStatsIndex.appsIndex[data.appId].ddCounter = ddCounter;
                    ddPublishedAppsStatsIndex.appsIndex[data.appId].lastUpdatedBy = this.skapp;
                    if (!ddPublishedAppsStatsIndex.appsIndex[data.appId].skapps.includes(this.skapp))
                        ddPublishedAppsStatsIndex.appsIndex[data.appId].skapps.push(this.skapp);
                    let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, ddPublishedAppsStatsIndex.appsIndex[data.appId].publishedAppStatsRecord);
                    ddPublishedAppsStatsIndex.appsIndex[data.appId].publishedAppStatsRecord = publishedAppStatsRecord;
                }
            }
            // --> SkappDomain Index File
            if (sdPublishedAppsStatsIndex.appsIndex == null) { //first time
                // first time deploying
                const publishedAppsStatsSDIDXRecord = {
                    appId: data.appId,
                    sdCounter: 0,
                    //latestDataLink: "",// value will be set here later on.
                    publishedAppStatsRecord: types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD,
                };
                let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD);
                publishedAppsStatsSDIDXRecord.publishedAppStatsRecord = publishedAppStatsRecord;
                sdPublishedAppsStatsIndex.appsIndex = {
                    [data.appId]: publishedAppsStatsSDIDXRecord
                };
            }
            else { //Not FirstTime 
                const sdAppIds = Object.keys(sdPublishedAppsStatsIndex.appsIndex);
                if (!sdAppIds.includes(data.appId)) { // "New App" PublishedApp !
                    const publishedAppsStatsSDIDXRecord = {
                        appId: data.appId,
                        sdCounter: 0,
                        //latestDataLink: "",// value will be set here later on.
                        publishedAppStatsRecord: types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD,
                    };
                    let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, types_1.DEFAULT_PUBLISHED_APPS_STATS_RECORD);
                    publishedAppsStatsSDIDXRecord.publishedAppStatsRecord = publishedAppStatsRecord;
                    sdPublishedAppsStatsIndex.appsIndex[data.appId] = publishedAppsStatsSDIDXRecord;
                }
                else { // "Existing App" PublishedApp !
                    sdCounter = sdPublishedAppsStatsIndex.appsIndex[data.appId].sdCounter + 1;
                    sdPublishedAppsStatsIndex.appsIndex[data.appId].sdCounter = sdCounter;
                    let publishedAppStatsRecord = this.getUpdatesPublishedAppStatsRecord(action, sdPublishedAppsStatsIndex.appsIndex[data.appId].publishedAppStatsRecord);
                    sdPublishedAppsStatsIndex.appsIndex[data.appId].publishedAppStatsRecord = publishedAppStatsRecord;
                }
            }
            // ####### Step 2: Actual Data Write
            promises = [];
            promises.push(this.updateFile(DD_PUBLISHED_APPS_STATS_INDEX_PATH, ddPublishedAppsStatsIndex));
            promises.push(this.updateFile(SD_PUBLISHED_APPS_STATS_INDEX_PATH, sdPublishedAppsStatsIndex));
            const promiseResult = await Promise.all(promises);
            result.submitted = true;
        }
        catch (error) {
            result.error = error;
        }
        return result;
    }
    getUpdatesPublishedAppStatsRecord(action, data) {
        try {
            switch (action) {
                case types_1.skappActionType.LIKED:
                case types_1.skappActionType.UNLIKED:
                    data.content.liked = action == types_1.skappActionType.LIKED ? 1 : 0;
                    break;
                case types_1.skappActionType.FAVORITE:
                case types_1.skappActionType.UNFAVORITE:
                    data.content.favorite = action == types_1.skappActionType.FAVORITE ? 1 : 0;
                    break;
                case types_1.skappActionType.VIEWED:
                    data.content.viewed += 1;
                    break;
                case types_1.skappActionType.ACCESSED:
                    data.content.accessed += 1;
                    break;
                default:
                    this.log('No such Implementation');
            }
            data.timestamp = (new Date()).valueOf();
        }
        catch (error) {
            this.log(' ### Error updating IPublishedAppStatsRecord');
        }
        return data;
    }
    async getStats(appIds, userId) {
        let publishedApps = null;
        const { DD_PUBLISHED_APPS_STATS_INDEX_PATH } = this.paths;
        try {
            const publishedAppsStatsIndex = await this.downloadFile(DD_PUBLISHED_APPS_STATS_INDEX_PATH);
            if (publishedAppsStatsIndex != null && publishedAppsStatsIndex.appsIndex != null) {
                let statsRecordArray = Object.values(publishedAppsStatsIndex.appsIndex);
                if (appIds) // If appIds are provided
                 {
                    publishedApps = statsRecordArray.filter((item) => { if (appIds.includes(item.appId)) {
                        return item.publishedAppStatsRecord;
                    } });
                }
                else // If No AppIds are provided, then fetch all apps deployment record
                 {
                    publishedApps = statsRecordArray.map((item) => item.publishedAppStatsRecord);
                }
            }
            return publishedApps;
        }
        catch (error) {
            this.log('Error in getPublishedApps :', error);
        }
        return publishedApps;
    }
    // #####################################################################################
    // ############################ Review Below Methods ###################################
    // #####################################################################################
    // public async getPublishedAppsByUserIds(userIds: string[]): Promise<any[]> {
    //   let results: any = [];
    //   for (let userId of userIds) {
    //     this.log('getPublishedAppsByUserIds : ', userId);
    //     try {
    //       let { data: publishedList } = await this.client.file.getJSON(userId, this.paths.PUBLISHED_INDEX_PATH);
    //       this.log("getPublishedAppsByUserIds : " + userId + " ,publishedList " + JSON.stringify(publishedList));
    //       if (publishedList != null && publishedList.published !== null) {
    //         let appIdsList: any = publishedList.published;
    //         results[userId] = appIdsList;
    //       }
    //       else {
    //         results[userId] = [];
    //       }
    //       //results.push(publishedList);
    //     } catch (error) {
    //       this.log('missing json for appid :', userId);
    //     }
    //   }
    //   this.log("getPublishedAppsByUserIds : consolidated : " + JSON.stringify(results));
    //   return results;
    // }
    // public async getPublishedAppsCountByUserIds(userIds: string[]): Promise<any[]> {
    //   let results: any = {};
    //   for (let userId of userIds) {
    //     this.log('getPublishedAppsCountByUserIds : ', userId);
    //     try {
    //       let { data: publishedList } = await this.client.file.getJSON(userId, this.paths.PUBLISHED_INDEX_PATH);
    //       this.log("getPublishedAppsCountByUserIds : " + userId + " ,publishedList " + JSON.stringify(publishedList));
    //       if (publishedList != null && publishedList.published !== null) {
    //         let appIdsList: any = publishedList.published;
    //         results[userId] = appIdsList.length;
    //       }
    //       else {
    //         results[userId] = 0;
    //       }
    //       //results.push(publishedList);
    //     } catch (error) {
    //       this.log('missing json for appid :', userId);
    //     }
    //   }
    //   this.log("getPublishedAppsCountByUserIds : consolidated : " + JSON.stringify(results));
    //   return results;
    // }
    // public async getSkappComments(appId: string): Promise<any> {
    //   let appData: any;
    //   try {
    //     appData = await this.downloadFile(this.paths.PUBLISHED_APP_INFO_PATH + appId + '/' + 'appComments.json');
    //   } catch (error) {
    //     this.log('missing json for appid :', appId);
    //     throw new Error("missing json for appid :" + appId);
    //   }
    //   return appData;
    // }
    // downloadFile merely wraps getJSON but is typed in a way that avoids
    // repeating the awkward "as unknown as T" everywhere
    async downloadFile(path) {
        this.log('### Skapp-Record ### :: downloading file at path', path);
        const { data } = await this.mySky.getJSON(path);
        if (!data) {
            this.log('no data found at path', path);
            return null;
        }
        this.log('data found at path', path, data);
        return data;
    }
    // updateFile merely wraps setJSON but is typed in a way that avoids repeating
    // the awkwars "as unknown as JsonData" everywhere
    async setDataLink(path, dataLink) {
        // TODO: add validation for dataLink
        this.log('updating EntryData at path', path, dataLink);
        try {
            await this.mySky.setDataLink(path, dataLink);
        }
        catch (e) {
            this.log(' Error in setDataLink ', e);
            throw e;
        }
    }
    // updateFile merely wraps setJSON but is typed in a way that avoids repeating
    // the awkwars "as unknown as JsonData" everywhere
    async setEntryData(path, dataLink) {
        // TODO: add validation for dataLink
        this.log('updating EntryData at path', path, dataLink);
        const paddedDataLink = `${util_1.trimUriPrefix(dataLink, util_1.uriSkynetPrefix)}==`;
        this.log(' paddedDataLink ', paddedDataLink);
        const entrydata = util_1.base64RawUrlToUint8Array(paddedDataLink);
        this.log(' entrydata ', JSON.stringify(entrydata));
        try {
            await this.mySky.setEntryData(path, entrydata, {});
        }
        catch (e) {
            this.log(' Error Setting Entry Data ', e);
            throw e;
        }
    }
    // updateFile merely wraps setJSON but is typed in a way that avoids repeating
    // the awkwars "as unknown as JsonData" everywhere
    async getEntryData(path, data) {
        this.log('reading EntryData at path', path, data);
        //let jsonString = JSON.stringify(data);
        //let dataJSON = JSON.parse(jsonString);
        //this.log('updating file at path(jsonString)', path, jsonString)
        await this.mySky.setJSON(path, data);
    }
    // updateFile merely wraps setJSON but is typed in a way that avoids repeating
    // the awkwars "as unknown as JsonData" everywhere
    async updateFile(path, data) {
        this.log('updating file at path', path, data);
        //let jsonString = JSON.stringify(data);
        //let dataJSON = JSON.parse(jsonString);
        //this.log('updating file at path(jsonString)', path, jsonString)
        return await this.mySky.setJSON(path, data);
    }
    // // this function returns promise
    // private async updateFile<T>(path: string, data: T): Promise<void> {
    //   this.log('updating file at path', path, data)
    //   await this.mySky.setJSON(path, data as unknown as JsonData)
    // }
    waitUntilFilesArePresent() {
        return new Promise((resolve, reject) => {
            if (this.fileHierarchyEnsured) {
                resolve(true);
                return;
            }
            const start = new Date().getTime();
            while (true) {
                setTimeout(() => {
                    if (this.fileHierarchyEnsured) {
                        resolve(true);
                    }
                    const elapsed = new Date().getTime() - start;
                    if (elapsed > 60000) {
                        this.log(`waitUntilFilesArePresent timed out after ${elapsed}ms`);
                        reject(false);
                    }
                }, 100);
            }
        });
    }
    // log prints to stdout only if DEBUG_ENABLED flag is set
    log(message, ...optionalContext) {
        if (DEBUG_ENABLED) {
            console.log("### SKAPP-DAC (DEBUG) #### " + message, ...optionalContext);
        }
    }
    fail(error) {
        this.log(error);
        return { submitted: false, error };
    }
}
exports.default = SkappDAC;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dac_1 = __importDefault(__webpack_require__(/*! ./dac */ "./src/dac.ts"));
(async () => {
    new dac_1.default();
})();


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_DOMAIN_RECORD = exports.DEFAULT_DOMAIN = exports.DEFAULT_DOMAIN_INDEX = exports.skappActionType = exports.DEFAULT_PUBLISHED_APPS_STATS_RECORD = exports.DEFAULT_SD_PUBLISHED_APPS_STATS_INDEX = exports.DEFAULT_DD_PUBLISHED_APPS_STATS_INDEX = exports.DEFAULT_SD_PUBLISHED_APPS_INDEX = exports.DEFAULT_DD_PUBLISHED_APPS_INDEX = exports.DEFAULT_SD_DEPLOYED_APPS_INDEX = exports.DEFAULT_DD_DEPLOYED_APPS_INDEX = exports.VERSION = void 0;
exports.VERSION = 1;
exports.DEFAULT_DD_DEPLOYED_APPS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_SD_DEPLOYED_APPS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_DD_PUBLISHED_APPS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_SD_PUBLISHED_APPS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_DD_PUBLISHED_APPS_STATS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_SD_PUBLISHED_APPS_STATS_INDEX = {
    version: exports.VERSION,
    appsIndex: null,
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_PUBLISHED_APPS_STATS_RECORD = {
    version: exports.VERSION,
    $type: "skapp",
    $subType: "interactions",
    appId: null,
    content: {
        favorite: 0,
        liked: 0,
        viewed: 0,
        accessed: 0,
    },
    ddCounter: 0,
    timestamp: (new Date()).valueOf()
};
var skappActionType;
(function (skappActionType) {
    skappActionType[skappActionType["VIEWED"] = 0] = "VIEWED";
    skappActionType[skappActionType["ACCESSED"] = 1] = "ACCESSED";
    skappActionType[skappActionType["FAVORITE"] = 2] = "FAVORITE";
    skappActionType[skappActionType["UNFAVORITE"] = 3] = "UNFAVORITE";
    skappActionType[skappActionType["LIKED"] = 4] = "LIKED";
    skappActionType[skappActionType["UNLIKED"] = 5] = "UNLIKED";
    skappActionType[skappActionType["ADD_COMMENT"] = 6] = "ADD_COMMENT";
    skappActionType[skappActionType["EDIT_COMMENT"] = 7] = "EDIT_COMMENT";
    skappActionType[skappActionType["REMOVE_COMMENT"] = 8] = "REMOVE_COMMENT";
})(skappActionType = exports.skappActionType || (exports.skappActionType = {}));
// DEFAULT_USER_PROFILE defines all props as it is used in validator
exports.DEFAULT_DOMAIN_INDEX = {
    version: exports.VERSION,
    domains: null,
    lastUpdatedBy: "",
};
exports.DEFAULT_DOMAIN = {
    version: exports.VERSION,
    domainType: "HNS",
    domainName: "",
    domainRecords: [],
    status: "Active",
    timestamp: (new Date()).valueOf()
};
exports.DEFAULT_DOMAIN_RECORD = {
    recordType: "TXT",
    recordValue: "", // sia:{skylinkv2}
    // dataLink: "" // SkylinkV1 of uploaded code/site
};


/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trimUriPrefix = exports.trimSuffix = exports.base64RawUrlToUint8Array = exports.uint8ArrayToBase64RawUrl = exports.uriSkynetPrefix = void 0;
const base64_js_1 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
exports.uriSkynetPrefix = "sia://";
/**
 * Encodes the bytes to a string encoded using base64 raw URL encoding.
 *
 * @param bytes - The bytes to encode.
 * @returns - The encoded string.
 */
function uint8ArrayToBase64RawUrl(bytes) {
    let base64 = base64_js_1.fromByteArray(bytes);
    // Convert to URL encoding.
    base64 = base64.replace(/\+/g, "-").replace(/\//g, "_");
    return base64;
}
exports.uint8ArrayToBase64RawUrl = uint8ArrayToBase64RawUrl;
/**
 * Decodes the string encoded using base64 raw URL encoding to bytes.
 *
 * @param s - The encoded string.
 * @returns - The decoded bytes.
 */
function base64RawUrlToUint8Array(s) {
    // Convert from URL encoding.
    s = s.replace(/-/g, "+").replace(/_/g, "/");
    const bytes = base64_js_1.toByteArray(s);
    return bytes;
}
exports.base64RawUrlToUint8Array = base64RawUrlToUint8Array;
// TODO: Move to mysky-utils
/**
 * Removes a suffix from the end of the string.
 *
 * @param str - The string to process.
 * @param suffix - The suffix to remove.
 * @param [limit] - Maximum amount of times to trim. No limit by default.
 * @returns - The processed string.
 */
function trimSuffix(str, suffix, limit) {
    while (str.endsWith(suffix)) {
        if (limit !== undefined && limit <= 0) {
            break;
        }
        str = str.substring(0, str.length - suffix.length);
        if (limit) {
            limit -= 1;
        }
    }
    return str;
}
exports.trimSuffix = trimSuffix;
/**
 * Removes a URI prefix from the beginning of the string.
 *
 * @param str - The string to process.
 * @param prefix - The prefix to remove.
 * @returns - The processed string.
 */
function trimUriPrefix(str, prefix) {
    const shortPrefix = trimSuffix(prefix, "/");
    if (str.startsWith(prefix)) {
        // longPrefix is exactly at the beginning
        return str.slice(prefix.length);
    }
    if (str.startsWith(shortPrefix)) {
        // else prefix is exactly at the beginning
        return str.slice(shortPrefix.length);
    }
    return str;
}
exports.trimUriPrefix = trimUriPrefix;


/***/ }),

/***/ "?8396":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9wb3N0LW1lL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9kb3dubG9hZC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL215c2t5L2Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL215c2t5L2RhYy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL215c2t5L2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvbXlza3kvdHdlYWsuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9teXNreS91dGlscy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3JlZ2lzdHJ5LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvc2t5ZGIuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9za3lsaW5rL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3NreWxpbmsvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy9za3lsaW5rL3NpYS5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3VwbG9hZC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL2FycmF5LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9kaXN0L2Nqcy91dGlscy9maWxlLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvbnVtYmVyLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvZGlzdC9janMvdXRpbHMvb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL3VybC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL2Rpc3QvY2pzL3V0aWxzL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9iYXNlMzItZGVjb2RlL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2Jhc2UzMi1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2JsYWtlanMvYmxha2UyYi5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9ibGFrZWpzL2JsYWtlMnMuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYmxha2Vqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9ibGFrZWpzL3V0aWwuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvbWltZS9NaW1lLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL21pbWUvbGl0ZS5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9taW1lL3R5cGVzL3N0YW5kYXJkLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9wb3N0LW1lL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3NqY2wvc2pjbC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9za3luZXQtbXlza3ktdXRpbHMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9za3luZXQtbXlza3ktdXRpbHMvZGlzdC9wYXRocy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9za3luZXQtbXlza3ktdXRpbHMvZGlzdC9wZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9za3luZXQtbXlza3ktdXRpbHMvZGlzdC91dGlscy5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9ub2RlX21vZHVsZXMvc2t5bmV0LWpzL25vZGVfbW9kdWxlcy9za3luZXQtbXlza3ktdXRpbHMvZGlzdC93aW5kb3ctbGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvdG8tZGF0YS12aWV3L2luZGV4LmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vbm9kZV9tb2R1bGVzL3NreW5ldC1qcy9ub2RlX21vZHVsZXMvdXJsLWpvaW4vbGliL3VybC1qb2luLmpzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9zcmMvZGFjLnRzIiwid2VicGFjazovL3NrYXBwLWRhYy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9za2FwcC1kYWMvLi9zcmMvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjLy4vc3JjL3V0aWwudHMiLCJ3ZWJwYWNrOi8vc2thcHAtZGFjL2lnbm9yZWR8L1VzZXJzL2ZyZXlhL015U3BhY2UvZ2l0L2dpdGh1Yi9za3luZXRodWJpby9za2FwcHMtcmVjb3JkL25vZGVfbW9kdWxlcy9za3luZXQtanMvbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbHxjcnlwdG8iLCJ3ZWJwYWNrOi8vc2thcHAtZGFjL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3NrYXBwLWRhYy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3NrYXBwLWRhYy93ZWJwYWNrL3N0YXJ0dXAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLEdBQUc7OztBQUd4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxlQUFlLFFBQVE7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dB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Q0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMscUVBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3Qzs7QUFFbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcseUJBQXlCOztBQUVwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtDQUFrQyxHQUFHOzs7QUFHeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRyw4QkFBOEI7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBWEQsc0NBV0M7Ozs7Ozs7Ozs7O0FDakVELGU7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1VDUEQ7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoXCJQb3N0TWVcIiwgW1wiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QuZXhwb3J0cyk7XG4gICAgZ2xvYmFsLlBvc3RNZSA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBfZXhwb3J0cy5DaGlsZEhhbmRzaGFrZSA9IENoaWxkSGFuZHNoYWtlO1xuICBfZXhwb3J0cy5EZWJ1Z01lc3NlbmdlciA9IERlYnVnTWVzc2VuZ2VyO1xuICBfZXhwb3J0cy5QYXJlbnRIYW5kc2hha2UgPSBQYXJlbnRIYW5kc2hha2U7XG4gIF9leHBvcnRzLmRlYnVnID0gZGVidWc7XG4gIF9leHBvcnRzLldvcmtlck1lc3NlbmdlciA9IF9leHBvcnRzLldpbmRvd01lc3NlbmdlciA9IF9leHBvcnRzLlBvcnRNZXNzZW5nZXIgPSBfZXhwb3J0cy5Db25jcmV0ZUVtaXR0ZXIgPSBfZXhwb3J0cy5CYXJlTWVzc2VuZ2VyID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuICB2YXIgTUFSS0VSID0gJ0Bwb3N0LW1lJztcblxuICBmdW5jdGlvbiBjcmVhdGVVbmlxdWVJZEZuKCkge1xuICAgIHZhciBfX2lkID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlkID0gX19pZDtcbiAgICAgIF9faWQgKz0gMTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgRW1pdHRlcn0gaW50ZXJmYWNlXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICB2YXIgQ29uY3JldGVFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jcmV0ZUVtaXR0ZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uY3JldGVFbWl0dGVyKTtcblxuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXREb2MgRW1pdHRlci5hZGRFdmVudExpc3RlbmVyfSAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uY3JldGVFbWl0dGVyLCBbe1xuICAgICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICAvKioge0Bpbmhlcml0RG9jIEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyc1tcImRlbGV0ZVwiXShsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICAvKioge0Bpbmhlcml0RG9jIEVtaXR0ZXIub25jZX0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbWl0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUFsbExpc3RlbmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9saXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVycykge1xuICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbmNyZXRlRW1pdHRlcjtcbiAgfSgpO1xuXG4gIF9leHBvcnRzLkNvbmNyZXRlRW1pdHRlciA9IENvbmNyZXRlRW1pdHRlcjtcbiAgdmFyIE1lc3NhZ2VUeXBlO1xuXG4gIChmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtcIkhhbmRzaGFrZVJlcXVlc3RcIl0gPSBcImhhbmRzaGFrZS1yZXF1ZXN0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJIYW5kc2hha2VSZXNwb25zZVwiXSA9IFwiaGFuZHNoYWtlLXJlc3BvbnNlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDYWxsXCJdID0gXCJjYWxsXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJSZXNwb25zZVwiXSA9IFwicmVzcG9uc2VcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiRXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDYWxsYmFja1wiXSA9IFwiY2FsbGJhY2tcIjtcbiAgfSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTsgLy8gTWVzc2FnZSBDcmVhdG9yc1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlSGFuZHNoYWtlUmVxdWVzdE1lc3NhZ2Uoc2Vzc2lvbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdCxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhbmRzaGFrZVJlc3BvbnNlTWVzc2FnZShzZXNzaW9uSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogTUFSS0VSLFxuICAgICAgYWN0aW9uOiBNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXNwb25zZSxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxNZXNzYWdlKHNlc3Npb25JZCwgcmVxdWVzdElkLCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuQ2FsbCxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxuICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCwgcmVzdWx0LCBlcnJvcikge1xuICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgdHlwZTogTUFSS0VSLFxuICAgICAgYWN0aW9uOiBNZXNzYWdlVHlwZS5SZXNwb25zZSxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxuICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWRcbiAgICB9O1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXNzYWdlLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVzc2FnZS5lcnJvciA9IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tNZXNzYWdlKHNlc3Npb25JZCwgcmVxdWVzdElkLCBjYWxsYmFja0lkLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuQ2FsbGJhY2ssXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxuICAgICAgY2FsbGJhY2tJZDogY2FsbGJhY2tJZCxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRNZXNzYWdlKHNlc3Npb25JZCwgZXZlbnROYW1lLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuRXZlbnQsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lLFxuICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgIH07XG4gIH0gLy8gVHlwZSBHdWFyZHNcblxuXG4gIGZ1bmN0aW9uIGlzTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIG0gJiYgbS50eXBlID09PSBNQVJLRVI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhbmRzaGFrZVJlcXVlc3RNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXF1ZXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYW5kc2hha2VSZXNwb25zZU1lc3NhZ2UobSkge1xuICAgIHJldHVybiBpc01lc3NhZ2UobSkgJiYgbS5hY3Rpb24gPT09IE1lc3NhZ2VUeXBlLkhhbmRzaGFrZVJlc3BvbnNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWxsTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuQ2FsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVzcG9uc2VNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5SZXNwb25zZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FsbGJhY2tNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5DYWxsYmFjaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXZlbnRNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDYWxsYmFja0V2ZW50KHJlcXVlc3RJZCkge1xuICAgIHJldHVybiBcImNhbGxiYWNrX1wiLmNvbmNhdChyZXF1ZXN0SWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVJlc3BvbnNlRXZlbnQocmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIFwicmVzcG9uc2VfXCIuY29uY2F0KHJlcXVlc3RJZCk7XG4gIH1cblxuICB2YXIgRGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbmNyZXRlRW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhEaXNwYXRjaGVyLCBfQ29uY3JldGVFbWl0dGVyKTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGlzcGF0Y2hlcik7XG5cbiAgICBmdW5jdGlvbiBEaXNwYXRjaGVyKG1lc3Nlbmdlciwgc2Vzc2lvbklkKSB7XG4gICAgICB2YXIgX3RoaXMyO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcGF0Y2hlcik7XG5cbiAgICAgIF90aGlzMiA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgX3RoaXMyLnVuaXF1ZUlkID0gY3JlYXRlVW5pcXVlSWRGbigpO1xuICAgICAgX3RoaXMyLm1lc3NlbmdlciA9IG1lc3NlbmdlcjtcbiAgICAgIF90aGlzMi5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgICBfdGhpczIucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIgPSBfdGhpczIubWVzc2VuZ2VyLmFkZE1lc3NhZ2VMaXN0ZW5lcihfdGhpczIubWVzc2VuZ2VyTGlzdGVuZXIuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMikpKTtcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERpc3BhdGNoZXIsIFt7XG4gICAgICBrZXk6IFwibWVzc2VuZ2VyTGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXNzZW5nZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKCFpc01lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWQgIT09IGRhdGEuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2FsbE1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVR5cGUuQ2FsbCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZXNwb25zZU1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQobWFrZVJlc3BvbnNlRXZlbnQoZGF0YS5yZXF1ZXN0SWQpLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50TWVzc2FnZShkYXRhKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChNZXNzYWdlVHlwZS5FdmVudCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDYWxsYmFja01lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQobWFrZUNhbGxiYWNrRXZlbnQoZGF0YS5yZXF1ZXN0SWQpLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxsT25SZW1vdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsT25SZW1vdGUobWV0aG9kTmFtZSwgYXJncywgdHJhbnNmZXIpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9IHRoaXMudW5pcXVlSWQoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBtYWtlQ2FsbGJhY2tFdmVudChyZXF1ZXN0SWQpO1xuICAgICAgICB2YXIgcmVzcG9uc2VFdmVudCA9IG1ha2VSZXNwb25zZUV2ZW50KHJlcXVlc3RJZCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gY3JlYXRlQ2FsbE1lc3NhZ2UodGhpcy5zZXNzaW9uSWQsIHJlcXVlc3RJZCwgbWV0aG9kTmFtZSwgYXJncyk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYWxsYmFja0V2ZW50OiBjYWxsYmFja0V2ZW50LFxuICAgICAgICAgIHJlc3BvbnNlRXZlbnQ6IHJlc3BvbnNlRXZlbnRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVzcG9uZFRvUmVtb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzcG9uZFRvUmVtb3RlKHJlcXVlc3RJZCwgdmFsdWUsIGVycm9yLCB0cmFuc2Zlcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjcmVhdGVSZXNwb25zTWVzc2FnZSh0aGlzLnNlc3Npb25JZCwgcmVxdWVzdElkLCB2YWx1ZSwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGxiYWNrVG9SZW1vdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsYmFja1RvUmVtb3RlKHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUNhbGxiYWNrTWVzc2FnZSh0aGlzLnNlc3Npb25JZCwgcmVxdWVzdElkLCBjYWxsYmFja0lkLCBhcmdzKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVtaXRUb1JlbW90ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRUb1JlbW90ZShldmVudE5hbWUsIHBheWxvYWQsIHRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gY3JlYXRlRXZlbnRNZXNzYWdlKHRoaXMuc2Vzc2lvbklkLCBldmVudE5hbWUsIHBheWxvYWQpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGlzcGF0Y2hlcjtcbiAgfShDb25jcmV0ZUVtaXR0ZXIpO1xuXG4gIHZhciBQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29uY3JldGVFbWl0dGVyMikge1xuICAgIF9pbmhlcml0cyhQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyLCBfQ29uY3JldGVFbWl0dGVyMik7XG5cbiAgICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyKTtcblxuICAgIGZ1bmN0aW9uIFBhcmVudEhhbmRzaGFrZURpc3BhdGNoZXIobWVzc2VuZ2VyLCBzZXNzaW9uSWQpIHtcbiAgICAgIHZhciBfdGhpczM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyKTtcblxuICAgICAgX3RoaXMzID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuICAgICAgX3RoaXMzLm1lc3NlbmdlciA9IG1lc3NlbmdlcjtcbiAgICAgIF90aGlzMy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgICBfdGhpczMucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIgPSBfdGhpczMubWVzc2VuZ2VyLmFkZE1lc3NhZ2VMaXN0ZW5lcihfdGhpczMubWVzc2VuZ2VyTGlzdGVuZXIuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpKTtcbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBhcmVudEhhbmRzaGFrZURpc3BhdGNoZXIsIFt7XG4gICAgICBrZXk6IFwibWVzc2VuZ2VyTGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXNzZW5nZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKCFpc01lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWQgIT09IGRhdGEuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGFuZHNoYWtlUmVzcG9uc2VNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGRhdGEuc2Vzc2lvbklkLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbml0aWF0ZUhhbmRzaGFrZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYXRlSGFuZHNoYWtlKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUhhbmRzaGFrZVJlcXVlc3RNZXNzYWdlKHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb25JZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNZXNzZW5nZXJMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyO1xuICB9KENvbmNyZXRlRW1pdHRlcik7XG5cbiAgdmFyIENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbmNyZXRlRW1pdHRlcjMpIHtcbiAgICBfaW5oZXJpdHMoQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyLCBfQ29uY3JldGVFbWl0dGVyMyk7XG5cbiAgICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyKG1lc3Nlbmdlcikge1xuICAgICAgdmFyIF90aGlzNDtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlcik7XG5cbiAgICAgIF90aGlzNCA9IF9zdXBlcjMuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzNC5tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICBfdGhpczQucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIgPSBfdGhpczQubWVzc2VuZ2VyLmFkZE1lc3NhZ2VMaXN0ZW5lcihfdGhpczQubWVzc2VuZ2VyTGlzdGVuZXIuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNCkpKTtcbiAgICAgIHJldHVybiBfdGhpczQ7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlciwgW3tcbiAgICAgIGtleTogXCJtZXNzZW5nZXJMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1lc3Nlbmdlckxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBpZiAoaXNIYW5kc2hha2VSZXF1ZXN0TWVzc2FnZShkYXRhKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXF1ZXN0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhY2NlcHRIYW5kc2hha2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRIYW5kc2hha2Uoc2Vzc2lvbklkKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gY3JlYXRlSGFuZHNoYWtlUmVzcG9uc2VNZXNzYWdlKHNlc3Npb25JZCk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlcjtcbiAgfShDb25jcmV0ZUVtaXR0ZXIpO1xuXG4gIHZhciBQcm94eVR5cGU7XG5cbiAgKGZ1bmN0aW9uIChQcm94eVR5cGUpIHtcbiAgICBQcm94eVR5cGVbXCJDYWxsYmFja1wiXSA9IFwiY2FsbGJhY2tcIjtcbiAgfSkoUHJveHlUeXBlIHx8IChQcm94eVR5cGUgPSB7fSkpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrUHJveHkoY2FsbGJhY2tJZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBwcm94eTogUHJveHlUeXBlLkNhbGxiYWNrLFxuICAgICAgY2FsbGJhY2tJZDogY2FsbGJhY2tJZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0NhbGxiYWNrUHJveHkocCkge1xuICAgIHJldHVybiBwICYmIHAudHlwZSA9PT0gTUFSS0VSICYmIHAucHJveHkgPT09IFByb3h5VHlwZS5DYWxsYmFjaztcbiAgfVxuXG4gIHZhciBDb25jcmV0ZVJlbW90ZUhhbmRsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbmNyZXRlRW1pdHRlcjQpIHtcbiAgICBfaW5oZXJpdHMoQ29uY3JldGVSZW1vdGVIYW5kbGUsIF9Db25jcmV0ZUVtaXR0ZXI0KTtcblxuICAgIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKENvbmNyZXRlUmVtb3RlSGFuZGxlKTtcblxuICAgIGZ1bmN0aW9uIENvbmNyZXRlUmVtb3RlSGFuZGxlKGRpc3BhdGNoZXIpIHtcbiAgICAgIHZhciBfdGhpczU7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25jcmV0ZVJlbW90ZUhhbmRsZSk7XG5cbiAgICAgIF90aGlzNSA9IF9zdXBlcjQuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzNS5fZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICBfdGhpczUuX2NhbGxUcmFuc2ZlciA9IHt9O1xuXG4gICAgICBfdGhpczUuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihNZXNzYWdlVHlwZS5FdmVudCwgX3RoaXM1Ll9oYW5kbGVFdmVudC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM1KSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM1O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb25jcmV0ZVJlbW90ZUhhbmRsZSwgW3tcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRDYWxsVHJhbnNmZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWxsVHJhbnNmZXIobWV0aG9kTmFtZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5fY2FsbFRyYW5zZmVyW21ldGhvZE5hbWVdID0gdHJhbnNmZXI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tQ2FsbChtZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VzdG9tQ2FsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGN1c3RvbUNhbGwobWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHNhbml0aXplZEFyZ3MgPSBbXTtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgdmFyIGNhbGxiYWNrSWQgPSAwO1xuICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICBzYW5pdGl6ZWRBcmdzLnB1c2goY3JlYXRlQ2FsbGJhY2tQcm94eShjYWxsYmFja0lkKSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrSWQgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNhbml0aXplZEFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBoYXNDYWxsYmFja3MgPSBjYWxsYmFja3MubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChoYXNDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrTGlzdGVuZXIgPSBmdW5jdGlvbiBjYWxsYmFja0xpc3RlbmVyKGRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICAgICAgICBhcmdzID0gZGF0YS5hcmdzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbY2FsbGJhY2tJZF0uYXBwbHkoY2FsbGJhY2tzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdHJhbnNmZXIgPSBvcHRpb25zLnRyYW5zZmVyO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZmVyID09PSB1bmRlZmluZWQgJiYgX3RoaXM2Ll9jYWxsVHJhbnNmZXJbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgIHZhciBfdGhpczYkX2NhbGxUcmFuc2ZlcjtcblxuICAgICAgICAgICAgdHJhbnNmZXIgPSAoX3RoaXM2JF9jYWxsVHJhbnNmZXIgPSBfdGhpczYuX2NhbGxUcmFuc2ZlcilbbWV0aG9kTmFtZV0uYXBwbHkoX3RoaXM2JF9jYWxsVHJhbnNmZXIsIHNhbml0aXplZEFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdGhpczYkX2Rpc3BhdGNoZXIkY2EgPSBfdGhpczYuX2Rpc3BhdGNoZXIuY2FsbE9uUmVtb3RlKG1ldGhvZE5hbWUsIHNhbml0aXplZEFyZ3MsIHRyYW5zZmVyKSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tFdmVudCA9IF90aGlzNiRfZGlzcGF0Y2hlciRjYS5jYWxsYmFja0V2ZW50LFxuICAgICAgICAgICAgICByZXNwb25zZUV2ZW50ID0gX3RoaXM2JF9kaXNwYXRjaGVyJGNhLnJlc3BvbnNlRXZlbnQ7XG5cbiAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBfdGhpczYuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihjYWxsYmFja0V2ZW50LCBjYWxsYmFja0xpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczYuX2Rpc3BhdGNoZXIub25jZShyZXNwb25zZUV2ZW50KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXM2Ll9kaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2tFdmVudCwgY2FsbGJhY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXNwb25zZS5yZXN1bHQsXG4gICAgICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblxuICAgICAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFdmVudChkYXRhKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBkYXRhLmV2ZW50TmFtZSxcbiAgICAgICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIHBheWxvYWQpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25jcmV0ZVJlbW90ZUhhbmRsZTtcbiAgfShDb25jcmV0ZUVtaXR0ZXIpO1xuXG4gIHZhciBDb25jcmV0ZUxvY2FsSGFuZGxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jcmV0ZUxvY2FsSGFuZGxlKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNyZXRlTG9jYWxIYW5kbGUpO1xuXG4gICAgICB0aGlzLl9kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgIHRoaXMuX21ldGhvZHMgPSBsb2NhbE1ldGhvZHM7XG4gICAgICB0aGlzLl9yZXR1cm5UcmFuc2ZlciA9IHt9O1xuICAgICAgdGhpcy5fZW1pdFRyYW5zZmVyID0ge307XG5cbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihNZXNzYWdlVHlwZS5DYWxsLCB0aGlzLl9oYW5kbGVDYWxsLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb25jcmV0ZUxvY2FsSGFuZGxlLCBbe1xuICAgICAga2V5OiBcImVtaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIHZhciB0cmFuc2ZlciA9IG9wdGlvbnMudHJhbnNmZXI7XG5cbiAgICAgICAgaWYgKHRyYW5zZmVyID09PSB1bmRlZmluZWQgJiYgdGhpcy5fZW1pdFRyYW5zZmVyW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICB0cmFuc2ZlciA9IHRoaXMuX2VtaXRUcmFuc2ZlcltldmVudE5hbWVdKHBheWxvYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5lbWl0VG9SZW1vdGUoZXZlbnROYW1lLCBwYXlsb2FkLCB0cmFuc2Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldE1ldGhvZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNZXRob2RzKG1ldGhvZHMpIHtcbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldE1ldGhvZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1ldGhvZChtZXRob2ROYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5fbWV0aG9kc1ttZXRob2ROYW1lXSA9IG1ldGhvZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0UmV0dXJuVHJhbnNmZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZXR1cm5UcmFuc2ZlcihtZXRob2ROYW1lLCB0cmFuc2Zlcikge1xuICAgICAgICB0aGlzLl9yZXR1cm5UcmFuc2ZlclttZXRob2ROYW1lXSA9IHRyYW5zZmVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRFbWl0VHJhbnNmZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFbWl0VHJhbnNmZXIoZXZlbnROYW1lLCB0cmFuc2Zlcikge1xuICAgICAgICB0aGlzLl9lbWl0VHJhbnNmZXJbZXZlbnROYW1lXSA9IHRyYW5zZmVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlQ2FsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDYWxsKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9IGRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSA9IGRhdGEubWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZ3MgPSBkYXRhLmFyZ3M7XG4gICAgICAgIHZhciBjYWxsTWV0aG9kID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBfdGhpczckX21ldGhvZHM7XG5cbiAgICAgICAgICB2YXIgbWV0aG9kID0gX3RoaXM3Ll9tZXRob2RzW21ldGhvZE5hbWVdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaGUgbWV0aG9kIFxcXCJcIi5jb25jYXQobWV0aG9kTmFtZSwgXCJcXFwiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZC5cIikpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVzYW5pdGl6ZWRBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGJhY2tQcm94eShhcmcpKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gYXJnLmNhbGxiYWNrSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXM3Ll9kaXNwYXRjaGVyLmNhbGxiYWNrVG9SZW1vdGUocmVxdWVzdElkLCBjYWxsYmFja0lkLCBhcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKChfdGhpczckX21ldGhvZHMgPSBfdGhpczcuX21ldGhvZHMpW21ldGhvZE5hbWVdLmFwcGx5KF90aGlzNyRfbWV0aG9kcywgX3RvQ29uc3VtYWJsZUFycmF5KGRlc2FuaXRpemVkQXJncykpKS50aGVuKHJlc29sdmUpW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxNZXRob2QudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgdmFyIHRyYW5zZmVyO1xuXG4gICAgICAgICAgaWYgKF90aGlzNy5fcmV0dXJuVHJhbnNmZXJbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgIHRyYW5zZmVyID0gX3RoaXM3Ll9yZXR1cm5UcmFuc2ZlclttZXRob2ROYW1lXShyZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNy5fZGlzcGF0Y2hlci5yZXNwb25kVG9SZW1vdGUocmVxdWVzdElkLCByZXN1bHQsIHVuZGVmaW5lZCwgdHJhbnNmZXIpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzNy5fZGlzcGF0Y2hlci5yZXNwb25kVG9SZW1vdGUocmVxdWVzdElkLCB1bmRlZmluZWQsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbmNyZXRlTG9jYWxIYW5kbGU7XG4gIH0oKTtcblxuICB2YXIgQ29uY3JldGVDb25uZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jcmV0ZUNvbm5lY3Rpb24oZGlzcGF0Y2hlciwgbG9jYWxNZXRob2RzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uY3JldGVDb25uZWN0aW9uKTtcblxuICAgICAgdGhpcy5fZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICB0aGlzLl9sb2NhbEhhbmRsZSA9IG5ldyBDb25jcmV0ZUxvY2FsSGFuZGxlKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcyk7XG4gICAgICB0aGlzLl9yZW1vdGVIYW5kbGUgPSBuZXcgQ29uY3JldGVSZW1vdGVIYW5kbGUoZGlzcGF0Y2hlcik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbmNyZXRlQ29ubmVjdGlvbiwgW3tcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmNsb3NlKCk7XG5cbiAgICAgICAgdGhpcy5yZW1vdGVIYW5kbGUoKS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2NhbEhhbmRsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsSGFuZGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxIYW5kbGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW90ZUhhbmRsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW90ZUhhbmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZUhhbmRsZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uY3JldGVDb25uZWN0aW9uO1xuICB9KCk7XG5cbiAgdmFyIHVuaXF1ZVNlc3Npb25JZCA9IGNyZWF0ZVVuaXF1ZUlkRm4oKTtcblxuICB2YXIgcnVuVW50aWwgPSBmdW5jdGlvbiBydW5VbnRpbCh3b3JrZXIsIGNvbmRpdGlvbiwgdW5mdWxmaWxsZWQsIG1heEF0dGVtcHRzLCBhdHRlbXB0SW50ZXJ2YWwpIHtcbiAgICB2YXIgYXR0ZW1wdCA9IDA7XG5cbiAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKCkgJiYgKGF0dGVtcHQgPCBtYXhBdHRlbXB0cyB8fCBtYXhBdHRlbXB0cyA8IDEpKSB7XG4gICAgICAgIHdvcmtlcigpO1xuICAgICAgICBhdHRlbXB0ICs9IDE7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIGF0dGVtcHRJbnRlcnZhbCk7XG4gICAgICB9IGVsc2UgaWYgKCFjb25kaXRpb24oKSAmJiBhdHRlbXB0ID49IG1heEF0dGVtcHRzICYmIG1heEF0dGVtcHRzID49IDEpIHtcbiAgICAgICAgdW5mdWxmaWxsZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4oKTtcbiAgfTtcbiAgLyoqXG4gICAqIEluaXRpYXRlIHRoZSBoYW5kc2hha2UgZnJvbSB0aGUgUGFyZW50IHNpZGVcbiAgICpcbiAgICogQHBhcmFtIG1lc3NlbmdlciAtIFRoZSBNZXNzZW5nZXIgdXNlZCB0byBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIGZyb20gdGhlIG90aGVyIGVuZFxuICAgKiBAcGFyYW0gbG9jYWxNZXRob2RzIC0gVGhlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIG90aGVyIGVuZFxuICAgKiBAcGFyYW0gbWF4QXR0ZW1wdHMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaGFuZHNoYWtlIGF0dGVtcHRzXG4gICAqIEBwYXJhbSBhdHRlbXB0c0ludGVydmFsIC0gVGhlIGludGVydmFsIGJldHdlZW4gaGFuZHNoYWtlIGF0dGVtcHRzXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0byBhbiBhY3RpdmUge0BsaW5rIENvbm5lY3Rpb259IHRvIHRoZSBvdGhlciBlbmRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFBhcmVudEhhbmRzaGFrZShtZXNzZW5nZXIpIHtcbiAgICB2YXIgbG9jYWxNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgbWF4QXR0ZW1wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDU7XG4gICAgdmFyIGF0dGVtcHRzSW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEwMDtcbiAgICB2YXIgdGhpc1Nlc3Npb25JZCA9IHVuaXF1ZVNlc3Npb25JZCgpO1xuICAgIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGhhbmRzaGFrZURpc3BhdGNoZXIgPSBuZXcgUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcihtZXNzZW5nZXIsIHRoaXNTZXNzaW9uSWQpO1xuICAgICAgaGFuZHNoYWtlRGlzcGF0Y2hlci5vbmNlKHRoaXNTZXNzaW9uSWQpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGhhbmRzaGFrZURpc3BhdGNoZXIuY2xvc2UoKTtcbiAgICAgICAgdmFyIHNlc3Npb25JZCA9IHJlc3BvbnNlLnNlc3Npb25JZDtcbiAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcihtZXNzZW5nZXIsIHNlc3Npb25JZCk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gbmV3IENvbmNyZXRlQ29ubmVjdGlvbihkaXNwYXRjaGVyLCBsb2NhbE1ldGhvZHMpO1xuICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICBydW5VbnRpbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYW5kc2hha2VEaXNwYXRjaGVyLmluaXRpYXRlSGFuZHNoYWtlKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0ZWQ7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiSGFuZHNoYWtlIGZhaWxlZCwgcmVhY2hlZCBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0c1wiKSk7XG4gICAgICB9LCBtYXhBdHRlbXB0cywgYXR0ZW1wdHNJbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlIHRoZSBoYW5kc2hha2UgZnJvbSB0aGUgQ2hpbGQgc2lkZVxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIE1lc3NlbmdlciB1c2VkIHRvIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgb3RoZXIgZW5kXG4gICAqIEBwYXJhbSBsb2NhbE1ldGhvZHMgLSBUaGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgZXhwb3NlZCB0byB0aGUgb3RoZXIgZW5kXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0byBhbiBhY3RpdmUge0BsaW5rIENvbm5lY3Rpb259IHRvIHRoZSBvdGhlciBlbmRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENoaWxkSGFuZHNoYWtlKG1lc3Nlbmdlcikge1xuICAgIHZhciBsb2NhbE1ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgaGFuZHNoYWtlRGlzcGF0Y2hlciA9IG5ldyBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIobWVzc2VuZ2VyKTtcbiAgICAgIGhhbmRzaGFrZURpc3BhdGNoZXIub25jZShNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgc2Vzc2lvbklkID0gcmVzcG9uc2Uuc2Vzc2lvbklkO1xuICAgICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLmFjY2VwdEhhbmRzaGFrZShzZXNzaW9uSWQpO1xuICAgICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLmNsb3NlKCk7XG4gICAgICAgIHZhciBkaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIobWVzc2VuZ2VyLCBzZXNzaW9uSWQpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBDb25jcmV0ZUNvbm5lY3Rpb24oZGlzcGF0Y2hlciwgbG9jYWxNZXRob2RzKTtcbiAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFjY2VwdGFibGVNZXNzYWdlRXZlbnQgPSBmdW5jdGlvbiBhY2NlcHRhYmxlTWVzc2FnZUV2ZW50KGV2ZW50LCByZW1vdGVXaW5kb3csIGFjY2VwdGVkT3JpZ2luKSB7XG4gICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSxcbiAgICAgICAgb3JpZ2luID0gZXZlbnQub3JpZ2luO1xuXG4gICAgaWYgKHNvdXJjZSAhPT0gcmVtb3RlV2luZG93KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbiAhPT0gYWNjZXB0ZWRPcmlnaW4gJiYgYWNjZXB0ZWRPcmlnaW4gIT09ICcqJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogQSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTWVzc2VuZ2VyfSB1c2VkIHRvIGNvbW11bmljYXRlIHdpdGggYW5vdGhlciBXaW5kb3cuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICovXG5cblxuICB2YXIgV2luZG93TWVzc2VuZ2VyID0gZnVuY3Rpb24gV2luZG93TWVzc2VuZ2VyKF9yZWYpIHtcbiAgICB2YXIgbG9jYWxXaW5kb3cgPSBfcmVmLmxvY2FsV2luZG93LFxuICAgICAgICByZW1vdGVXaW5kb3cgPSBfcmVmLnJlbW90ZVdpbmRvdyxcbiAgICAgICAgcmVtb3RlT3JpZ2luID0gX3JlZi5yZW1vdGVPcmlnaW47XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2luZG93TWVzc2VuZ2VyKTtcblxuICAgIGxvY2FsV2luZG93ID0gbG9jYWxXaW5kb3cgfHwgd2luZG93O1xuXG4gICAgdGhpcy5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2Zlcikge1xuICAgICAgcmVtb3RlV2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHJlbW90ZU9yaWdpbiwgdHJhbnNmZXIpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZE1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgdmFyIG91dGVyTGlzdGVuZXIgPSBmdW5jdGlvbiBvdXRlckxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIGlmIChhY2NlcHRhYmxlTWVzc2FnZUV2ZW50KGV2ZW50LCByZW1vdGVXaW5kb3csIHJlbW90ZU9yaWdpbikpIHtcbiAgICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGxvY2FsV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvdXRlckxpc3RlbmVyKTtcblxuICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGxvY2FsV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvdXRlckxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbiAgICB9O1xuICB9O1xuICAvKiogQHB1YmxpYyAqL1xuXG5cbiAgX2V4cG9ydHMuV2luZG93TWVzc2VuZ2VyID0gV2luZG93TWVzc2VuZ2VyO1xuXG4gIHZhciBCYXJlTWVzc2VuZ2VyID0gZnVuY3Rpb24gQmFyZU1lc3Nlbmdlcihwb3N0YWJsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJlTWVzc2VuZ2VyKTtcblxuICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgdmFyIHRyYW5zZmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHBvc3RhYmxlLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHZhciBvdXRlckxpc3RlbmVyID0gZnVuY3Rpb24gb3V0ZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9O1xuXG4gICAgICBwb3N0YWJsZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG5cbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBwb3N0YWJsZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIE1lc3Nlbmdlcn0gdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIGEgV29ya2VyLlxuICAgKlxuICAgKiBUYWtlcyBhIHtAbGluayBQb3N0YWJsZX0gcmVwcmVzZW50aW5nIHRoZSBgV29ya2VyYCAod2hlbiBjYWxsaW5nIGZyb21cbiAgICogdGhlIHBhcmVudCBjb250ZXh0KSBvciB0aGUgYHNlbGZgIGBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZWAgb2JqZWN0XG4gICAqICh3aGVuIGNhbGxpbmcgZnJvbSB0aGUgY2hpbGQgY29udGV4dCkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICovXG5cblxuICBfZXhwb3J0cy5CYXJlTWVzc2VuZ2VyID0gQmFyZU1lc3NlbmdlcjtcblxuICB2YXIgV29ya2VyTWVzc2VuZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyZU1lc3Nlbmdlcikge1xuICAgIF9pbmhlcml0cyhXb3JrZXJNZXNzZW5nZXIsIF9CYXJlTWVzc2VuZ2VyKTtcblxuICAgIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKFdvcmtlck1lc3Nlbmdlcik7XG5cbiAgICBmdW5jdGlvbiBXb3JrZXJNZXNzZW5nZXIoX3JlZjIpIHtcbiAgICAgIHZhciB3b3JrZXIgPSBfcmVmMi53b3JrZXI7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXb3JrZXJNZXNzZW5nZXIpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyNS5jYWxsKHRoaXMsIHdvcmtlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdvcmtlck1lc3NlbmdlcjtcbiAgfShCYXJlTWVzc2VuZ2VyKTtcbiAgLyoqXG4gICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIE1lc3Nlbmdlcn0gdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIGEgTWVzc2FnZVBvcnQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICovXG5cblxuICBfZXhwb3J0cy5Xb3JrZXJNZXNzZW5nZXIgPSBXb3JrZXJNZXNzZW5nZXI7XG5cbiAgdmFyIFBvcnRNZXNzZW5nZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJlTWVzc2VuZ2VyMikge1xuICAgIF9pbmhlcml0cyhQb3J0TWVzc2VuZ2VyLCBfQmFyZU1lc3NlbmdlcjIpO1xuXG4gICAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoUG9ydE1lc3Nlbmdlcik7XG5cbiAgICBmdW5jdGlvbiBQb3J0TWVzc2VuZ2VyKF9yZWYzKSB7XG4gICAgICB2YXIgcG9ydCA9IF9yZWYzLnBvcnQ7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3J0TWVzc2VuZ2VyKTtcblxuICAgICAgcG9ydC5zdGFydCgpO1xuICAgICAgcmV0dXJuIF9zdXBlcjYuY2FsbCh0aGlzLCBwb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUG9ydE1lc3NlbmdlcjtcbiAgfShCYXJlTWVzc2VuZ2VyKTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvZ2dlciBmdW5jdGlvbiB3aXRoIGEgc3BlY2lmaWMgbmFtZXNwYWNlXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGFsbCB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbG9nZ2VyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBsb2cgLSBUaGUgdW5kZXJseWluZyBsb2dnZXIgKGBjb25zb2xlLmxvZ2AgYnkgZGVmYXVsdClcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKi9cblxuXG4gIF9leHBvcnRzLlBvcnRNZXNzZW5nZXIgPSBQb3J0TWVzc2VuZ2VyO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSwgbG9nKSB7XG4gICAgbG9nID0gbG9nIHx8IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGRhdGFbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgbG9nLmFwcGx5KHZvaWQgMCwgW25hbWVzcGFjZV0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWNvcmF0ZSBhIHtAbGluayBNZXNzZW5nZXJ9IHNvIHRoYXQgaXQgd2lsbCBsb2cgYW55IG1lc3NhZ2UgZXhjaGFuZ2VkXG4gICAqIEBwYXJhbSBtZXNzZW5nZXIgLSBUaGUgTWVzc2VuZ2VyIHRoYXQgd2lsbCBiZSBkZWNvcmF0ZWRcbiAgICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnZXIgZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgZWFjaCBtZXNzYWdlXG4gICAqIEByZXR1cm5zIEEgZGVjb3JhdGVkIE1lc3NlbmdlclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gRGVidWdNZXNzZW5nZXIobWVzc2VuZ2VyLCBsb2cpIHtcbiAgICBsb2cgPSBsb2cgfHwgZGVidWcoJ3Bvc3QtbWUnKTtcblxuICAgIHZhciBkZWJ1Z0xpc3RlbmVyID0gZnVuY3Rpb24gZGVidWdMaXN0ZW5lcihldmVudCkge1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgbG9nKCfirIXvuI8gcmVjZWl2ZWQgbWVzc2FnZScsIGRhdGEpO1xuICAgIH07XG5cbiAgICBtZXNzZW5nZXIuYWRkTWVzc2FnZUxpc3RlbmVyKGRlYnVnTGlzdGVuZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgbG9nKCfinqHvuI8gc2VuZGluZyBtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgIG1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICB9LFxuICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyOiBmdW5jdGlvbiBhZGRNZXNzYWdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIG1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNreW5ldENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbmNvbnN0IHVwbG9hZF8xID0gcmVxdWlyZShcIi4vdXBsb2FkXCIpO1xuY29uc3QgZG93bmxvYWRfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkXCIpO1xuY29uc3QgZmlsZV8xID0gcmVxdWlyZShcIi4vZmlsZVwiKTtcbmNvbnN0IHNreWRiXzEgPSByZXF1aXJlKFwiLi9za3lkYlwiKTtcbmNvbnN0IHJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yZWdpc3RyeVwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3QgbXlza3lfMSA9IHJlcXVpcmUoXCIuL215c2t5XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL215c2t5L3V0aWxzXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdcIik7XG4vKipcbiAqIFRoZSBTa3luZXQgQ2xpZW50IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBTa3luZXQuXG4gKi9cbmNsYXNzIFNreW5ldENsaWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIFNreW5ldCBDbGllbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYWNjZXNzIFNreW5ldC5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBbaW5pdGlhbFBvcnRhbFVybF0gVGhlIGluaXRpYWwgcG9ydGFsIFVSTCB0byB1c2UgdG8gYWNjZXNzIFNreW5ldCwgaWYgc3BlY2lmaWVkLiBBIHJlcXVlc3Qgd2lsbCBiZSBtYWRlIHRvIHRoaXMgVVJMIHRvIGdldCB0aGUgYWN0dWFsIHBvcnRhbCBVUkwuIFRvIHVzZSB0aGUgZGVmYXVsdCBwb3J0YWwgd2hpbGUgcGFzc2luZyBjdXN0b20gb3B0aW9ucywgcGFzcyBcIlwiLlxuICAgICAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gQ29uZmlndXJhdGlvbiBmb3IgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUG9ydGFsVXJsID0gXCJcIiwgY3VzdG9tT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIFNldCBtZXRob2RzIChkZWZpbmVkIGluIG90aGVyIGZpbGVzKS5cbiAgICAgICAgLy8gVXBsb2FkXG4gICAgICAgIHRoaXMudXBsb2FkRmlsZSA9IHVwbG9hZF8xLnVwbG9hZEZpbGU7XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZVJlcXVlc3QgPSB1cGxvYWRfMS51cGxvYWRGaWxlUmVxdWVzdDtcbiAgICAgICAgdGhpcy51cGxvYWREaXJlY3RvcnkgPSB1cGxvYWRfMS51cGxvYWREaXJlY3Rvcnk7XG4gICAgICAgIHRoaXMudXBsb2FkRGlyZWN0b3J5UmVxdWVzdCA9IHVwbG9hZF8xLnVwbG9hZERpcmVjdG9yeVJlcXVlc3Q7XG4gICAgICAgIC8vIERvd25sb2FkXG4gICAgICAgIHRoaXMuZG93bmxvYWRGaWxlID0gZG93bmxvYWRfMS5kb3dubG9hZEZpbGU7XG4gICAgICAgIHRoaXMuZG93bmxvYWRGaWxlSG5zID0gZG93bmxvYWRfMS5kb3dubG9hZEZpbGVIbnM7XG4gICAgICAgIHRoaXMuZ2V0U2t5bGlua1VybCA9IGRvd25sb2FkXzEuZ2V0U2t5bGlua1VybDtcbiAgICAgICAgdGhpcy5nZXRIbnNVcmwgPSBkb3dubG9hZF8xLmdldEhuc1VybDtcbiAgICAgICAgdGhpcy5nZXRIbnNyZXNVcmwgPSBkb3dubG9hZF8xLmdldEhuc3Jlc1VybDtcbiAgICAgICAgdGhpcy5nZXRNZXRhZGF0YSA9IGRvd25sb2FkXzEuZ2V0TWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUNvbnRlbnQgPSBkb3dubG9hZF8xLmdldEZpbGVDb250ZW50O1xuICAgICAgICB0aGlzLmdldEZpbGVDb250ZW50SG5zID0gZG93bmxvYWRfMS5nZXRGaWxlQ29udGVudEhucztcbiAgICAgICAgdGhpcy5nZXRGaWxlQ29udGVudFJlcXVlc3QgPSBkb3dubG9hZF8xLmdldEZpbGVDb250ZW50UmVxdWVzdDtcbiAgICAgICAgdGhpcy5vcGVuRmlsZSA9IGRvd25sb2FkXzEub3BlbkZpbGU7XG4gICAgICAgIHRoaXMub3BlbkZpbGVIbnMgPSBkb3dubG9hZF8xLm9wZW5GaWxlSG5zO1xuICAgICAgICB0aGlzLnJlc29sdmVIbnMgPSBkb3dubG9hZF8xLnJlc29sdmVIbnM7XG4gICAgICAgIC8vIE15U2t5XG4gICAgICAgIHRoaXMuZXh0cmFjdERvbWFpbiA9IHV0aWxzXzEuZXh0cmFjdERvbWFpbjtcbiAgICAgICAgdGhpcy5nZXRGdWxsRG9tYWluVXJsID0gdXRpbHNfMS5nZXRGdWxsRG9tYWluVXJsO1xuICAgICAgICB0aGlzLmxvYWRNeVNreSA9IG15c2t5XzEubG9hZE15U2t5O1xuICAgICAgICAvLyBGaWxlIEFQSVxuICAgICAgICB0aGlzLmZpbGUgPSB7XG4gICAgICAgICAgICBnZXRKU09OOiBmaWxlXzEuZ2V0SlNPTi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RW50cnlEYXRhOiBmaWxlXzEuZ2V0RW50cnlEYXRhLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbnRyeUxpbms6IGZpbGVfMS5nZXRFbnRyeUxpbmsuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2t5REJcbiAgICAgICAgdGhpcy5kYiA9IHtcbiAgICAgICAgICAgIGRlbGV0ZUpTT046IHNreWRiXzEuZGVsZXRlSlNPTi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0SlNPTjogc2t5ZGJfMS5nZXRKU09OLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRKU09OOiBza3lkYl8xLnNldEpTT04uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldERhdGFMaW5rOiBza3lkYl8xLnNldERhdGFMaW5rLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNreURCIGhlbHBlcnNcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHtcbiAgICAgICAgICAgIGdldEVudHJ5OiByZWdpc3RyeV8xLmdldEVudHJ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbnRyeVVybDogcmVnaXN0cnlfMS5nZXRFbnRyeVVybC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RW50cnlMaW5rOiByZWdpc3RyeV8xLmdldEVudHJ5TGluay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2V0RW50cnk6IHJlZ2lzdHJ5XzEuc2V0RW50cnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHBvc3RTaWduZWRFbnRyeTogcmVnaXN0cnlfMS5wb3N0U2lnbmVkRW50cnkuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluaXRpYWxQb3J0YWxVcmwgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIFBvcnRhbCB3YXMgbm90IGdpdmVuLCB1c2UgdGhlIGRlZmF1bHQgcG9ydGFsIFVSTC4gV2UnbGwgc3RpbGwgbWFrZSBhIHJlcXVlc3QgZm9yIHRoZSByZXNvbHZlZCBwb3J0YWwgVVJMLlxuICAgICAgICAgICAgaW5pdGlhbFBvcnRhbFVybCA9IHVybF8xLmRlZmF1bHRQb3J0YWxVcmwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBvcnRhbCB3YXMgZ2l2ZW4sIGRvbid0IG1ha2UgdGhlIHJlcXVlc3QgZm9yIHRoZSByZXNvbHZlZCBwb3J0YWwgVVJMLlxuICAgICAgICAgICAgdGhpcy5naXZlblBvcnRhbFVybCA9IGluaXRpYWxQb3J0YWxVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsUG9ydGFsVXJsID0gaW5pdGlhbFBvcnRhbFVybDtcbiAgICAgICAgdGhpcy5jdXN0b21PcHRpb25zID0gY3VzdG9tT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgcmVxdWVzdCBmb3IgdGhlIEFQSSBwb3J0YWwgVVJMLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgYXN5bmMgaW5pdFBvcnRhbFVybCgpIHtcbiAgICAgICAgaWYgKCFTa3luZXRDbGllbnQucmVzb2x2ZWRQb3J0YWxVcmwpIHtcbiAgICAgICAgICAgIFNreW5ldENsaWVudC5yZXNvbHZlZFBvcnRhbFVybCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiaGVhZFwiLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuaW5pdGlhbFBvcnRhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRQYXRoOiBcIi9cIixcbiAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmhlYWRlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJEaWQgbm90IGdldCAnaGVhZGVycycgaW4gcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3J0YWxVcmwgPSByZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LXBvcnRhbC1hcGlcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9ydGFsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBwb3J0YWwgVVJMIGZvciB0aGUgZ2l2ZW4gcG9ydGFsXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0cmluZ18xLnRyaW1TdWZmaXgocG9ydGFsVXJsLCBcIi9cIikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgU2t5bmV0Q2xpZW50LnJlc29sdmVkUG9ydGFsVXJsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFQSSBwb3J0YWwgVVJMLiBNYWtlcyB0aGUgcmVxdWVzdCB0byBnZXQgaXQgaWYgbm90IGRvbmUgc28gYWxyZWFkeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gdGhlIHBvcnRhbCBVUkwuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBhc3luYyBwb3J0YWxVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLmdpdmVuUG9ydGFsVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5naXZlblBvcnRhbFVybDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0IGlmIG5lZWRlZCBhbmQgbm90IGRvbmUgc28uXG4gICAgICAgIHRoaXMuaW5pdFBvcnRhbFVybCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgU2t5bmV0Q2xpZW50LnJlc29sdmVkUG9ydGFsVXJsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGV4ZWN1dGVzIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSByZXNwb25zZSBmcm9tIGF4aW9zLlxuICAgICAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHVuaW1wbGVtZW50ZWQgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVSZXF1ZXN0KGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBVUkwuXG4gICAgICAgIGxldCB1cmwgPSBjb25maWcudXJsO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgY29uc3QgcG9ydGFsVXJsID0gYXdhaXQgdGhpcy5wb3J0YWxVcmwoKTtcbiAgICAgICAgICAgIHVybCA9IHVybF8xLm1ha2VVcmwocG9ydGFsVXJsLCBjb25maWcuZW5kcG9pbnRQYXRoLCAoX2EgPSBjb25maWcuZXh0cmFQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnF1ZXJ5KSB7XG4gICAgICAgICAgICB1cmwgPSB1cmxfMS5hZGRVcmxRdWVyeSh1cmwsIGNvbmZpZy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4uY29uZmlnLmhlYWRlcnMgfTtcbiAgICAgICAgLy8gU2V0IHNvbWUgaGVhZGVycyBmcm9tIGNvbW1vbiBvcHRpb25zLlxuICAgICAgICBpZiAoY29uZmlnLmN1c3RvbVVzZXJBZ2VudCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSBjb25maWcuY3VzdG9tVXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY3VzdG9tQ29va2llKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29va2llXCJdID0gY29uZmlnLmN1c3RvbUNvb2tpZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoID0gY29uZmlnLkFQSUtleSA/IHsgdXNlcm5hbWU6IFwiXCIsIHBhc3N3b3JkOiBjb25maWcuQVBJS2V5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGNvbnN0IG9uVXBsb2FkUHJvZ3Jlc3MgPSBjb25maWcub25VcGxvYWRQcm9ncmVzcyAmJlxuICAgICAgICAgICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRoZSBpZi1zdGF0ZW1lbnQgb3IgVFMgY29tcGxhaW5zLlxuICAgICAgICAgICAgICAgIGlmIChjb25maWcub25VcGxvYWRQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIGV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBheGlvc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLFxuICAgICAgICAgICAgZGF0YTogY29uZmlnLmRhdGEsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICAgICAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBjb25maWcudHJhbnNmb3JtUmVxdWVzdCxcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgICBtYXhDb250ZW50TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAgICAgICAgIG1heEJvZHlMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICAgICAgLy8gQWxsb3cgY3Jvc3Mtc2l0ZSBjb29raWVzLlxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNreW5ldENsaWVudCA9IFNreW5ldENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoUmVnaXN0cnlFbnRyeSA9IGV4cG9ydHMuaGFzaERhdGFLZXkgPSBleHBvcnRzLmhhc2hBbGwgPSBleHBvcnRzLmdlbktleVBhaXJGcm9tU2VlZCA9IGV4cG9ydHMuZ2VuS2V5UGFpckFuZFNlZWQgPSBleHBvcnRzLmRlcml2ZUNoaWxkU2VlZCA9IHZvaWQgMDtcbmNvbnN0IHNqY2xfMSA9IHJlcXVpcmUoXCJzamNsXCIpO1xuY29uc3QgYmxha2Vqc18xID0gcmVxdWlyZShcImJsYWtlanNcIik7XG5jb25zdCByYW5kb21ieXRlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyYW5kb21ieXRlc1wiKSk7XG5jb25zdCB0d2VldG5hY2xfMSA9IHJlcXVpcmUoXCJ0d2VldG5hY2xcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRpb25cIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvZW5jb2RpbmdcIik7XG4vKipcbiAqIFJldHVybnMgYSBibGFrZTJiIDI1NmJpdCBoYXNoZXIuIFNlZSBgTmV3SGFzaGAgaW4gU2lhLlxuICpcbiAqIEByZXR1cm5zIC0gYmxha2UyYiAyNTZiaXQgaGFzaGVyLlxuICovXG5mdW5jdGlvbiBuZXdIYXNoKCkge1xuICAgIHJldHVybiBibGFrZWpzXzEuYmxha2UyYkluaXQoMzIsIG51bGwpO1xufVxuLyoqXG4gKiBEZXJpdmVzIGEgY2hpbGQgc2VlZCBmcm9tIHRoZSBnaXZlbiBtYXN0ZXIgc2VlZCBhbmQgc3ViIHNlZWQuXG4gKlxuICogQHBhcmFtIG1hc3RlclNlZWQgLSBUaGUgbWFzdGVyIHNlZWQgdG8gZGVyaXZlIGZyb20uXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBzdWIgc2VlZCBmb3IgdGhlIGRlcml2YXRpb24uXG4gKiBAcmV0dXJucyAtIFRoZSBjaGlsZCBzZWVkIGRlcml2ZWQgZnJvbSBgbWFzdGVyU2VlZGAgdXNpbmcgYHNlZWRgLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0cyBhcmUgbm90IHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZUNoaWxkU2VlZChtYXN0ZXJTZWVkLCBzZWVkKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwibWFzdGVyU2VlZFwiLCBtYXN0ZXJTZWVkLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJzZWVkXCIsIHNlZWQsIFwicGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiBzdHJpbmdfMS50b0hleFN0cmluZyhoYXNoQWxsKGVuY29kaW5nXzEuZW5jb2RlVXRmOFN0cmluZyhtYXN0ZXJTZWVkKSwgZW5jb2RpbmdfMS5lbmNvZGVVdGY4U3RyaW5nKHNlZWQpKSk7XG59XG5leHBvcnRzLmRlcml2ZUNoaWxkU2VlZCA9IGRlcml2ZUNoaWxkU2VlZDtcbi8qKlxuICogR2VuZXJhdGVzIGEgbWFzdGVyIGtleSBwYWlyIGFuZCBzZWVkLlxuICpcbiAqIEBwYXJhbSBbbGVuZ3RoPTY0XSAtIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIGZvciB0aGUgc2VlZC4gTm90ZSB0aGF0IHRoZSBzdHJpbmcgc2VlZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBoZXggcmVwcmVzZW50YXRpb24sIG1ha2luZyBpdCB0d2ljZSB0aGlzIGxlbmd0aC5cbiAqIEByZXR1cm5zIC0gVGhlIGdlbmVyYXRlZCBrZXkgcGFpciBhbmQgc2VlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuS2V5UGFpckFuZFNlZWQobGVuZ3RoID0gNjQpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVOdW1iZXIoXCJsZW5ndGhcIiwgbGVuZ3RoLCBcInBhcmFtZXRlclwiKTtcbiAgICBjb25zdCBzZWVkID0gbWFrZVNlZWQobGVuZ3RoKTtcbiAgICByZXR1cm4geyAuLi5nZW5LZXlQYWlyRnJvbVNlZWQoc2VlZCksIHNlZWQgfTtcbn1cbmV4cG9ydHMuZ2VuS2V5UGFpckFuZFNlZWQgPSBnZW5LZXlQYWlyQW5kU2VlZDtcbi8qKlxuICogR2VuZXJhdGVzIGEgcHVibGljIGFuZCBwcml2YXRlIGtleSBmcm9tIGEgcHJvdmlkZWQsIHNlY3VyZSBzZWVkLlxuICpcbiAqIEBwYXJhbSBzZWVkIC0gQSBzZWN1cmUgc2VlZC5cbiAqIEByZXR1cm5zIC0gVGhlIGdlbmVyYXRlZCBrZXkgcGFpci5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdlbktleVBhaXJGcm9tU2VlZChzZWVkKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwic2VlZFwiLCBzZWVkLCBcInBhcmFtZXRlclwiKTtcbiAgICAvLyBHZXQgYSAzMi1ieXRlIGtleS5cbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gc2pjbF8xLm1pc2MucGJrZGYyKHNlZWQsIFwiXCIsIDEwMDAsIDMyICogOCk7XG4gICAgY29uc3QgZGVyaXZlZEtleUhleCA9IHNqY2xfMS5jb2RlYy5oZXguZnJvbUJpdHMoZGVyaXZlZEtleSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHNlY3JldEtleSB9ID0gdHdlZXRuYWNsXzEuc2lnbi5rZXlQYWlyLmZyb21TZWVkKHN0cmluZ18xLmhleFRvVWludDhBcnJheShkZXJpdmVkS2V5SGV4KSk7XG4gICAgcmV0dXJuIHsgcHVibGljS2V5OiBzdHJpbmdfMS50b0hleFN0cmluZyhwdWJsaWNLZXkpLCBwcml2YXRlS2V5OiBzdHJpbmdfMS50b0hleFN0cmluZyhzZWNyZXRLZXkpIH07XG59XG5leHBvcnRzLmdlbktleVBhaXJGcm9tU2VlZCA9IGdlbktleVBhaXJGcm9tU2VlZDtcbi8qKlxuICogVGFrZXMgYWxsIGdpdmVuIGFyZ3VtZW50cyBhbmQgaGFzaGVzIHRoZW0uXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBCeXRlIGFycmF5cyB0byBoYXNoLlxuICogQHJldHVybnMgLSBUaGUgZmluYWwgaGFzaCBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGhhc2hBbGwoLi4uYXJncykge1xuICAgIGNvbnN0IGhhc2hlciA9IG5ld0hhc2goKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmxha2Vqc18xLmJsYWtlMmJVcGRhdGUoaGFzaGVyLCBhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsYWtlanNfMS5ibGFrZTJiRmluYWwoaGFzaGVyKTtcbn1cbmV4cG9ydHMuaGFzaEFsbCA9IGhhc2hBbGw7XG4vKipcbiAqIEhhc2ggdGhlIGdpdmVuIGRhdGEga2V5LlxuICpcbiAqIEBwYXJhbSBkYXRhS2V5IC0gRGF0YSBrZXkgdG8gaGFzaC5cbiAqIEByZXR1cm5zIC0gSGFzaCBvZiB0aGUgZGF0YSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEYXRhS2V5KGRhdGFLZXkpIHtcbiAgICByZXR1cm4gaGFzaEFsbChlbmNvZGluZ18xLmVuY29kZVV0ZjhTdHJpbmcoZGF0YUtleSkpO1xufVxuZXhwb3J0cy5oYXNoRGF0YUtleSA9IGhhc2hEYXRhS2V5O1xuLyoqXG4gKiBIYXNoZXMgdGhlIGdpdmVuIHJlZ2lzdHJ5IGVudHJ5LlxuICpcbiAqIEBwYXJhbSByZWdpc3RyeUVudHJ5IC0gUmVnaXN0cnkgZW50cnkgdG8gaGFzaC5cbiAqIEBwYXJhbSBoYXNoZWREYXRhS2V5SGV4IC0gV2hldGhlciB0aGUgZGF0YSBrZXkgaXMgYWxyZWFkeSBoYXNoZWQgYW5kIGluIGhleCBmb3JtYXQuIElmIG5vdCwgd2UgaGFzaCB0aGUgZGF0YSBrZXkuXG4gKiBAcmV0dXJucyAtIEhhc2ggb2YgdGhlIHJlZ2lzdHJ5IGVudHJ5LlxuICovXG5mdW5jdGlvbiBoYXNoUmVnaXN0cnlFbnRyeShyZWdpc3RyeUVudHJ5LCBoYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgbGV0IGRhdGFLZXlCeXRlcztcbiAgICBpZiAoaGFzaGVkRGF0YUtleUhleCkge1xuICAgICAgICBkYXRhS2V5Qnl0ZXMgPSBzdHJpbmdfMS5oZXhUb1VpbnQ4QXJyYXkocmVnaXN0cnlFbnRyeS5kYXRhS2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFLZXlCeXRlcyA9IGhhc2hEYXRhS2V5KHJlZ2lzdHJ5RW50cnkuZGF0YUtleSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFCeXRlcyA9IGVuY29kaW5nXzEuZW5jb2RlUHJlZml4ZWRCeXRlcyhyZWdpc3RyeUVudHJ5LmRhdGEpO1xuICAgIHJldHVybiBoYXNoQWxsKGRhdGFLZXlCeXRlcywgZGF0YUJ5dGVzLCBlbmNvZGluZ18xLmVuY29kZUJpZ2ludEFzVWludDY0KHJlZ2lzdHJ5RW50cnkucmV2aXNpb24pKTtcbn1cbmV4cG9ydHMuaGFzaFJlZ2lzdHJ5RW50cnkgPSBoYXNoUmVnaXN0cnlFbnRyeTtcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHNlZWQgb2YgdGhlIGdpdmVuIGxlbmd0aCBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSBzZWVkIGluIGJ5dGVzLlxuICogQHJldHVybnMgLSBUaGUgZ2VuZXJhdGVkIHNlZWQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZWVkKGxlbmd0aCkge1xuICAgIC8vIENyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gSXQgc2hvdWxkIHVzZSB0aGVcbiAgICAvLyBidWlsdC1pbiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGluIHRoZSBicm93c2VyLlxuICAgIGNvbnN0IGFycmF5ID0gcmFuZG9tYnl0ZXNfMS5kZWZhdWx0KGxlbmd0aCk7XG4gICAgcmV0dXJuIHN0cmluZ18xLnRvSGV4U3RyaW5nKGFycmF5KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlSG5zID0gZXhwb3J0cy5vcGVuRmlsZUhucyA9IGV4cG9ydHMub3BlbkZpbGUgPSBleHBvcnRzLmdldEZpbGVDb250ZW50UmVxdWVzdCA9IGV4cG9ydHMuZ2V0RmlsZUNvbnRlbnRIbnMgPSBleHBvcnRzLmdldEZpbGVDb250ZW50ID0gZXhwb3J0cy5nZXRNZXRhZGF0YSA9IGV4cG9ydHMuZ2V0SG5zcmVzVXJsID0gZXhwb3J0cy5nZXRIbnNVcmwgPSBleHBvcnRzLmdldFNreWxpbmtVcmxGb3JQb3J0YWwgPSBleHBvcnRzLmdldFNreWxpbmtVcmwgPSBleHBvcnRzLmRvd25sb2FkRmlsZUhucyA9IGV4cG9ydHMuZG93bmxvYWRGaWxlID0gZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL2Zvcm1hdFwiKTtcbmNvbnN0IHBhcnNlXzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL3BhcnNlXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi91dGlscy9vcHRpb25zXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwiLi91dGlscy91cmxcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0aW9uXCIpO1xuZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnNfMS5kZWZhdWx0QmFzZU9wdGlvbnMsXG4gICAgZW5kcG9pbnREb3dubG9hZDogXCIvXCIsXG4gICAgZG93bmxvYWQ6IGZhbHNlLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICByYW5nZTogdW5kZWZpbmVkLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgc3ViZG9tYWluOiBmYWxzZSxcbn07XG5jb25zdCBkZWZhdWx0R2V0TWV0YWRhdGFPcHRpb25zID0ge1xuICAgIGVuZHBvaW50R2V0TWV0YWRhdGE6IFwiL3NreW5ldC9tZXRhZGF0YVwiLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG59O1xuY29uc3QgZGVmYXVsdERvd25sb2FkSG5zT3B0aW9ucyA9IHtcbiAgICAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsXG4gICAgZW5kcG9pbnREb3dubG9hZEhuczogXCJobnNcIixcbiAgICBobnNTdWJkb21haW46IFwiaG5zXCIsXG4gICAgLy8gRGVmYXVsdCB0byBzdWJkb21haW4gZm9ybWF0IGZvciBITlMgVVJMcy5cbiAgICBzdWJkb21haW46IHRydWUsXG59O1xuY29uc3QgZGVmYXVsdFJlc29sdmVIbnNPcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnNfMS5kZWZhdWx0QmFzZU9wdGlvbnMsXG4gICAgZW5kcG9pbnRSZXNvbHZlSG5zOiBcImhuc3Jlc1wiLFxufTtcbi8qKlxuICogSW5pdGlhdGVzIGEgZG93bmxvYWQgb2YgdGhlIGNvbnRlbnQgb2YgdGhlIHNreWxpbmsgd2l0aGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gc2t5bGlua1VybCAtIDQ2LWNoYXJhY3RlciBza3lsaW5rLCBvciBhIHZhbGlkIHNreWxpbmsgVVJMLiBDYW4gYmUgZm9sbG93ZWQgYnkgYSBwYXRoLiBOb3RlIHRoYXQgdGhlIHNreWxpbmsgd2lsbCBub3QgYmUgZW5jb2RlZCwgc28gaWYgeW91ciBwYXRoIG1pZ2h0IGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLCBjb25zaWRlciB1c2luZyBgY3VzdG9tT3B0aW9ucy5wYXRoYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50RG93bmxvYWQ9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIHRoYXQgd2FzIHVzZWQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoc2t5bGlua1VybCwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0U2t5bGlua1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMsIGRvd25sb2FkOiB0cnVlIH07XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRTa3lsaW5rVXJsKHNreWxpbmtVcmwsIG9wdHMpO1xuICAgIC8vIERvd25sb2FkIHRoZSB1cmwuXG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLmRvd25sb2FkRmlsZSA9IGRvd25sb2FkRmlsZTtcbi8qKlxuICogSW5pdGlhdGVzIGEgZG93bmxvYWQgb2YgdGhlIGNvbnRlbnQgb2YgdGhlIHNreWxpbmsgYXQgdGhlIEhhbmRzaGFrZSBkb21haW4uXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBkb21haW4gLSBIYW5kc2hha2UgZG9tYWluLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnREb3dubG9hZEhucz1cIi9obnNcIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgdGhhdCB3YXMgdXNlZC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBkb21haW4gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGVIbnMoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRIbnNVcmxgLlxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmRlZmF1bHREb3dubG9hZEhuc09wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucywgZG93bmxvYWQ6IHRydWUgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldEhuc1VybChkb21haW4sIG9wdHMpO1xuICAgIC8vIERvd25sb2FkIHRoZSB1cmwuXG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLmRvd25sb2FkRmlsZUhucyA9IGRvd25sb2FkRmlsZUhucztcbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBza3lsaW5rLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gc2t5bGlua1VybCAtIFNreWxpbmsgc3RyaW5nLiBTZWUgYGRvd25sb2FkRmlsZWAuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludERvd25sb2FkPVwiL1wiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIFVSTCBmb3IgdGhlIHNreWxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTa3lsaW5rVXJsKHNreWxpbmtVcmwsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldFNreWxpbmtVcmxGb3JQb3J0YWxgLlxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgcG9ydGFsVXJsID0gYXdhaXQgdGhpcy5wb3J0YWxVcmwoKTtcbiAgICByZXR1cm4gZ2V0U2t5bGlua1VybEZvclBvcnRhbChwb3J0YWxVcmwsIHNreWxpbmtVcmwsIG9wdHMpO1xufVxuZXhwb3J0cy5nZXRTa3lsaW5rVXJsID0gZ2V0U2t5bGlua1VybDtcbi8qKlxuICogR2V0cyB0aGUgc2t5bGluayBVUkwgd2l0aG91dCBhbiBpbml0aWFsaXplZCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHBvcnRhbFVybCAtIFRoZSBwb3J0YWwgVVJMLlxuICogQHBhcmFtIHNreWxpbmtVcmwgLSBTa3lsaW5rIHN0cmluZy4gU2VlIGBkb3dubG9hZEZpbGVgLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnREb3dubG9hZD1cIi9cIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIGZvciB0aGUgc2t5bGluay5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBza3lsaW5rVXJsIGRvZXMgbm90IGNvbnRhaW4gYSBza3lsaW5rIG9yIGlmIHRoZSBwYXRoIG9wdGlvbiBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldFNreWxpbmtVcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwb3J0YWxVcmxcIiwgcG9ydGFsVXJsLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJza3lsaW5rVXJsXCIsIHNreWxpbmtVcmwsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHF1ZXJ5ID0gKF9hID0gb3B0cy5xdWVyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgaWYgKG9wdHMuZG93bmxvYWQpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBcImF0dGFjaG1lbnRcIiBwYXJhbWV0ZXIuXG4gICAgICAgIHF1ZXJ5LmF0dGFjaG1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBVUkwtZW5jb2RlIHRoZSBwYXRoLlxuICAgIGxldCBwYXRoID0gXCJcIjtcbiAgICBpZiAob3B0cy5wYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wdHMucGF0aCBoYXMgdG8gYmUgYSBzdHJpbmcsICR7dHlwZW9mIG9wdHMucGF0aH0gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmNvZGUgZWFjaCBlbGVtZW50IG9mIHRoZSBwYXRoIHNlcGFyYXRlbHkgYW5kIGpvaW4gdGhlbS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRG9uJ3QgdXNlIGVuY29kZVVSSSBiZWNhdXNlIGl0IGRvZXMgbm90IGVuY29kZSBjaGFyYWN0ZXJzIHN1Y2ggYXMgJz8nXG4gICAgICAgIC8vIGV0Yy4gVGhlc2UgYXJlIGFsbG93ZWQgYXMgZmlsZW5hbWVzIG9uIFNreW5ldCBhbmQgc2hvdWxkIGJlIGVuY29kZWQgc29cbiAgICAgICAgLy8gdGhleSBhcmUgbm90IHRyZWF0ZWQgYXMgVVJMIHNlcGFyYXRvcnMuXG4gICAgICAgIHBhdGggPSBvcHRzLnBhdGhcbiAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgIC5tYXAoKGVsZW1lbnQpID0+IGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KSlcbiAgICAgICAgICAgIC5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHVybDtcbiAgICBpZiAob3B0cy5zdWJkb21haW4pIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwYXRoIGZyb20gdGhlIHNreWxpbmsuIFVzZSB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgY29uc3Qgc2t5bGlua1BhdGggPSAoX2IgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsLCB7IG9ubHlQYXRoOiB0cnVlIH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICAvLyBHZXQganVzdCB0aGUgc2t5bGluay5cbiAgICAgICAgbGV0IHNreWxpbmsgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsKTtcbiAgICAgICAgaWYgKHNreWxpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBza3lsaW5rIG91dCBvZiBpbnB1dCAnJHtza3lsaW5rVXJsfSdgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBza3lsaW5rICh3aXRob3V0IHRoZSBwYXRoKSB0byBiYXNlMzIuXG4gICAgICAgIHNreWxpbmsgPSBmb3JtYXRfMS5jb252ZXJ0U2t5bGlua1RvQmFzZTMyKHNreWxpbmspO1xuICAgICAgICB1cmwgPSB1cmxfMS5hZGRTdWJkb21haW4ocG9ydGFsVXJsLCBza3lsaW5rKTtcbiAgICAgICAgdXJsID0gdXJsXzEubWFrZVVybCh1cmwsIHNreWxpbmtQYXRoLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgc2t5bGluayBpbmNsdWRpbmcgdGhlIHBhdGguXG4gICAgICAgIGNvbnN0IHNreWxpbmsgPSBwYXJzZV8xLnBhcnNlU2t5bGluayhza3lsaW5rVXJsLCB7IGluY2x1ZGVQYXRoOiB0cnVlIH0pO1xuICAgICAgICBpZiAoc2t5bGluayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IHNreWxpbmsgd2l0aCBwYXRoIG91dCBvZiBpbnB1dCAnJHtza3lsaW5rVXJsfSdgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYWRkaXRpb25hbCBwYXRoIGlmIHBhc3NlZCBpbi5cbiAgICAgICAgdXJsID0gdXJsXzEubWFrZVVybChwb3J0YWxVcmwsIG9wdHMuZW5kcG9pbnREb3dubG9hZCwgc2t5bGluayk7XG4gICAgICAgIHVybCA9IHVybF8xLm1ha2VVcmwodXJsLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybF8xLmFkZFVybFF1ZXJ5KHVybCwgcXVlcnkpO1xufVxuZXhwb3J0cy5nZXRTa3lsaW5rVXJsRm9yUG9ydGFsID0gZ2V0U2t5bGlua1VybEZvclBvcnRhbDtcbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBITlMgZG9tYWluLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gSGFuZHNoYWtlIGRvbWFpbi5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucz17fV0gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50RG93bmxvYWRIbnM9XCIvaG5zXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIGZvciB0aGUgSE5TIGRvbWFpbi5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBkb21haW4gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRIbnNVcmwoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRvbWFpblwiLCBkb21haW4sIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBkZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0RG93bmxvYWRIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCBxdWVyeSA9IChfYSA9IG9wdHMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRzLmRvd25sb2FkKSB7XG4gICAgICAgIHF1ZXJ5LmF0dGFjaG1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBkb21haW4gPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KGRvbWFpbiwgdXJsXzEudXJpSGFuZHNoYWtlUHJlZml4KTtcbiAgICBjb25zdCBwb3J0YWxVcmwgPSBhd2FpdCB0aGlzLnBvcnRhbFVybCgpO1xuICAgIGNvbnN0IHVybCA9IG9wdHMuc3ViZG9tYWluXG4gICAgICAgID8gdXJsXzEuYWRkU3ViZG9tYWluKHVybF8xLmFkZFN1YmRvbWFpbihwb3J0YWxVcmwsIG9wdHMuaG5zU3ViZG9tYWluKSwgZG9tYWluKVxuICAgICAgICA6IHVybF8xLm1ha2VVcmwocG9ydGFsVXJsLCBvcHRzLmVuZHBvaW50RG93bmxvYWRIbnMsIGRvbWFpbik7XG4gICAgcmV0dXJuIHVybF8xLmFkZFVybFF1ZXJ5KHVybCwgcXVlcnkpO1xufVxuZXhwb3J0cy5nZXRIbnNVcmwgPSBnZXRIbnNVcmw7XG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIGZ1bGwgVVJMIGZvciB0aGUgcmVzb2x2ZXIgZm9yIHRoZSBnaXZlbiBITlMgZG9tYWluLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gSGFuZHNoYWtlIGRvbWFpbi5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucz17fV0gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UmVzb2x2ZUhucz1cIi9obnNyZXNcIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgZm9yIHRoZSByZXNvbHZlciBmb3IgdGhlIEhOUyBkb21haW4uXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQgZG9tYWluIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SG5zcmVzVXJsKGRvbWFpbiwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRvbWFpblwiLCBkb21haW4sIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBkZWZhdWx0UmVzb2x2ZUhuc09wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmRlZmF1bHRSZXNvbHZlSG5zT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgZG9tYWluID0gc3RyaW5nXzEudHJpbVVyaVByZWZpeChkb21haW4sIHVybF8xLnVyaUhhbmRzaGFrZVByZWZpeCk7XG4gICAgY29uc3QgcG9ydGFsVXJsID0gYXdhaXQgdGhpcy5wb3J0YWxVcmwoKTtcbiAgICByZXR1cm4gdXJsXzEubWFrZVVybChwb3J0YWxVcmwsIG9wdHMuZW5kcG9pbnRSZXNvbHZlSG5zLCBkb21haW4pO1xufVxuZXhwb3J0cy5nZXRIbnNyZXNVcmwgPSBnZXRIbnNyZXNVcmw7XG4vKipcbiAqIEdldHMgb25seSB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBza3lsaW5rIHdpdGhvdXQgdGhlIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gc2t5bGlua1VybCAtIFNreWxpbmsgc3RyaW5nLiBTZWUgYGRvd25sb2FkRmlsZWAuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC4gU2VlIGBkb3dubG9hZEZpbGVgIGZvciB0aGUgZnVsbCBsaXN0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50R2V0TWV0YWRhdGE9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIG1ldGFkYXRhIGluIEpTT04gZm9ybWF0LiBFbXB0eSBpZiBubyBtZXRhZGF0YSB3YXMgZm91bmQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRNZXRhZGF0YShza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRTa3lsaW5rVXJsYC5cbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdEdldE1ldGFkYXRhT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgcGF0aCBmb3Igbm93IHNpbmNlIHRoZSBlbmRwb2ludCBkb2Vzbid0IHN1cHBvcnQgaXQuXG4gICAgY29uc3QgcGF0aCA9IHBhcnNlXzEucGFyc2VTa3lsaW5rKHNreWxpbmtVcmwsIHsgb25seVBhdGg6IHRydWUgfSk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2t5bGluayBzdHJpbmcgc2hvdWxkIG5vdCBjb250YWluIGEgcGF0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgZ2V0U2t5bGlua1VybE9wdHMgPSB7IGVuZHBvaW50RG93bmxvYWQ6IG9wdHMuZW5kcG9pbnRHZXRNZXRhZGF0YSwgcXVlcnk6IG9wdHMucXVlcnkgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFNreWxpbmtVcmwoc2t5bGlua1VybCwgZ2V0U2t5bGlua1VybE9wdHMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGVuZHBvaW50UGF0aDogb3B0cy5lbmRwb2ludEdldE1ldGFkYXRhLFxuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZUdldE1ldGFkYXRhUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmhlYWRlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBnZXQgJ2hlYWRlcnMnIGluIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcG9ydGFsVXJsID0gKF9hID0gcmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1wb3J0YWwtYXBpXCJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgIGNvbnN0IHNreWxpbmsgPSByZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LXNreWxpbmtcIl0gPyBmb3JtYXRfMS5mb3JtYXRTa3lsaW5rKHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtc2t5bGlua1wiXSkgOiBcIlwiO1xuICAgIHJldHVybiB7IG1ldGFkYXRhLCBwb3J0YWxVcmwsIHNreWxpbmsgfTtcbn1cbmV4cG9ydHMuZ2V0TWV0YWRhdGEgPSBnZXRNZXRhZGF0YTtcbi8qKlxuICogR2V0cyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYXQgdGhlIGdpdmVuIHNreWxpbmsuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBza3lsaW5rVXJsIC0gU2t5bGluayBzdHJpbmcuIFNlZSBgZG93bmxvYWRGaWxlYC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50RG93bmxvYWQ9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIGZpbGUsIHRoZSBjb250ZW50LXR5cGUsIG1ldGFkYXRhLCBhbmQgdGhlIGZpbGUncyBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHNreWxpbmtVcmwgZG9lcyBub3QgY29udGFpbiBhIHNreWxpbmsgb3IgaWYgdGhlIHBhdGggb3B0aW9uIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZUNvbnRlbnQoc2t5bGlua1VybCwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0U2t5bGlua1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0RG93bmxvYWRPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFNreWxpbmtVcmwoc2t5bGlua1VybCwgb3B0cyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsZUNvbnRlbnRSZXF1ZXN0KHVybCwgb3B0cyk7XG59XG5leHBvcnRzLmdldEZpbGVDb250ZW50ID0gZ2V0RmlsZUNvbnRlbnQ7XG4vKipcbiAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGF0IHRoZSBnaXZlbiBIYW5kc2hha2UgZG9tYWluLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gSGFuZHNoYWtlIGRvbWFpbi5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50RG93bmxvYWRIbnM9XCIvaG5zXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIGZpbGUsIHRoZSBjb250ZW50LXR5cGUsIG1ldGFkYXRhLCBhbmQgdGhlIGZpbGUncyBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGRvbWFpbiBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluay5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZUNvbnRlbnRIbnMoZG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRIbnNVcmxgLlxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmRlZmF1bHREb3dubG9hZEhuc09wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0SG5zVXJsKGRvbWFpbiwgb3B0cyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsZUNvbnRlbnRSZXF1ZXN0KHVybCwgb3B0cyk7XG59XG5leHBvcnRzLmdldEZpbGVDb250ZW50SG5zID0gZ2V0RmlsZUNvbnRlbnRIbnM7XG4vKipcbiAqIERvZXMgYSBHRVQgcmVxdWVzdCBvZiB0aGUgc2t5bGluaywgcmV0dXJuaW5nIHRoZSBkYXRhIHByb3BlcnR5IG9mIHRoZSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHVybCAtIFVSTC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgZmlsZSwgdGhlIGNvbnRlbnQtdHlwZSwgbWV0YWRhdGEsIGFuZCB0aGUgZmlsZSdzIHNreWxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgcmVxdWVzdCBkb2VzIG5vdCBzdWNjZWVkIG9yIHRoZSByZXNwb25zZSBpcyBtaXNzaW5nIGRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbGVDb250ZW50UmVxdWVzdCh1cmwsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBOb3QgcHVibGljbHkgYXZhaWxhYmxlLCBkb24ndCB2YWxpZGF0ZSBpbnB1dC5cbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLmV4cG9ydHMuZGVmYXVsdERvd25sb2FkT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdHMucmFuZ2UgPyB7IFJhbmdlOiBvcHRzLnJhbmdlIH0gOiB1bmRlZmluZWQ7XG4gICAgLy8gR0VUIHJlcXVlc3QgdGhlIGRhdGEgYXQgdGhlIHNreWxpbmsuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZW5kcG9pbnRQYXRoOiBvcHRzLmVuZHBvaW50RG93bmxvYWQsXG4gICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgdXJsLFxuICAgICAgICBoZWFkZXJzLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGdldCAnZGF0YScgaW4gcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmhlYWRlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBnZXQgJ2hlYWRlcnMnIGluIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudFR5cGUgPSAoX2EgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IChfYiA9IHJlc3BvbnNlLmhlYWRlcnNbXCJza3luZXQtcG9ydGFsLWFwaVwiXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICBjb25zdCBza3lsaW5rID0gcmVzcG9uc2UuaGVhZGVyc1tcInNreW5ldC1za3lsaW5rXCJdID8gZm9ybWF0XzEuZm9ybWF0U2t5bGluayhyZXNwb25zZS5oZWFkZXJzW1wic2t5bmV0LXNreWxpbmtcIl0pIDogXCJcIjtcbiAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5kYXRhLCBjb250ZW50VHlwZSwgcG9ydGFsVXJsLCBza3lsaW5rIH07XG59XG5leHBvcnRzLmdldEZpbGVDb250ZW50UmVxdWVzdCA9IGdldEZpbGVDb250ZW50UmVxdWVzdDtcbi8qKlxuICogT3BlbnMgdGhlIGNvbnRlbnQgb2YgdGhlIHNreWxpbmsgd2l0aGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gc2t5bGlua1VybCAtIFNreWxpbmsgc3RyaW5nLiBTZWUgYGRvd25sb2FkRmlsZWAuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC4gU2VlIGBkb3dubG9hZEZpbGVgIGZvciB0aGUgZnVsbCBsaXN0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50RG93bmxvYWQ9XCIvXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIHRoYXQgd2FzIHVzZWQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc2t5bGlua1VybCBkb2VzIG5vdCBjb250YWluIGEgc2t5bGluayBvciBpZiB0aGUgcGF0aCBvcHRpb24gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBvcGVuRmlsZShza3lsaW5rVXJsLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRTa3lsaW5rVXJsYC5cbiAgICBjb25zdCBvcHRzID0geyAuLi5leHBvcnRzLmRlZmF1bHREb3dubG9hZE9wdGlvbnMsIC4uLnRoaXMuY3VzdG9tT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0U2t5bGlua1VybChza3lsaW5rVXJsLCBvcHRzKTtcbiAgICB3aW5kb3cub3Blbih1cmwsIFwiX2JsYW5rXCIpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLm9wZW5GaWxlID0gb3BlbkZpbGU7XG4vKipcbiAqIE9wZW5zIHRoZSBjb250ZW50IG9mIHRoZSBza3lsaW5rIGZyb20gdGhlIGdpdmVuIEhhbmRzaGFrZSBkb21haW4gd2l0aGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZG9tYWluIC0gSGFuZHNoYWtlIGRvbWFpbi5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LiBTZWUgYGRvd25sb2FkRmlsZUhuc2AgZm9yIHRoZSBmdWxsIGxpc3QuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnREb3dubG9hZEhucz1cIi9obnNcIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgZnVsbCBVUkwgdGhhdCB3YXMgdXNlZC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBkb21haW4gaXMgbm90IGEgc3RyaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBvcGVuRmlsZUhucyhkb21haW4sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldEhuc1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdERvd25sb2FkSG5zT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRIbnNVcmwoZG9tYWluLCBvcHRzKTtcbiAgICAvLyBPcGVuIHRoZSB1cmwgaW4gYSBuZXcgdGFiLlxuICAgIHdpbmRvdy5vcGVuKHVybCwgXCJfYmxhbmtcIik7XG4gICAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMub3BlbkZpbGVIbnMgPSBvcGVuRmlsZUhucztcbi8qKlxuICogUmVzb2x2ZXMgdGhlIGdpdmVuIEhOUyBkb21haW4gdG8gaXRzIHNreWxpbmsgYW5kIHJldHVybnMgaXQgYW5kIHRoZSByYXcgZGF0YS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRvbWFpbiAtIEhhbmRzaGFrZSByZXNvbHZlciBkb21haW4uXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnM9e31dIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFJlc29sdmVIbnM9XCIvaG5zcmVzXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIHJhdyBkYXRhIGFuZCBjb3JyZXNwb25kaW5nIHNreWxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQgZG9tYWluIGlzIG5vdCBhIHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUhucyhkb21haW4sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIGlzIGRvbmUgaW4gYGdldEhuc3Jlc1VybGAuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdFJlc29sdmVIbnNPcHRpb25zLCAuLi50aGlzLmN1c3RvbU9wdGlvbnMsIC4uLmN1c3RvbU9wdGlvbnMgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldEhuc3Jlc1VybChkb21haW4sIG9wdHMpO1xuICAgIC8vIEdldCB0aGUgdHh0IHJlY29yZCBmcm9tIHRoZSBobnNyZXMgZG9tYWluIG9uIHRoZSBwb3J0YWwuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZW5kcG9pbnRQYXRoOiBvcHRzLmVuZHBvaW50UmVzb2x2ZUhucyxcbiAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICB1cmwsXG4gICAgfSk7XG4gICAgdmFsaWRhdGVSZXNvbHZlSG5zUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGlmIChyZXNwb25zZS5kYXRhLnNreWxpbmspIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UuZGF0YSwgc2t5bGluazogcmVzcG9uc2UuZGF0YS5za3lsaW5rIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBza3lsaW5rID0gYXdhaXQgdGhpcy5yZWdpc3RyeS5nZXRFbnRyeUxpbmsocmVzcG9uc2UuZGF0YS5yZWdpc3RyeS5wdWJsaWNrZXksIHJlc3BvbnNlLmRhdGEucmVnaXN0cnkuZGF0YWtleSwge1xuICAgICAgICAgICAgaGFzaGVkRGF0YUtleUhleDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLmRhdGEsIHNreWxpbmsgfTtcbiAgICB9XG59XG5leHBvcnRzLnJlc29sdmVIbnMgPSByZXNvbHZlSG5zO1xuLyoqXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVHZXRNZXRhZGF0YVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZS5kYXRhIGZpZWxkIG1pc3NpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGFkYXRhIHJlc3BvbnNlIGludmFsaWQgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuIEVycm9yOiAke2Vycn1gKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlc29sdmVIbnNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2UuZGF0YSBmaWVsZCBtaXNzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLnNreWxpbmspIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInJlc3BvbnNlLmRhdGEuc2t5bGlua1wiLCByZXNwb25zZS5kYXRhLnNreWxpbmssIFwicmVzb2x2ZUhucyByZXNwb25zZSBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5kYXRhLnJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPYmplY3QoXCJyZXNwb25zZS5kYXRhLnJlZ2lzdHJ5XCIsIHJlc3BvbnNlLmRhdGEucmVnaXN0cnksIFwicmVzb2x2ZUhucyByZXNwb25zZSBmaWVsZFwiKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInJlc3BvbnNlLmRhdGEucmVnaXN0cnkucHVibGlja2V5XCIsIHJlc3BvbnNlLmRhdGEucmVnaXN0cnkucHVibGlja2V5LCBcInJlc29sdmVIbnMgcmVzcG9uc2UgZmllbGRcIik7XG4gICAgICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJyZXNwb25zZS5kYXRhLnJlZ2lzdHJ5LmRhdGFrZXlcIiwgcmVzcG9uc2UuZGF0YS5yZWdpc3RyeS5kYXRha2V5LCBcInJlc29sdmVIbnMgcmVzcG9uc2UgZmllbGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uXzEudGhyb3dWYWxpZGF0aW9uRXJyb3IoXCJyZXNwb25zZS5kYXRhXCIsIHJlc3BvbnNlLmRhdGEsIFwicmVzcG9uc2UgZGF0YSBvYmplY3RcIiwgXCJvYmplY3QgY29udGFpbmluZyBza3lsaW5rIG9yIHJlZ2lzdHJ5IGZpZWxkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWQgbm90IGdldCBhIGNvbXBsZXRlIHJlc29sdmUgSE5TIHJlc3BvbnNlIGRlc3BpdGUgYSBzdWNjZXNzZnVsIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gYW5kIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZzIGlmIGl0IHBlcnNpc3RzLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVudHJ5RGF0YSA9IGV4cG9ydHMuZ2V0RW50cnlMaW5rID0gZXhwb3J0cy5nZXRKU09OID0gdm9pZCAwO1xuY29uc3QgdHdlYWtfMSA9IHJlcXVpcmUoXCIuL215c2t5L3R3ZWFrXCIpO1xuY29uc3QgcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JlZ2lzdHJ5XCIpO1xuY29uc3Qgc2t5ZGJfMSA9IHJlcXVpcmUoXCIuL3NreWRiXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbi8qKlxuICogR2V0cyBEaXNjb3ZlcmFibGUgSlNPTiBzZXQgd2l0aCBNeVNreSBhdCB0aGUgZ2l2ZW4gZGF0YSBwYXRoIGZvciB0aGUgZ2l2ZW5cbiAqIHB1YmxpYyB1c2VyIElELlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gdXNlcklEIC0gVGhlIE15U2t5IHB1YmxpYyB1c2VyIElELlxuICogQHBhcmFtIHBhdGggLSBUaGUgZGF0YSBwYXRoLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBqc29uIGRhdGEgYXMgd2VsbCBhcyB0aGUgc2t5bGluayBmb3IgdGhlIGRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEpTT04odXNlcklELCBwYXRoLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwidXNlcklEXCIsIHVzZXJJRCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgc2t5ZGJfMS5kZWZhdWx0R2V0SlNPTk9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLnNreWRiXzEuZGVmYXVsdEdldEpTT05PcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5nZXRKU09OKHVzZXJJRCwgZGF0YUtleSwgb3B0cyk7XG59XG5leHBvcnRzLmdldEpTT04gPSBnZXRKU09OO1xuLyoqXG4gKiBHZXRzIHRoZSBlbnRyeSBsaW5rIGZvciB0aGUgZW50cnkgc2V0IHdpdGggTXlTa3kgYXQgdGhlIGdpdmVuIGRhdGEgcGF0aCwgZm9yXG4gKiB0aGUgZ2l2ZW4gcHVibGljIHVzZXIgSUQuIFRoaXMgaXMgYSB2MiBza3lsaW5rLiBUaGlzIGxpbmsgc3RheXMgdGhlIHNhbWUgZXZlblxuICogaWYgdGhlIGNvbnRlbnQgYXQgdGhlIGVudHJ5IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSB1c2VySUQgLSBUaGUgTXlTa3kgcHVibGljIHVzZXIgSUQuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkYXRhIHBhdGguXG4gKiBAcmV0dXJucyAtIFRoZSBlbnRyeSBsaW5rLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFbnRyeUxpbmsodXNlcklELCBwYXRoKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwidXNlcklEXCIsIHVzZXJJRCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICBjb25zdCBvcHRzID0gcmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zO1xuICAgIG9wdHMuaGFzaGVkRGF0YUtleUhleCA9IHRydWU7IC8vIERvIG5vdCBoYXNoIHRoZSB0d2VhayBhbnltb3JlLlxuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmdldEVudHJ5TGluayh1c2VySUQsIGRhdGFLZXksIG9wdHMpO1xufVxuZXhwb3J0cy5nZXRFbnRyeUxpbmsgPSBnZXRFbnRyeUxpbms7XG4vKipcbiAqIEdldHMgdGhlIGVudHJ5IGRhdGEgZm9yIHRoZSBlbnRyeSBzZXQgd2l0aCBNeVNreSBhdCB0aGUgZ2l2ZW4gZGF0YSBwYXRoLCBmb3JcbiAqIHRoZSBnaXZlbiBwdWJsaWMgdXNlciBJRC5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHVzZXJJRCAtIFRoZSBNeVNreSBwdWJsaWMgdXNlciBJRC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGRhdGEgcGF0aC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgZW50cnkgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnlEYXRhKHVzZXJJRCwgcGF0aCwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInVzZXJJRFwiLCB1c2VySUQsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBhdGhcIiwgcGF0aCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4ucmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICBjb25zdCB7IGVudHJ5IH0gPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmdldEVudHJ5KHVzZXJJRCwgZGF0YUtleSwgb3B0cyk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGVudHJ5LmRhdGEgfTtcbn1cbmV4cG9ydHMuZ2V0RW50cnlEYXRhID0gZ2V0RW50cnlEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1MZWdhY3lTa3lJRCA9IGV4cG9ydHMuUGVybURpc2NvdmVyYWJsZSA9IGV4cG9ydHMuUGVybUhpZGRlbiA9IGV4cG9ydHMuUGVybVdyaXRlID0gZXhwb3J0cy5QZXJtUmVhZCA9IGV4cG9ydHMuUGVybVR5cGUgPSBleHBvcnRzLlBlcm1DYXRlZ29yeSA9IGV4cG9ydHMuUGVybWlzc2lvbiA9IGV4cG9ydHMudXJpU2t5bmV0UHJlZml4ID0gZXhwb3J0cy51cmlIYW5kc2hha2VQcmVmaXggPSBleHBvcnRzLmdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWwgPSBleHBvcnRzLmV4dHJhY3REb21haW5Gb3JQb3J0YWwgPSBleHBvcnRzLmRlZmF1bHRTa3luZXRQb3J0YWxVcmwgPSBleHBvcnRzLmRlZmF1bHRQb3J0YWxVcmwgPSBleHBvcnRzLnVpbnQ4QXJyYXlUb1N0cmluZ1V0ZjggPSBleHBvcnRzLnN0cmluZ1RvVWludDhBcnJheVV0ZjggPSBleHBvcnRzLk1BWF9SRVZJU0lPTiA9IGV4cG9ydHMuZ2V0Um9vdERpcmVjdG9yeSA9IGV4cG9ydHMuZ2V0UmVsYXRpdmVGaWxlUGF0aCA9IGV4cG9ydHMuaXNTa3lsaW5rVjIgPSBleHBvcnRzLmlzU2t5bGlua1YxID0gZXhwb3J0cy5wYXJzZVNreWxpbmsgPSBleHBvcnRzLmNvbnZlcnRTa3lsaW5rVG9CYXNlNjQgPSBleHBvcnRzLmNvbnZlcnRTa3lsaW5rVG9CYXNlMzIgPSBleHBvcnRzLm15U2t5RGV2RG9tYWluID0gZXhwb3J0cy5teVNreURvbWFpbiA9IGV4cG9ydHMuRGFjTGlicmFyeSA9IGV4cG9ydHMuc2lnbkVudHJ5ID0gZXhwb3J0cy5nZXRFbnRyeVVybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0U2t5bGlua1VybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2VuS2V5UGFpckZyb21TZWVkID0gZXhwb3J0cy5nZW5LZXlQYWlyQW5kU2VlZCA9IGV4cG9ydHMuZGVyaXZlQ2hpbGRTZWVkID0gZXhwb3J0cy5Ta3luZXRDbGllbnQgPSB2b2lkIDA7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTa3luZXRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLlNreW5ldENsaWVudDsgfSB9KTtcbnZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL2NyeXB0b1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlcml2ZUNoaWxkU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEuZGVyaXZlQ2hpbGRTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuS2V5UGFpckFuZFNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLmdlbktleVBhaXJBbmRTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuS2V5UGFpckZyb21TZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcnlwdG9fMS5nZW5LZXlQYWlyRnJvbVNlZWQ7IH0gfSk7XG52YXIgZG93bmxvYWRfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U2t5bGlua1VybEZvclBvcnRhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG93bmxvYWRfMS5nZXRTa3lsaW5rVXJsRm9yUG9ydGFsOyB9IH0pO1xudmFyIHJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yZWdpc3RyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEVudHJ5VXJsRm9yUG9ydGFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeV8xLmdldEVudHJ5VXJsRm9yUG9ydGFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2lnbkVudHJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeV8xLnNpZ25FbnRyeTsgfSB9KTtcbnZhciBteXNreV8xID0gcmVxdWlyZShcIi4vbXlza3lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYWNMaWJyYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBteXNreV8xLkRhY0xpYnJhcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJteVNreURvbWFpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbXlza3lfMS5teVNreURvbWFpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm15U2t5RGV2RG9tYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBteXNreV8xLm15U2t5RGV2RG9tYWluOyB9IH0pO1xudmFyIGZvcm1hdF8xID0gcmVxdWlyZShcIi4vc2t5bGluay9mb3JtYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0U2t5bGlua1RvQmFzZTMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXRfMS5jb252ZXJ0U2t5bGlua1RvQmFzZTMyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydFNreWxpbmtUb0Jhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9ybWF0XzEuY29udmVydFNreWxpbmtUb0Jhc2U2NDsgfSB9KTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vc2t5bGluay9wYXJzZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlU2t5bGlua1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VfMS5wYXJzZVNreWxpbms7IH0gfSk7XG52YXIgc2lhXzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL3NpYVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU2t5bGlua1YxXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWFfMS5pc1NreWxpbmtWMTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU2t5bGlua1YyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWFfMS5pc1NreWxpbmtWMjsgfSB9KTtcbnZhciBmaWxlXzEgPSByZXF1aXJlKFwiLi91dGlscy9maWxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UmVsYXRpdmVGaWxlUGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsZV8xLmdldFJlbGF0aXZlRmlsZVBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb290RGlyZWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWxlXzEuZ2V0Um9vdERpcmVjdG9yeTsgfSB9KTtcbnZhciBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1BWF9SRVZJU0lPTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyXzEuTUFYX1JFVklTSU9OOyB9IH0pO1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvc3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5nVG9VaW50OEFycmF5VXRmOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nXzEuc3RyaW5nVG9VaW50OEFycmF5VXRmODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVpbnQ4QXJyYXlUb1N0cmluZ1V0ZjhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ18xLnVpbnQ4QXJyYXlUb1N0cmluZ1V0Zjg7IH0gfSk7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwiLi91dGlscy91cmxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UG9ydGFsVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfMS5kZWZhdWx0UG9ydGFsVXJsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFNreW5ldFBvcnRhbFVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsXzEuZGVmYXVsdFNreW5ldFBvcnRhbFVybDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImV4dHJhY3REb21haW5Gb3JQb3J0YWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF8xLmV4dHJhY3REb21haW5Gb3JQb3J0YWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfMS5nZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpSGFuZHNoYWtlUHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfMS51cmlIYW5kc2hha2VQcmVmaXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1cmlTa3luZXRQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF8xLnVyaVNreW5ldFByZWZpeDsgfSB9KTtcbi8vIFJlLWV4cG9ydCBQZXJtaXNzaW9uIEFQSS5cbnZhciBza3luZXRfbXlza3lfdXRpbHNfMSA9IHJlcXVpcmUoXCJza3luZXQtbXlza3ktdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtaXNzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtaXNzaW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybUNhdGVnb3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtQ2F0ZWdvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtUmVhZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybVJlYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtV3JpdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1Xcml0ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcm1IaWRkZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNreW5ldF9teXNreV91dGlsc18xLlBlcm1IaWRkZW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtRGlzY292ZXJhYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtRGlzY292ZXJhYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybUxlZ2FjeVNreUlEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtTGVnYWN5U2t5SUQ7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdG9yID0gZXhwb3J0cy5kZWZhdWx0Q29ubmVjdG9yT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IHBvc3RfbWVfMSA9IHJlcXVpcmUoXCJwb3N0LW1lXCIpO1xuY29uc3Qgc2t5bmV0X215c2t5X3V0aWxzXzEgPSByZXF1aXJlKFwic2t5bmV0LW15c2t5LXV0aWxzXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJsXCIpO1xuZXhwb3J0cy5kZWZhdWx0Q29ubmVjdG9yT3B0aW9ucyA9IHtcbiAgICBkZXY6IGZhbHNlLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgaGFuZHNoYWtlTWF4QXR0ZW1wdHM6IHNreW5ldF9teXNreV91dGlsc18xLmRlZmF1bHRIYW5kc2hha2VNYXhBdHRlbXB0cyxcbiAgICBoYW5kc2hha2VBdHRlbXB0c0ludGVydmFsOiBza3luZXRfbXlza3lfdXRpbHNfMS5kZWZhdWx0SGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbCxcbn07XG5jbGFzcyBDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHVybCwgY2xpZW50LCBjaGlsZEZyYW1lLCBjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5jaGlsZEZyYW1lID0gY2hpbGRGcmFtZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLy8gU3RhdGljIGluaXRpYWxpemVyXG4gICAgc3RhdGljIGFzeW5jIGluaXQoY2xpZW50LCBkb21haW4sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0Q29ubmVjdG9yT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgICAgICAvLyBHZXQgdGhlIFVSTCBmb3IgdGhlIGRvbWFpbiBvbiB0aGUgY3VycmVudCBwb3J0YWwuXG4gICAgICAgIGxldCBkb21haW5VcmwgPSBhd2FpdCBjbGllbnQuZ2V0RnVsbERvbWFpblVybChkb21haW4pO1xuICAgICAgICBpZiAob3B0cy5kZXYpIHtcbiAgICAgICAgICAgIGRvbWFpblVybCA9IHVybF8xLmFkZFVybFF1ZXJ5KGRvbWFpblVybCwgeyBkZXY6IFwidHJ1ZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmRlYnVnKSB7XG4gICAgICAgICAgICBkb21haW5VcmwgPSB1cmxfMS5hZGRVcmxRdWVyeShkb21haW5VcmwsIHsgZGVidWc6IFwidHJ1ZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmFscGhhKSB7XG4gICAgICAgICAgICBkb21haW5VcmwgPSB1cmxfMS5hZGRVcmxRdWVyeShkb21haW5VcmwsIHsgYWxwaGE6IFwidHJ1ZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaWZyYW1lLlxuICAgICAgICBjb25zdCBjaGlsZEZyYW1lID0gc2t5bmV0X215c2t5X3V0aWxzXzEuY3JlYXRlSWZyYW1lKGRvbWFpblVybCwgZG9tYWluVXJsKTtcbiAgICAgICAgY29uc3QgY2hpbGRXaW5kb3cgPSBjaGlsZEZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIGlmcmFtZS5cbiAgICAgICAgY29uc3QgbWVzc2VuZ2VyID0gbmV3IHBvc3RfbWVfMS5XaW5kb3dNZXNzZW5nZXIoe1xuICAgICAgICAgICAgbG9jYWxXaW5kb3c6IHdpbmRvdyxcbiAgICAgICAgICAgIHJlbW90ZVdpbmRvdzogY2hpbGRXaW5kb3csXG4gICAgICAgICAgICByZW1vdGVPcmlnaW46IFwiKlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHBvc3RfbWVfMS5QYXJlbnRIYW5kc2hha2UobWVzc2VuZ2VyLCB7fSwgb3B0cy5oYW5kc2hha2VNYXhBdHRlbXB0cywgb3B0cy5oYW5kc2hha2VBdHRlbXB0c0ludGVydmFsKTtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBjb21wb25lbnQgY29ubmVjdG9yLlxuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3Rvcihkb21haW5VcmwsIGNsaWVudCwgY2hpbGRGcmFtZSwgY29ubmVjdGlvbiwgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwobWV0aG9kLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ucmVtb3RlSGFuZGxlKCkuY2FsbChtZXRob2QsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdG9yID0gQ29ubmVjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhY0xpYnJhcnkgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvclwiKTtcbmNsYXNzIERhY0xpYnJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGRhY0RvbWFpbikge1xuICAgICAgICB0aGlzLmRhY0RvbWFpbiA9IGRhY0RvbWFpbjtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChjbGllbnQsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBhd2FpdCBjb25uZWN0b3JfMS5Db25uZWN0b3IuaW5pdChjbGllbnQsIHRoaXMuZGFjRG9tYWluLCBjdXN0b21PcHRpb25zKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0b3IuY29ubmVjdGlvbi5yZW1vdGVIYW5kbGUoKS5jYWxsKFwiaW5pdFwiKTtcbiAgICB9XG4gICAgb25Vc2VyTG9naW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluaXQgd2FzIG5vdCBjYWxsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0b3IuY29ubmVjdGlvbi5yZW1vdGVIYW5kbGUoKS5jYWxsKFwib25Vc2VyTG9naW5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5EYWNMaWJyYXJ5ID0gRGFjTGlicmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NeVNreSA9IGV4cG9ydHMubG9hZE15U2t5ID0gZXhwb3J0cy5NQVhfRU5UUllfTEVOR1RIID0gZXhwb3J0cy5teVNreUFscGhhRG9tYWluID0gZXhwb3J0cy5teVNreURldkRvbWFpbiA9IGV4cG9ydHMubXlTa3lEb21haW4gPSBleHBvcnRzLkRhY0xpYnJhcnkgPSB2b2lkIDA7XG52YXIgZGFjXzEgPSByZXF1aXJlKFwiLi9kYWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYWNMaWJyYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYWNfMS5EYWNMaWJyYXJ5OyB9IH0pO1xuY29uc3QgcG9zdF9tZV8xID0gcmVxdWlyZShcInBvc3QtbWVcIik7XG5jb25zdCBza3luZXRfbXlza3lfdXRpbHNfMSA9IHJlcXVpcmUoXCJza3luZXQtbXlza3ktdXRpbHNcIik7XG5jb25zdCBjb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvclwiKTtcbmNvbnN0IHJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi4vcmVnaXN0cnlcIik7XG5jb25zdCBza3lkYl8xID0gcmVxdWlyZShcIi4uL3NreWRiXCIpO1xuY29uc3QgdHdlYWtfMSA9IHJlcXVpcmUoXCIuL3R3ZWFrXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbmNvbnN0IHNpYV8xID0gcmVxdWlyZShcIi4uL3NreWxpbmsvc2lhXCIpO1xuZXhwb3J0cy5teVNreURvbWFpbiA9IFwic2t5bmV0LW15c2t5Lmhuc1wiO1xuZXhwb3J0cy5teVNreURldkRvbWFpbiA9IFwic2t5bmV0LW15c2t5LWRldi5obnNcIjtcbmV4cG9ydHMubXlTa3lBbHBoYURvbWFpbiA9IFwic2FuZGJyaWRnZS5obnNcIjtcbmV4cG9ydHMuTUFYX0VOVFJZX0xFTkdUSCA9IDcwO1xuY29uc3QgbXlTa3lVaVJlbGF0aXZlVXJsID0gXCJ1aS5odG1sXCI7XG5jb25zdCBteVNreVVpVGl0bGUgPSBcIk15U2t5IFVJXCI7XG5jb25zdCBbbXlTa3lVaVcsIG15U2t5VWlIXSA9IFs2MDAsIDYwMF07XG4vKipcbiAqIExvYWRzIE15U2t5LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBsb2cgaW4gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBUaGUgU2t5bmV0IGNsaWVudC5cbiAqIEBwYXJhbSBza2FwcERvbWFpbiAtIFRoZSBkb21haW4gb2YgdGhlIGhvc3Qgc2thcHAuIEZvciB0aGlzIGRvbWFpbiBwZXJtaXNzaW9ucyB3aWxsIGJlIHJlcXVlc3RlZCBhbmQsIGJ5IGRlZmF1bHQsIGF1dG9tYXRpY2FsbHkgZ3JhbnRlZC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBMb2FkZWQgKGJ1dCBub3QgbG9nZ2VkLWluKSBNeVNreSBpbnN0YW5jZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZE15U2t5KHNrYXBwRG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgY29uc3QgbXlTa3kgPSBhd2FpdCBNeVNreS5OZXcodGhpcywgc2thcHBEb21haW4sIGN1c3RvbU9wdGlvbnMpO1xuICAgIHJldHVybiBteVNreTtcbn1cbmV4cG9ydHMubG9hZE15U2t5ID0gbG9hZE15U2t5O1xuY2xhc3MgTXlTa3kge1xuICAgIC8vID09PT09PT09PT09PVxuICAgIC8vIENvbnN0cnVjdG9yc1xuICAgIC8vID09PT09PT09PT09PVxuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3RvciwgcGVybWlzc2lvbnMsIGhvc3REb21haW4pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdERvbWFpbiA9IGhvc3REb21haW47XG4gICAgICAgIC8vIEhvbGRzIHRoZSBsb2FkZWQgREFDcy5cbiAgICAgICAgdGhpcy5kYWNzID0gW107XG4gICAgICAgIC8vIEhvbGRzIHRoZSBjdXJyZW50bHkgZ3JhbnRlZCBwZXJtaXNzaW9ucy5cbiAgICAgICAgdGhpcy5ncmFudGVkUGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIE5ldyhjbGllbnQsIHNrYXBwRG9tYWluLCBjdXN0b21PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLmNvbm5lY3Rvcl8xLmRlZmF1bHRDb25uZWN0b3JPcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xldG9uLlxuICAgICAgICBpZiAoTXlTa3kuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNeVNreS5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9tYWluID0gZXhwb3J0cy5teVNreURvbWFpbjtcbiAgICAgICAgaWYgKG9wdHMuYWxwaGEpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGV4cG9ydHMubXlTa3lBbHBoYURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmRldikge1xuICAgICAgICAgICAgZG9tYWluID0gZXhwb3J0cy5teVNreURldkRvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0b3IgPSBhd2FpdCBjb25uZWN0b3JfMS5Db25uZWN0b3IuaW5pdChjbGllbnQsIGRvbWFpbiwgY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGhvc3REb21haW4gPSBhd2FpdCBjbGllbnQuZXh0cmFjdERvbWFpbih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoc2thcHBEb21haW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEFyZSB0aGVzZSBwZXJtaXNzaW9ucyBjb3JyZWN0P1xuICAgICAgICAgICAgY29uc3QgcGVybTEgPSBuZXcgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybWlzc2lvbihob3N0RG9tYWluLCBza2FwcERvbWFpbiwgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybUNhdGVnb3J5LkhpZGRlbiwgc2t5bmV0X215c2t5X3V0aWxzXzEuUGVybVR5cGUuUmVhZCk7XG4gICAgICAgICAgICBjb25zdCBwZXJtMiA9IG5ldyBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtaXNzaW9uKGhvc3REb21haW4sIHNrYXBwRG9tYWluLCBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtQ2F0ZWdvcnkuSGlkZGVuLCBza3luZXRfbXlza3lfdXRpbHNfMS5QZXJtVHlwZS5Xcml0ZSk7XG4gICAgICAgICAgICBwZXJtaXNzaW9ucy5wdXNoKHBlcm0xLCBwZXJtMik7XG4gICAgICAgIH1cbiAgICAgICAgTXlTa3kuaW5zdGFuY2UgPSBuZXcgTXlTa3koY29ubmVjdG9yLCBwZXJtaXNzaW9ucywgaG9zdERvbWFpbik7XG4gICAgICAgIHJldHVybiBNeVNreS5pbnN0YW5jZTtcbiAgICB9XG4gICAgLy8gPT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBBUElcbiAgICAvLyA9PT09PT09PT09XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGdpdmVuIERBQ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGFjcyAtIFRoZSBEQUMgbGlicmFyeSBpbnN0YW5jZXMgdG8gY2FsbCBgaW5pdGAgb24uXG4gICAgICovXG4gICAgYXN5bmMgbG9hZERhY3MoLi4uZGFjcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRhYyBvZiBkYWNzKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMubG9hZERhYyhkYWMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhY3MucHVzaCguLi5kYWNzKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBhc3luYyBhZGRQZXJtaXNzaW9ucyguLi5wZXJtaXNzaW9ucykge1xuICAgICAgICB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucy5wdXNoKC4uLnBlcm1pc3Npb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tMb2dpbigpIHtcbiAgICAgICAgY29uc3QgW3NlZWRGb3VuZCwgcGVybWlzc2lvbnNSZXNwb25zZV0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0aW9uXG4gICAgICAgICAgICAucmVtb3RlSGFuZGxlKClcbiAgICAgICAgICAgIC5jYWxsKFwiY2hlY2tMb2dpblwiLCB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyk7XG4gICAgICAgIC8vIFNhdmUgZ3JhbnRlZCBhbmQgZmFpbGVkIHBlcm1pc3Npb25zLlxuICAgICAgICBjb25zdCB7IGdyYW50ZWRQZXJtaXNzaW9ucywgZmFpbGVkUGVybWlzc2lvbnMgfSA9IHBlcm1pc3Npb25zUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuZ3JhbnRlZFBlcm1pc3Npb25zID0gZ3JhbnRlZFBlcm1pc3Npb25zO1xuICAgICAgICB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyA9IGZhaWxlZFBlcm1pc3Npb25zO1xuICAgICAgICBjb25zdCBsb2dnZWRJbiA9IHNlZWRGb3VuZCAmJiBmYWlsZWRQZXJtaXNzaW9ucy5sZW5ndGggPT09IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlTG9naW4obG9nZ2VkSW4pO1xuICAgICAgICByZXR1cm4gbG9nZ2VkSW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBteXNreSBjb25uZWN0aW9uIGJ5OlxuICAgICAqXG4gICAgICogMS4gRGVzdHJveWluZyB0aGUgY29ubmVjdGVkIERBQ3MsXG4gICAgICpcbiAgICAgKiAyLiBDbG9zaW5nIHRoZSBjb25uZWN0aW9uLFxuICAgICAqXG4gICAgICogMy4gQ2xvc2luZyB0aGUgY2hpbGQgaWZyYW1lXG4gICAgICovXG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVE9ETzogRm9yIGFsbCBjb25uZWN0ZWQgZGFjcywgc2VuZCBhIGRlc3Ryb3kgY2FsbC5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIGFsbCBjb25uZWN0ZWQgZGFjcy5cbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNoaWxkIGlmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yLmNoaWxkRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmNoaWxkRnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbm5lY3Rvci5jaGlsZEZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsb2dvdXQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0aW9uLnJlbW90ZUhhbmRsZSgpLmNhbGwoXCJsb2dvdXRcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RMb2dpbkFjY2VzcygpIHtcbiAgICAgICAgbGV0IHVpV2luZG93O1xuICAgICAgICBsZXQgdWlDb25uZWN0aW9uO1xuICAgICAgICBsZXQgc2VlZEZvdW5kID0gZmFsc2U7XG4gICAgICAgIC8vIEFkZCBlcnJvciBsaXN0ZW5lci5cbiAgICAgICAgY29uc3QgeyBwcm9taXNlOiBwcm9taXNlRXJyb3IsIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXJFcnJvciB9ID0gc2t5bmV0X215c2t5X3V0aWxzXzEubW9uaXRvcldpbmRvd0Vycm9yKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHRoaXMgcHJvbWlzZSBydW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIHJlamVjdCBvbiB3aW5kb3cgY2xvc2Ugb3IgYW55IGVycm9ycy5cbiAgICAgICAgICAgIHByb21pc2VFcnJvci5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gc2t5bmV0X215c2t5X3V0aWxzXzEuZXJyb3JXaW5kb3dDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aXRob3V0IHVwZGF0aW5nIHRoZSBwZW5kaW5nIHBlcm1pc3Npb25zLlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTGF1bmNoIHRoZSBVSS5cbiAgICAgICAgICAgICAgICB1aVdpbmRvdyA9IGF3YWl0IHRoaXMubGF1bmNoVUkoKTtcbiAgICAgICAgICAgICAgICB1aUNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmNvbm5lY3RVaSh1aVdpbmRvdyk7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgVUkgdGhlIGxpc3Qgb2YgcmVxdWlyZWQgcGVybWlzc2lvbnMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgYSBkdWFsLXByb21pc2UgdGhhdCBhbHNvIGNhbGxzIHBpbmcoKSBvbiBhbiBpbnRlcnZhbCBhbmQgcmVqZWN0cyBpZiBubyByZXNwb25zZSB3YXMgZm91bmQgaW4gYSBnaXZlbiBhbW91bnQgb2YgdGltZS5cbiAgICAgICAgICAgICAgICBjb25zdCBbc2VlZEZvdW5kUmVzcG9uc2UsIHBlcm1pc3Npb25zUmVzcG9uc2VdID0gYXdhaXQgdWlDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdGVIYW5kbGUoKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChcInJlcXVlc3RMb2dpbkFjY2Vzc1wiLCB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgc2VlZEZvdW5kID0gc2VlZEZvdW5kUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBmYWlsZWQgcGVybWlzc2lvbnMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBncmFudGVkUGVybWlzc2lvbnMsIGZhaWxlZFBlcm1pc3Npb25zIH0gPSBwZXJtaXNzaW9uc1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhbnRlZFBlcm1pc3Npb25zID0gZ3JhbnRlZFBlcm1pc3Npb25zO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Blcm1pc3Npb25zID0gZmFpbGVkUGVybWlzc2lvbnM7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSB3aW5kb3cuXG4gICAgICAgICAgICBpZiAodWlXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICB1aVdpbmRvdy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBpZiAodWlDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdWlDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9taXNlcy5cbiAgICAgICAgICAgIGNvbnRyb2xsZXJFcnJvci5jbGVhbnVwKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsb2dnZWRJbiA9IHNlZWRGb3VuZCAmJiB0aGlzLnBlbmRpbmdQZXJtaXNzaW9ucy5sZW5ndGggPT09IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlTG9naW4obG9nZ2VkSW4pO1xuICAgICAgICByZXR1cm4gbG9nZ2VkSW47XG4gICAgfVxuICAgIGFzeW5jIHVzZXJJRChvcHRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0aW9uLnJlbW90ZUhhbmRsZSgpLmNhbGwoXCJ1c2VySURcIiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgRGlzY292ZXJhYmxlIEpTT04gYXQgdGhlIGdpdmVuIHBhdGggdGhyb3VnaCBNeVNreSwgaWYgdGhlIHVzZXIgaGFzIGdpdmVuIFJlYWQgcGVybWlzc2lvbnMgdG8gZG8gc28uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBkYXRhIHBhdGguXG4gICAgICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gICAgICogQHJldHVybnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUganNvbiBkYXRhIGFzIHdlbGwgYXMgdGhlIHNreWxpbmsgZm9yIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEpTT04ocGF0aCwgY3VzdG9tT3B0aW9ucykge1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwYXRoXCIsIHBhdGgsIFwicGFyYW1ldGVyXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgc2t5ZGJfMS5kZWZhdWx0R2V0SlNPTk9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4uc2t5ZGJfMS5kZWZhdWx0R2V0SlNPTk9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmNvbm5lY3Rvci5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMudXNlcklEKCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0d2Vha18xLmRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrKHBhdGgpO1xuICAgICAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNsaWVudC5kYi5nZXRKU09OKHB1YmxpY0tleSwgZGF0YUtleSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVudHJ5IGxpbmsgZm9yIHRoZSBlbnRyeSBhdCB0aGUgZ2l2ZW4gcGF0aC4gVGhpcyBpcyBhIHYyIHNreWxpbmsuXG4gICAgICogVGhpcyBsaW5rIHN0YXlzIHRoZSBzYW1lIGV2ZW4gaWYgdGhlIGNvbnRlbnQgYXQgdGhlIGVudHJ5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBkYXRhIHBhdGguXG4gICAgICogQHJldHVybnMgLSBUaGUgZW50cnkgbGluay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFbnRyeUxpbmsocGF0aCkge1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwYXRoXCIsIHBhdGgsIFwicGFyYW1ldGVyXCIpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCB0aGlzLnVzZXJJRCgpO1xuICAgICAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucztcbiAgICAgICAgb3B0cy5oYXNoZWREYXRhS2V5SGV4ID0gdHJ1ZTsgLy8gRG8gbm90IGhhc2ggdGhlIHR3ZWFrIGFueW1vcmUuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rvci5jbGllbnQucmVnaXN0cnkuZ2V0RW50cnlMaW5rKHB1YmxpY0tleSwgZGF0YUtleSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgRGlzY292ZXJhYmxlIEpTT04gYXQgdGhlIGdpdmVuIHBhdGggdGhyb3VnaCBNeVNreSwgaWYgdGhlIHVzZXIgaGFzIGdpdmVuIFdyaXRlIHBlcm1pc3Npb25zIHRvIGRvIHNvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZGF0YSBwYXRoLlxuICAgICAqIEBwYXJhbSBqc29uIC0gVGhlIGpzb24gdG8gc2V0LlxuICAgICAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGpzb24gZGF0YSBhcyB3ZWxsIGFzIHRoZSBza3lsaW5rIGZvciB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRKU09OKHBhdGgsIGpzb24sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT2JqZWN0KFwianNvblwiLCBqc29uLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIHNreWRiXzEuZGVmYXVsdFNldEpTT05PcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnNreWRiXzEuZGVmYXVsdFNldEpTT05PcHRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy5jb25uZWN0b3IuY2xpZW50LmN1c3RvbU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCB0aGlzLnVzZXJJRCgpO1xuICAgICAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICAgICAgb3B0cy5oYXNoZWREYXRhS2V5SGV4ID0gdHJ1ZTsgLy8gRG8gbm90IGhhc2ggdGhlIHR3ZWFrIGFueW1vcmUuXG4gICAgICAgIGNvbnN0IFtlbnRyeSwgZGF0YUxpbmtdID0gYXdhaXQgc2t5ZGJfMS5nZXRPckNyZWF0ZVJlZ2lzdHJ5RW50cnkodGhpcy5jb25uZWN0b3IuY2xpZW50LCBwdWJsaWNLZXksIGRhdGFLZXksIGpzb24sIG9wdHMpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25SZWdpc3RyeUVudHJ5KGVudHJ5LCBwYXRoKTtcbiAgICAgICAgY29uc3Qgc2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNsaWVudC5yZWdpc3RyeS5wb3N0U2lnbmVkRW50cnkocHVibGljS2V5LCBlbnRyeSwgc2lnbmF0dXJlLCBzZXRFbnRyeU9wdHMpO1xuICAgICAgICByZXR1cm4geyBkYXRhOiBqc29uLCBkYXRhTGluayB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGVudHJ5IGF0IHRoZSBnaXZlbiBwYXRoIHRvIHBvaW50IHRvIHRoZSBkYXRhIGxpbmsuIExpa2Ugc2V0SlNPTiwgYnV0IGl0IGRvZXNuJ3QgdXBsb2FkIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGRhdGEgcGF0aC5cbiAgICAgKiBAcGFyYW0gZGF0YUxpbmsgLSBUaGUgZGF0YSBsaW5rIHRvIHNldCBhdCB0aGUgcGF0aC5cbiAgICAgKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAgICAgKiBAcmV0dXJucyAtIEFuIGVtcHR5IHByb21pc2UuXG4gICAgICovXG4gICAgYXN5bmMgc2V0RGF0YUxpbmsocGF0aCwgZGF0YUxpbmssIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZGF0YUxpbmtcIiwgZGF0YUxpbmssIFwicGFyYW1ldGVyXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgc2t5ZGJfMS5kZWZhdWx0U2V0SlNPTk9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4uc2t5ZGJfMS5kZWZhdWx0U2V0SlNPTk9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmNvbm5lY3Rvci5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMudXNlcklEKCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0d2Vha18xLmRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrKHBhdGgpO1xuICAgICAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICAgICAgY29uc3QgZ2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgc2t5ZGJfMS5nZXROZXh0UmVnaXN0cnlFbnRyeSh0aGlzLmNvbm5lY3Rvci5jbGllbnQsIHB1YmxpY0tleSwgZGF0YUtleSwgc2lhXzEuZGVjb2RlU2t5bGluayhkYXRhTGluayksIGdldEVudHJ5T3B0cyk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnblJlZ2lzdHJ5RW50cnkoZW50cnksIHBhdGgpO1xuICAgICAgICBjb25zdCBzZXRFbnRyeU9wdHMgPSBvcHRpb25zXzEuZXh0cmFjdE9wdGlvbnMob3B0cywgcmVnaXN0cnlfMS5kZWZhdWx0U2V0RW50cnlPcHRpb25zKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0b3IuY2xpZW50LnJlZ2lzdHJ5LnBvc3RTaWduZWRFbnRyeShwdWJsaWNLZXksIGVudHJ5LCBzaWduYXR1cmUsIHNldEVudHJ5T3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgRGlzY292ZXJhYmxlIEpTT04gYXQgdGhlIGdpdmVuIHBhdGggdGhyb3VnaCBNeVNreSwgaWYgdGhlIHVzZXIgaGFzIGdpdmVuIFdyaXRlIHBlcm1pc3Npb25zIHRvIGRvIHNvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZGF0YSBwYXRoLlxuICAgICAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICAgICAqIEByZXR1cm5zIC0gQW4gZW1wdHkgcHJvbWlzZS5cbiAgICAgKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgcmV2aXNpb24gaXMgYWxyZWFkeSB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVKU09OKHBhdGgsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIHNreWRiXzEuZGVmYXVsdFNldEpTT05PcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnNreWRiXzEuZGVmYXVsdFNldEpTT05PcHRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy5jb25uZWN0b3IuY2xpZW50LmN1c3RvbU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCB0aGlzLnVzZXJJRCgpO1xuICAgICAgICBjb25zdCBkYXRhS2V5ID0gdHdlYWtfMS5kZXJpdmVEaXNjb3ZlcmFibGVUd2VhayhwYXRoKTtcbiAgICAgICAgb3B0cy5oYXNoZWREYXRhS2V5SGV4ID0gdHJ1ZTsgLy8gRG8gbm90IGhhc2ggdGhlIHR3ZWFrIGFueW1vcmUuXG4gICAgICAgIGNvbnN0IGdldEVudHJ5T3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCByZWdpc3RyeV8xLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHNreWRiXzEuZ2V0TmV4dFJlZ2lzdHJ5RW50cnkodGhpcy5jb25uZWN0b3IuY2xpZW50LCBwdWJsaWNLZXksIGRhdGFLZXksIG5ldyBVaW50OEFycmF5KHNpYV8xLlJBV19TS1lMSU5LX1NJWkUpLCBnZXRFbnRyeU9wdHMpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25SZWdpc3RyeUVudHJ5KGVudHJ5LCBwYXRoKTtcbiAgICAgICAgY29uc3Qgc2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNsaWVudC5yZWdpc3RyeS5wb3N0U2lnbmVkRW50cnkocHVibGljS2V5LCBlbnRyeSwgc2lnbmF0dXJlLCBzZXRFbnRyeU9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByYXcgcmVnaXN0cnkgZW50cnkgZGF0YSBmb3IgdGhlIGdpdmVuIHBhdGgsIGlmIHRoZSB1c2VyIGhhcyBnaXZlbiBSRUFEIHBlcm1pc3Npb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZGF0YSBwYXRoLlxuICAgICAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGVudHJ5IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RW50cnlEYXRhKHBhdGgsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAuLi5yZWdpc3RyeV8xLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmNvbm5lY3Rvci5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMudXNlcklEKCk7XG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSB0d2Vha18xLmRlcml2ZURpc2NvdmVyYWJsZVR3ZWFrKHBhdGgpO1xuICAgICAgICBvcHRzLmhhc2hlZERhdGFLZXlIZXggPSB0cnVlOyAvLyBEbyBub3QgaGFzaCB0aGUgdHdlYWsgYW55bW9yZS5cbiAgICAgICAgY29uc3QgeyBlbnRyeSB9ID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuY2xpZW50LnJlZ2lzdHJ5LmdldEVudHJ5KHB1YmxpY0tleSwgZGF0YUtleSwgb3B0cyk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiBlbnRyeS5kYXRhIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVudHJ5IGRhdGEgYXQgdGhlIGdpdmVuIHBhdGgsIGlmIHRoZSB1c2VyIGhhcyBnaXZlbiBXUklURSBwZXJtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGRhdGEgcGF0aC5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSByYXcgZW50cnkgZGF0YSB0byBzZXQuXG4gICAgICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gICAgICogQHJldHVybnMgLSBUaGUgZW50cnkgZGF0YS5cbiAgICAgKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBkYXRhIGlzID4gNzAgYnl0ZXMuXG4gICAgICovXG4gICAgYXN5bmMgc2V0RW50cnlEYXRhKHBhdGgsIGRhdGEsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicGF0aFwiLCBwYXRoLCBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlVWludDhBcnJheShcImRhdGFcIiwgZGF0YSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCByZWdpc3RyeV8xLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBleHBvcnRzLk1BWF9FTlRSWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25fMS50aHJvd1ZhbGlkYXRpb25FcnJvcihcImRhdGFcIiwgZGF0YSwgXCJwYXJhbWV0ZXJcIiwgYCdVaW50OEFycmF5JyBvZiBsZW5ndGggPD0gJHtleHBvcnRzLk1BWF9FTlRSWV9MRU5HVEh9LCB3YXMgbGVuZ3RoICR7ZGF0YS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnJlZ2lzdHJ5XzEuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnRoaXMuY29ubmVjdG9yLmNsaWVudC5jdXN0b21PcHRpb25zLFxuICAgICAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy51c2VySUQoKTtcbiAgICAgICAgY29uc3QgZGF0YUtleSA9IHR3ZWFrXzEuZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsocGF0aCk7XG4gICAgICAgIG9wdHMuaGFzaGVkRGF0YUtleUhleCA9IHRydWU7IC8vIERvIG5vdCBoYXNoIHRoZSB0d2VhayBhbnltb3JlLlxuICAgICAgICBjb25zdCBnZXRFbnRyeU9wdHMgPSBvcHRpb25zXzEuZXh0cmFjdE9wdGlvbnMob3B0cywgcmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zKTtcbiAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBza3lkYl8xLmdldE5leHRSZWdpc3RyeUVudHJ5KHRoaXMuY29ubmVjdG9yLmNsaWVudCwgcHVibGljS2V5LCBkYXRhS2V5LCBkYXRhLCBnZXRFbnRyeU9wdHMpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25SZWdpc3RyeUVudHJ5KGVudHJ5LCBwYXRoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0b3IuY2xpZW50LnJlZ2lzdHJ5LnBvc3RTaWduZWRFbnRyeShwdWJsaWNLZXksIGVudHJ5LCBzaWduYXR1cmUsIG9wdHMpO1xuICAgICAgICByZXR1cm4geyBkYXRhOiBlbnRyeS5kYXRhIH07XG4gICAgfVxuICAgIC8vID09PT09PT09PT09PT09PT1cbiAgICAvLyBJbnRlcm5hbCBNZXRob2RzXG4gICAgLy8gPT09PT09PT09PT09PT09PVxuICAgIGFzeW5jIGNhdGNoRXJyb3IoZXJyb3JNc2cpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoc2t5bmV0X215c2t5X3V0aWxzXzEuZGlzcGF0Y2hlZEVycm9yRXZlbnQsIHsgZGV0YWlsOiBlcnJvck1zZyB9KTtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBsYXVuY2hVSSgpIHtcbiAgICAgICAgY29uc3QgbXlTa3lVcmwgPSBuZXcgVVJMKHRoaXMuY29ubmVjdG9yLnVybCk7XG4gICAgICAgIG15U2t5VXJsLnBhdGhuYW1lID0gbXlTa3lVaVJlbGF0aXZlVXJsO1xuICAgICAgICBjb25zdCB1aVVybCA9IG15U2t5VXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIE9wZW4gdGhlIHdpbmRvdy5cbiAgICAgICAgY29uc3QgY2hpbGRXaW5kb3cgPSB1dGlsc18xLnBvcHVwQ2VudGVyKHVpVXJsLCBteVNreVVpVGl0bGUsIG15U2t5VWlXLCBteVNreVVpSCk7XG4gICAgICAgIGlmICghY2hpbGRXaW5kb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IG9wZW4gd2luZG93IGF0ICcke3VpVXJsfSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRXaW5kb3c7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3RVaShjaGlsZFdpbmRvdykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb25uZWN0b3Iub3B0aW9ucztcbiAgICAgICAgLy8gQ29tcGxldGUgaGFuZHNoYWtlIHdpdGggVUkgd2luZG93LlxuICAgICAgICBjb25zdCBtZXNzZW5nZXIgPSBuZXcgcG9zdF9tZV8xLldpbmRvd01lc3Nlbmdlcih7XG4gICAgICAgICAgICBsb2NhbFdpbmRvdzogd2luZG93LFxuICAgICAgICAgICAgcmVtb3RlV2luZG93OiBjaGlsZFdpbmRvdyxcbiAgICAgICAgICAgIHJlbW90ZU9yaWdpbjogXCIqXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAgICAgY2F0Y2hFcnJvcjogdGhpcy5jYXRjaEVycm9yLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgcG9zdF9tZV8xLlBhcmVudEhhbmRzaGFrZShtZXNzZW5nZXIsIG1ldGhvZHMsIG9wdGlvbnMuaGFuZHNoYWtlTWF4QXR0ZW1wdHMsIG9wdGlvbnMuaGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBhc3luYyBsb2FkRGFjKGRhYykge1xuICAgICAgICAvLyBJbml0aWFsaXplIERBQy5cbiAgICAgICAgYXdhaXQgZGFjLmluaXQodGhpcy5jb25uZWN0b3IuY2xpZW50LCB0aGlzLmNvbm5lY3Rvci5vcHRpb25zKTtcbiAgICAgICAgLy8gQWRkIERBQyBwZXJtaXNzaW9ucy5cbiAgICAgICAgY29uc3QgcGVybXMgPSBkYWMuZ2V0UGVybWlzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5hZGRQZXJtaXNzaW9ucyguLi5wZXJtcyk7XG4gICAgfVxuICAgIGhhbmRsZUxvZ2luKGxvZ2dlZEluKSB7XG4gICAgICAgIGlmIChsb2dnZWRJbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYWMgb2YgdGhpcy5kYWNzKSB7XG4gICAgICAgICAgICAgICAgZGFjLm9uVXNlckxvZ2luKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnblJlZ2lzdHJ5RW50cnkoZW50cnksIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb24ucmVtb3RlSGFuZGxlKCkuY2FsbChcInNpZ25SZWdpc3RyeUVudHJ5XCIsIGVudHJ5LCBwYXRoKTtcbiAgICB9XG59XG5leHBvcnRzLk15U2t5ID0gTXlTa3k7XG5NeVNreS5pbnN0YW5jZSA9IG51bGw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsgPSBleHBvcnRzLmhhc2hQYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5zcGxpdFBhdGggPSBleHBvcnRzLkRpc2NvdmVyYWJsZUJ1Y2tldFR3ZWFrID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyaW5nXCIpO1xuY29uc3QgZGlzY292ZXJhYmxlQnVja2V0VHdlYWtWZXJzaW9uID0gMTtcbmNsYXNzIERpc2NvdmVyYWJsZUJ1Y2tldFR3ZWFrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gc3BsaXRQYXRoKHBhdGgpO1xuICAgICAgICBjb25zdCBwYXRoSGFzaGVzID0gcGF0aHMubWFwKGhhc2hQYXRoQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gZGlzY292ZXJhYmxlQnVja2V0VHdlYWtWZXJzaW9uO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoSGFzaGVzO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSAxICsgMzIgKiB0aGlzLnBhdGgubGVuZ3RoO1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgYnVmLnNldChbdGhpcy52ZXJzaW9uXSk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGhMZXZlbCBvZiB0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgIGJ1Zi5zZXQocGF0aExldmVsLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDMyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGdldEhhc2goKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gdGhpcy5lbmNvZGUoKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmhhc2hBbGwoZW5jb2RpbmcpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlzY292ZXJhYmxlQnVja2V0VHdlYWsgPSBEaXNjb3ZlcmFibGVCdWNrZXRUd2VhaztcbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpO1xufVxuZXhwb3J0cy5zcGxpdFBhdGggPSBzcGxpdFBhdGg7XG5mdW5jdGlvbiBoYXNoUGF0aENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY3J5cHRvXzEuaGFzaEFsbChzdHJpbmdfMS5zdHJpbmdUb1VpbnQ4QXJyYXlVdGY4KGNvbXBvbmVudCkpO1xufVxuZXhwb3J0cy5oYXNoUGF0aENvbXBvbmVudCA9IGhhc2hQYXRoQ29tcG9uZW50O1xuZnVuY3Rpb24gZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsocGF0aCkge1xuICAgIGNvbnN0IGRidCA9IG5ldyBEaXNjb3ZlcmFibGVCdWNrZXRUd2VhayhwYXRoKTtcbiAgICBjb25zdCBieXRlcyA9IGRidC5nZXRIYXNoKCk7XG4gICAgcmV0dXJuIHN0cmluZ18xLnRvSGV4U3RyaW5nKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZGVyaXZlRGlzY292ZXJhYmxlVHdlYWsgPSBkZXJpdmVEaXNjb3ZlcmFibGVUd2VhaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb3B1cENlbnRlciA9IGV4cG9ydHMuZXh0cmFjdERvbWFpbiA9IGV4cG9ydHMuZ2V0RnVsbERvbWFpblVybCA9IHZvaWQgMDtcbmNvbnN0IHNreW5ldF9teXNreV91dGlsc18xID0gcmVxdWlyZShcInNreW5ldC1teXNreS11dGlsc1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4uL3V0aWxzL3VybFwiKTtcbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQgZG9tYWluLFxuICogZS5nLiBcImRhYy5obnNcIiA9PiBcImh0dHBzOi8vZGFjLmhucy5zaWFza3kubmV0XCJcbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRvbWFpbiAtIENvbXBvbmVudCBkb21haW4uXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIFVSTCBmb3IgdGhlIGNvbXBvbmVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RnVsbERvbWFpblVybChkb21haW4pIHtcbiAgICBjb25zdCBwb3J0YWxVcmwgPSBhd2FpdCB0aGlzLnBvcnRhbFVybCgpO1xuICAgIHJldHVybiB1cmxfMS5nZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsKHBvcnRhbFVybCwgZG9tYWluKTtcbn1cbmV4cG9ydHMuZ2V0RnVsbERvbWFpblVybCA9IGdldEZ1bGxEb21haW5Vcmw7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBkb21haW4gZnJvbSB0aGUgY3VycmVudCBwb3J0YWwgVVJMLFxuICogZS5nLiAoXCJkYWMuaG5zLnNpYXNreS5uZXRcIikgPT4gXCJkYWMuaG5zXCJcbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGZ1bGxEb21haW4gLSBGdWxsIFVSTC5cbiAqIEByZXR1cm5zIC0gVGhlIGV4dHJhY3RlZCBkb21haW4uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3REb21haW4oZnVsbERvbWFpbikge1xuICAgIGNvbnN0IHBvcnRhbFVybCA9IGF3YWl0IHRoaXMucG9ydGFsVXJsKCk7XG4gICAgcmV0dXJuIHVybF8xLmV4dHJhY3REb21haW5Gb3JQb3J0YWwocG9ydGFsVXJsLCBmdWxsRG9tYWluKTtcbn1cbmV4cG9ydHMuZXh0cmFjdERvbWFpbiA9IGV4dHJhY3REb21haW47XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwb3B1cCB3aW5kb3cuIEZyb20gU2t5SUQuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gb3Blbi5cbiAqIEBwYXJhbSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgcG9wdXAgd2luZG93LlxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHBvcHVwIHdpbmRvdy5cbiAqIEBwYXJhbSBoIC0gdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgd2luZG93LlxuICogQHJldHVybnMgLSBUaGUgd2luZG93LlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9wdXBDZW50ZXIodXJsLCB0aXRsZSwgdywgaCkge1xuICAgIHVybCA9IHNreW5ldF9teXNreV91dGlsc18xLmVuc3VyZVVybCh1cmwpO1xuICAgIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICAgIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gICAgY29uc3QgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiB3aW5kb3cuc2NyZWVuWTtcbiAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICA6IHNjcmVlbi53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgPyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogc2NyZWVuLmhlaWdodDtcbiAgICBjb25zdCBzeXN0ZW1ab29tID0gd2lkdGggLyB3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGg7XG4gICAgY29uc3QgbGVmdCA9ICh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdDtcbiAgICBjb25zdCB0b3AgPSAoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3A7XG4gICAgY29uc3QgbmV3V2luZG93ID0gd2luZG93Lm9wZW4odXJsLCB0aXRsZSwgYFxuc2Nyb2xsYmFycz15ZXMsXG53aWR0aD0ke3cgLyBzeXN0ZW1ab29tfSxcbmhlaWdodD0ke2ggLyBzeXN0ZW1ab29tfSxcbnRvcD0ke3RvcH0sXG5sZWZ0PSR7bGVmdH1cbmApO1xuICAgIGlmICghbmV3V2luZG93KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBvcGVuIHdpbmRvd1wiKTtcbiAgICB9XG4gICAgaWYgKG5ld1dpbmRvdy5mb2N1cykge1xuICAgICAgICBuZXdXaW5kb3cuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1dpbmRvdztcbn1cbmV4cG9ydHMucG9wdXBDZW50ZXIgPSBwb3B1cENlbnRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVJlZ2lzdHJ5RW50cnkgPSBleHBvcnRzLnBvc3RTaWduZWRFbnRyeSA9IGV4cG9ydHMuc2lnbkVudHJ5ID0gZXhwb3J0cy5zZXRFbnRyeSA9IGV4cG9ydHMuZ2V0RW50cnlMaW5rID0gZXhwb3J0cy5nZXRFbnRyeVVybEZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0RW50cnlVcmwgPSBleHBvcnRzLmdldEVudHJ5ID0gZXhwb3J0cy5yZWdleFJldmlzaW9uTm9RdW90ZXMgPSBleHBvcnRzLkRFRkFVTFRfR0VUX0VOVFJZX1RJTUVPVVQgPSBleHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCB0d2VldG5hY2xfMSA9IHJlcXVpcmUoXCJ0d2VldG5hY2xcIik7XG5jb25zdCBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9jcnlwdG9cIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0aW9uXCIpO1xuY29uc3Qgc2lhXzEgPSByZXF1aXJlKFwiLi9za3lsaW5rL3NpYVwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vc2t5bGluay9mb3JtYXRcIik7XG5leHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICBlbmRwb2ludEdldEVudHJ5OiBcIi9za3luZXQvcmVnaXN0cnlcIixcbiAgICBoYXNoZWREYXRhS2V5SGV4OiBmYWxzZSxcbn07XG5leHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc18xLmRlZmF1bHRCYXNlT3B0aW9ucyxcbiAgICBlbmRwb2ludFNldEVudHJ5OiBcIi9za3luZXQvcmVnaXN0cnlcIixcbiAgICBoYXNoZWREYXRhS2V5SGV4OiBmYWxzZSxcbn07XG5leHBvcnRzLkRFRkFVTFRfR0VUX0VOVFJZX1RJTUVPVVQgPSA1OyAvLyA1IHNlY29uZHNcbi8qKlxuICogUmVnZXggZm9yIEpTT04gcmV2aXNpb24gdmFsdWUgd2l0aG91dCBxdW90ZXMuXG4gKi9cbmV4cG9ydHMucmVnZXhSZXZpc2lvbk5vUXVvdGVzID0gL1wicmV2aXNpb25cIjpcXHMqKFswLTldKykvO1xuLyoqXG4gKiBSZWdleCBmb3IgSlNPTiByZXZpc2lvbiB2YWx1ZSB3aXRoIHF1b3Rlcy5cbiAqL1xuY29uc3QgcmVnZXhSZXZpc2lvbldpdGhRdW90ZXMgPSAvXCJyZXZpc2lvblwiOlxccypcIihbMC05XSspXCIvO1xuLyoqXG4gKiBHZXRzIHRoZSByZWdpc3RyeSBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwdWJsaWNLZXkgYW5kIGRhdGFLZXkuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgdXNlciBwdWJsaWMga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUga2V5IG9mIHRoZSBkYXRhIHRvIGZldGNoIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgc2lnbmVkIHJlZ2lzdHJ5IGVudHJ5LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJldHVybmVkIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCB0aGUgcmV0dXJuZWQgZW50cnkgb3IgdGhlIHByb3ZpZGVkIHRpbWVvdXQgaXMgaW52YWxpZCBvciB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCB2YWxpZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnkocHVibGljS2V5LCBkYXRhS2V5LCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRFbnRyeVVybGAuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmdldEVudHJ5VXJsKHB1YmxpY0tleSwgZGF0YUtleSwgb3B0cyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgZW5kcG9pbnRQYXRoOiBvcHRzLmVuZHBvaW50R2V0RW50cnksXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3BvbnNlIHRvIGFkZCBxdW90ZXMsIHNpbmNlIHVpbnQ2NCBjYW5ub3QgYmUgYWNjdXJhdGVseVxuICAgICAgICAgICAgLy8gcmVhZCBieSBKUyBzbyB0aGUgcmV2aXNpb24gbmVlZHMgdG8gYmUgcGFyc2VkIGFzIGEgc3RyaW5nLlxuICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcmV2aXNpb24gdmFsdWUgZnJvbSBhIEpTT04gaW50ZWdlciB0byBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKGV4cG9ydHMucmVnZXhSZXZpc2lvbk5vUXVvdGVzLCAnXCJyZXZpc2lvblwiOlwiJDFcIicpO1xuICAgICAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aW5nIHRoZSBKU09OIGRhdGEgdG8gYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIG5vdCBKU09OLCBpdCdzIGxpa2VseSBhbiBIVE1MIGVycm9yIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gaGFuZGxlR2V0RW50cnlFcnJSZXNwb25zZShlcnIpO1xuICAgIH1cbiAgICAvLyBTYW5pdHkgY2hlY2suXG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicmVzcG9uc2UuZGF0YS5kYXRhXCIsIHJlc3BvbnNlLmRhdGEuZGF0YSwgXCJlbnRyeSByZXNwb25zZSBmaWVsZFwiKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicmVzcG9uc2UuZGF0YS5yZXZpc2lvblwiLCByZXNwb25zZS5kYXRhLnJldmlzaW9uLCBcImVudHJ5IHJlc3BvbnNlIGZpZWxkXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJyZXNwb25zZS5kYXRhLnNpZ25hdHVyZVwiLCByZXNwb25zZS5kYXRhLnNpZ25hdHVyZSwgXCJlbnRyeSByZXNwb25zZSBmaWVsZFwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCBub3QgZ2V0IGEgY29tcGxldGUgZW50cnkgcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuIEVycm9yOiAke2Vycn1gKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgcmV2aXNpb24gZnJvbSBhIHN0cmluZyB0byBiaWdpbnQuXG4gICAgY29uc3QgcmV2aXNpb24gPSBCaWdJbnQocmVzcG9uc2UuZGF0YS5yZXZpc2lvbik7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHJlc3BvbnNlLmRhdGEuc2lnbmF0dXJlKSk7XG4gICAgLy8gVXNlIGVtcHR5IGFycmF5IGlmIHRoZSBkYXRhIGlzIGVtcHR5LlxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIGlmIChyZXNwb25zZS5kYXRhLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShyZXNwb25zZS5kYXRhLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRFbnRyeSA9IHtcbiAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgIGRhdGFLZXksXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xuICAgIC8vIFRyeSB2ZXJpZnlpbmcgdGhlIHJldHVybmVkIGRhdGEuXG4gICAgaWYgKHR3ZWV0bmFjbF8xLnNpZ24uZGV0YWNoZWQudmVyaWZ5KGNyeXB0b18xLmhhc2hSZWdpc3RyeUVudHJ5KHNpZ25lZEVudHJ5LmVudHJ5LCBvcHRzLmhhc2hlZERhdGFLZXlIZXgpLCBuZXcgVWludDhBcnJheShzaWduZWRFbnRyeS5zaWduYXR1cmUpLCBzdHJpbmdfMS5oZXhUb1VpbnQ4QXJyYXkocHVibGljS2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEVudHJ5O1xuICAgIH1cbiAgICAvLyBUaGUgcmVzcG9uc2UgY291bGQgbm90IGJlIHZlcmlmaWVkLlxuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCB2ZXJpZnkgc2lnbmF0dXJlIGZyb20gcmV0cmlldmVkLCBzaWduZWQgcmVnaXN0cnkgZW50cnkgLS0gcG9zc2libGUgY29ycnVwdGVkIGVudHJ5XCIpO1xufVxuZXhwb3J0cy5nZXRFbnRyeSA9IGdldEVudHJ5O1xuLyoqXG4gKiBHZXRzIHRoZSByZWdpc3RyeSBlbnRyeSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcHVibGljS2V5IGFuZCBkYXRhS2V5LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHVzZXIgcHVibGljIGtleS5cbiAqIEBwYXJhbSBkYXRhS2V5IC0gVGhlIGtleSBvZiB0aGUgZGF0YSB0byBmZXRjaCBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgZ2V0IGVudHJ5IFVSTC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBwcm92aWRlZCB0aW1lb3V0IGlzIGludmFsaWQgb3IgdGhlIGdpdmVuIGtleSBpcyBub3QgdmFsaWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEVudHJ5VXJsKHB1YmxpY0tleSwgZGF0YUtleSwgY3VzdG9tT3B0aW9ucykge1xuICAgIC8vIFZhbGlkYXRpb24gaXMgZG9uZSBpbiBgZ2V0RW50cnlVcmxGb3JQb3J0YWxgLlxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgcG9ydGFsVXJsID0gYXdhaXQgdGhpcy5wb3J0YWxVcmwoKTtcbiAgICByZXR1cm4gZ2V0RW50cnlVcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBwdWJsaWNLZXksIGRhdGFLZXksIG9wdHMpO1xufVxuZXhwb3J0cy5nZXRFbnRyeVVybCA9IGdldEVudHJ5VXJsO1xuLyoqXG4gKiBHZXRzIHRoZSByZWdpc3RyeSBlbnRyeSBVUkwgd2l0aG91dCBhbiBpbml0aWFsaXplZCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHBvcnRhbFVybCAtIFRoZSBwb3J0YWwgVVJMLlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSB1c2VyIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gZGF0YUtleSAtIFRoZSBrZXkgb2YgdGhlIGRhdGEgdG8gZmV0Y2ggZm9yIHRoZSBnaXZlbiB1c2VyLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSBmdWxsIGdldCBlbnRyeSBVUkwuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW50cnlVcmxGb3JQb3J0YWwocG9ydGFsVXJsLCBwdWJsaWNLZXksIGRhdGFLZXksIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwb3J0YWxVcmxcIiwgcG9ydGFsVXJsLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwdWJsaWNLZXlcIiwgcHVibGljS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJkYXRhS2V5XCIsIGRhdGFLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRHZXRFbnRyeU9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIFRyaW0gdGhlIHByZWZpeCBpZiBpdCB3YXMgcGFzc2VkIGluLlxuICAgIHB1YmxpY0tleSA9IHN0cmluZ18xLnRyaW1QcmVmaXgocHVibGljS2V5LCBcImVkMjU1MTk6XCIpO1xuICAgIHZhbGlkYXRlVHJpbW1lZFB1YmxpY0tleShcInB1YmxpY0tleVwiLCBwdWJsaWNLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIC8vIEhhc2ggYW5kIGhleCBlbmNvZGUgdGhlIGdpdmVuIGRhdGEga2V5IGlmIGl0IGlzIG5vdCBhIGhhc2ggYWxyZWFkeS5cbiAgICBsZXQgZGF0YUtleUhhc2hIZXggPSBkYXRhS2V5O1xuICAgIGlmICghb3B0cy5oYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgICAgIGRhdGFLZXlIYXNoSGV4ID0gc3RyaW5nXzEudG9IZXhTdHJpbmcoY3J5cHRvXzEuaGFzaERhdGFLZXkoZGF0YUtleSkpO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgICAgcHVibGlja2V5OiBgZWQyNTUxOToke3B1YmxpY0tleX1gLFxuICAgICAgICBkYXRha2V5OiBkYXRhS2V5SGFzaEhleCxcbiAgICAgICAgdGltZW91dDogZXhwb3J0cy5ERUZBVUxUX0dFVF9FTlRSWV9USU1FT1VULFxuICAgIH07XG4gICAgbGV0IHVybCA9IHVybF8xLm1ha2VVcmwocG9ydGFsVXJsLCBvcHRzLmVuZHBvaW50R2V0RW50cnkpO1xuICAgIHVybCA9IHVybF8xLmFkZFVybFF1ZXJ5KHVybCwgcXVlcnkpO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLmdldEVudHJ5VXJsRm9yUG9ydGFsID0gZ2V0RW50cnlVcmxGb3JQb3J0YWw7XG4vKipcbiAqIEdldHMgdGhlIGVudHJ5IGxpbmsgZm9yIHRoZSBlbnRyeSBhdCB0aGUgZ2l2ZW4gcHVibGljIGtleSBhbmQgZGF0YSBrZXkuIFRoaXMgbGluayBzdGF5cyB0aGUgc2FtZSBldmVuIGlmIHRoZSBjb250ZW50IGF0IHRoZSBlbnRyeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHVzZXIgcHVibGljIGtleS5cbiAqIEBwYXJhbSBkYXRhS2V5IC0gVGhlIGtleSBvZiB0aGUgZGF0YSB0byBmZXRjaCBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gVGhlIGVudHJ5IGxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCB2YWxpZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnlMaW5rKHB1YmxpY0tleSwgZGF0YUtleSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInB1YmxpY0tleVwiLCBwdWJsaWNLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRhdGFLZXlcIiwgZGF0YUtleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGV4cG9ydHMuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgLy8gVHJpbSB0aGUgcHJlZml4IGlmIGl0IHdhcyBwYXNzZWQgaW4uXG4gICAgcHVibGljS2V5ID0gc3RyaW5nXzEudHJpbVByZWZpeChwdWJsaWNLZXksIFwiZWQyNTUxOTpcIik7XG4gICAgdmFsaWRhdGVUcmltbWVkUHVibGljS2V5KFwicHVibGljS2V5XCIsIHB1YmxpY0tleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgY29uc3Qgc2lhUHVibGljS2V5ID0gc2lhXzEubmV3RWQyNTUxOVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIGxldCB0d2VhaztcbiAgICBpZiAob3B0cy5oYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgICAgIHR3ZWFrID0gc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KGRhdGFLZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHdlYWsgPSBjcnlwdG9fMS5oYXNoRGF0YUtleShkYXRhS2V5KTtcbiAgICB9XG4gICAgY29uc3Qgc2t5bGluayA9IHNpYV8xLm5ld1NreWxpbmtWMihzaWFQdWJsaWNLZXksIHR3ZWFrKS50b1N0cmluZygpO1xuICAgIHJldHVybiBmb3JtYXRfMS5mb3JtYXRTa3lsaW5rKHNreWxpbmspO1xufVxuZXhwb3J0cy5nZXRFbnRyeUxpbmsgPSBnZXRFbnRyeUxpbms7XG4vKipcbiAqIFNldHMgdGhlIHJlZ2lzdHJ5IGVudHJ5LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSB1c2VyIHByaXZhdGUga2V5LlxuICogQHBhcmFtIGVudHJ5IC0gVGhlIGVudHJ5IHRvIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBBbiBlbXB0eSBwcm9taXNlLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGVudHJ5IHJldmlzaW9uIGRvZXMgbm90IGZpdCBpbiA2NCBiaXRzIG9yIHRoZSBnaXZlbiBrZXkgaXMgbm90IHZhbGlkLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRFbnRyeShwcml2YXRlS2V5LCBlbnRyeSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUhleFN0cmluZyhcInByaXZhdGVLZXlcIiwgcHJpdmF0ZUtleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGVSZWdpc3RyeUVudHJ5KFwiZW50cnlcIiwgZW50cnksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMpO1xuICAgIC8vIEFzc2VydCB0aGUgaW5wdXQgaXMgNjQgYml0cy5cbiAgICBudW1iZXJfMS5hc3NlcnRVaW50NjQoZW50cnkucmV2aXNpb24pO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgcHJpdmF0ZUtleUFycmF5ID0gc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25FbnRyeShwcml2YXRlS2V5LCBlbnRyeSwgb3B0cy5oYXNoZWREYXRhS2V5SGV4KTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogcHVibGljS2V5QXJyYXkgfSA9IHR3ZWV0bmFjbF8xLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlBcnJheSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVnaXN0cnkucG9zdFNpZ25lZEVudHJ5KHN0cmluZ18xLnRvSGV4U3RyaW5nKHB1YmxpY0tleUFycmF5KSwgZW50cnksIHNpZ25hdHVyZSwgb3B0cyk7XG59XG5leHBvcnRzLnNldEVudHJ5ID0gc2V0RW50cnk7XG4vKipcbiAqIFNpZ25zIHRoZSBlbnRyeSB3aXRoIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSB1c2VyIHByaXZhdGUga2V5LlxuICogQHBhcmFtIGVudHJ5IC0gVGhlIGVudHJ5IHRvIHNpZ24uXG4gKiBAcGFyYW0gaGFzaGVkRGF0YUtleUhleCAtIFdoZXRoZXIgdGhlIGRhdGEga2V5IGlzIGFscmVhZHkgaGFzaGVkIGFuZCBpbiBoZXggZm9ybWF0LiBJZiBub3QsIHdlIGhhc2ggdGhlIGRhdGEga2V5LlxuICogQHJldHVybnMgLSBUaGUgc2lnbmF0dXJlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduRW50cnkocHJpdmF0ZUtleSwgZW50cnksIGhhc2hlZERhdGFLZXlIZXgpIHtcbiAgICAvLyBUT0RPOiBQdWJsaWNseSBhdmFpbGFibGUsIHZhbGlkYXRlIGlucHV0LlxuICAgIGNvbnN0IHByaXZhdGVLZXlBcnJheSA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShwcml2YXRlS2V5KTtcbiAgICAvLyBTaWduIHRoZSBlbnRyeS5cbiAgICAvLyBUT0RPOiBzaWduYXR1cmUgdHlwZSBzaG91bGQgYmUgU2lnbmF0dXJlP1xuICAgIHJldHVybiB0d2VldG5hY2xfMS5zaWduKGNyeXB0b18xLmhhc2hSZWdpc3RyeUVudHJ5KGVudHJ5LCBoYXNoZWREYXRhS2V5SGV4KSwgcHJpdmF0ZUtleUFycmF5KTtcbn1cbmV4cG9ydHMuc2lnbkVudHJ5ID0gc2lnbkVudHJ5O1xuLyoqXG4gKiBQb3N0cyB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gcHVibGljIGtleSBhbmQgc2lnbmF0dXJlIHRvIFNreW5ldC5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFRoZSBTa3luZXQgY2xpZW50LlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSB1c2VyIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gZW50cnkgLSBUaGUgZW50cnkgdG8gc2V0LlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gQW4gZW1wdHkgcHJvbWlzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcG9zdFNpZ25lZEVudHJ5KHB1YmxpY0tleSwgZW50cnksIHNpZ25hdHVyZSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUhleFN0cmluZyhcInB1YmxpY0tleVwiLCBwdWJsaWNLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIGVudHJ5IGFuZCBzaWduYXR1cmVcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJlbnRyeS5kYXRhS2V5XCIsIGVudHJ5LmRhdGFLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgLy8gSGFzaCBhbmQgaGV4IGVuY29kZSB0aGUgZ2l2ZW4gZGF0YSBrZXkgaWYgaXQgaXMgbm90IGEgaGFzaCBhbHJlYWR5LlxuICAgIGxldCBkYXRha2V5ID0gZW50cnkuZGF0YUtleTtcbiAgICBpZiAoIW9wdHMuaGFzaGVkRGF0YUtleUhleCkge1xuICAgICAgICBkYXRha2V5ID0gc3RyaW5nXzEudG9IZXhTdHJpbmcoY3J5cHRvXzEuaGFzaERhdGFLZXkoZGF0YWtleSkpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBlbnRyeSBkYXRhIHRvIGFuIGFycmF5IGZyb20gcmF3IGJ5dGVzLlxuICAgIGNvbnN0IGVudHJ5RGF0YSA9IEFycmF5LmZyb20oZW50cnkuZGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgcHVibGlja2V5OiB7XG4gICAgICAgICAgICBhbGdvcml0aG06IFwiZWQyNTUxOVwiLFxuICAgICAgICAgICAga2V5OiBBcnJheS5mcm9tKHN0cmluZ18xLmhleFRvVWludDhBcnJheShwdWJsaWNLZXkpKSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YWtleSxcbiAgICAgICAgLy8gU2V0IHRoZSByZXZpc2lvbiBhcyBhIHN0cmluZyBoZXJlLiBUaGUgdmFsdWUgbWF5IGJlIHVwIHRvIDY0IGJpdHMgYW5kIHRoZSBsaW1pdCBmb3IgYSBKUyBudW1iZXIgaXMgNTMgYml0cy5cbiAgICAgICAgLy8gV2UgcmVtb3ZlIHRoZSBxdW90ZXMgbGF0ZXIgaW4gdHJhbnNmb3JtUmVxdWVzdCwgYXMgSlNPTiBkb2VzIHN1cHBvcnQgNjQgYml0IG51bWJlcnMuXG4gICAgICAgIHJldmlzaW9uOiBlbnRyeS5yZXZpc2lvbi50b1N0cmluZygpLFxuICAgICAgICBkYXRhOiBlbnRyeURhdGEsXG4gICAgICAgIHNpZ25hdHVyZTogQXJyYXkuZnJvbShzaWduYXR1cmUpLFxuICAgIH07XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGVuZHBvaW50UGF0aDogb3B0cy5lbmRwb2ludFNldEVudHJ5LFxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlcXVlc3QgdG8gcmVtb3ZlIHF1b3Rlcywgc2luY2UgdGhlIHJldmlzaW9uIG5lZWRzIHRvIGJlXG4gICAgICAgIC8vIHBhcnNlZCBhcyBhIHVpbnQ2NCBvbiB0aGUgR28gc2lkZS5cbiAgICAgICAgdHJhbnNmb3JtUmVxdWVzdDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBkYXRhIHRvIEpTT04uXG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIHJldmlzaW9uIHZhbHVlIGZyb20gYSBzdHJpbmcgdG8gYSBKU09OIGludGVnZXIuXG4gICAgICAgICAgICByZXR1cm4ganNvbi5yZXBsYWNlKHJlZ2V4UmV2aXNpb25XaXRoUXVvdGVzLCAnXCJyZXZpc2lvblwiOiQxJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnBvc3RTaWduZWRFbnRyeSA9IHBvc3RTaWduZWRFbnRyeTtcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBnaXZlbiByZWdpc3RyeSBlbnRyeS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWVLaW5kIC0gVGhlIGtpbmQgb2YgdmFsdWUgdGhhdCBpcyBiZWluZyBjaGVja2VkIChlLmcuIFwicGFyYW1ldGVyXCIsIFwicmVzcG9uc2UgZmllbGRcIiwgZXRjLilcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZWdpc3RyeUVudHJ5KG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPYmplY3QobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKGAke25hbWV9LmRhdGFLZXlgLCB2YWx1ZS5kYXRhS2V5LCBgJHt2YWx1ZUtpbmR9IGZpZWxkYCk7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlVWludDhBcnJheShgJHtuYW1lfS5kYXRhYCwgdmFsdWUuZGF0YSwgYCR7dmFsdWVLaW5kfSBmaWVsZGApO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUJpZ2ludChgJHtuYW1lfS5yZXZpc2lvbmAsIHZhbHVlLnJldmlzaW9uLCBgJHt2YWx1ZUtpbmR9IGZpZWxkYCk7XG59XG5leHBvcnRzLnZhbGlkYXRlUmVnaXN0cnlFbnRyeSA9IHZhbGlkYXRlUmVnaXN0cnlFbnRyeTtcbi8qKlxuICogSGFuZGxlcyBlcnJvciByZXNwb25zZXMgcmV0dXJuZWQgaW4gZ2V0RW50cnkuXG4gKlxuICogQHBhcmFtIGVyciAtIFRoZSBBeGlvcyBlcnJvci5cbiAqIEByZXR1cm5zIC0gQW4gZW1wdHkgc2lnbmVkIHJlZ2lzdHJ5IGVudHJ5IGlmIHRoZSBzdGF0dXMgY29kZSBpcyA0MDQuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgbm90IDQwNC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlR2V0RW50cnlFcnJSZXNwb25zZShlcnIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghZXJyLnJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVzcG9uc2UgZmllbGQgbm90IGZvdW5kLCBpbmNvbXBsZXRlIEF4aW9zIGVycm9yLiBGdWxsIGVycm9yOiAke2Vycn1gKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIWVyci5yZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciByZXNwb25zZSBkaWQgbm90IGNvbnRhaW4gZXhwZWN0ZWQgZmllbGQgJ3N0YXR1cycuIEZ1bGwgZXJyb3I6ICR7ZXJyfWApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBzdGF0dXMgd2FzIDQwNCBcIm5vdCBmb3VuZFwiIGFuZCByZXR1cm4gbnVsbCBpZiBzby5cbiAgICBpZiAoZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiB7IGVudHJ5OiBudWxsLCBzaWduYXR1cmU6IG51bGwgfTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgaGV4LWVuY29kZWQgcHVibGljIGtleS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgaGV4LWVuY29kZWQgcHVibGljIGtleS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUcmltbWVkUHVibGljS2V5KG5hbWUsIHB1YmxpY0tleSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKCFzdHJpbmdfMS5pc0hleFN0cmluZyhwdWJsaWNLZXkpKSB7XG4gICAgICAgIHZhbGlkYXRpb25fMS50aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCBwdWJsaWNLZXksIHZhbHVlS2luZCwgXCJhIGhleC1lbmNvZGVkIHN0cmluZyB3aXRoIGEgdmFsaWQgcHJlZml4XCIpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROZXh0UmV2aXNpb25Gcm9tRW50cnkgPSBleHBvcnRzLmdldE9yQ3JlYXRlUmVnaXN0cnlFbnRyeSA9IGV4cG9ydHMuZ2V0TmV4dFJlZ2lzdHJ5RW50cnkgPSBleHBvcnRzLnNldERhdGFMaW5rID0gZXhwb3J0cy5kZWxldGVKU09OID0gZXhwb3J0cy5zZXRKU09OID0gZXhwb3J0cy5nZXRKU09OID0gZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRHZXRKU09OT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IHR3ZWV0bmFjbF8xID0gcmVxdWlyZShcInR3ZWV0bmFjbFwiKTtcbmNvbnN0IGRvd25sb2FkXzEgPSByZXF1aXJlKFwiLi9kb3dubG9hZFwiKTtcbmNvbnN0IHJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yZWdpc3RyeVwiKTtcbmNvbnN0IHNpYV8xID0gcmVxdWlyZShcIi4vc2t5bGluay9zaWFcIik7XG5jb25zdCBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL251bWJlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdXJsXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL3NreWxpbmsvZm9ybWF0XCIpO1xuY29uc3QgcGFyc2VfMSA9IHJlcXVpcmUoXCIuL3NreWxpbmsvcGFyc2VcIik7XG5jb25zdCB1cGxvYWRfMSA9IHJlcXVpcmUoXCIuL3VwbG9hZFwiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9lbmNvZGluZ1wiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnNcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FycmF5XCIpO1xuY29uc3QgSlNPTl9SRVNQT05TRV9WRVJTSU9OID0gMjtcbmV4cG9ydHMuZGVmYXVsdEdldEpTT05PcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnNfMS5kZWZhdWx0QmFzZU9wdGlvbnMsXG4gICAgLi4ucmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgIC4uLmRvd25sb2FkXzEuZGVmYXVsdERvd25sb2FkT3B0aW9ucyxcbiAgICBjYWNoZWREYXRhTGluazogdW5kZWZpbmVkLFxufTtcbmV4cG9ydHMuZGVmYXVsdFNldEpTT05PcHRpb25zID0ge1xuICAgIC4uLm9wdGlvbnNfMS5kZWZhdWx0QmFzZU9wdGlvbnMsXG4gICAgLi4uZXhwb3J0cy5kZWZhdWx0R2V0SlNPTk9wdGlvbnMsXG4gICAgLi4ucmVnaXN0cnlfMS5kZWZhdWx0U2V0RW50cnlPcHRpb25zLFxuICAgIC4uLnVwbG9hZF8xLmRlZmF1bHRVcGxvYWRPcHRpb25zLFxufTtcbi8qKlxuICogR2V0cyB0aGUgSlNPTiBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgcHVibGljS2V5IGFuZCBkYXRhS2V5LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHVzZXIgcHVibGljIGtleS5cbiAqIEBwYXJhbSBkYXRhS2V5IC0gVGhlIGtleSBvZiB0aGUgZGF0YSB0byBmZXRjaCBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEByZXR1cm5zIC0gVGhlIHJldHVybmVkIEpTT04gYW5kIHJldmlzaW9uIG51bWJlci5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSByZXR1cm5lZCBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggdGhlIHJldHVybmVkIGVudHJ5LCBvciBpZiB0aGUgc2t5bGluayBpbiB0aGUgZW50cnkgaXMgaW52YWxpZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SlNPTihwdWJsaWNLZXksIGRhdGFLZXksIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0R2V0SlNPTk9wdGlvbnMpO1xuICAgIC8vIFJlc3Qgb2YgdmFsaWRhdGlvbiBpcyBkb25lIGluIGBnZXRFbnRyeWAuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0R2V0SlNPTk9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIExvb2t1cCB0aGUgcmVnaXN0cnkgZW50cnkuXG4gICAgY29uc3QgZ2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgY29uc3QgeyBlbnRyeSB9ID0gYXdhaXQgdGhpcy5yZWdpc3RyeS5nZXRFbnRyeShwdWJsaWNLZXksIGRhdGFLZXksIGdldEVudHJ5T3B0cyk7XG4gICAgaWYgKGVudHJ5ID09PSBudWxsIHx8IGFycmF5XzEuYXJlRXF1YWxVaW50OEFycmF5cyhlbnRyeS5kYXRhLCBzaWFfMS5FTVBUWV9TS1lMSU5LKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBkYXRhTGluazogbnVsbCB9O1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRhdGEgbGluay5cbiAgICAvLyBUT0RPOiBDYW4gdGhpcyBzdGlsbCBiZSBhbiBlbnRyeSBsaW5rIHdoaWNoIGhhc24ndCB5ZXQgcmVzb2x2ZWQgdG8gYSBkYXRhIGxpbms/XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHJldHVybmVkIGVudHJ5IGRhdGEgdG8gYmUgYnl0ZXNcIik7XG4gICAgfVxuICAgIGxldCByYXdEYXRhTGluaztcbiAgICBpZiAoZW50cnkuZGF0YS5sZW5ndGggPT09IDQ2KSB7XG4gICAgICAgIC8vIExlZ2FjeSBkYXRhLCBjb252ZXJ0IHRvIHN0cmluZy5cbiAgICAgICAgcmF3RGF0YUxpbmsgPSBzdHJpbmdfMS51aW50OEFycmF5VG9TdHJpbmdVdGY4KGVudHJ5LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbnRyeS5kYXRhLmxlbmd0aCA9PT0gc2lhXzEuUkFXX1NLWUxJTktfU0laRSkge1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBieXRlcyB0byBhIGJhc2U2NCBza3lsaW5rLlxuICAgICAgICByYXdEYXRhTGluayA9IGVuY29kaW5nXzEuZW5jb2RlU2t5bGlua0Jhc2U2NChlbnRyeS5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZXMgZW50cnkuZGF0YSByZXNwb25zZSB3YXMgbm90ICR7c2lhXzEuUkFXX1NLWUxJTktfU0laRX0gYnl0ZXM6ICR7ZW50cnkuZGF0YX1cImApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhTGluayA9IGZvcm1hdF8xLmZvcm1hdFNreWxpbmsocmF3RGF0YUxpbmspO1xuICAgIC8vIElmIGEgY2FjaGVkIGRhdGEgbGluayBpcyBwcm92aWRlZCBhbmQgdGhlIGRhdGEgbGluayBoYXNuJ3QgY2hhbmdlZCwgcmV0dXJuLlxuICAgIGlmIChvcHRzLmNhY2hlZERhdGFMaW5rICYmIHJhd0RhdGFMaW5rID09PSBwYXJzZV8xLnBhcnNlU2t5bGluayhvcHRzLmNhY2hlZERhdGFMaW5rKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBkYXRhTGluayB9O1xuICAgIH1cbiAgICAvLyBEb3dubG9hZCB0aGUgZGF0YSBpbiB0aGUgcmV0dXJuZWQgZGF0YSBsaW5rLlxuICAgIGNvbnN0IGRvd25sb2FkT3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCBkb3dubG9hZF8xLmRlZmF1bHREb3dubG9hZE9wdGlvbnMpO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5nZXRGaWxlQ29udGVudChkYXRhTGluaywgZG93bmxvYWRPcHRzKTtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgZGF0YSBmb3IgdGhlIGVudHJ5IGF0IGRhdGEga2V5ICcke2RhdGFLZXl9JyBpcyBub3QgSlNPTi5gKTtcbiAgICB9XG4gICAgaWYgKCEoZGF0YVtcIl9kYXRhXCJdICYmIGRhdGFbXCJfdlwiXSkpIHtcbiAgICAgICAgLy8gTGVnYWN5IGRhdGEgcHJpb3IgdG8gdjQsIHJldHVybiBhcy1pcy5cbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgZGF0YUxpbmsgfTtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsRGF0YSA9IGRhdGFbXCJfZGF0YVwiXTtcbiAgICBpZiAodHlwZW9mIGFjdHVhbERhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgZGF0YSAnX2RhdGEnIGZvciB0aGUgZW50cnkgYXQgZGF0YSBrZXkgJyR7ZGF0YUtleX0nIGlzIG5vdCBKU09OLmApO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBhY3R1YWxEYXRhLCBkYXRhTGluayB9O1xufVxuZXhwb3J0cy5nZXRKU09OID0gZ2V0SlNPTjtcbi8qKlxuICogU2V0cyBhIEpTT04gb2JqZWN0IGF0IHRoZSByZWdpc3RyeSBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwdWJsaWNLZXkgYW5kIGRhdGFLZXkuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gVGhlIHVzZXIgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gZGF0YUtleSAtIFRoZSBrZXkgb2YgdGhlIGRhdGEgdG8gZmV0Y2ggZm9yIHRoZSBnaXZlbiB1c2VyLlxuICogQHBhcmFtIGpzb24gLSBUaGUgSlNPTiBkYXRhIHRvIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgcmV0dXJuZWQgSlNPTiBhbmQgcmV2aXNpb24gbnVtYmVyLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGtleXMgYXJlIG5vdCB2YWxpZCBzdHJpbmdzLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRKU09OKHByaXZhdGVLZXksIGRhdGFLZXksIGpzb24sIGN1c3RvbU9wdGlvbnMpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJwcml2YXRlS2V5XCIsIHByaXZhdGVLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRhdGFLZXlcIiwgZGF0YUtleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT2JqZWN0KFwianNvblwiLCBqc29uLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdFNldEpTT05PcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogcHVibGljS2V5QXJyYXkgfSA9IHR3ZWV0bmFjbF8xLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5KHN0cmluZ18xLmhleFRvVWludDhBcnJheShwcml2YXRlS2V5KSk7XG4gICAgY29uc3QgW2VudHJ5LCBkYXRhTGlua10gPSBhd2FpdCBnZXRPckNyZWF0ZVJlZ2lzdHJ5RW50cnkodGhpcywgc3RyaW5nXzEudG9IZXhTdHJpbmcocHVibGljS2V5QXJyYXkpLCBkYXRhS2V5LCBqc29uLCBvcHRzKTtcbiAgICAvLyBVcGRhdGUgdGhlIHJlZ2lzdHJ5LlxuICAgIGNvbnN0IHNldEVudHJ5T3B0cyA9IG9wdGlvbnNfMS5leHRyYWN0T3B0aW9ucyhvcHRzLCByZWdpc3RyeV8xLmRlZmF1bHRTZXRFbnRyeU9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMucmVnaXN0cnkuc2V0RW50cnkocHJpdmF0ZUtleSwgZW50cnksIHNldEVudHJ5T3B0cyk7XG4gICAgcmV0dXJuIHsgZGF0YToganNvbiwgZGF0YUxpbms6IGZvcm1hdF8xLmZvcm1hdFNreWxpbmsoZGF0YUxpbmspIH07XG59XG5leHBvcnRzLnNldEpTT04gPSBzZXRKU09OO1xuLyoqXG4gKiBEZWxldGVzIGEgSlNPTiBvYmplY3QgYXQgdGhlIHJlZ2lzdHJ5IGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpY0tleSBhbmQgZGF0YUtleS5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgdXNlciBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBkYXRhS2V5IC0gVGhlIGtleSBvZiB0aGUgZGF0YSB0byBmZXRjaCBmb3IgdGhlIGdpdmVuIHVzZXIuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBrZXlzIGFyZSBub3QgdmFsaWQgc3RyaW5ncy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlSlNPTihwcml2YXRlS2V5LCBkYXRhS2V5LCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlSGV4U3RyaW5nKFwicHJpdmF0ZUtleVwiLCBwcml2YXRlS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJkYXRhS2V5XCIsIGRhdGFLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9wdGlvbmFsT2JqZWN0KFwiY3VzdG9tT3B0aW9uc1wiLCBjdXN0b21PcHRpb25zLCBcInBhcmFtZXRlclwiLCBleHBvcnRzLmRlZmF1bHRTZXRKU09OT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMsXG4gICAgICAgIC4uLnRoaXMuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlBcnJheSB9ID0gdHdlZXRuYWNsXzEuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkoc3RyaW5nXzEuaGV4VG9VaW50OEFycmF5KHByaXZhdGVLZXkpKTtcbiAgICBjb25zdCBnZXRFbnRyeU9wdHMgPSBvcHRpb25zXzEuZXh0cmFjdE9wdGlvbnMob3B0cywgcmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zKTtcbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGdldE5leHRSZWdpc3RyeUVudHJ5KHRoaXMsIHN0cmluZ18xLnRvSGV4U3RyaW5nKHB1YmxpY0tleUFycmF5KSwgZGF0YUtleSwgbmV3IFVpbnQ4QXJyYXkoc2lhXzEuUkFXX1NLWUxJTktfU0laRSksIGdldEVudHJ5T3B0cyk7XG4gICAgLy8gVXBkYXRlIHRoZSByZWdpc3RyeS5cbiAgICBjb25zdCBzZXRFbnRyeU9wdHMgPSBvcHRpb25zXzEuZXh0cmFjdE9wdGlvbnMob3B0cywgcmVnaXN0cnlfMS5kZWZhdWx0U2V0RW50cnlPcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnJlZ2lzdHJ5LnNldEVudHJ5KHByaXZhdGVLZXksIGVudHJ5LCBzZXRFbnRyeU9wdHMpO1xufVxuZXhwb3J0cy5kZWxldGVKU09OID0gZGVsZXRlSlNPTjtcbi8qKlxuICogU2V0cyB0aGUgZGF0YWxpbmsgZm9yIHRoZSBlbnRyeSBhdCB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkgYW5kIGRhdGEga2V5LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSB1c2VyIHByaXZhdGUga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUga2V5IG9mIHRoZSBkYXRhIHRvIGZldGNoIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAqIEBwYXJhbSBkYXRhTGluayAtIFRoZSBkYXRhIGxpbmsgdG8gc2V0IGF0IHRoZSBlbnRyeS5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGtleXMgYXJlIG5vdCB2YWxpZCBzdHJpbmdzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldERhdGFMaW5rKHByaXZhdGVLZXksIGRhdGFLZXksIGRhdGFMaW5rLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlSGV4U3RyaW5nKFwicHJpdmF0ZUtleVwiLCBwcml2YXRlS2V5LCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJkYXRhS2V5XCIsIGRhdGFLZXksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImRhdGFMaW5rXCIsIGRhdGFMaW5rLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLmV4cG9ydHMuZGVmYXVsdFNldEpTT05PcHRpb25zLFxuICAgICAgICAuLi50aGlzLmN1c3RvbU9wdGlvbnMsXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogcHVibGljS2V5QXJyYXkgfSA9IHR3ZWV0bmFjbF8xLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5KHN0cmluZ18xLmhleFRvVWludDhBcnJheShwcml2YXRlS2V5KSk7XG4gICAgY29uc3QgZ2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCBnZXROZXh0UmVnaXN0cnlFbnRyeSh0aGlzLCBzdHJpbmdfMS50b0hleFN0cmluZyhwdWJsaWNLZXlBcnJheSksIGRhdGFLZXksIHNpYV8xLmRlY29kZVNreWxpbmsoZGF0YUxpbmspLCBnZXRFbnRyeU9wdHMpO1xuICAgIC8vIFVwZGF0ZSB0aGUgcmVnaXN0cnkuXG4gICAgY29uc3Qgc2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdFNldEVudHJ5T3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5yZWdpc3RyeS5zZXRFbnRyeShwcml2YXRlS2V5LCBlbnRyeSwgc2V0RW50cnlPcHRzKTtcbn1cbmV4cG9ydHMuc2V0RGF0YUxpbmsgPSBzZXREYXRhTGluaztcbi8qKlxuICogR2V0cyB0aGUgbmV4dCBlbnRyeSBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkgYW5kIGRhdGEga2V5LCBzZXR0aW5nIHRoZSBkYXRhIHRvIGJlIHRoZSBnaXZlbiBkYXRhIGFuZCB0aGUgcmV2aXNpb24gbnVtYmVyIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBjbGllbnQgLSBUaGUgU2t5bmV0IGNsaWVudC5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgdXNlciBwdWJsaWMga2V5LlxuICogQHBhcmFtIGRhdGFLZXkgLSBUaGUgZGF0IGFrZXkuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHJldHVybnMgLSBUaGUgcmVnaXN0cnkgZW50cnkgYW5kIGNvcnJlc3BvbmRpbmcgZGF0YSBsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJldmlzaW9uIGlzIGFscmVhZHkgdGhlIG1heGltdW0gdmFsdWUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE5leHRSZWdpc3RyeUVudHJ5KGNsaWVudCwgcHVibGljS2V5LCBkYXRhS2V5LCBkYXRhLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gTm90IHB1YmxpY2x5IGF2YWlsYWJsZSwgZG9uJ3QgdmFsaWRhdGUgaW5wdXQuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4ucmVnaXN0cnlfMS5kZWZhdWx0R2V0RW50cnlPcHRpb25zLFxuICAgICAgICAuLi5jbGllbnQuY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIEdldCB0aGUgbGF0ZXN0IGVudHJ5LlxuICAgIC8vIFRPRE86IENhbiByZW1vdmUgdGhpcyBvbmNlIHdlIHN0YXJ0IGNhY2hpbmcgdGhlIGxhdGVzdCByZXZpc2lvbi5cbiAgICBjb25zdCBzaWduZWRFbnRyeSA9IGF3YWl0IGNsaWVudC5yZWdpc3RyeS5nZXRFbnRyeShwdWJsaWNLZXksIGRhdGFLZXksIG9wdHMpO1xuICAgIGNvbnN0IHJldmlzaW9uID0gZ2V0TmV4dFJldmlzaW9uRnJvbUVudHJ5KHNpZ25lZEVudHJ5LmVudHJ5KTtcbiAgICAvLyBCdWlsZCB0aGUgcmVnaXN0cnkgZW50cnkuXG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIGRhdGFLZXksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHJldmlzaW9uLFxuICAgIH07XG4gICAgcmV0dXJuIGVudHJ5O1xufVxuZXhwb3J0cy5nZXROZXh0UmVnaXN0cnlFbnRyeSA9IGdldE5leHRSZWdpc3RyeUVudHJ5O1xuLyoqXG4gKiBHZXRzIHRoZSByZWdpc3RyeSBlbnRyeSBhbmQgZGF0YSBsaW5rIG9yIGNyZWF0ZXMgdGhlIGVudHJ5IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogQHBhcmFtIGNsaWVudCAtIFRoZSBTa3luZXQgY2xpZW50LlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSB1c2VyIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gZGF0YUtleSAtIFRoZSBkYXQgYWtleS5cbiAqIEBwYXJhbSBqc29uIC0gVGhlIEpTT04gdG8gc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSByZWdpc3RyeSBlbnRyeSBhbmQgY29ycmVzcG9uZGluZyBkYXRhIGxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgcmV2aXNpb24gaXMgYWxyZWFkeSB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0T3JDcmVhdGVSZWdpc3RyeUVudHJ5KGNsaWVudCwgcHVibGljS2V5LCBkYXRhS2V5LCBqc29uLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gTm90IHB1YmxpY2x5IGF2YWlsYWJsZSwgZG9uJ3QgdmFsaWRhdGUgaW5wdXQuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0U2V0SlNPTk9wdGlvbnMsXG4gICAgICAgIC4uLmNsaWVudC5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH07XG4gICAgLy8gU2V0IHRoZSBoaWRkZW4gX2RhdGEgYW5kIF92IGZpZWxkcy5cbiAgICBjb25zdCBmdWxsRGF0YSA9IHsgX2RhdGE6IGpzb24sIF92OiBKU09OX1JFU1BPTlNFX1ZFUlNJT04gfTtcbiAgICAvLyBDcmVhdGUgdGhlIGRhdGEgdG8gdXBsb2FkIHRvIGFjcXVpcmUgaXRzIHNreWxpbmsuXG4gICAgbGV0IGRhdGFLZXlIZXggPSBkYXRhS2V5O1xuICAgIGlmICghb3B0cy5oYXNoZWREYXRhS2V5SGV4KSB7XG4gICAgICAgIGRhdGFLZXlIZXggPSBzdHJpbmdfMS50b0hleFN0cmluZyhzdHJpbmdfMS5zdHJpbmdUb1VpbnQ4QXJyYXlVdGY4KGRhdGFLZXkpKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtKU09OLnN0cmluZ2lmeShmdWxsRGF0YSldLCBgZGs6JHtkYXRhS2V5SGV4fWAsIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gICAgLy8gU3RhcnQgZmlsZSB1cGxvYWQsIGRvIG5vdCBibG9jay5cbiAgICBjb25zdCB1cGxvYWRPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHVwbG9hZF8xLmRlZmF1bHRVcGxvYWRPcHRpb25zKTtcbiAgICBjb25zdCBza3lmaWxlUHJvbWlzZSA9IGNsaWVudC51cGxvYWRGaWxlKGZpbGUsIHVwbG9hZE9wdHMpO1xuICAgIC8vIEZldGNoIHRoZSBjdXJyZW50IHZhbHVlIHRvIGZpbmQgb3V0IHRoZSByZXZpc2lvbi5cbiAgICAvL1xuICAgIC8vIFN0YXJ0IGdldEVudHJ5LCBkbyBub3QgYmxvY2suXG4gICAgY29uc3QgZ2V0RW50cnlPcHRzID0gb3B0aW9uc18xLmV4dHJhY3RPcHRpb25zKG9wdHMsIHJlZ2lzdHJ5XzEuZGVmYXVsdEdldEVudHJ5T3B0aW9ucyk7XG4gICAgY29uc3QgZW50cnlQcm9taXNlID0gY2xpZW50LnJlZ2lzdHJ5LmdldEVudHJ5KHB1YmxpY0tleSwgZGF0YUtleSwgZ2V0RW50cnlPcHRzKTtcbiAgICAvLyBCbG9jayB1bnRpbCBib3RoIGdldEVudHJ5IGFuZCB1cGxvYWRGaWxlIGFyZSBmaW5pc2hlZC5cbiAgICBjb25zdCBbc2lnbmVkRW50cnksIHNreWZpbGVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBlbnRyeVByb21pc2UsXG4gICAgICAgIHNreWZpbGVQcm9taXNlLFxuICAgIF0pO1xuICAgIGNvbnN0IHJldmlzaW9uID0gZ2V0TmV4dFJldmlzaW9uRnJvbUVudHJ5KHNpZ25lZEVudHJ5LmVudHJ5KTtcbiAgICAvLyBCdWlsZCB0aGUgcmVnaXN0cnkgZW50cnkuXG4gICAgY29uc3QgZGF0YUxpbmsgPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KHNreWZpbGUuc2t5bGluaywgdXJsXzEudXJpU2t5bmV0UHJlZml4KTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RpbmdfMS5kZWNvZGVTa3lsaW5rQmFzZTY0KGRhdGFMaW5rKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVVaW50OEFycmF5TGVuKFwiZGF0YVwiLCBkYXRhLCBcInNreWxpbmsgYnl0ZSBhcnJheVwiLCBzaWFfMS5SQVdfU0tZTElOS19TSVpFKTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgZGF0YUtleSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcmV2aXNpb24sXG4gICAgfTtcbiAgICByZXR1cm4gW2VudHJ5LCBmb3JtYXRfMS5mb3JtYXRTa3lsaW5rKGRhdGFMaW5rKV07XG59XG5leHBvcnRzLmdldE9yQ3JlYXRlUmVnaXN0cnlFbnRyeSA9IGdldE9yQ3JlYXRlUmVnaXN0cnlFbnRyeTtcbi8qKlxuICogR2V0cyB0aGUgbmV4dCByZXZpc2lvbiBmcm9tIGEgcmV0dXJuZWQgZW50cnkgKG9yIDAgaWYgdGhlIGVudHJ5IHdhcyBub3QgZm91bmQpLlxuICpcbiAqIEBwYXJhbSBlbnRyeSAtIFRoZSByZXR1cm5lZCByZWdpc3RyeSBlbnRyeS5cbiAqIEByZXR1cm5zIC0gVGhlIHJldmlzaW9uLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIG5leHQgcmV2aXNpb24gd291bGQgYmUgYmV5b25kIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRSZXZpc2lvbkZyb21FbnRyeShlbnRyeSkge1xuICAgIGxldCByZXZpc2lvbjtcbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV2aXNpb24gPSBCaWdJbnQoMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXZpc2lvbiA9IGVudHJ5LnJldmlzaW9uICsgQmlnSW50KDEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBpZiB0aGUgcmV2aXNpb24gaXMgYWxyZWFkeSB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICBpZiAocmV2aXNpb24gPiBudW1iZXJfMS5NQVhfUkVWSVNJT04pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VycmVudCBlbnRyeSBhbHJlYWR5IGhhcyBtYXhpbXVtIGFsbG93ZWQgcmV2aXNpb24sIGNvdWxkIG5vdCB1cGRhdGUgdGhlIGVudHJ5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV2aXNpb247XG59XG5leHBvcnRzLmdldE5leHRSZXZpc2lvbkZyb21FbnRyeSA9IGdldE5leHRSZXZpc2lvbkZyb21FbnRyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRTa3lsaW5rID0gZXhwb3J0cy5jb252ZXJ0U2t5bGlua1RvQmFzZTY0ID0gZXhwb3J0cy5jb252ZXJ0U2t5bGlua1RvQmFzZTMyID0gdm9pZCAwO1xuY29uc3Qgc2lhXzEgPSByZXF1aXJlKFwiLi9zaWFcIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2VuY29kaW5nXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyaW5nXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJsXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL3ZhbGlkYXRpb25cIik7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBiYXNlNjQgc2t5bGluayB0byBiYXNlMzIuXG4gKlxuICogQHBhcmFtIHNreWxpbmsgLSBUaGUgYmFzZTY0IHNreWxpbmsuXG4gKiBAcmV0dXJucyAtIFRoZSBjb252ZXJ0ZWQgYmFzZTMyIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTa3lsaW5rVG9CYXNlMzIoc2t5bGluaykge1xuICAgIHNreWxpbmsgPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KHNreWxpbmssIHVybF8xLnVyaVNreW5ldFByZWZpeCk7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nTGVuKFwic2t5bGlua1wiLCBza3lsaW5rLCBcInBhcmFtZXRlclwiLCBzaWFfMS5CQVNFNjRfRU5DT0RFRF9TS1lMSU5LX1NJWkUpO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2RpbmdfMS5kZWNvZGVTa3lsaW5rQmFzZTY0KHNreWxpbmspO1xuICAgIHJldHVybiBlbmNvZGluZ18xLmVuY29kZVNreWxpbmtCYXNlMzIoYnl0ZXMpO1xufVxuZXhwb3J0cy5jb252ZXJ0U2t5bGlua1RvQmFzZTMyID0gY29udmVydFNreWxpbmtUb0Jhc2UzMjtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGJhc2UzMiBza3lsaW5rIHRvIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gc2t5bGluayAtIFRoZSBiYXNlMzIgc2t5bGluay5cbiAqIEByZXR1cm5zIC0gVGhlIGNvbnZlcnRlZCBiYXNlNjQgc2t5bGluay5cbiAqL1xuZnVuY3Rpb24gY29udmVydFNreWxpbmtUb0Jhc2U2NChza3lsaW5rKSB7XG4gICAgc2t5bGluayA9IHN0cmluZ18xLnRyaW1VcmlQcmVmaXgoc2t5bGluaywgdXJsXzEudXJpU2t5bmV0UHJlZml4KTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmdMZW4oXCJza3lsaW5rXCIsIHNreWxpbmssIFwicGFyYW1ldGVyXCIsIHNpYV8xLkJBU0UzMl9FTkNPREVEX1NLWUxJTktfU0laRSk7XG4gICAgY29uc3QgYnl0ZXMgPSBlbmNvZGluZ18xLmRlY29kZVNreWxpbmtCYXNlMzIoc2t5bGluayk7XG4gICAgcmV0dXJuIGVuY29kaW5nXzEuZW5jb2RlU2t5bGlua0Jhc2U2NChieXRlcyk7XG59XG5leHBvcnRzLmNvbnZlcnRTa3lsaW5rVG9CYXNlNjQgPSBjb252ZXJ0U2t5bGlua1RvQmFzZTY0O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBza3lsaW5rIGJ5IGFkZGluZyB0aGUgc2lhOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHNreWxpbmsgLSBUaGUgc2t5bGluay5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCBza3lsaW5rLlxuICovXG5mdW5jdGlvbiBmb3JtYXRTa3lsaW5rKHNreWxpbmspIHtcbiAgICBpZiAoc2t5bGluayA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gc2t5bGluaztcbiAgICB9XG4gICAgaWYgKCFza3lsaW5rLnN0YXJ0c1dpdGgodXJsXzEudXJpU2t5bmV0UHJlZml4KSkge1xuICAgICAgICBza3lsaW5rID0gYCR7dXJsXzEudXJpU2t5bmV0UHJlZml4fSR7c2t5bGlua31gO1xuICAgIH1cbiAgICByZXR1cm4gc2t5bGluaztcbn1cbmV4cG9ydHMuZm9ybWF0U2t5bGluayA9IGZvcm1hdFNreWxpbms7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VTa3lsaW5rQmFzZTMyID0gZXhwb3J0cy5wYXJzZVNreWxpbmsgPSB2b2lkIDA7XG5jb25zdCB1cmxfcGFyc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXJsLXBhcnNlXCIpKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcIi4uL3V0aWxzL3VybFwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi91dGlscy92YWxpZGF0aW9uXCIpO1xuY29uc3QgZGVmYXVsdFBhcnNlU2t5bGlua09wdGlvbnMgPSB7XG4gICAgZnJvbVN1YmRvbWFpbjogZmFsc2UsXG4gICAgaW5jbHVkZVBhdGg6IGZhbHNlLFxuICAgIG9ubHlQYXRoOiBmYWxzZSxcbn07XG5jb25zdCBTS1lMSU5LX01BVENIRVIgPSBcIihbYS16QS1aMC05Xy1dezQ2fSlcIjtcbmNvbnN0IFNLWUxJTktfTUFUQ0hFUl9TVUJET01BSU4gPSBcIihbYS16MC05Xy1dezU1fSlcIjtcbmNvbnN0IFNLWUxJTktfRElSRUNUX1JFR0VYID0gbmV3IFJlZ0V4cChgXiR7U0tZTElOS19NQVRDSEVSfSRgKTtcbmNvbnN0IFNLWUxJTktfUEFUSE5BTUVfUkVHRVggPSBuZXcgUmVnRXhwKGBeLz8ke1NLWUxJTktfTUFUQ0hFUn0oKC8uKik/KSRgKTtcbmNvbnN0IFNLWUxJTktfU1VCRE9NQUlOX1JFR0VYID0gbmV3IFJlZ0V4cChgXiR7U0tZTElOS19NQVRDSEVSX1NVQkRPTUFJTn0oXFxcXC4uKik/JGApO1xuY29uc3QgU0tZTElOS19ESVJFQ1RfTUFUQ0hfUE9TSVRJT04gPSAxO1xuY29uc3QgU0tZTElOS19QQVRIX01BVENIX1BPU0lUSU9OID0gMjtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBzdHJpbmcgZm9yIGEgYmFzZTY0IHNreWxpbmssIG9yIGJhc2UzMiBpZiBvcHRzLmZyb21TdWJkb21haW4gaXMgZ2l2ZW4uIElmIHRoZSBnaXZlbiBzdHJpbmcgaXMgcHJlZml4ZWQgd2l0aCBzaWE6LCBzaWE6Ly8sIG9yIGEgcG9ydGFsIFVSTCwgdGhvc2Ugd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgcmF3IHNreWxpbmsgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHNreWxpbmtVcmwgLSBQbGFpbiBza3lsaW5rLCBza3lsaW5rIHdpdGggVVJJIHByZWZpeCwgb3IgVVJMIHdpdGggc2t5bGluayBhcyB0aGUgZmlyc3QgcGF0aCBlbGVtZW50LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSBiYXNlNjQgKG9yIGJhc2UzMikgc2t5bGluaywgb3B0aW9uYWxseSB3aXRoIHRoZSBwYXRoIGluY2x1ZGVkLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgb24gaW52YWxpZCBjb21iaW5hdGlvbiBvZiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBwYXJzZVNreWxpbmsoc2t5bGlua1VybCwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInNreWxpbmtVcmxcIiwgc2t5bGlua1VybCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlT3B0aW9uYWxPYmplY3QoXCJjdXN0b21PcHRpb25zXCIsIGN1c3RvbU9wdGlvbnMsIFwicGFyYW1ldGVyXCIsIGRlZmF1bHRQYXJzZVNreWxpbmtPcHRpb25zKTtcbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0UGFyc2VTa3lsaW5rT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIGlmIChvcHRzLmluY2x1ZGVQYXRoICYmIG9wdHMub25seVBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGluY2x1ZGVQYXRoIGFuZCBvbmx5UGF0aCBvcHRpb25zIGNhbm5vdCBib3RoIGJlIHNldFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuaW5jbHVkZVBhdGggJiYgb3B0cy5mcm9tU3ViZG9tYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbmNsdWRlUGF0aCBhbmQgZnJvbVN1YmRvbWFpbiBvcHRpb25zIGNhbm5vdCBib3RoIGJlIHNldFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuZnJvbVN1YmRvbWFpbikge1xuICAgICAgICByZXR1cm4gcGFyc2VTa3lsaW5rQmFzZTMyKHNreWxpbmtVcmwsIG9wdHMpO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3Igc2t5bGluayBwcmVmaXhlZCB3aXRoIHNpYTogb3Igc2lhOi8vIGFuZCBleHRyYWN0IGl0LlxuICAgIC8vIEV4YW1wbGU6IHNpYTpYQUJ2aTdKdEpiUVNNQWNEd25Vbm1wMkZLRFBqZzhfdFRURlA0QndNU3hWZEVnXG4gICAgLy8gRXhhbXBsZTogc2lhOi8vWEFCdmk3SnRKYlFTTUFjRHduVW5tcDJGS0RQamc4X3RUVEZQNEJ3TVN4VmRFZ1xuICAgIHNreWxpbmtVcmwgPSBzdHJpbmdfMS50cmltVXJpUHJlZml4KHNreWxpbmtVcmwsIHVybF8xLnVyaVNreW5ldFByZWZpeCk7XG4gICAgLy8gQ2hlY2sgZm9yIGRpcmVjdCBiYXNlNjQgc2t5bGluayBtYXRjaC5cbiAgICBjb25zdCBtYXRjaERpcmVjdCA9IHNreWxpbmtVcmwubWF0Y2goU0tZTElOS19ESVJFQ1RfUkVHRVgpO1xuICAgIGlmIChtYXRjaERpcmVjdCkge1xuICAgICAgICBpZiAob3B0cy5vbmx5UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoRGlyZWN0W1NLWUxJTktfRElSRUNUX01BVENIX1BPU0lUSU9OXTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHNreWxpbmsgcGFzc2VkIGluIGFuIHVybCBhbmQgZXh0cmFjdCBpdC5cbiAgICAvLyBFeGFtcGxlOiBodHRwczovL3NpYXNreS5uZXQvWEFCdmk3SnRKYlFTTUFjRHduVW5tcDJGS0RQamc4X3RUVEZQNEJ3TVN4VmRFZ1xuICAgIC8vIEV4YW1wbGU6IGh0dHBzOi8vYmcwNnYydGlka2lyODRoZzBzMXM0dDk3amFlb2FhMWpzZTFzdnJhZDY1N3UwNzBjOWNhbHE0Zy5zaWFza3kubmV0IChpZiBvcHRzLmZyb21TdWJkb21haW4gPSB0cnVlKVxuICAgIC8vIFBhc3MgZW1wdHkgb2JqZWN0IGFzIHNlY29uZCBwYXJhbSB0byBkaXNhYmxlIHVzaW5nIGxvY2F0aW9uIGFzIGJhc2UgdXJsXG4gICAgLy8gd2hlbiBwYXJzaW5nIGluIGJyb3dzZXIuXG4gICAgY29uc3QgcGFyc2VkID0gdXJsX3BhcnNlXzEuZGVmYXVsdChza3lsaW5rVXJsLCB7fSk7XG4gICAgY29uc3Qgc2t5bGlua0FuZFBhdGggPSBzdHJpbmdfMS50cmltU3VmZml4KHBhcnNlZC5wYXRobmFtZSwgXCIvXCIpO1xuICAgIGNvbnN0IG1hdGNoUGF0aG5hbWUgPSBza3lsaW5rQW5kUGF0aC5tYXRjaChTS1lMSU5LX1BBVEhOQU1FX1JFR0VYKTtcbiAgICBpZiAoIW1hdGNoUGF0aG5hbWUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHBhdGggPSBtYXRjaFBhdGhuYW1lW1NLWUxJTktfUEFUSF9NQVRDSF9QT1NJVElPTl07XG4gICAgaWYgKG9wdHMuaW5jbHVkZVBhdGgpXG4gICAgICAgIHJldHVybiBzdHJpbmdfMS50cmltRm9yd2FyZFNsYXNoKHNreWxpbmtBbmRQYXRoKTtcbiAgICBlbHNlIGlmIChvcHRzLm9ubHlQYXRoKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBtYXRjaFBhdGhuYW1lW1NLWUxJTktfRElSRUNUX01BVENIX1BPU0lUSU9OXTtcbn1cbmV4cG9ydHMucGFyc2VTa3lsaW5rID0gcGFyc2VTa3lsaW5rO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBwYXJzZXMgdGhlIGdpdmVuIHN0cmluZyBmb3IgYSBiYXNlMzIgc2t5bGluay5cbiAqXG4gKiBAcGFyYW0gc2t5bGlua1VybCAtIEJhc2UzMiBza3lsaW5rLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcmV0dXJucyAtIFRoZSBiYXNlMzIgc2t5bGluay5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTa3lsaW5rQmFzZTMyKHNreWxpbmtVcmwsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICAvLyBEbyBub3QgdmFsaWRhdGUsIHRoaXMgaGVscGVyIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIHBhcnNlU2t5bGluay5cbiAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0UGFyc2VTa3lsaW5rT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICAgIC8vIFBhc3MgZW1wdHkgb2JqZWN0IGFzIHNlY29uZCBwYXJhbSB0byBkaXNhYmxlIHVzaW5nIGxvY2F0aW9uIGFzIGJhc2UgdXJsXG4gICAgLy8gd2hlbiBwYXJzaW5nIGluIGJyb3dzZXIuXG4gICAgY29uc3QgcGFyc2VkID0gdXJsX3BhcnNlXzEuZGVmYXVsdChza3lsaW5rVXJsLCB7fSk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGhvc3RuYW1lIGNvbnRhaW5zIGEgc2t5bGluayBzdWJkb21haW4uXG4gICAgY29uc3QgbWF0Y2hIb3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZS5tYXRjaChTS1lMSU5LX1NVQkRPTUFJTl9SRUdFWCk7XG4gICAgaWYgKG1hdGNoSG9zdG5hbWUpIHtcbiAgICAgICAgaWYgKG9wdHMub25seVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdfMS50cmltU3VmZml4KHBhcnNlZC5wYXRobmFtZSwgXCIvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaEhvc3RuYW1lW1NLWUxJTktfRElSRUNUX01BVENIX1BPU0lUSU9OXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnBhcnNlU2t5bGlua0Jhc2UzMiA9IHBhcnNlU2t5bGlua0Jhc2UzMjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVTa3lsaW5rID0gZXhwb3J0cy5uZXdTa3lsaW5rVjIgPSBleHBvcnRzLm5ld0VkMjU1MTlQdWJsaWNLZXkgPSBleHBvcnRzLm5ld1NwZWNpZmllciA9IGV4cG9ydHMuaXNTa3lsaW5rVjIgPSBleHBvcnRzLmlzU2t5bGlua1YxID0gZXhwb3J0cy5TaWFTa3lsaW5rID0gZXhwb3J0cy5FTVBUWV9TS1lMSU5LID0gZXhwb3J0cy5SQVdfU0tZTElOS19TSVpFID0gZXhwb3J0cy5CQVNFNjRfRU5DT0RFRF9TS1lMSU5LX1NJWkUgPSBleHBvcnRzLkJBU0UzMl9FTkNPREVEX1NLWUxJTktfU0laRSA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0b1wiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZW5jb2RpbmdcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJpbmdcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCIuLi91dGlscy91cmxcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdmFsaWRhdGlvblwiKTtcbi8qKlxuICogVGhlIHN0cmluZyBsZW5ndGggb2YgdGhlIFNreWxpbmsgYWZ0ZXIgaXQgaGFzIGJlZW4gZW5jb2RlZCB1c2luZyBiYXNlMzIuXG4gKi9cbmV4cG9ydHMuQkFTRTMyX0VOQ09ERURfU0tZTElOS19TSVpFID0gNTU7XG4vKipcbiAqIFRoZSBzdHJpbmcgbGVuZ3RoIG9mIHRoZSBTa3lsaW5rIGFmdGVyIGl0IGhhcyBiZWVuIGVuY29kZWQgdXNpbmcgYmFzZTY0LlxuICovXG5leHBvcnRzLkJBU0U2NF9FTkNPREVEX1NLWUxJTktfU0laRSA9IDQ2O1xuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgc3RyaW5nIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGludG8gYSBTa3lsaW5rIGR1ZSB0byBpdCBoYXZpbmdcbiAqIGFuIGluY29ycmVjdCBzaXplLlxuICovXG5jb25zdCBFUlJfU0tZTElOS19JTkNPUlJFQ1RfU0laRSA9IFwic2t5bGluayBoYXMgaW5jb3JyZWN0IHNpemVcIjtcbi8qKlxuICogVGhlIHJhdyBzaXplIGluIGJ5dGVzIG9mIHRoZSBkYXRhIHRoYXQgZ2V0cyBwdXQgaW50byBhIGxpbmsuXG4gKi9cbmV4cG9ydHMuUkFXX1NLWUxJTktfU0laRSA9IDM0O1xuLyoqXG4gKiBBbiBlbXB0eSBza3lsaW5rLlxuICovXG5leHBvcnRzLkVNUFRZX1NLWUxJTksgPSBuZXcgVWludDhBcnJheShleHBvcnRzLlJBV19TS1lMSU5LX1NJWkUpO1xuY2xhc3MgU2lhU2t5bGluayB7XG4gICAgY29uc3RydWN0b3IoYml0ZmllbGQsIG1lcmtsZVJvb3QpIHtcbiAgICAgICAgdGhpcy5iaXRmaWVsZCA9IGJpdGZpZWxkO1xuICAgICAgICB0aGlzLm1lcmtsZVJvb3QgPSBtZXJrbGVSb290O1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVOdW1iZXIoXCJiaXRmaWVsZFwiLCBiaXRmaWVsZCwgXCJjb25zdHJ1Y3RvciBwYXJhbWV0ZXJcIik7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVVpbnQ4QXJyYXlMZW4oXCJtZXJrbGVSb290XCIsIG1lcmtsZVJvb3QsIFwiY29uc3RydWN0b3IgcGFyYW1ldGVyXCIsIDMyKTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKGV4cG9ydHMuUkFXX1NLWUxJTktfU0laRSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MTYoMCwgdGhpcy5iaXRmaWVsZCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHVpbnQ4Qnl0ZXMgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICB1aW50OEJ5dGVzLnNldCh0aGlzLm1lcmtsZVJvb3QsIDIpO1xuICAgICAgICByZXR1cm4gdWludDhCeXRlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGluZ18xLmVuY29kZVNreWxpbmtCYXNlNjQodGhpcy50b0J5dGVzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lhU2t5bGluayA9IFNpYVNreWxpbms7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgdjEgc2t5bGluay5cbiAqXG4gKiBAcGFyYW0gc1xuICovXG5mdW5jdGlvbiBpc1NreWxpbmtWMShzKSB7XG4gICAgY29uc3QgcmF3ID0gZGVjb2RlU2t5bGluayhzKTtcbiAgICAvLyBMb2FkIGFuZCBjaGVjayB0aGUgYml0ZmllbGQuXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhyYXcuYnVmZmVyKTtcbiAgICBjb25zdCBiaXRmaWVsZCA9IHZpZXcuZ2V0VWludDE2KDAsIHRydWUpO1xuICAgIHJldHVybiBpc0JpdGZpZWxkU2t5bGlua1YxKGJpdGZpZWxkKTtcbn1cbmV4cG9ydHMuaXNTa3lsaW5rVjEgPSBpc1NreWxpbmtWMTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSB2MiBza3lsaW5rLlxuICpcbiAqIEBwYXJhbSBzXG4gKi9cbmZ1bmN0aW9uIGlzU2t5bGlua1YyKHMpIHtcbiAgICAvLyBEZWNvZGUgdGhlIGJhc2UgaW50byByYXcgZGF0YS5cbiAgICBjb25zdCByYXcgPSBkZWNvZGVTa3lsaW5rKHMpO1xuICAgIC8vIExvYWQgYW5kIGNoZWNrIHRoZSBiaXRmaWVsZC5cbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJhdy5idWZmZXIpO1xuICAgIGNvbnN0IGJpdGZpZWxkID0gdmlldy5nZXRVaW50MTYoMCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGlzQml0ZmllbGRTa3lsaW5rVjIoYml0ZmllbGQpO1xufVxuZXhwb3J0cy5pc1NreWxpbmtWMiA9IGlzU2t5bGlua1YyO1xuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBTa3lsaW5rIGlzIGEgVjEgc2t5bGlua1xuICpcbiAqIEBwYXJhbSBiaXRmaWVsZFxuICovXG5mdW5jdGlvbiBpc0JpdGZpZWxkU2t5bGlua1YxKGJpdGZpZWxkKSB7XG4gICAgcmV0dXJuIChiaXRmaWVsZCAmIDMpID09PSAwO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBTa3lsaW5rIGlzIGEgVjIgc2t5bGlua1xuICpcbiAqIEBwYXJhbSBiaXRmaWVsZFxuICovXG5mdW5jdGlvbiBpc0JpdGZpZWxkU2t5bGlua1YyKGJpdGZpZWxkKSB7XG4gICAgLy8gV2UgY29tcGFyZSBhZ2FpbnN0IDEgaGVyZSBiZWNhdXNlIGEgVjIgc2t5bGluayBvbmx5IHVzZXMgdGhlIHZlcnNpb25cbiAgICAvLyBiaXRzLiBBbGwgb3RoZXIgYml0cyBzaG91bGQgYmUgc2V0IHRvIDAuXG4gICAgcmV0dXJuIGJpdGZpZWxkID09IDE7XG59XG5jb25zdCBTUEVDSUZJRVJfTEVOID0gMTY7XG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWZpZXIgZm9yIGdpdmVuIG5hbWUsIGEgc3BlY2lmaWVyIGNhbiBvbmx5IGJlIDE2IGJ5dGVzIHNvIHdlXG4gKiBwYW5pYyBpZiB0aGUgZ2l2ZW4gbmFtZSBpcyB0b28gbG9uZy5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lLlxuICogQHJldHVybnMgLSBUaGUgc3BlY2lmaWVyLCBpZiB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gbmV3U3BlY2lmaWVyKG5hbWUpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJuYW1lXCIsIG5hbWUsIFwicGFyYW1ldGVyXCIpO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IG5ldyBVaW50OEFycmF5KFNQRUNJRklFUl9MRU4pO1xuICAgIHNwZWNpZmllci5zZXQoc3RyaW5nXzEuc3RyaW5nVG9VaW50OEFycmF5VXRmOChuYW1lKSk7XG4gICAgcmV0dXJuIHNwZWNpZmllcjtcbn1cbmV4cG9ydHMubmV3U3BlY2lmaWVyID0gbmV3U3BlY2lmaWVyO1xuY29uc3QgUFVCTElDX0tFWV9TSVpFID0gMzI7XG5jbGFzcyBTaWFQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKGFsZ29yaXRobSwga2V5KSB7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgbWFyc2hhbFNpYSgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShTUEVDSUZJRVJfTEVOICsgOCArIFBVQkxJQ19LRVlfU0laRSk7XG4gICAgICAgIGJ5dGVzLnNldCh0aGlzLmFsZ29yaXRobSk7XG4gICAgICAgIGJ5dGVzLnNldChlbmNvZGluZ18xLmVuY29kZVByZWZpeGVkQnl0ZXModGhpcy5rZXkpLCBTUEVDSUZJRVJfTEVOKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzaWEgcHVibGljIGtleS4gTWF0Y2hlcyBFZDI1NTE5UHVibGljS2V5IGluIHNpYS5cbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIGhleC1lbmNvZGVkIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyAtIFRoZSBTaWFQdWJsaWNLZXkuXG4gKi9cbmZ1bmN0aW9uIG5ld0VkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlSGV4U3RyaW5nKFwicHVibGljS2V5XCIsIHB1YmxpY0tleSwgXCJwYXJhbWV0ZXJcIik7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gbmV3U3BlY2lmaWVyKFwiZWQyNTUxOVwiKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHN0cmluZ18xLmhleFRvVWludDhBcnJheShwdWJsaWNLZXkpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVVpbnQ4QXJyYXlMZW4oXCJwdWJsaWNLZXlCeXRlc1wiLCBwdWJsaWNLZXlCeXRlcywgXCJjb252ZXJ0ZWQgcHVibGljS2V5XCIsIFBVQkxJQ19LRVlfU0laRSk7XG4gICAgcmV0dXJuIG5ldyBTaWFQdWJsaWNLZXkoYWxnb3JpdGhtLCBwdWJsaWNLZXlCeXRlcyk7XG59XG5leHBvcnRzLm5ld0VkMjU1MTlQdWJsaWNLZXkgPSBuZXdFZDI1NTE5UHVibGljS2V5O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHYyIHNreWxpbmsuIE1hdGNoZXMgTmV3U2t5bGlua1YyIGluIHNreWQuXG4gKlxuICogQHBhcmFtIHNpYVB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IGFzIGEgU2lhUHVibGljS2V5LlxuICogQHBhcmFtIHR3ZWFrIC0gVGhlIGhhc2hlZCB0d2Vhay5cbiAqIEByZXR1cm5zIC0gVGhlIHYyIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIG5ld1NreWxpbmtWMihzaWFQdWJsaWNLZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IDI7XG4gICAgY29uc3QgYml0ZmllbGQgPSB2ZXJzaW9uIC0gMTtcbiAgICBjb25zdCBtZXJrbGVSb290ID0gZGVyaXZlUmVnaXN0cnlFbnRyeUlEKHNpYVB1YmxpY0tleSwgdHdlYWspO1xuICAgIHJldHVybiBuZXcgU2lhU2t5bGluayhiaXRmaWVsZCwgbWVya2xlUm9vdCk7XG59XG5leHBvcnRzLm5ld1NreWxpbmtWMiA9IG5ld1NreWxpbmtWMjtcbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBkZWNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBza3lsaW5rXG4gKiBpbnRvIHJhdyBieXRlcy4gSXQgZWl0aGVyIHBlcmZvcm1zIGEgYmFzZTMyIGRlY29kaW5nLCBvciBiYXNlNjQgZGVjb2RpbmcsXG4gKiBkZXBlbmRpbmcgb24gdGhlIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0gZW5jb2RlZCAtIFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIC0gVGhlIGRlY29kZWQgcmF3IGJ5dGVzLlxuICovXG5mdW5jdGlvbiBkZWNvZGVTa3lsaW5rKGVuY29kZWQpIHtcbiAgICBlbmNvZGVkID0gc3RyaW5nXzEudHJpbVVyaVByZWZpeChlbmNvZGVkLCB1cmxfMS51cmlTa3luZXRQcmVmaXgpO1xuICAgIGxldCBieXRlcztcbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IGV4cG9ydHMuQkFTRTMyX0VOQ09ERURfU0tZTElOS19TSVpFKSB7XG4gICAgICAgIGJ5dGVzID0gZW5jb2RpbmdfMS5kZWNvZGVTa3lsaW5rQmFzZTMyKGVuY29kZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gZXhwb3J0cy5CQVNFNjRfRU5DT0RFRF9TS1lMSU5LX1NJWkUpIHtcbiAgICAgICAgYnl0ZXMgPSBlbmNvZGluZ18xLmRlY29kZVNreWxpbmtCYXNlNjQoZW5jb2RlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX1NLWUxJTktfSU5DT1JSRUNUX1NJWkUpO1xuICAgIH1cbiAgICAvLyBTYW5pdHkgY2hlY2sgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGRhdGEuXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSBleHBvcnRzLlJBV19TS1lMSU5LX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGxvYWQgc2t5bGluayBkYXRhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZVNreWxpbmsgPSBkZWNvZGVTa3lsaW5rO1xuLyoqXG4gKiBBIGhlbHBlciB0byBkZXJpdmUgYW4gZW50cnkgaWQgZm9yIGEgcmVnaXN0cnkga2V5IHZhbHVlIHBhaXIuIE1hdGNoZXMgYERlcml2ZVJlZ2lzdHJ5RW50cnlJRGAgaW4gc2lhLlxuICpcbiAqIEBwYXJhbSBwdWJLZXkgLSBUaGUgc2lhIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gdHdlYWsgLSBUaGUgdHdlYWsuXG4gKiBAcmV0dXJucyAtIFRoZSBlbnRyeSBJRCBhcyBhIGhhc2ggb2YgdGhlIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gZGVyaXZlUmVnaXN0cnlFbnRyeUlEKHB1YktleSwgdHdlYWspIHtcbiAgICByZXR1cm4gY3J5cHRvXzEuaGFzaEFsbChwdWJLZXkubWFyc2hhbFNpYSgpLCB0d2Vhayk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXBsb2FkRGlyZWN0b3J5UmVxdWVzdCA9IGV4cG9ydHMudXBsb2FkRGlyZWN0b3J5ID0gZXhwb3J0cy51cGxvYWRGaWxlUmVxdWVzdCA9IGV4cG9ydHMudXBsb2FkRmlsZSA9IGV4cG9ydHMuZGVmYXVsdFVwbG9hZE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBmaWxlXzEgPSByZXF1aXJlKFwiLi91dGlscy9maWxlXCIpO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4vdXRpbHMvb3B0aW9uc1wiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vc2t5bGluay9mb3JtYXRcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0aW9uXCIpO1xuZXhwb3J0cy5kZWZhdWx0VXBsb2FkT3B0aW9ucyA9IHtcbiAgICAuLi5vcHRpb25zXzEuZGVmYXVsdEJhc2VPcHRpb25zLFxuICAgIGVuZHBvaW50VXBsb2FkOiBcIi9za3luZXQvc2t5ZmlsZVwiLFxuICAgIHBvcnRhbEZpbGVGaWVsZG5hbWU6IFwiZmlsZVwiLFxuICAgIHBvcnRhbERpcmVjdG9yeUZpbGVGaWVsZG5hbWU6IFwiZmlsZXNbXVwiLFxuICAgIGN1c3RvbUZpbGVuYW1lOiBcIlwiLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG59O1xuLyoqXG4gKiBVcGxvYWRzIGEgZmlsZSB0byBTa3luZXQuXG4gKlxuICogQHBhcmFtIHRoaXMgLSBTa3luZXRDbGllbnRcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGZpbGUgdG8gdXBsb2FkLlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL3NreW5ldC9za3lmaWxlXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIHJldHVybmVkIHNreWxpbmsuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsIGJ1dCB0aGUgdXBsb2FkIHJlc3BvbnNlIGRvZXMgbm90IGNvbnRhaW4gYSBjb21wbGV0ZSByZXNwb25zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZShmaWxlLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGB1cGxvYWREaXJlY3RvcnlSZXF1ZXN0YC5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudXBsb2FkRmlsZVJlcXVlc3QoZmlsZSwgY3VzdG9tT3B0aW9ucyk7XG4gICAgLy8gU2FuaXR5IGNoZWNrLlxuICAgIHZhbGlkYXRlVXBsb2FkUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IHNreWxpbmsgPSBmb3JtYXRfMS5mb3JtYXRTa3lsaW5rKHJlc3BvbnNlLmRhdGEuc2t5bGluayk7XG4gICAgY29uc3QgbWVya2xlcm9vdCA9IHJlc3BvbnNlLmRhdGEubWVya2xlcm9vdDtcbiAgICBjb25zdCBiaXRmaWVsZCA9IHJlc3BvbnNlLmRhdGEuYml0ZmllbGQ7XG4gICAgcmV0dXJuIHsgc2t5bGluaywgbWVya2xlcm9vdCwgYml0ZmllbGQgfTtcbn1cbmV4cG9ydHMudXBsb2FkRmlsZSA9IHVwbG9hZEZpbGU7XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byB1cGxvYWQgYSBmaWxlIHRvIFNreW5ldC5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB0byB1cGxvYWQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnNdIC0gQWRkaXRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHNldC5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9ucy5lbmRwb2ludFBhdGg9XCIvc2t5bmV0L3NreWZpbGVcIl0gLSBUaGUgcmVsYXRpdmUgVVJMIHBhdGggb2YgdGhlIHBvcnRhbCBlbmRwb2ludCB0byBjb250YWN0LlxuICogQHJldHVybnMgLSBUaGUgdXBsb2FkIHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlUmVxdWVzdChmaWxlLCBjdXN0b21PcHRpb25zKSB7XG4gICAgdmFsaWRhdGVGaWxlKFwiZmlsZVwiLCBmaWxlLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0VXBsb2FkT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0VXBsb2FkT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmaWxlID0gZW5zdXJlRmlsZU9iamVjdENvbnNpc3RlbmN5KGZpbGUpO1xuICAgIGlmIChvcHRzLmN1c3RvbUZpbGVuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChvcHRzLnBvcnRhbEZpbGVGaWVsZG5hbWUsIGZpbGUsIG9wdHMuY3VzdG9tRmlsZW5hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG9wdHMucG9ydGFsRmlsZUZpZWxkbmFtZSwgZmlsZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGVuZHBvaW50UGF0aDogb3B0cy5lbmRwb2ludFVwbG9hZCxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0cy51cGxvYWRGaWxlUmVxdWVzdCA9IHVwbG9hZEZpbGVSZXF1ZXN0O1xuLyoqXG4gKiBVcGxvYWRzIGEgZGlyZWN0b3J5IHRvIFNreW5ldC5cbiAqXG4gKiBAcGFyYW0gdGhpcyAtIFNreW5ldENsaWVudFxuICogQHBhcmFtIGRpcmVjdG9yeSAtIEZpbGUgb2JqZWN0cyB0byB1cGxvYWQsIGluZGV4ZWQgYnkgdGhlaXIgcGF0aCBzdHJpbmdzLlxuICogQHBhcmFtIGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBbY3VzdG9tT3B0aW9uc10gLSBBZGRpdGlvbmFsIHNldHRpbmdzIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgc2V0LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zLmVuZHBvaW50UGF0aD1cIi9za3luZXQvc2t5ZmlsZVwiXSAtIFRoZSByZWxhdGl2ZSBVUkwgcGF0aCBvZiB0aGUgcG9ydGFsIGVuZHBvaW50IHRvIGNvbnRhY3QuXG4gKiBAcmV0dXJucyAtIFRoZSByZXR1cm5lZCBza3lsaW5rLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBidXQgdGhlIHVwbG9hZCByZXNwb25zZSBkb2VzIG5vdCBjb250YWluIGEgY29tcGxldGUgcmVzcG9uc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZERpcmVjdG9yeShkaXJlY3RvcnksIGZpbGVuYW1lLCBjdXN0b21PcHRpb25zKSB7XG4gICAgLy8gVmFsaWRhdGlvbiBpcyBkb25lIGluIGB1cGxvYWREaXJlY3RvcnlSZXF1ZXN0YC5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudXBsb2FkRGlyZWN0b3J5UmVxdWVzdChkaXJlY3RvcnksIGZpbGVuYW1lLCBjdXN0b21PcHRpb25zKTtcbiAgICAvLyBTYW5pdHkgY2hlY2suXG4gICAgdmFsaWRhdGVVcGxvYWRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3Qgc2t5bGluayA9IGZvcm1hdF8xLmZvcm1hdFNreWxpbmsocmVzcG9uc2UuZGF0YS5za3lsaW5rKTtcbiAgICBjb25zdCBtZXJrbGVyb290ID0gcmVzcG9uc2UuZGF0YS5tZXJrbGVyb290O1xuICAgIGNvbnN0IGJpdGZpZWxkID0gcmVzcG9uc2UuZGF0YS5iaXRmaWVsZDtcbiAgICByZXR1cm4geyBza3lsaW5rLCBtZXJrbGVyb290LCBiaXRmaWVsZCB9O1xufVxuZXhwb3J0cy51cGxvYWREaXJlY3RvcnkgPSB1cGxvYWREaXJlY3Rvcnk7XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byB1cGxvYWQgYSBkaXJlY3RvcnkgdG8gU2t5bmV0LlxuICpcbiAqIEBwYXJhbSB0aGlzIC0gU2t5bmV0Q2xpZW50XG4gKiBAcGFyYW0gZGlyZWN0b3J5IC0gRmlsZSBvYmplY3RzIHRvIHVwbG9hZCwgaW5kZXhlZCBieSB0aGVpciBwYXRoIHN0cmluZ3MuXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5LlxuICogQHBhcmFtIFtjdXN0b21PcHRpb25zXSAtIEFkZGl0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSBzZXQuXG4gKiBAcGFyYW0gW2N1c3RvbU9wdGlvbnMuZW5kcG9pbnRQYXRoPVwiL3NreW5ldC9za3lmaWxlXCJdIC0gVGhlIHJlbGF0aXZlIFVSTCBwYXRoIG9mIHRoZSBwb3J0YWwgZW5kcG9pbnQgdG8gY29udGFjdC5cbiAqIEByZXR1cm5zIC0gVGhlIHVwbG9hZCByZXNwb25zZS5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBmaWxlbmFtZSBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZERpcmVjdG9yeVJlcXVlc3QoZGlyZWN0b3J5LCBmaWxlbmFtZSwgY3VzdG9tT3B0aW9ucykge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU9iamVjdChcImRpcmVjdG9yeVwiLCBkaXJlY3RvcnksIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcImZpbGVuYW1lXCIsIGZpbGVuYW1lLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVPcHRpb25hbE9iamVjdChcImN1c3RvbU9wdGlvbnNcIiwgY3VzdG9tT3B0aW9ucywgXCJwYXJhbWV0ZXJcIiwgZXhwb3J0cy5kZWZhdWx0VXBsb2FkT3B0aW9ucyk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uZXhwb3J0cy5kZWZhdWx0VXBsb2FkT3B0aW9ucywgLi4udGhpcy5jdXN0b21PcHRpb25zLCAuLi5jdXN0b21PcHRpb25zIH07XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBPYmplY3QuZW50cmllcyhkaXJlY3RvcnkpLmZvckVhY2goKFtwYXRoLCBmaWxlXSkgPT4ge1xuICAgICAgICBmaWxlID0gZW5zdXJlRmlsZU9iamVjdENvbnNpc3RlbmN5KGZpbGUpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQob3B0cy5wb3J0YWxEaXJlY3RvcnlGaWxlRmllbGRuYW1lLCBmaWxlLCBwYXRoKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBlbmRwb2ludFBhdGg6IG9wdHMuZW5kcG9pbnRVcGxvYWQsXG4gICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICBxdWVyeTogeyBmaWxlbmFtZSB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydHMudXBsb2FkRGlyZWN0b3J5UmVxdWVzdCA9IHVwbG9hZERpcmVjdG9yeVJlcXVlc3Q7XG4vKipcbiAqIFNvbWV0aW1lcyBmaWxlIG9iamVjdCBtaWdodCBoYXZlIGhhZCB0aGUgdHlwZSBwcm9wZXJ0eSBkZWZpbmVkIG1hbnVhbGx5IHdpdGhcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgc29tZSBicm93c2VycyAobmFtZWx5IGZpcmVmb3gpIGNhbiBoYXZlIHByb2JsZW1zXG4gKiByZWFkaW5nIGl0IGFmdGVyIHRoZSBmaWxlIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGZvcm0gZGF0YS4gVG8gb3ZlcmNvbWUgdGhpcyxcbiAqIHdlIHJlY3JlYXRlIHRoZSBmaWxlIG9iamVjdCB1c2luZyBuYXRpdmUgRmlsZSBjb25zdHJ1Y3RvciB3aXRoIGEgdHlwZSBkZWZpbmVkXG4gKiBhcyBhIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGlucHV0IGZpbGUuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgZmlsZS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9OZWJ1bG91c0xhYnMvc2t5bmV0LXdlYnBvcnRhbC9pc3N1ZXMvMjkwfCBSZWxhdGVkIElzc3VlfVxuICovXG5mdW5jdGlvbiBlbnN1cmVGaWxlT2JqZWN0Q29uc2lzdGVuY3koZmlsZSkge1xuICAgIHJldHVybiBuZXcgRmlsZShbZmlsZV0sIGZpbGUubmFtZSwgeyB0eXBlOiBmaWxlXzEuZ2V0RmlsZU1pbWVUeXBlKGZpbGUpIH0pO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgZmlsZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWVLaW5kIC0gVGhlIGtpbmQgb2YgdmFsdWUgdGhhdCBpcyBiZWluZyBjaGVja2VkIChlLmcuIFwicGFyYW1ldGVyXCIsIFwicmVzcG9uc2UgZmllbGRcIiwgZXRjLilcbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIG5vdCBhIHZhbGlkIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRmlsZShuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICB2YWxpZGF0aW9uXzEudGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgXCInRmlsZSdcIik7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHVwbG9hZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgdXBsb2FkIHJlc3BvbnNlLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgdXBsb2FkIHJlc3BvbnNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVVwbG9hZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZS5kYXRhIGZpZWxkIG1pc3NpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwic2t5bGlua1wiLCByZXNwb25zZS5kYXRhLnNreWxpbmssIFwidXBsb2FkIHJlc3BvbnNlIGZpZWxkXCIpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJtZXJrbGVyb290XCIsIHJlc3BvbnNlLmRhdGEubWVya2xlcm9vdCwgXCJ1cGxvYWQgcmVzcG9uc2UgZmllbGRcIik7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZU51bWJlcihcImJpdGZpZWxkXCIsIHJlc3BvbnNlLmRhdGEuYml0ZmllbGQsIFwidXBsb2FkIHJlc3BvbnNlIGZpZWxkXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlkIG5vdCBnZXQgYSBjb21wbGV0ZSB1cGxvYWQgcmVzcG9uc2UgZGVzcGl0ZSBhIHN1Y2Nlc3NmdWwgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2FpbiBhbmQgcmVwb3J0IHRoaXMgaXNzdWUgdG8gdGhlIGRldnMgaWYgaXQgcGVyc2lzdHMuIEVycm9yOiAke2Vycn1gKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJlRXF1YWxVaW50OEFycmF5cyA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gdWludDggYXJyYXlzIGFyZSBlcXVhbC4gRnJvbVxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYwODE4MTA1LzYwODUyNDJcbiAqXG4gKiBAcGFyYW0gYXJyYXkxIC0gVGhlIGZpcnN0IHVpbnQ4IGFycmF5LlxuICogQHBhcmFtIGFycmF5MiAtIFRoZSBzZWNvbmQgdWludDggYXJyYXkuXG4gKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIGFyZUVxdWFsVWludDhBcnJheXMoYXJyYXkxLCBhcnJheTIpIHtcbiAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5MVtpXSAhPSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXJlRXF1YWxVaW50OEFycmF5cyA9IGFyZUVxdWFsVWludDhBcnJheXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVXRmOFN0cmluZyA9IGV4cG9ydHMuZW5jb2RlUHJlZml4ZWRCeXRlcyA9IGV4cG9ydHMuZW5jb2RlQmlnaW50QXNVaW50NjQgPSBleHBvcnRzLmVuY29kZU51bWJlciA9IGV4cG9ydHMuZW5jb2RlU2t5bGlua0Jhc2U2NCA9IGV4cG9ydHMuZGVjb2RlU2t5bGlua0Jhc2U2NCA9IGV4cG9ydHMuZW5jb2RlU2t5bGlua0Jhc2UzMiA9IGV4cG9ydHMuZGVjb2RlU2t5bGlua0Jhc2UzMiA9IHZvaWQgMDtcbmNvbnN0IGJhc2UzMl9kZWNvZGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmFzZTMyLWRlY29kZVwiKSk7XG5jb25zdCBiYXNlMzJfZW5jb2RlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJhc2UzMi1lbmNvZGVcIikpO1xuY29uc3QgYmFzZTY0X2pzXzEgPSByZXF1aXJlKFwiYmFzZTY0LWpzXCIpO1xuY29uc3QgbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9udW1iZXJcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbmNvbnN0IEJBU0UzMl9FTkNPRElOR19WQVJJQU5UID0gXCJSRkM0NjQ4LUhFWFwiO1xuLyoqXG4gKiBEZWNvZGVzIHRoZSBza3lsaW5rIGVuY29kZWQgdXNpbmcgYmFzZTMyIGVuY29kaW5nIHRvIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzIC0gVGhlIGVuY29kZWQgc2t5bGluay5cbiAqIEByZXR1cm5zIC0gVGhlIGRlY29kZWQgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVNreWxpbmtCYXNlMzIoc2t5bGluaykge1xuICAgIHNreWxpbmsgPSBza3lsaW5rLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBiYXNlMzJfZGVjb2RlXzEuZGVmYXVsdChza3lsaW5rLCBCQVNFMzJfRU5DT0RJTkdfVkFSSUFOVCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbn1cbmV4cG9ydHMuZGVjb2RlU2t5bGlua0Jhc2UzMiA9IGRlY29kZVNreWxpbmtCYXNlMzI7XG4vKipcbiAqIEVuY29kZXMgdGhlIGJ5dGVzIHRvIGEgc2t5bGluayBlbmNvZGVkIHVzaW5nIGJhc2UzMiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gZW5jb2RlLlxuICogQHJldHVybnMgLSBUaGUgZW5jb2RlZCBza3lsaW5rLlxuICovXG5mdW5jdGlvbiBlbmNvZGVTa3lsaW5rQmFzZTMyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJhc2UzMl9lbmNvZGVfMS5kZWZhdWx0KGJ5dGVzLCBCQVNFMzJfRU5DT0RJTkdfVkFSSUFOVCwgeyBwYWRkaW5nOiBmYWxzZSB9KS50b0xvd2VyQ2FzZSgpO1xufVxuZXhwb3J0cy5lbmNvZGVTa3lsaW5rQmFzZTMyID0gZW5jb2RlU2t5bGlua0Jhc2UzMjtcbi8qKlxuICogRGVjb2RlcyB0aGUgc2t5bGluayBlbmNvZGVkIHVzaW5nIGJhc2U2NCByYXcgVVJMIGVuY29kaW5nIHRvIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzIC0gVGhlIGVuY29kZWQgc2t5bGluay5cbiAqIEByZXR1cm5zIC0gVGhlIGRlY29kZWQgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVNreWxpbmtCYXNlNjQoc2t5bGluaykge1xuICAgIC8vIEFkZCBwYWRkaW5nLlxuICAgIHNreWxpbmsgPSBgJHtza3lsaW5rfT09YDtcbiAgICAvLyBDb252ZXJ0IGZyb20gVVJMIGVuY29kaW5nLlxuICAgIHNreWxpbmsgPSBza3lsaW5rLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIHJldHVybiBiYXNlNjRfanNfMS50b0J5dGVBcnJheShza3lsaW5rKTtcbn1cbmV4cG9ydHMuZGVjb2RlU2t5bGlua0Jhc2U2NCA9IGRlY29kZVNreWxpbmtCYXNlNjQ7XG4vKipcbiAqIEVuY29kZXMgdGhlIGJ5dGVzIHRvIGEgc2t5bGluayBlbmNvZGVkIHVzaW5nIGJhc2U2NCByYXcgVVJMIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyAtIFRoZSBlbmNvZGVkIHNreWxpbmsuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVNreWxpbmtCYXNlNjQoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gYmFzZTY0X2pzXzEuZnJvbUJ5dGVBcnJheShieXRlcyk7XG4gICAgLy8gQ29udmVydCB0byBVUkwgZW5jb2RpbmcuXG4gICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgXCI9PVwiLiBUaGlzIHdpbGwgYWx3YXlzIGJlIHByZXNlbnQgYXMgdGhlIHNreWxpbmsgZW5jb2RpbmdcbiAgICAvLyBnZXRzIHBhZGRlZCBzbyB0aGF0IHRoZSBzdHJpbmcgaXMgYSBtdWx0aXBsZSBvZiA0IGNoYXJhY3RlcnMgaW4gbGVuZ3RoLlxuICAgIHJldHVybiBiYXNlNjQuc2xpY2UoMCwgLTIpO1xufVxuZXhwb3J0cy5lbmNvZGVTa3lsaW5rQmFzZTY0ID0gZW5jb2RlU2t5bGlua0Jhc2U2NDtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIG51bWJlciBpbnRvIGEgdWludDggYXJyYXlcbiAqXG4gKiBAcGFyYW0gbnVtIC0gTnVtYmVyIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIC0gTnVtYmVyIGVuY29kZWQgYXMgYSBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBlbmNvZGVOdW1iZXIobnVtKSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBlbmNvZGVkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBieXRlID0gbnVtICYgMHhmZjtcbiAgICAgICAgZW5jb2RlZFtpbmRleF0gPSBieXRlO1xuICAgICAgICBudW0gPSBudW0gPj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5leHBvcnRzLmVuY29kZU51bWJlciA9IGVuY29kZU51bWJlcjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmlnaW50IGludG8gYSB1aW50OCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gaW50IC0gQmlnaW50IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIC0gQmlnaW50IGVuY29kZWQgYXMgYSBieXRlIGFycmF5LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGludCBkb2VzIG5vdCBmaXQgaW4gNjQgYml0cy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmlnaW50QXNVaW50NjQoaW50KSB7XG4gICAgLy8gQXNzZXJ0IHRoZSBpbnB1dCBpcyA2NCBiaXRzLlxuICAgIG51bWJlcl8xLmFzc2VydFVpbnQ2NChpbnQpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZW5jb2RlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGludCAmIEJpZ0ludCgweGZmKTtcbiAgICAgICAgZW5jb2RlZFtpbmRleF0gPSBOdW1iZXIoYnl0ZSk7XG4gICAgICAgIGludCA9IGludCA+PiBCaWdJbnQoOCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkO1xufVxuZXhwb3J0cy5lbmNvZGVCaWdpbnRBc1VpbnQ2NCA9IGVuY29kZUJpZ2ludEFzVWludDY0O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSB1aW50OGFycmF5LCBwcmVmaXhlZCBieSBpdHMgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBpbnB1dCBhcnJheS5cbiAqIEByZXR1cm5zIC0gVGhlIGVuY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlUHJlZml4ZWRCeXRlcyhieXRlcykge1xuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoOCArIGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpO1xuICAgIC8vIFNpYSB1c2VzIHNldFVpbnQ2NCB3aGljaCBpcyB1bmF2YWlsYWJsZSBpbiBKUy5cbiAgICB2aWV3LnNldFVpbnQzMigwLCBsZW4sIHRydWUpO1xuICAgIGNvbnN0IHVpbnQ4Qnl0ZXMgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHVpbnQ4Qnl0ZXMuc2V0KGJ5dGVzLCA4KTtcbiAgICByZXR1cm4gdWludDhCeXRlcztcbn1cbmV4cG9ydHMuZW5jb2RlUHJlZml4ZWRCeXRlcyA9IGVuY29kZVByZWZpeGVkQnl0ZXM7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIFVURi04IHN0cmluZyBpbnRvIGEgdWludDggYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIGxlbmd0aCBhbmQgdGhlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIC0gU3RyaW5nIGVuY29kZWQgYXMgYSBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBlbmNvZGVVdGY4U3RyaW5nKHN0cikge1xuICAgIGNvbnN0IGJ5dGVBcnJheSA9IHN0cmluZ18xLnN0cmluZ1RvVWludDhBcnJheVV0Zjgoc3RyKTtcbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoOCArIGJ5dGVBcnJheS5sZW5ndGgpO1xuICAgIGVuY29kZWQuc2V0KGVuY29kZU51bWJlcihieXRlQXJyYXkubGVuZ3RoKSk7XG4gICAgZW5jb2RlZC5zZXQoYnl0ZUFycmF5LCA4KTtcbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmV4cG9ydHMuZW5jb2RlVXRmOFN0cmluZyA9IGVuY29kZVV0ZjhTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RmlsZU1pbWVUeXBlID0gZXhwb3J0cy5nZXRSb290RGlyZWN0b3J5ID0gZXhwb3J0cy5nZXRSZWxhdGl2ZUZpbGVQYXRoID0gdm9pZCAwO1xuY29uc3QgbGl0ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtaW1lL2xpdGVcIikpO1xuY29uc3QgcGF0aF9icm93c2VyaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGgtYnJvd3NlcmlmeVwiKSk7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbi8qKlxuICogR2V0cyB0aGUgcGF0aCBmb3IgdGhlIGZpbGUuXG4gKlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZS5cbiAqIEByZXR1cm5zIC0gVGhlIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVQYXRoKGZpbGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aCB8fCBmaWxlLnBhdGggfHwgZmlsZS5uYW1lO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBmaWxlIHBhdGggcmVsYXRpdmUgdG8gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBwYXRoLCBlLmcuIGBiYXJgIGluIGAvZm9vL2JhcmAuXG4gKlxuICogQHBhcmFtIGZpbGUgLSBUaGUgaW5wdXQgZmlsZS5cbiAqIEByZXR1cm5zIC0gVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVGaWxlUGF0aChmaWxlKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBnZXRGaWxlUGF0aChmaWxlKTtcbiAgICBjb25zdCB7IHJvb3QsIGRpciwgYmFzZSB9ID0gcGF0aF9icm93c2VyaWZ5XzEuZGVmYXVsdC5wYXJzZShmaWxlUGF0aCk7XG4gICAgY29uc3QgcmVsYXRpdmUgPSBwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0Lm5vcm1hbGl6ZShkaXIpLnNsaWNlKHJvb3QubGVuZ3RoKS5zcGxpdChwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0LnNlcCkuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHBhdGhfYnJvd3NlcmlmeV8xLmRlZmF1bHQuam9pbiguLi5yZWxhdGl2ZSwgYmFzZSk7XG59XG5leHBvcnRzLmdldFJlbGF0aXZlRmlsZVBhdGggPSBnZXRSZWxhdGl2ZUZpbGVQYXRoO1xuLyoqXG4gKiBHZXRzIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgZmlsZSBwYXRoLCBlLmcuIGBmb29gIGluIGAvZm9vL2JhcmAuXG4gKlxuICogQHBhcmFtIGZpbGUgLSBUaGUgaW5wdXQgZmlsZS5cbiAqIEByZXR1cm5zIC0gVGhlIHJvb3QgZGlyZWN0b3J5LlxuICovXG5mdW5jdGlvbiBnZXRSb290RGlyZWN0b3J5KGZpbGUpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGdldEZpbGVQYXRoKGZpbGUpO1xuICAgIGNvbnN0IHsgcm9vdCwgZGlyIH0gPSBwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0LnBhcnNlKGZpbGVQYXRoKTtcbiAgICByZXR1cm4gcGF0aF9icm93c2VyaWZ5XzEuZGVmYXVsdC5ub3JtYWxpemUoZGlyKS5zbGljZShyb290Lmxlbmd0aCkuc3BsaXQocGF0aF9icm93c2VyaWZ5XzEuZGVmYXVsdC5zZXApWzBdO1xufVxuZXhwb3J0cy5nZXRSb290RGlyZWN0b3J5ID0gZ2V0Um9vdERpcmVjdG9yeTtcbi8qKlxuICogR2V0IHRoZSBmaWxlIG1pbWUgdHlwZS4gSW4gY2FzZSB0aGUgdHlwZSBpcyBub3QgcHJvdmlkZWQsIHVzZSBtaW1lLWRiIGFuZCB0cnlcbiAqIHRvIGd1ZXNzIHRoZSBmaWxlIHR5cGUgYmFzZWQgb24gdGhlIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlLlxuICogQHJldHVybnMgLSBUaGUgbWltZSB0eXBlLlxuICovXG5mdW5jdGlvbiBnZXRGaWxlTWltZVR5cGUoZmlsZSkge1xuICAgIGlmIChmaWxlLnR5cGUpXG4gICAgICAgIHJldHVybiBmaWxlLnR5cGU7XG4gICAgbGV0IHsgZXh0IH0gPSBwYXRoX2Jyb3dzZXJpZnlfMS5kZWZhdWx0LnBhcnNlKGZpbGUubmFtZSk7XG4gICAgZXh0ID0gc3RyaW5nXzEudHJpbVByZWZpeChleHQsIFwiLlwiKTtcbiAgICBpZiAoZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbGl0ZV8xLmRlZmF1bHQuZ2V0VHlwZShleHQpO1xuICAgICAgICBpZiAobWltZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmV4cG9ydHMuZ2V0RmlsZU1pbWVUeXBlID0gZ2V0RmlsZU1pbWVUeXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFVpbnQ2NCA9IGV4cG9ydHMuTUFYX1JFVklTSU9OID0gdm9pZCAwO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbi8qKlxuICogVGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgYW4gZW50cnkgcmV2aXNpb24uIFNldHRpbmcgYW4gZW50cnkgcmV2aXNpb24gdG8gdGhpcyB2YWx1ZSBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHVwZGF0ZWQgZnVydGhlci5cbiAqL1xuZXhwb3J0cy5NQVhfUkVWSVNJT04gPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTsgLy8gbWF4IHVpbnQ2NFxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGJpZ2ludCBjYW4gZml0IGluIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQHBhcmFtIGludCAtIFRoZSBwcm92aWRlZCBpbnRlZ2VyLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGludCBkb2VzIG5vdCBmaXQgaW4gNjQgYml0cy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0JpZ0ludC9hc1VpbnROIHwgTUROIERlbW99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVpbnQ2NChpbnQpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVCaWdpbnQoXCJpbnRcIiwgaW50LCBcInBhcmFtZXRlclwiKTtcbiAgICBpZiAoaW50IDwgQmlnSW50KDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJHtpbnR9IG11c3QgYmUgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXI7IHdhcyBuZWdhdGl2ZWApO1xuICAgIH1cbiAgICBpZiAoaW50ID4gZXhwb3J0cy5NQVhfUkVWSVNJT04pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAke2ludH0gZG9lcyBub3QgZml0IGluIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXI7IGV4Y2VlZHMgMl42NC0xYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRVaW50NjQgPSBhc3NlcnRVaW50NjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRCYXNlT3B0aW9ucyA9IHZvaWQgMDtcbi8qKlxuICogVGhlIGRlZmF1bHQgYmFzZSBjdXN0b20gb3B0aW9ucy5cbiAqL1xuZXhwb3J0cy5kZWZhdWx0QmFzZU9wdGlvbnMgPSB7XG4gICAgQVBJS2V5OiBcIlwiLFxuICAgIGN1c3RvbVVzZXJBZ2VudDogXCJcIixcbiAgICBjdXN0b21Db29raWU6IFwiXCIsXG4gICAgb25VcGxvYWRQcm9ncmVzczogdW5kZWZpbmVkLFxufTtcbi8qKlxuICogRXh0cmFjdCBvbmx5IHRoZSBtb2RlbCdzIGN1c3RvbSBvcHRpb25zIGZyb20gdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdHMgLSBUaGUgZ2l2ZW4gb3B0aW9ucy5cbiAqIEBwYXJhbSBtb2RlbCAtIFRoZSBtb2RlbCBvcHRpb25zLlxuICogQHJldHVybnMgLSBUaGUgZXh0cmFjdGVkIGN1c3RvbSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBleHRyYWN0T3B0aW9ucyhvcHRzLCBtb2RlbCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gbW9kZWwpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2RlbCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gb3B0c1twcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZXh0cmFjdE9wdGlvbnMgPSBleHRyYWN0T3B0aW9ucztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0hleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmhleFRvVWludDhBcnJheSA9IGV4cG9ydHMudWludDhBcnJheVRvU3RyaW5nVXRmOCA9IGV4cG9ydHMuc3RyaW5nVG9VaW50OEFycmF5VXRmOCA9IGV4cG9ydHMudHJpbVVyaVByZWZpeCA9IGV4cG9ydHMudHJpbVN1ZmZpeCA9IGV4cG9ydHMudHJpbVByZWZpeCA9IGV4cG9ydHMudHJpbUZvcndhcmRTbGFzaCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG4vKipcbiAqIFJlbW92ZXMgc2xhc2hlcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0cmltRm9yd2FyZFNsYXNoKHN0cikge1xuICAgIHJldHVybiB0cmltUHJlZml4KHRyaW1TdWZmaXgoc3RyLCBcIi9cIiksIFwiL1wiKTtcbn1cbmV4cG9ydHMudHJpbUZvcndhcmRTbGFzaCA9IHRyaW1Gb3J3YXJkU2xhc2g7XG4vLyBUT0RPOiBNb3ZlIHRvIG15c2t5LXV0aWxzXG4vKipcbiAqIFJlbW92ZXMgYSBwcmVmaXggZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBwcmVmaXggLSBUaGUgcHJlZml4IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbbGltaXRdIC0gTWF4aW11bSBhbW91bnQgb2YgdGltZXMgdG8gdHJpbS4gTm8gbGltaXQgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIC0gVGhlIHByb2Nlc3NlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRyaW1QcmVmaXgoc3RyLCBwcmVmaXgsIGxpbWl0KSB7XG4gICAgd2hpbGUgKHN0ci5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIGxpbWl0IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVByZWZpeCA9IHRyaW1QcmVmaXg7XG4vLyBUT0RPOiBNb3ZlIHRvIG15c2t5LXV0aWxzXG4vKipcbiAqIFJlbW92ZXMgYSBzdWZmaXggZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBzdWZmaXggLSBUaGUgc3VmZml4IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbbGltaXRdIC0gTWF4aW11bSBhbW91bnQgb2YgdGltZXMgdG8gdHJpbS4gTm8gbGltaXQgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIC0gVGhlIHByb2Nlc3NlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRyaW1TdWZmaXgoc3RyLCBzdWZmaXgsIGxpbWl0KSB7XG4gICAgd2hpbGUgKHN0ci5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIGxpbWl0IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVN1ZmZpeCA9IHRyaW1TdWZmaXg7XG4vKipcbiAqIFJlbW92ZXMgYSBVUkkgcHJlZml4IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gcHJlZml4IC0gVGhlIHByZWZpeCB0byByZW1vdmUuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0cmltVXJpUHJlZml4KHN0ciwgcHJlZml4KSB7XG4gICAgY29uc3Qgc2hvcnRQcmVmaXggPSB0cmltU3VmZml4KHByZWZpeCwgXCIvXCIpO1xuICAgIGlmIChzdHIuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIC8vIGxvbmdQcmVmaXggaXMgZXhhY3RseSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIHJldHVybiBzdHIuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChzdHIuc3RhcnRzV2l0aChzaG9ydFByZWZpeCkpIHtcbiAgICAgICAgLy8gZWxzZSBwcmVmaXggaXMgZXhhY3RseSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIHJldHVybiBzdHIuc2xpY2Uoc2hvcnRQcmVmaXgubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudHJpbVVyaVByZWZpeCA9IHRyaW1VcmlQcmVmaXg7XG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgdWludDggYXJyYXkgY29udGFpbmluZyB2YWxpZCBVVEYtOCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgLSBUaGUgdWludDggYXJyYXkuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXlVdGY4KHN0cikge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInN0clwiLCBzdHIsIFwicGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyXzEuQnVmZmVyLmZyb20oc3RyLCBcInV0Zi04XCIpKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9VaW50OEFycmF5VXRmOCA9IHN0cmluZ1RvVWludDhBcnJheVV0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgdWludDggYXJyYXkgY29udGFpbmluZyB2YWxpZCB1dGYtOCBieXRlcyB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgdWludDggYXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvU3RyaW5nVXRmOChhcnJheSkge1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShhcnJheSkudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbn1cbmV4cG9ydHMudWludDhBcnJheVRvU3RyaW5nVXRmOCA9IHVpbnQ4QXJyYXlUb1N0cmluZ1V0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgdWludDggYXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIHVpbnQ4IGFycmF5LlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIGhleC1lbmNvZGVkIHN0cmluZyBvciBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleFRvVWludDhBcnJheShzdHIpIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVIZXhTdHJpbmcoXCJzdHJcIiwgc3RyLCBcInBhcmFtZXRlclwiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gc3RyLm1hdGNoKC8uezEsMn0vZyk7XG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvbl8xLnRocm93VmFsaWRhdGlvbkVycm9yKFwic3RyXCIsIHN0ciwgXCJwYXJhbWV0ZXJcIiwgXCJhIGhleC1lbmNvZGVkIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hdGNoZXMubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbn1cbmV4cG9ydHMuaGV4VG9VaW50OEFycmF5ID0gaGV4VG9VaW50OEFycmF5O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIGEgdmFsaWQgaGV4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nLlxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBpbnB1dCBpcyBoZXgtZW5jb2RlZC5cbiAqIEB0aHJvd3MgLSBXaWxsIHRocm93IGlmIHRoZSBpbnB1dCBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHN0cikge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInN0clwiLCBzdHIsIFwicGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiAvXlswLTlBLUZhLWZdKiQvZy50ZXN0KHN0cik7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZUFycmF5IC0gVGhlIGJ5dGUgYXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIC0gVGhlIGhleCBzdHJpbmcuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ2MDg4MTl8U3RhY2sgT3ZlcmZsb3d9XG4gKi9cbmZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ5dGVBcnJheSkge1xuICAgIGxldCBzID0gXCJcIjtcbiAgICBieXRlQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICBzICs9IChcIjBcIiArIChieXRlICYgMHhmZikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG59XG5leHBvcnRzLnRvSGV4U3RyaW5nID0gdG9IZXhTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdERvbWFpbkZvclBvcnRhbCA9IGV4cG9ydHMuZ2V0RnVsbERvbWFpblVybEZvclBvcnRhbCA9IGV4cG9ydHMubWFrZVVybCA9IGV4cG9ydHMuYWRkVXJsUXVlcnkgPSBleHBvcnRzLmFkZFN1YmRvbWFpbiA9IGV4cG9ydHMuYWRkUGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBvcnRhbFVybCA9IGV4cG9ydHMudXJpU2t5bmV0UHJlZml4ID0gZXhwb3J0cy51cmlIYW5kc2hha2VQcmVmaXggPSBleHBvcnRzLmRlZmF1bHRTa3luZXRQb3J0YWxVcmwgPSB2b2lkIDA7XG5jb25zdCB1cmxfcGFyc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXJsLXBhcnNlXCIpKTtcbmNvbnN0IHVybF9qb2luXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybC1qb2luXCIpKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmV4cG9ydHMuZGVmYXVsdFNreW5ldFBvcnRhbFVybCA9IFwiaHR0cHM6Ly9zaWFza3kubmV0XCI7XG5leHBvcnRzLnVyaUhhbmRzaGFrZVByZWZpeCA9IFwiaG5zOi8vXCI7XG5leHBvcnRzLnVyaVNreW5ldFByZWZpeCA9IFwic2lhOi8vXCI7XG4vLyBUT0RPOiBUaGlzIHdpbGwgYmUgc21hcnRlci4gU2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTmVidWxvdXNMYWJzL3NreW5ldC1kb2NzL2lzc3Vlcy8yMS5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBwb3J0YWwgVVJMLlxuICpcbiAqIEByZXR1cm5zIC0gVGhlIHBvcnRhbCBVUkwuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0YWxVcmwoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIFwiL1wiOyAvLyBkZWZhdWx0IHRvIHBhdGggcm9vdCBvbiBzc3JcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbn1cbmV4cG9ydHMuZGVmYXVsdFBvcnRhbFVybCA9IGRlZmF1bHRQb3J0YWxVcmw7XG4vKipcbiAqIEFkZHMgYSBwYXRoIHRvIHRoZSBnaXZlbiBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBnaXZlbiBwYXRoLlxuICogQHJldHVybnMgLSBUaGUgZmluYWwgVVJMLlxuICovXG5mdW5jdGlvbiBhZGRQYXRoKHVybCwgcGF0aCkge1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInVybFwiLCB1cmwsIFwicGFyYW1ldGVyXCIpO1xuICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVN0cmluZyhcInBhdGhcIiwgcGF0aCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgcGF0aCA9IHN0cmluZ18xLnRyaW1Gb3J3YXJkU2xhc2gocGF0aCk7XG4gICAgbGV0IHN0cjtcbiAgICBpZiAodXJsID09PSBcImxvY2FsaG9zdFwiKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGxvY2FsaG9zdC5cbiAgICAgICAgc3RyID0gYGxvY2FsaG9zdC8ke3BhdGh9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIFVSTCBvYmplY3QgYW5kIHNldCB0aGUgcGF0aG5hbWUgcHJvcGVydHkuXG4gICAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aDtcbiAgICAgICAgc3RyID0gdXJsT2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdfMS50cmltU3VmZml4KHN0ciwgXCIvXCIpO1xufVxuZXhwb3J0cy5hZGRQYXRoID0gYWRkUGF0aDtcbi8qKlxuICogQWRkcyBhIHN1YmRvbWFpbiB0byB0aGUgZ2l2ZW4gVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMLlxuICogQHBhcmFtIHN1YmRvbWFpbiAtIFRoZSBzdWJkb21haW4gdG8gYWRkLlxuICogQHJldHVybnMgLSBUaGUgZmluYWwgVVJMLlxuICovXG5mdW5jdGlvbiBhZGRTdWJkb21haW4odXJsLCBzdWJkb21haW4pIHtcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgdXJsT2JqLmhvc3RuYW1lID0gYCR7c3ViZG9tYWlufS4ke3VybE9iai5ob3N0bmFtZX1gO1xuICAgIGNvbnN0IHN0ciA9IHVybE9iai50b1N0cmluZygpO1xuICAgIHJldHVybiBzdHJpbmdfMS50cmltU3VmZml4KHN0ciwgXCIvXCIpO1xufVxuZXhwb3J0cy5hZGRTdWJkb21haW4gPSBhZGRTdWJkb21haW47XG4vKipcbiAqIEFkZHMgYSBxdWVyeSB0byB0aGUgZ2l2ZW4gVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMLlxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyAtIFRoZSBmaW5hbCBVUkwuXG4gKi9cbmZ1bmN0aW9uIGFkZFVybFF1ZXJ5KHVybCwgcXVlcnkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB1cmxfcGFyc2VfMS5kZWZhdWx0KHVybCwgdHJ1ZSk7XG4gICAgLy8gQ29tYmluZSB0aGUgZGVzaXJlZCBxdWVyeSBwYXJhbXMgd2l0aCB0aGUgYWxyZWFkeSBleGlzdGluZyBvbmVzLlxuICAgIHF1ZXJ5ID0geyAuLi5wYXJzZWQucXVlcnksIC4uLnF1ZXJ5IH07XG4gICAgcGFyc2VkLnNldChcInF1ZXJ5XCIsIHF1ZXJ5KTtcbiAgICByZXR1cm4gcGFyc2VkLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLmFkZFVybFF1ZXJ5ID0gYWRkVXJsUXVlcnk7XG4vKipcbiAqIFByb3Blcmx5IGpvaW5zIHBhdGhzIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIFVSTC4gVGFrZXMgYSB2YXJpYWJsZSBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIEFycmF5IG9mIFVSTCBwYXJ0cyB0byBqb2luLlxuICogQHJldHVybnMgLSBGaW5hbCBVUkwgY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5wdXQgcGFydHMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VVcmwoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWxpZGF0aW9uXzEudGhyb3dWYWxpZGF0aW9uRXJyb3IoXCJhcmdzXCIsIGFyZ3MsIFwicGFyYW1ldGVyXCIsIFwibm9uLWVtcHR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB1cmxfam9pbl8xLmRlZmF1bHQoYWNjLCBjdXIpKTtcbn1cbmV4cG9ydHMubWFrZVVybCA9IG1ha2VVcmw7XG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gZG9tYWluLFxuICogZS5nLiAoXCJodHRwczovL3NpYXNreS5uZXRcIiwgXCJkYWMuaG5zL3BhdGgvZmlsZVwiKSA9PiBcImh0dHBzOi8vZGFjLmhucy5zaWFza3kubmV0L3BhdGgvZmlsZVwiXG4gKlxuICogQHBhcmFtIHBvcnRhbFVybCAtIFRoZSBwb3J0YWwgVVJMLlxuICogQHBhcmFtIGRvbWFpbiAtIERvbWFpbi5cbiAqIEByZXR1cm5zIC0gVGhlIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gZG9tYWluLlxuICovXG5mdW5jdGlvbiBnZXRGdWxsRG9tYWluVXJsRm9yUG9ydGFsKHBvcnRhbFVybCwgZG9tYWluKSB7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwicG9ydGFsVXJsXCIsIHBvcnRhbFVybCwgXCJwYXJhbWV0ZXJcIik7XG4gICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlU3RyaW5nKFwiZG9tYWluXCIsIGRvbWFpbiwgXCJwYXJhbWV0ZXJcIik7XG4gICAgZG9tYWluID0gc3RyaW5nXzEudHJpbVVyaVByZWZpeChkb21haW4sIGV4cG9ydHMudXJpU2t5bmV0UHJlZml4KTtcbiAgICBkb21haW4gPSBzdHJpbmdfMS50cmltRm9yd2FyZFNsYXNoKGRvbWFpbik7XG4gICAgLy8gU3BsaXQgb24gZmlyc3QgLyB0byBnZXQgdGhlIHBhdGguXG4gICAgbGV0IHBhdGg7XG4gICAgW2RvbWFpbiwgcGF0aF0gPSBkb21haW4uc3BsaXQoL1xcLyguKykvKTtcbiAgICAvLyBBZGQgdG8gc3ViZG9tYWluLlxuICAgIGxldCB1cmw7XG4gICAgaWYgKGRvbWFpbiA9PT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBsb2NhbGhvc3QuXG4gICAgICAgIHVybCA9IFwibG9jYWxob3N0XCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSBhZGRTdWJkb21haW4ocG9ydGFsVXJsLCBkb21haW4pO1xuICAgIH1cbiAgICAvLyBBZGQgYmFjayB0aGUgcGF0aCBpZiB0aGVyZSB3YXMgb25lLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHVybCA9IGFkZFBhdGgodXJsLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMuZ2V0RnVsbERvbWFpblVybEZvclBvcnRhbCA9IGdldEZ1bGxEb21haW5VcmxGb3JQb3J0YWw7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBkb21haW4gZnJvbSB0aGUgZ2l2ZW4gcG9ydGFsIFVSTCxcbiAqIGUuZy4gKFwiaHR0cHM6Ly9zaWFza3kubmV0XCIsIFwiZGFjLmhucy5zaWFza3kubmV0L3BhdGgvZmlsZVwiKSA9PiBcImRhYy5obnMvcGF0aC9maWxlXCJcbiAqXG4gKiBAcGFyYW0gcG9ydGFsVXJsIC0gVGhlIHBvcnRhbCBVUkwuXG4gKiBAcGFyYW0gZnVsbERvbWFpbiAtIEZ1bGwgVVJMLlxuICogQHJldHVybnMgLSBUaGUgZXh0cmFjdGVkIGRvbWFpbi5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdERvbWFpbkZvclBvcnRhbChwb3J0YWxVcmwsIGZ1bGxEb21haW4pIHtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJwb3J0YWxVcmxcIiwgcG9ydGFsVXJsLCBcInBhcmFtZXRlclwiKTtcbiAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVTdHJpbmcoXCJmdWxsRG9tYWluXCIsIGZ1bGxEb21haW4sIFwicGFyYW1ldGVyXCIpO1xuICAgIGxldCBwYXRoO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHRoZSBkb21haW4gZnJvbSB0aGUgZnVsbERvbWFpbi5cbiAgICAgICAgY29uc3QgZnVsbERvbWFpbk9iaiA9IG5ldyBVUkwoZnVsbERvbWFpbik7XG4gICAgICAgIGZ1bGxEb21haW4gPSBmdWxsRG9tYWluT2JqLmhvc3RuYW1lO1xuICAgICAgICBwYXRoID0gZnVsbERvbWFpbk9iai5wYXRobmFtZTtcbiAgICAgICAgcGF0aCA9IHN0cmluZ18xLnRyaW1Gb3J3YXJkU2xhc2gocGF0aCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gSWYgZnVsbERvbWFpbiBpcyBub3QgYSBVUkwsIGlnbm9yZSB0aGUgZXJyb3IgYW5kIHVzZSBpdCBhcy1pcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVHJpbSBhbnkgc2xhc2hlcyBmcm9tIHRoZSBpbnB1dCBVUkwuXG4gICAgICAgIGZ1bGxEb21haW4gPSBzdHJpbmdfMS50cmltRm9yd2FyZFNsYXNoKGZ1bGxEb21haW4pO1xuICAgICAgICAvLyBTcGxpdCBvbiBmaXJzdCAvIHRvIGdldCB0aGUgcGF0aC5cbiAgICAgICAgW2Z1bGxEb21haW4sIHBhdGhdID0gZnVsbERvbWFpbi5zcGxpdCgvXFwvKC4rKS8pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHBvcnRhbCBkb21haW4uXG4gICAgY29uc3QgcG9ydGFsVXJsT2JqID0gbmV3IFVSTChwb3J0YWxVcmwpO1xuICAgIGNvbnN0IHBvcnRhbERvbWFpbiA9IHN0cmluZ18xLnRyaW1Gb3J3YXJkU2xhc2gocG9ydGFsVXJsT2JqLmhvc3RuYW1lKTtcbiAgICAvLyBSZW1vdmUgdGhlIHBvcnRhbCBkb21haW4gZnJvbSB0aGUgZG9tYWluLlxuICAgIGxldCBkb21haW4gPSBzdHJpbmdfMS50cmltU3VmZml4KGZ1bGxEb21haW4sIHBvcnRhbERvbWFpbiwgMSk7XG4gICAgZG9tYWluID0gc3RyaW5nXzEudHJpbVN1ZmZpeChkb21haW4sIFwiLlwiKTtcbiAgICAvLyBBZGQgYmFjayB0aGUgcGF0aCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgaWYgKHBhdGggJiYgcGF0aCAhPT0gXCJcIikge1xuICAgICAgICBwYXRoID0gc3RyaW5nXzEudHJpbUZvcndhcmRTbGFzaChwYXRoKTtcbiAgICAgICAgZG9tYWluID0gYCR7ZG9tYWlufS8ke3BhdGh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbWFpbjtcbn1cbmV4cG9ydHMuZXh0cmFjdERvbWFpbkZvclBvcnRhbCA9IGV4dHJhY3REb21haW5Gb3JQb3J0YWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGhyb3dWYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLnZhbGlkYXRlVWludDhBcnJheUxlbiA9IGV4cG9ydHMudmFsaWRhdGVVaW50OEFycmF5ID0gZXhwb3J0cy52YWxpZGF0ZUhleFN0cmluZyA9IGV4cG9ydHMudmFsaWRhdGVTdHJpbmdMZW4gPSBleHBvcnRzLnZhbGlkYXRlU3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZU51bWJlciA9IGV4cG9ydHMudmFsaWRhdGVPcHRpb25hbE9iamVjdCA9IGV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSBleHBvcnRzLnZhbGlkYXRlQmlnaW50ID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdcIik7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSBiaWdpbnQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQmlnaW50KG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwidHlwZSAnYmlnaW50J1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQmlnaW50ID0gdmFsaWRhdGVCaWdpbnQ7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBcInR5cGUgJ29iamVjdCdcIik7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBcIm5vbi1udWxsXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBnaXZlbiB2YWx1ZSBhcyBhbiBvcHRpb25hbCBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAcGFyYW0gbW9kZWwgLSBBIG1vZGVsIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBmaWVsZHMuICd2YWx1ZScgZG9lcyBub3QgbmVlZCB0byBoYXZlIGFsbCBmaWVsZHMsIGJ1dCBpdCBtYXkgbm90IGhhdmUgYW55IGZpZWxkcyBub3QgY29udGFpbmVkIGluICdtb2RlbCcuXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCBvcHRpb25hbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxPYmplY3QobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgbW9kZWwpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgb2theSwgdGhlIG9iamVjdCBpcyBvcHRpb25hbC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YWxpZGF0ZU9iamVjdChuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKTtcbiAgICAvLyBDaGVjayBpZiBhbGwgZ2l2ZW4gcHJvcGVydGllcyBvZiB2YWx1ZSBhbHNvIGV4aXN0IGluIHRoZSBtb2RlbC5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIG1vZGVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgJHt2YWx1ZUtpbmR9ICcke25hbWV9JyBjb250YWlucyB1bmV4cGVjdGVkIHByb3BlcnR5ICcke3Byb3BlcnR5fSdgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVPcHRpb25hbE9iamVjdCA9IHZhbGlkYXRlT3B0aW9uYWxPYmplY3Q7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwidHlwZSAnbnVtYmVyJ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlTnVtYmVyID0gdmFsaWRhdGVOdW1iZXI7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwidHlwZSAnc3RyaW5nJ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU3RyaW5nID0gdmFsaWRhdGVTdHJpbmc7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSBzdHJpbmcgb2YgdGhlIGdpdmVuIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWVLaW5kIC0gVGhlIGtpbmQgb2YgdmFsdWUgdGhhdCBpcyBiZWluZyBjaGVja2VkIChlLmcuIFwicGFyYW1ldGVyXCIsIFwicmVzcG9uc2UgZmllbGRcIiwgZXRjLilcbiAqIEBwYXJhbSBsZW4gLSBUaGUgbGVuZ3RoIHRvIGNoZWNrLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgc3RyaW5nIG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nTGVuKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIGxlbikge1xuICAgIHZhbGlkYXRlU3RyaW5nKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpO1xuICAgIGNvbnN0IGFjdHVhbExlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAoYWN0dWFsTGVuICE9PSBsZW4pIHtcbiAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgYCdzdHJpbmcnIG9mIGxlbmd0aCAke2xlbn0sIHdhcyBsZW5ndGggJHthY3R1YWxMZW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVN0cmluZ0xlbiA9IHZhbGlkYXRlU3RyaW5nTGVuO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgaGV4LWVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhleFN0cmluZyhuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kKSB7XG4gICAgdmFsaWRhdGVTdHJpbmcobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgaWYgKCFzdHJpbmdfMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgXCJhIGhleC1lbmNvZGVkIHN0cmluZ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlSGV4U3RyaW5nID0gdmFsaWRhdGVIZXhTdHJpbmc7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdmFsdWUgYXMgYSB1aW50OGFycmF5LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgbm90IGEgdmFsaWQgdWludDhhcnJheS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVVaW50OEFycmF5KG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93VmFsaWRhdGlvbkVycm9yKG5hbWUsIHZhbHVlLCB2YWx1ZUtpbmQsIFwiJ1VpbnQ4QXJyYXknXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVVaW50OEFycmF5ID0gdmFsaWRhdGVVaW50OEFycmF5O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFzIGEgdWludDhhcnJheSBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZUtpbmQgLSBUaGUga2luZCBvZiB2YWx1ZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWQgKGUuZy4gXCJwYXJhbWV0ZXJcIiwgXCJyZXNwb25zZSBmaWVsZFwiLCBldGMuKVxuICogQHBhcmFtIGxlbiAtIFRoZSBsZW5ndGggdG8gY2hlY2suXG4gKiBAdGhyb3dzIC0gV2lsbCB0aHJvdyBpZiBub3QgYSB2YWxpZCB1aW50OGFycmF5IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVWludDhBcnJheUxlbihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBsZW4pIHtcbiAgICB2YWxpZGF0ZVVpbnQ4QXJyYXkobmFtZSwgdmFsdWUsIHZhbHVlS2luZCk7XG4gICAgY29uc3QgYWN0dWFsTGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIGlmIChhY3R1YWxMZW4gIT09IGxlbikge1xuICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihuYW1lLCB2YWx1ZSwgdmFsdWVLaW5kLCBgJ1VpbnQ4QXJyYXknIG9mIGxlbmd0aCAke2xlbn0sIHdhcyBsZW5ndGggJHthY3R1YWxMZW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVVpbnQ4QXJyYXlMZW4gPSB2YWxpZGF0ZVVpbnQ4QXJyYXlMZW47XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBmb3IgdGhlIGdpdmVuIHZhbHVlXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYWN0dWFsIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlS2luZCAtIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQgaXMgYmVpbmcgY2hlY2tlZCAoZS5nLiBcInBhcmFtZXRlclwiLCBcInJlc3BvbnNlIGZpZWxkXCIsIGV0Yy4pXG4gKiBAcGFyYW0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgYXNwZWN0IG9mIHRoZSB2YWx1ZSB0aGF0IGNvdWxkIG5vdCBiZSB2YWxpZGF0ZWQgKGUuZy4gXCJ0eXBlICdzdHJpbmcnXCIgb3IgXCJub24tbnVsbFwiKS5cbiAqIEB0aHJvd3MgLSBXaWxsIGFsd2F5cyB0aHJvdy5cbiAqL1xuZnVuY3Rpb24gdGhyb3dWYWxpZGF0aW9uRXJyb3IobmFtZSwgdmFsdWUsIHZhbHVlS2luZCwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dmFsdWVLaW5kfSAnJHtuYW1lfScgdG8gYmUgJHtleHBlY3RlZH0sIHdhcyAnJHt2YWx1ZX0nYCk7XG59XG5leHBvcnRzLnRocm93VmFsaWRhdGlvbkVycm9yID0gdGhyb3dWYWxpZGF0aW9uRXJyb3I7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcih0aW1lb3V0RXJyb3JNZXNzYWdlLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCJ2YXIgUkZDNDY0OCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NydcbnZhciBSRkM0NjQ4X0hFWCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVidcbnZhciBDUk9DS0ZPUkQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonXG5cbmZ1bmN0aW9uIHJlYWRDaGFyIChhbHBoYWJldCwgY2hhcikge1xuICB2YXIgaWR4ID0gYWxwaGFiZXQuaW5kZXhPZihjaGFyKVxuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZDogJyArIGNoYXIpXG4gIH1cblxuICByZXR1cm4gaWR4XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTMyRGVjb2RlIChpbnB1dCwgdmFyaWFudCkge1xuICB2YXIgYWxwaGFiZXRcblxuICBzd2l0Y2ggKHZhcmlhbnQpIHtcbiAgICBjYXNlICdSRkMzNTQ4JzpcbiAgICBjYXNlICdSRkM0NjQ4JzpcbiAgICAgIGFscGhhYmV0ID0gUkZDNDY0OFxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC89KyQvLCAnJylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnUkZDNDY0OC1IRVgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4X0hFWFxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC89KyQvLCAnJylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnQ3JvY2tmb3JkJzpcbiAgICAgIGFscGhhYmV0ID0gQ1JPQ0tGT1JEXG4gICAgICBpbnB1dCA9IGlucHV0LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UzMiB2YXJpYW50OiAnICsgdmFyaWFudClcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGhcblxuICB2YXIgYml0cyA9IDBcbiAgdmFyIHZhbHVlID0gMFxuXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KChsZW5ndGggKiA1IC8gOCkgfCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA1KSB8IHJlYWRDaGFyKGFscGhhYmV0LCBpbnB1dFtpXSlcbiAgICBiaXRzICs9IDVcblxuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIG91dHB1dFtpbmRleCsrXSA9ICh2YWx1ZSA+Pj4gKGJpdHMgLSA4KSkgJiAyNTVcbiAgICAgIGJpdHMgLT0gOFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuYnVmZmVyXG59XG4iLCJ2YXIgdG9EYXRhVmlldyA9IHJlcXVpcmUoJ3RvLWRhdGEtdmlldycpXG5cbnZhciBSRkM0NjQ4ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J1xudmFyIFJGQzQ2NDhfSEVYID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ1xudmFyIENST0NLRk9SRCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWidcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzJFbmNvZGUgKGRhdGEsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGFscGhhYmV0LCBkZWZhdWx0UGFkZGluZ1xuXG4gIHN3aXRjaCAodmFyaWFudCkge1xuICAgIGNhc2UgJ1JGQzM1NDgnOlxuICAgIGNhc2UgJ1JGQzQ2NDgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4XG4gICAgICBkZWZhdWx0UGFkZGluZyA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnUkZDNDY0OC1IRVgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4X0hFWFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0Nyb2NrZm9yZCc6XG4gICAgICBhbHBoYWJldCA9IENST0NLRk9SRFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UzMiB2YXJpYW50OiAnICsgdmFyaWFudClcbiAgfVxuXG4gIHZhciBwYWRkaW5nID0gKG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogZGVmYXVsdFBhZGRpbmcpXG4gIHZhciB2aWV3ID0gdG9EYXRhVmlldyhkYXRhKVxuXG4gIHZhciBiaXRzID0gMFxuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBvdXRwdXQgPSAnJ1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA4KSB8IHZpZXcuZ2V0VWludDgoaSlcbiAgICBiaXRzICs9IDhcblxuICAgIHdoaWxlIChiaXRzID49IDUpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFsodmFsdWUgPj4+IChiaXRzIC0gNSkpICYgMzFdXG4gICAgICBiaXRzIC09IDVcbiAgICB9XG4gIH1cblxuICBpZiAoYml0cyA+IDApIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlIDw8ICg1IC0gYml0cykpICYgMzFdXG4gIH1cblxuICBpZiAocGFkZGluZykge1xuICAgIHdoaWxlICgob3V0cHV0Lmxlbmd0aCAlIDgpICE9PSAwKSB7XG4gICAgICBvdXRwdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvLyBCbGFrZTJCIGluIHB1cmUgSmF2YXNjcmlwdFxuLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuLy8gUG9ydGVkIHRvIEphdmFzY3JpcHQgYnkgREMgLSBodHRwczovL2dpdGh1Yi5jb20vZGNwb3NjaFxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSB2W2IsYisxXVxuLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuZnVuY3Rpb24gQURENjRBQSAodiwgYSwgYikge1xuICB2YXIgbzAgPSB2W2FdICsgdltiXVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gYlxuLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuZnVuY3Rpb24gQURENjRBQyAodiwgYSwgYjAsIGIxKSB7XG4gIHZhciBvMCA9IHZbYV0gKyBiMFxuICBpZiAoYjAgPCAwKSB7XG4gICAgbzAgKz0gMHgxMDAwMDAwMDBcbiAgfVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzXG5mdW5jdGlvbiBCMkJfR0VUMzIgKGFyciwgaSkge1xuICByZXR1cm4gKGFycltpXSBeXG4gIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgKGFycltpICsgM10gPDwgMjQpKVxufVxuXG4vLyBHIE1peGluZyBmdW5jdGlvblxuLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuZnVuY3Rpb24gQjJCX0cgKGEsIGIsIGMsIGQsIGl4LCBpeSkge1xuICB2YXIgeDAgPSBtW2l4XVxuICB2YXIgeDEgPSBtW2l4ICsgMV1cbiAgdmFyIHkwID0gbVtpeV1cbiAgdmFyIHkxID0gbVtpeSArIDFdXG5cbiAgQURENjRBQSh2LCBhLCBiKSAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICBBREQ2NEFDKHYsIGEsIHgwLCB4MSkgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHRvIHRoZSByaWdodCBieSAzMiBiaXRzXG4gIHZhciB4b3IwID0gdltkXSBeIHZbYV1cbiAgdmFyIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSB4b3IxXG4gIHZbZCArIDFdID0geG9yMFxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KVxuICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KVxuXG4gIEFERDY0QUEodiwgYSwgYilcbiAgQURENjRBQyh2LCBhLCB5MCwgeTEpXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpXG4gIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KVxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgNjMgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IxID4+PiAzMSkgXiAoeG9yMCA8PCAxKVxuICB2W2IgKyAxXSA9ICh4b3IwID4+PiAzMSkgXiAoeG9yMSA8PCAxKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweEYzQkNDOTA4LCAweDZBMDlFNjY3LCAweDg0Q0FBNzNCLCAweEJCNjdBRTg1LFxuICAweEZFOTRGODJCLCAweDNDNkVGMzcyLCAweDVGMUQzNkYxLCAweEE1NEZGNTNBLFxuICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAweEZCNDFCRDZCLCAweDFGODNEOUFCLCAweDEzN0UyMTc5LCAweDVCRTBDRDE5XG5dKVxuXG52YXIgU0lHTUE4ID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0LFxuICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5LFxuICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICA2LCAxNSwgMTQsIDksIDExLCAzLCAwLCA4LCAxMiwgMiwgMTMsIDcsIDEsIDQsIDEwLCA1LFxuICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzXG5dXG5cbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqIDIgfSkpXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgzMilcbmZ1bmN0aW9uIGJsYWtlMmJDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuXG4gIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuXG4gIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICB2WzI0XSA9IHZbMjRdIF4gY3R4LnRcbiAgdlsyNV0gPSB2WzI1XSBeIChjdHgudCAvIDB4MTAwMDAwMDAwKVxuICAvLyBoaWdoIDY0IGJpdHMgbm90IHN1cHBvcnRlZCwgb2Zmc2V0IG1heSBub3QgYmUgaGlnaGVyIHRoYW4gMioqNTMtMVxuXG4gIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICBpZiAobGFzdCkge1xuICAgIHZbMjhdID0gfnZbMjhdXG4gICAgdlsyOV0gPSB+dlsyOV1cbiAgfVxuXG4gIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgbVtpXSA9IEIyQl9HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICAvLyB1bmNvbW1lbnQgdGhlIERlYnVnUHJpbnQgY2FsbHMgdG8gbG9nIHRoZSBjb21wdXRhdGlvblxuICAvLyBhbmQgbWF0Y2ggdGhlIFJGQyBzYW1wbGUgZG9jdW1lbnRhdGlvblxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgICAgICAgICBtWzE2XScsIG0sIDY0KVxuICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9JyArIChpIDwgMTAgPyAnICcgOiAnJykgKyBpICsgJykgdlsxNl0nLCB2LCA2NClcbiAgICBCMkJfRygwLCA4LCAxNiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMF0sIFNJR01BODJbaSAqIDE2ICsgMV0pXG4gICAgQjJCX0coMiwgMTAsIDE4LCAyNiwgU0lHTUE4MltpICogMTYgKyAyXSwgU0lHTUE4MltpICogMTYgKyAzXSlcbiAgICBCMkJfRyg0LCAxMiwgMjAsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDRdLCBTSUdNQTgyW2kgKiAxNiArIDVdKVxuICAgIEIyQl9HKDYsIDE0LCAyMiwgMzAsIFNJR01BODJbaSAqIDE2ICsgNl0sIFNJR01BODJbaSAqIDE2ICsgN10pXG4gICAgQjJCX0coMCwgMTAsIDIwLCAzMCwgU0lHTUE4MltpICogMTYgKyA4XSwgU0lHTUE4MltpICogMTYgKyA5XSlcbiAgICBCMkJfRygyLCAxMiwgMjIsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDEwXSwgU0lHTUE4MltpICogMTYgKyAxMV0pXG4gICAgQjJCX0coNCwgMTQsIDE2LCAyNiwgU0lHTUE4MltpICogMTYgKyAxMl0sIFNJR01BODJbaSAqIDE2ICsgMTNdKVxuICAgIEIyQl9HKDYsIDgsIDE4LCAyOCwgU0lHTUE4MltpICogMTYgKyAxNF0sIFNJR01BODJbaSAqIDE2ICsgMTVdKVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9MTIpIHZbMTZdJywgdiwgNjQpXG5cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjdHguaFtpXSA9IGN0eC5oW2ldIF4gdltpXSBeIHZbaSArIDE2XVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnaFs4XScsIGN0eC5oLCA2NClcbn1cblxuLy8gQ3JlYXRlcyBhIEJMQUtFMmIgaGFzaGluZyBjb250ZXh0XG4vLyBSZXF1aXJlcyBhbiBvdXRwdXQgbGVuZ3RoIGJldHdlZW4gMSBhbmQgNjQgYnl0ZXNcbi8vIFRha2VzIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkga2V5XG5mdW5jdGlvbiBibGFrZTJiSW5pdCAob3V0bGVuLCBrZXkpIHtcbiAgaWYgKG91dGxlbiA9PT0gMCB8fCBvdXRsZW4gPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvdXRwdXQgbGVuZ3RoLCBleHBlY3RlZCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuICBpZiAoa2V5ICYmIGtleS5sZW5ndGggPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBrZXksIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuXG4gIC8vIHN0YXRlLCAncGFyYW0gYmxvY2snXG4gIHZhciBjdHggPSB7XG4gICAgYjogbmV3IFVpbnQ4QXJyYXkoMTI4KSxcbiAgICBoOiBuZXcgVWludDMyQXJyYXkoMTYpLFxuICAgIHQ6IDAsIC8vIGlucHV0IGNvdW50XG4gICAgYzogMCwgLy8gcG9pbnRlciB3aXRoaW4gYnVmZmVyXG4gICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gQkxBS0UyQl9JVjMyW2ldXG4gIH1cbiAgdmFyIGtleWxlbiA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIGN0eC5oWzBdIF49IDB4MDEwMTAwMDAgXiAoa2V5bGVuIDw8IDgpIF4gb3V0bGVuXG5cbiAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gIGlmIChrZXkpIHtcbiAgICBibGFrZTJiVXBkYXRlKGN0eCwga2V5KVxuICAgIC8vIGF0IHRoZSBlbmRcbiAgICBjdHguYyA9IDEyOFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2UyYlVwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSAxMjgpIHsgLy8gYnVmZmVyIGZ1bGwgP1xuICAgICAgY3R4LnQgKz0gY3R4LmMgLy8gYWRkIGNvdW50ZXJzXG4gICAgICBibGFrZTJiQ29tcHJlc3MoY3R4LCBmYWxzZSkgLy8gY29tcHJlc3MgKG5vdCBsYXN0KVxuICAgICAgY3R4LmMgPSAwIC8vIGNvdW50ZXIgdG8gemVyb1xuICAgIH1cbiAgICBjdHguYltjdHguYysrXSA9IGlucHV0W2ldXG4gIH1cbn1cblxuLy8gQ29tcGxldGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgbWVzc2FnZSBkaWdlc3RcbmZ1bmN0aW9uIGJsYWtlMmJGaW5hbCAoY3R4KSB7XG4gIGN0eC50ICs9IGN0eC5jIC8vIG1hcmsgbGFzdCBibG9jayBvZmZzZXRcblxuICB3aGlsZSAoY3R4LmMgPCAxMjgpIHsgLy8gZmlsbCB1cCB3aXRoIHplcm9zXG4gICAgY3R4LmJbY3R4LmMrK10gPSAwXG4gIH1cbiAgYmxha2UyYkNvbXByZXNzKGN0eCwgdHJ1ZSkgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICAvLyBsaXR0bGUgZW5kaWFuIGNvbnZlcnQgYW5kIHN0b3JlXG4gIHZhciBvdXQgPSBuZXcgVWludDhBcnJheShjdHgub3V0bGVuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIEJMQUtFMkIgaGFzaCBvZiBhIHN0cmluZyBvciBieXRlIGFycmF5LCBhbmQgcmV0dXJucyBhIFVpbnQ4QXJyYXlcbi8vXG4vLyBSZXR1cm5zIGEgbi1ieXRlIFVpbnQ4QXJyYXlcbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBpbnB1dCAtIHRoZSBpbnB1dCBieXRlcywgYXMgYSBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byA2NCBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG5mdW5jdGlvbiBibGFrZTJiIChpbnB1dCwga2V5LCBvdXRsZW4pIHtcbiAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgb3V0bGVuID0gb3V0bGVuIHx8IDY0XG4gIGlucHV0ID0gdXRpbC5ub3JtYWxpemVJbnB1dChpbnB1dClcblxuICAvLyBkbyB0aGUgbWF0aFxuICB2YXIgY3R4ID0gYmxha2UyYkluaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMmJVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMmJGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJCIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMmJIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICB2YXIgb3V0cHV0ID0gYmxha2UyYihpbnB1dCwga2V5LCBvdXRsZW4pXG4gIHJldHVybiB1dGlsLnRvSGV4KG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMmI6IGJsYWtlMmIsXG4gIGJsYWtlMmJIZXg6IGJsYWtlMmJIZXgsXG4gIGJsYWtlMmJJbml0OiBibGFrZTJiSW5pdCxcbiAgYmxha2UyYlVwZGF0ZTogYmxha2UyYlVwZGF0ZSxcbiAgYmxha2UyYkZpbmFsOiBibGFrZTJiRmluYWxcbn1cbiIsIi8vIEJMQUtFMnMgaGFzaCBmdW5jdGlvbiBpbiBwdXJlIEphdmFzY3JpcHRcbi8vIEFkYXB0ZWQgZnJvbSB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGluIFJGQzc2OTNcbi8vIFBvcnRlZCB0byBKYXZhc2NyaXB0IGJ5IERDIC0gaHR0cHM6Ly9naXRodWIuY29tL2RjcG9zY2hcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzLlxuLy8gRXhwZWN0cyBhIFVpbnQ4QXJyYXkgYW5kIGFuIGluZGV4XG4vLyBSZXR1cm5zIHRoZSBsaXR0bGUtZW5kaWFuIHVpbnQzMiBhdCB2W2kuLmkrM11cbmZ1bmN0aW9uIEIyU19HRVQzMiAodiwgaSkge1xuICByZXR1cm4gdltpXSBeICh2W2kgKyAxXSA8PCA4KSBeICh2W2kgKyAyXSA8PCAxNikgXiAodltpICsgM10gPDwgMjQpXG59XG5cbi8vIE1peGluZyBmdW5jdGlvbiBHLlxuZnVuY3Rpb24gQjJTX0cgKGEsIGIsIGMsIGQsIHgsIHkpIHtcbiAgdlthXSA9IHZbYV0gKyB2W2JdICsgeFxuICB2W2RdID0gUk9UUjMyKHZbZF0gXiB2W2FdLCAxNilcbiAgdltjXSA9IHZbY10gKyB2W2RdXG4gIHZbYl0gPSBST1RSMzIodltiXSBeIHZbY10sIDEyKVxuICB2W2FdID0gdlthXSArIHZbYl0gKyB5XG4gIHZbZF0gPSBST1RSMzIodltkXSBeIHZbYV0sIDgpXG4gIHZbY10gPSB2W2NdICsgdltkXVxuICB2W2JdID0gUk9UUjMyKHZbYl0gXiB2W2NdLCA3KVxufVxuXG4vLyAzMi1iaXQgcmlnaHQgcm90YXRpb25cbi8vIHggc2hvdWxkIGJlIGEgdWludDMyXG4vLyB5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzMSwgaW5jbHVzaXZlXG5mdW5jdGlvbiBST1RSMzIgKHgsIHkpIHtcbiAgcmV0dXJuICh4ID4+PiB5KSBeICh4IDw8ICgzMiAtIHkpKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3IuXG52YXIgQkxBS0UyU19JViA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsXG4gIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTldKVxuXG52YXIgU0lHTUEgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDBdKVxuXG4vLyBDb21wcmVzc2lvbiBmdW5jdGlvbi4gXCJsYXN0XCIgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9ja1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMTYpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgxNilcbmZ1bmN0aW9uIGJsYWtlMnNDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7IC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyA4XSA9IEJMQUtFMlNfSVZbaV1cbiAgfVxuXG4gIHZbMTJdIF49IGN0eC50IC8vIGxvdyAzMiBiaXRzIG9mIG9mZnNldFxuICB2WzEzXSBePSAoY3R4LnQgLyAweDEwMDAwMDAwMCkgLy8gaGlnaCAzMiBiaXRzXG4gIGlmIChsYXN0KSB7IC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICAgIHZbMTRdID0gfnZbMTRdXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeyAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgIG1baV0gPSBCMlNfR0VUMzIoY3R4LmIsIDQgKiBpKVxuICB9XG5cbiAgLy8gdGVuIHJvdW5kcyBvZiBtaXhpbmdcbiAgLy8gdW5jb21tZW50IHRoZSBEZWJ1Z1ByaW50IGNhbGxzIHRvIGxvZyB0aGUgY29tcHV0YXRpb25cbiAgLy8gYW5kIG1hdGNoIHRoZSBSRkMgc2FtcGxlIGRvY3VtZW50YXRpb25cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAgICAgICAgbVsxNl0nLCBtLCAzMilcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPScgKyBpICsgJykgIHZbMTZdJywgdiwgMzIpXG4gICAgQjJTX0coMCwgNCwgOCwgMTIsIG1bU0lHTUFbaSAqIDE2ICsgMF1dLCBtW1NJR01BW2kgKiAxNiArIDFdXSlcbiAgICBCMlNfRygxLCA1LCA5LCAxMywgbVtTSUdNQVtpICogMTYgKyAyXV0sIG1bU0lHTUFbaSAqIDE2ICsgM11dKVxuICAgIEIyU19HKDIsIDYsIDEwLCAxNCwgbVtTSUdNQVtpICogMTYgKyA0XV0sIG1bU0lHTUFbaSAqIDE2ICsgNV1dKVxuICAgIEIyU19HKDMsIDcsIDExLCAxNSwgbVtTSUdNQVtpICogMTYgKyA2XV0sIG1bU0lHTUFbaSAqIDE2ICsgN11dKVxuICAgIEIyU19HKDAsIDUsIDEwLCAxNSwgbVtTSUdNQVtpICogMTYgKyA4XV0sIG1bU0lHTUFbaSAqIDE2ICsgOV1dKVxuICAgIEIyU19HKDEsIDYsIDExLCAxMiwgbVtTSUdNQVtpICogMTYgKyAxMF1dLCBtW1NJR01BW2kgKiAxNiArIDExXV0pXG4gICAgQjJTX0coMiwgNywgOCwgMTMsIG1bU0lHTUFbaSAqIDE2ICsgMTJdXSwgbVtTSUdNQVtpICogMTYgKyAxM11dKVxuICAgIEIyU19HKDMsIDQsIDksIDE0LCBtW1NJR01BW2kgKiAxNiArIDE0XV0sIG1bU0lHTUFbaSAqIDE2ICsgMTVdXSlcbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPTEwKSB2WzE2XScsIHYsIDMyKVxuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBjdHguaFtpXSBePSB2W2ldIF4gdltpICsgOF1cbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJ2hbOF0nLCBjdHguaCwgMzIpXG59XG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJzIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDMyIGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gYmxha2Uyc0luaXQgKG91dGxlbiwga2V5KSB7XG4gIGlmICghKG91dGxlbiA+IDAgJiYgb3V0bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG91dHB1dCBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuICB2YXIga2V5bGVuID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgaWYgKGtleSAmJiAhKGtleWxlbiA+IDAgJiYga2V5bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGtleSBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuXG4gIHZhciBjdHggPSB7XG4gICAgaDogbmV3IFVpbnQzMkFycmF5KEJMQUtFMlNfSVYpLCAvLyBoYXNoIHN0YXRlXG4gICAgYjogbmV3IFVpbnQzMkFycmF5KDY0KSwgLy8gaW5wdXQgYmxvY2tcbiAgICBjOiAwLCAvLyBwb2ludGVyIHdpdGhpbiBibG9ja1xuICAgIHQ6IDAsIC8vIGlucHV0IGNvdW50XG4gICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICB9XG4gIGN0eC5oWzBdIF49IDB4MDEwMTAwMDAgXiAoa2V5bGVuIDw8IDgpIF4gb3V0bGVuXG5cbiAgaWYgKGtleWxlbiA+IDApIHtcbiAgICBibGFrZTJzVXBkYXRlKGN0eCwga2V5KVxuICAgIGN0eC5jID0gNjQgLy8gYXQgdGhlIGVuZFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UycyBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2Uyc1VwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSA2NCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMnNDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJzIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2Uyc0ZpbmFsIChjdHgpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuICB3aGlsZSAoY3R4LmMgPCA2NCkgeyAvLyBmaWxsIHVwIHdpdGggemVyb3NcbiAgICBjdHguYltjdHguYysrXSA9IDBcbiAgfVxuICBibGFrZTJzQ29tcHJlc3MoY3R4LCB0cnVlKSAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuXG4gIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGN0eC5vdXRsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gKGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKSkgJiAweEZGXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyUyBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyLCBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byAzMiBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG5mdW5jdGlvbiBibGFrZTJzIChpbnB1dCwga2V5LCBvdXRsZW4pIHtcbiAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgb3V0bGVuID0gb3V0bGVuIHx8IDMyXG4gIGlucHV0ID0gdXRpbC5ub3JtYWxpemVJbnB1dChpbnB1dClcblxuICAvLyBkbyB0aGUgbWF0aFxuICB2YXIgY3R4ID0gYmxha2Uyc0luaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMnNVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMnNGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJTIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDMyIGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMnNIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICB2YXIgb3V0cHV0ID0gYmxha2UycyhpbnB1dCwga2V5LCBvdXRsZW4pXG4gIHJldHVybiB1dGlsLnRvSGV4KG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMnM6IGJsYWtlMnMsXG4gIGJsYWtlMnNIZXg6IGJsYWtlMnNIZXgsXG4gIGJsYWtlMnNJbml0OiBibGFrZTJzSW5pdCxcbiAgYmxha2Uyc1VwZGF0ZTogYmxha2Uyc1VwZGF0ZSxcbiAgYmxha2Uyc0ZpbmFsOiBibGFrZTJzRmluYWxcbn1cbiIsInZhciBiMmIgPSByZXF1aXJlKCcuL2JsYWtlMmInKVxudmFyIGIycyA9IHJlcXVpcmUoJy4vYmxha2UycycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBibGFrZTJiOiBiMmIuYmxha2UyYixcbiAgYmxha2UyYkhleDogYjJiLmJsYWtlMmJIZXgsXG4gIGJsYWtlMmJJbml0OiBiMmIuYmxha2UyYkluaXQsXG4gIGJsYWtlMmJVcGRhdGU6IGIyYi5ibGFrZTJiVXBkYXRlLFxuICBibGFrZTJiRmluYWw6IGIyYi5ibGFrZTJiRmluYWwsXG4gIGJsYWtlMnM6IGIycy5ibGFrZTJzLFxuICBibGFrZTJzSGV4OiBiMnMuYmxha2Uyc0hleCxcbiAgYmxha2Uyc0luaXQ6IGIycy5ibGFrZTJzSW5pdCxcbiAgYmxha2Uyc1VwZGF0ZTogYjJzLmJsYWtlMnNVcGRhdGUsXG4gIGJsYWtlMnNGaW5hbDogYjJzLmJsYWtlMnNGaW5hbFxufVxuIiwidmFyIEVSUk9SX01TR19JTlBVVCA9ICdJbnB1dCBtdXN0IGJlIGFuIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG5cbi8vIEZvciBjb252ZW5pZW5jZSwgbGV0IHBlb3BsZSBoYXNoIGEgc3RyaW5nLCBub3QganVzdCBhIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0IChpbnB1dCkge1xuICB2YXIgcmV0XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXQgPSBpbnB1dFxuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIChpbnB1dCkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oaW5wdXQsICd1dGY4JykpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19JTlBVVClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleGFkZWNpbWFsIHN0cmluZ1xuLy8gRm9yIGV4YW1wbGUsIHRvSGV4KFsyNTUsIDAsIDI1NV0pIHJldHVybnMgXCJmZjAwZmZcIlxuZnVuY3Rpb24gdG9IZXggKGJ5dGVzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIDwgMTYgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KVxuICB9KS5qb2luKCcnKVxufVxuXG4vLyBDb252ZXJ0cyBhbnkgdmFsdWUgaW4gWzAuLi4yXjMyLTFdIHRvIGFuIDgtY2hhcmFjdGVyIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHVpbnQzMlRvSGV4ICh2YWwpIHtcbiAgcmV0dXJuICgweDEwMDAwMDAwMCArIHZhbCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKVxufVxuXG4vLyBGb3IgZGVidWdnaW5nOiBwcmludHMgb3V0IGhhc2ggc3RhdGUgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBSRkNcbi8vIHNhbXBsZSBjb21wdXRhdGlvbiBleGFjdGx5LCBzbyB0aGF0IHlvdSBjYW4gZGlmZlxuZnVuY3Rpb24gZGVidWdQcmludCAobGFiZWwsIGFyciwgc2l6ZSkge1xuICB2YXIgbXNnID0gJ1xcbicgKyBsYWJlbCArICcgPSAnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKHNpemUgPT09IDMyKSB7XG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gJyAnXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2kgKyAxXSkudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gNjQpIHtcbiAgICAgIG1zZyArPSB1aW50MzJUb0hleChhcnJbaSArIDFdKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplICcgKyBzaXplKVxuICAgIGlmIChpICUgNiA9PT0gNCkge1xuICAgICAgbXNnICs9ICdcXG4nICsgbmV3IEFycmF5KGxhYmVsLmxlbmd0aCArIDQpLmpvaW4oJyAnKVxuICAgIH0gZWxzZSBpZiAoaSA8IGFyci5sZW5ndGggLSAyKSB7XG4gICAgICBtc2cgKz0gJyAnXG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKG1zZylcbn1cblxuLy8gRm9yIHBlcmZvcm1hbmNlIHRlc3Rpbmc6IGdlbmVyYXRlcyBOIGJ5dGVzIG9mIGlucHV0LCBoYXNoZXMgTSB0aW1lc1xuLy8gTWVhc3VyZXMgYW5kIHByaW50cyBNQi9zZWNvbmQgaGFzaCBwZXJmb3JtYW5jZSBlYWNoIHRpbWVcbmZ1bmN0aW9uIHRlc3RTcGVlZCAoaGFzaEZuLCBOLCBNKSB7XG4gIHZhciBzdGFydE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICB2YXIgaW5wdXQgPSBuZXcgVWludDhBcnJheShOKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIGlucHV0W2ldID0gaSAlIDI1NlxuICB9XG4gIHZhciBnZW5NcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgcmFuZG9tIGlucHV0IGluICcgKyAoZ2VuTXMgLSBzdGFydE1zKSArICdtcycpXG4gIHN0YXJ0TXMgPSBnZW5Nc1xuXG4gIGZvciAoaSA9IDA7IGkgPCBNOyBpKyspIHtcbiAgICB2YXIgaGFzaEhleCA9IGhhc2hGbihpbnB1dClcbiAgICB2YXIgaGFzaE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB2YXIgbXMgPSBoYXNoTXMgLSBzdGFydE1zXG4gICAgc3RhcnRNcyA9IGhhc2hNc1xuICAgIGNvbnNvbGUubG9nKCdIYXNoZWQgaW4gJyArIG1zICsgJ21zOiAnICsgaGFzaEhleC5zdWJzdHJpbmcoMCwgMjApICsgJy4uLicpXG4gICAgY29uc29sZS5sb2coTWF0aC5yb3VuZChOIC8gKDEgPDwgMjApIC8gKG1zIC8gMTAwMCkgKiAxMDApIC8gMTAwICsgJyBNQiBQRVIgU0VDT05EJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9ybWFsaXplSW5wdXQ6IG5vcm1hbGl6ZUlucHV0LFxuICB0b0hleDogdG9IZXgsXG4gIGRlYnVnUHJpbnQ6IGRlYnVnUHJpbnQsXG4gIHRlc3RTcGVlZDogdGVzdFNwZWVkXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHR5cGVNYXAgW09iamVjdF0gTWFwIG9mIE1JTUUgdHlwZSAtPiBBcnJheVtleHRlbnNpb25zXVxuICogQHBhcmFtIC4uLlxuICovXG5mdW5jdGlvbiBNaW1lKCkge1xuICB0aGlzLl90eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2V4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5kZWZpbmUoYXJndW1lbnRzW2ldKTtcbiAgfVxuXG4gIHRoaXMuZGVmaW5lID0gdGhpcy5kZWZpbmUuYmluZCh0aGlzKTtcbiAgdGhpcy5nZXRUeXBlID0gdGhpcy5nZXRUeXBlLmJpbmQodGhpcyk7XG4gIHRoaXMuZ2V0RXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb24uYmluZCh0aGlzKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgbWltZXR5cGUgLT4gZXh0ZW5zaW9uIG1hcHBpbmdzLiAgRWFjaCBrZXkgaXMgYSBtaW1lLXR5cGUgdGhhdCBtYXBzXG4gKiB0byBhbiBhcnJheSBvZiBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZS4gIFRoZSBmaXJzdCBleHRlbnNpb24gaXNcbiAqIHVzZWQgYXMgdGhlIGRlZmF1bHQgZXh0ZW5zaW9uIGZvciB0aGUgdHlwZS5cbiAqXG4gKiBlLmcuIG1pbWUuZGVmaW5lKHsnYXVkaW8vb2dnJywgWydvZ2EnLCAnb2dnJywgJ3NweCddfSk7XG4gKlxuICogSWYgYSB0eXBlIGRlY2xhcmVzIGFuIGV4dGVuc2lvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCwgYW4gZXJyb3Igd2lsbFxuICogYmUgdGhyb3duLiAgVG8gc3VwcHJlc3MgdGhpcyBlcnJvciBhbmQgZm9yY2UgdGhlIGV4dGVuc2lvbiB0byBiZSBhc3NvY2lhdGVkXG4gKiB3aXRoIHRoZSBuZXcgdHlwZSwgcGFzcyBgZm9yY2VgPXRydWUuICBBbHRlcm5hdGl2ZWx5LCB5b3UgbWF5IHByZWZpeCB0aGVcbiAqIGV4dGVuc2lvbiB3aXRoIFwiKlwiIHRvIG1hcCB0aGUgdHlwZSB0byBleHRlbnNpb24sIHdpdGhvdXQgbWFwcGluZyB0aGVcbiAqIGV4dGVuc2lvbiB0byB0aGUgdHlwZS5cbiAqXG4gKiBlLmcuIG1pbWUuZGVmaW5lKHsnYXVkaW8vd2F2JywgWyd3YXYnXX0sIHsnYXVkaW8veC13YXYnLCBbJyp3YXYnXX0pO1xuICpcbiAqXG4gKiBAcGFyYW0gbWFwIChPYmplY3QpIHR5cGUgZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSBmb3JjZSAoQm9vbGVhbikgaWYgdHJ1ZSwgZm9yY2Ugb3ZlcnJpZGluZyBvZiBleGlzdGluZyBkZWZpbml0aW9uc1xuICovXG5NaW1lLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbih0eXBlTWFwLCBmb3JjZSkge1xuICBmb3IgKGxldCB0eXBlIGluIHR5cGVNYXApIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IHR5cGVNYXBbdHlwZV0ubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgLy8gJyonIHByZWZpeCA9IG5vdCB0aGUgcHJlZmVycmVkIHR5cGUgZm9yIHRoaXMgZXh0ZW5zaW9uLiAgU28gZml4dXAgdGhlXG4gICAgICAvLyBleHRlbnNpb24sIGFuZCBza2lwIGl0LlxuICAgICAgaWYgKGV4dFswXSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvcmNlICYmIChleHQgaW4gdGhpcy5fdHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQXR0ZW1wdCB0byBjaGFuZ2UgbWFwcGluZyBmb3IgXCInICsgZXh0ICtcbiAgICAgICAgICAnXCIgZXh0ZW5zaW9uIGZyb20gXCInICsgdGhpcy5fdHlwZXNbZXh0XSArICdcIiB0byBcIicgKyB0eXBlICtcbiAgICAgICAgICAnXCIuIFBhc3MgYGZvcmNlPXRydWVgIHRvIGFsbG93IHRoaXMsIG90aGVyd2lzZSByZW1vdmUgXCInICsgZXh0ICtcbiAgICAgICAgICAnXCIgZnJvbSB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGZvciBcIicgKyB0eXBlICsgJ1wiLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHlwZXNbZXh0XSA9IHR5cGU7XG4gICAgfVxuXG4gICAgLy8gVXNlIGZpcnN0IGV4dGVuc2lvbiBhcyBkZWZhdWx0XG4gICAgaWYgKGZvcmNlIHx8ICF0aGlzLl9leHRlbnNpb25zW3R5cGVdKSB7XG4gICAgICBjb25zdCBleHQgPSBleHRlbnNpb25zWzBdO1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1t0eXBlXSA9IChleHRbMF0gIT09ICcqJykgPyBleHQgOiBleHQuc3Vic3RyKDEpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMb29rdXAgYSBtaW1lIHR5cGUgYmFzZWQgb24gZXh0ZW5zaW9uXG4gKi9cbk1pbWUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHBhdGggPSBTdHJpbmcocGF0aCk7XG4gIGxldCBsYXN0ID0gcGF0aC5yZXBsYWNlKC9eLipbL1xcXFxdLywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBleHQgPSBsYXN0LnJlcGxhY2UoL14uKlxcLi8sICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGxldCBoYXNQYXRoID0gbGFzdC5sZW5ndGggPCBwYXRoLmxlbmd0aDtcbiAgbGV0IGhhc0RvdCA9IGV4dC5sZW5ndGggPCBsYXN0Lmxlbmd0aCAtIDE7XG5cbiAgcmV0dXJuIChoYXNEb3QgfHwgIWhhc1BhdGgpICYmIHRoaXMuX3R5cGVzW2V4dF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpbGUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCBhIG1pbWUgdHlwZVxuICovXG5NaW1lLnByb3RvdHlwZS5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbih0eXBlKSB7XG4gIHR5cGUgPSAvXlxccyooW147XFxzXSopLy50ZXN0KHR5cGUpICYmIFJlZ0V4cC4kMTtcbiAgcmV0dXJuIHR5cGUgJiYgdGhpcy5fZXh0ZW5zaW9uc1t0eXBlLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmxldCBNaW1lID0gcmVxdWlyZSgnLi9NaW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBNaW1lKHJlcXVpcmUoJy4vdHlwZXMvc3RhbmRhcmQnKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcImFwcGxpY2F0aW9uL2FuZHJldy1pbnNldFwiOltcImV6XCJdLFwiYXBwbGljYXRpb24vYXBwbGl4d2FyZVwiOltcImF3XCJdLFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIjpbXCJhdG9tXCJdLFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIjpbXCJhdG9tY2F0XCJdLFwiYXBwbGljYXRpb24vYXRvbWRlbGV0ZWQreG1sXCI6W1wiYXRvbWRlbGV0ZWRcIl0sXCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiOltcImF0b21zdmNcIl0sXCJhcHBsaWNhdGlvbi9hdHNjLWR3ZCt4bWxcIjpbXCJkd2RcIl0sXCJhcHBsaWNhdGlvbi9hdHNjLWhlbGQreG1sXCI6W1wiaGVsZFwiXSxcImFwcGxpY2F0aW9uL2F0c2MtcnNhdCt4bWxcIjpbXCJyc2F0XCJdLFwiYXBwbGljYXRpb24vYmRvY1wiOltcImJkb2NcIl0sXCJhcHBsaWNhdGlvbi9jYWxlbmRhcit4bWxcIjpbXCJ4Y3NcIl0sXCJhcHBsaWNhdGlvbi9jY3htbCt4bWxcIjpbXCJjY3htbFwiXSxcImFwcGxpY2F0aW9uL2NkZngreG1sXCI6W1wiY2RmeFwiXSxcImFwcGxpY2F0aW9uL2NkbWktY2FwYWJpbGl0eVwiOltcImNkbWlhXCJdLFwiYXBwbGljYXRpb24vY2RtaS1jb250YWluZXJcIjpbXCJjZG1pY1wiXSxcImFwcGxpY2F0aW9uL2NkbWktZG9tYWluXCI6W1wiY2RtaWRcIl0sXCJhcHBsaWNhdGlvbi9jZG1pLW9iamVjdFwiOltcImNkbWlvXCJdLFwiYXBwbGljYXRpb24vY2RtaS1xdWV1ZVwiOltcImNkbWlxXCJdLFwiYXBwbGljYXRpb24vY3Utc2VlbWVcIjpbXCJjdVwiXSxcImFwcGxpY2F0aW9uL2Rhc2greG1sXCI6W1wibXBkXCJdLFwiYXBwbGljYXRpb24vZGF2bW91bnQreG1sXCI6W1wiZGF2bW91bnRcIl0sXCJhcHBsaWNhdGlvbi9kb2Nib29rK3htbFwiOltcImRia1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCI6W1wiZHNzY1wiXSxcImFwcGxpY2F0aW9uL2Rzc2MreG1sXCI6W1wieGRzc2NcIl0sXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6W1wiZWNtYVwiLFwiZXNcIl0sXCJhcHBsaWNhdGlvbi9lbW1hK3htbFwiOltcImVtbWFcIl0sXCJhcHBsaWNhdGlvbi9lbW90aW9ubWwreG1sXCI6W1wiZW1vdGlvbm1sXCJdLFwiYXBwbGljYXRpb24vZXB1Yit6aXBcIjpbXCJlcHViXCJdLFwiYXBwbGljYXRpb24vZXhpXCI6W1wiZXhpXCJdLFwiYXBwbGljYXRpb24vZmR0K3htbFwiOltcImZkdFwiXSxcImFwcGxpY2F0aW9uL2ZvbnQtdGRwZnJcIjpbXCJwZnJcIl0sXCJhcHBsaWNhdGlvbi9nZW8ranNvblwiOltcImdlb2pzb25cIl0sXCJhcHBsaWNhdGlvbi9nbWwreG1sXCI6W1wiZ21sXCJdLFwiYXBwbGljYXRpb24vZ3B4K3htbFwiOltcImdweFwiXSxcImFwcGxpY2F0aW9uL2d4ZlwiOltcImd4ZlwiXSxcImFwcGxpY2F0aW9uL2d6aXBcIjpbXCJnelwiXSxcImFwcGxpY2F0aW9uL2hqc29uXCI6W1wiaGpzb25cIl0sXCJhcHBsaWNhdGlvbi9oeXBlcnN0dWRpb1wiOltcInN0a1wiXSxcImFwcGxpY2F0aW9uL2lua21sK3htbFwiOltcImlua1wiLFwiaW5rbWxcIl0sXCJhcHBsaWNhdGlvbi9pcGZpeFwiOltcImlwZml4XCJdLFwiYXBwbGljYXRpb24vaXRzK3htbFwiOltcIml0c1wiXSxcImFwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZVwiOltcImphclwiLFwid2FyXCIsXCJlYXJcIl0sXCJhcHBsaWNhdGlvbi9qYXZhLXNlcmlhbGl6ZWQtb2JqZWN0XCI6W1wic2VyXCJdLFwiYXBwbGljYXRpb24vamF2YS12bVwiOltcImNsYXNzXCJdLFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOltcImpzXCIsXCJtanNcIl0sXCJhcHBsaWNhdGlvbi9qc29uXCI6W1wianNvblwiLFwibWFwXCJdLFwiYXBwbGljYXRpb24vanNvbjVcIjpbXCJqc29uNVwiXSxcImFwcGxpY2F0aW9uL2pzb25tbCtqc29uXCI6W1wianNvbm1sXCJdLFwiYXBwbGljYXRpb24vbGQranNvblwiOltcImpzb25sZFwiXSxcImFwcGxpY2F0aW9uL2xncit4bWxcIjpbXCJsZ3JcIl0sXCJhcHBsaWNhdGlvbi9sb3N0K3htbFwiOltcImxvc3R4bWxcIl0sXCJhcHBsaWNhdGlvbi9tYWMtYmluaGV4NDBcIjpbXCJocXhcIl0sXCJhcHBsaWNhdGlvbi9tYWMtY29tcGFjdHByb1wiOltcImNwdFwiXSxcImFwcGxpY2F0aW9uL21hZHMreG1sXCI6W1wibWFkc1wiXSxcImFwcGxpY2F0aW9uL21hbmlmZXN0K2pzb25cIjpbXCJ3ZWJtYW5pZmVzdFwiXSxcImFwcGxpY2F0aW9uL21hcmNcIjpbXCJtcmNcIl0sXCJhcHBsaWNhdGlvbi9tYXJjeG1sK3htbFwiOltcIm1yY3hcIl0sXCJhcHBsaWNhdGlvbi9tYXRoZW1hdGljYVwiOltcIm1hXCIsXCJuYlwiLFwibWJcIl0sXCJhcHBsaWNhdGlvbi9tYXRobWwreG1sXCI6W1wibWF0aG1sXCJdLFwiYXBwbGljYXRpb24vbWJveFwiOltcIm1ib3hcIl0sXCJhcHBsaWNhdGlvbi9tZWRpYXNlcnZlcmNvbnRyb2wreG1sXCI6W1wibXNjbWxcIl0sXCJhcHBsaWNhdGlvbi9tZXRhbGluayt4bWxcIjpbXCJtZXRhbGlua1wiXSxcImFwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWxcIjpbXCJtZXRhNFwiXSxcImFwcGxpY2F0aW9uL21ldHMreG1sXCI6W1wibWV0c1wiXSxcImFwcGxpY2F0aW9uL21tdC1hZWkreG1sXCI6W1wibWFlaVwiXSxcImFwcGxpY2F0aW9uL21tdC11c2QreG1sXCI6W1wibXVzZFwiXSxcImFwcGxpY2F0aW9uL21vZHMreG1sXCI6W1wibW9kc1wiXSxcImFwcGxpY2F0aW9uL21wMjFcIjpbXCJtMjFcIixcIm1wMjFcIl0sXCJhcHBsaWNhdGlvbi9tcDRcIjpbXCJtcDRzXCIsXCJtNHBcIl0sXCJhcHBsaWNhdGlvbi9tcmItY29uc3VtZXIreG1sXCI6W1wiKnhkZlwiXSxcImFwcGxpY2F0aW9uL21yYi1wdWJsaXNoK3htbFwiOltcIip4ZGZcIl0sXCJhcHBsaWNhdGlvbi9tc3dvcmRcIjpbXCJkb2NcIixcImRvdFwiXSxcImFwcGxpY2F0aW9uL214ZlwiOltcIm14ZlwiXSxcImFwcGxpY2F0aW9uL24tcXVhZHNcIjpbXCJucVwiXSxcImFwcGxpY2F0aW9uL24tdHJpcGxlc1wiOltcIm50XCJdLFwiYXBwbGljYXRpb24vbm9kZVwiOltcImNqc1wiXSxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiOltcImJpblwiLFwiZG1zXCIsXCJscmZcIixcIm1hclwiLFwic29cIixcImRpc3RcIixcImRpc3R6XCIsXCJwa2dcIixcImJwa1wiLFwiZHVtcFwiLFwiZWxjXCIsXCJkZXBsb3lcIixcImV4ZVwiLFwiZGxsXCIsXCJkZWJcIixcImRtZ1wiLFwiaXNvXCIsXCJpbWdcIixcIm1zaVwiLFwibXNwXCIsXCJtc21cIixcImJ1ZmZlclwiXSxcImFwcGxpY2F0aW9uL29kYVwiOltcIm9kYVwiXSxcImFwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sXCI6W1wib3BmXCJdLFwiYXBwbGljYXRpb24vb2dnXCI6W1wib2d4XCJdLFwiYXBwbGljYXRpb24vb21kb2MreG1sXCI6W1wib21kb2NcIl0sXCJhcHBsaWNhdGlvbi9vbmVub3RlXCI6W1wib25ldG9jXCIsXCJvbmV0b2MyXCIsXCJvbmV0bXBcIixcIm9uZXBrZ1wiXSxcImFwcGxpY2F0aW9uL294cHNcIjpbXCJveHBzXCJdLFwiYXBwbGljYXRpb24vcDJwLW92ZXJsYXkreG1sXCI6W1wicmVsb1wiXSxcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIjpbXCIqeGVyXCJdLFwiYXBwbGljYXRpb24vcGRmXCI6W1wicGRmXCJdLFwiYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZFwiOltcInBncFwiXSxcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIjpbXCJhc2NcIixcInNpZ1wiXSxcImFwcGxpY2F0aW9uL3BpY3MtcnVsZXNcIjpbXCJwcmZcIl0sXCJhcHBsaWNhdGlvbi9wa2NzMTBcIjpbXCJwMTBcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1taW1lXCI6W1wicDdtXCIsXCJwN2NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIjpbXCJwN3NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzOFwiOltcInA4XCJdLFwiYXBwbGljYXRpb24vcGtpeC1hdHRyLWNlcnRcIjpbXCJhY1wiXSxcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiOltcImNlclwiXSxcImFwcGxpY2F0aW9uL3BraXgtY3JsXCI6W1wiY3JsXCJdLFwiYXBwbGljYXRpb24vcGtpeC1wa2lwYXRoXCI6W1wicGtpcGF0aFwiXSxcImFwcGxpY2F0aW9uL3BraXhjbXBcIjpbXCJwa2lcIl0sXCJhcHBsaWNhdGlvbi9wbHMreG1sXCI6W1wicGxzXCJdLFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiOltcImFpXCIsXCJlcHNcIixcInBzXCJdLFwiYXBwbGljYXRpb24vcHJvdmVuYW5jZSt4bWxcIjpbXCJwcm92eFwiXSxcImFwcGxpY2F0aW9uL3Bza2MreG1sXCI6W1wicHNrY3htbFwiXSxcImFwcGxpY2F0aW9uL3JhbWwreWFtbFwiOltcInJhbWxcIl0sXCJhcHBsaWNhdGlvbi9yZGYreG1sXCI6W1wicmRmXCIsXCJvd2xcIl0sXCJhcHBsaWNhdGlvbi9yZWdpbmZvK3htbFwiOltcInJpZlwiXSxcImFwcGxpY2F0aW9uL3JlbGF4LW5nLWNvbXBhY3Qtc3ludGF4XCI6W1wicm5jXCJdLFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sXCI6W1wicmxcIl0sXCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cy1kaWZmK3htbFwiOltcInJsZFwiXSxcImFwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWxcIjpbXCJyc1wiXSxcImFwcGxpY2F0aW9uL3JvdXRlLWFwZCt4bWxcIjpbXCJyYXBkXCJdLFwiYXBwbGljYXRpb24vcm91dGUtcy10c2lkK3htbFwiOltcInNsc1wiXSxcImFwcGxpY2F0aW9uL3JvdXRlLXVzZCt4bWxcIjpbXCJydXNkXCJdLFwiYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnNcIjpbXCJnYnJcIl0sXCJhcHBsaWNhdGlvbi9ycGtpLW1hbmlmZXN0XCI6W1wibWZ0XCJdLFwiYXBwbGljYXRpb24vcnBraS1yb2FcIjpbXCJyb2FcIl0sXCJhcHBsaWNhdGlvbi9yc2QreG1sXCI6W1wicnNkXCJdLFwiYXBwbGljYXRpb24vcnNzK3htbFwiOltcInJzc1wiXSxcImFwcGxpY2F0aW9uL3J0ZlwiOltcInJ0ZlwiXSxcImFwcGxpY2F0aW9uL3NibWwreG1sXCI6W1wic2JtbFwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdFwiOltcInNjcVwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2VcIjpbXCJzY3NcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjpbXCJzcHFcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlXCI6W1wic3BwXCJdLFwiYXBwbGljYXRpb24vc2RwXCI6W1wic2RwXCJdLFwiYXBwbGljYXRpb24vc2VubWwreG1sXCI6W1wic2VubWx4XCJdLFwiYXBwbGljYXRpb24vc2Vuc21sK3htbFwiOltcInNlbnNtbHhcIl0sXCJhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uXCI6W1wic2V0cGF5XCJdLFwiYXBwbGljYXRpb24vc2V0LXJlZ2lzdHJhdGlvbi1pbml0aWF0aW9uXCI6W1wic2V0cmVnXCJdLFwiYXBwbGljYXRpb24vc2hmK3htbFwiOltcInNoZlwiXSxcImFwcGxpY2F0aW9uL3NpZXZlXCI6W1wic2l2XCIsXCJzaWV2ZVwiXSxcImFwcGxpY2F0aW9uL3NtaWwreG1sXCI6W1wic21pXCIsXCJzbWlsXCJdLFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCI6W1wicnFcIl0sXCJhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWxcIjpbXCJzcnhcIl0sXCJhcHBsaWNhdGlvbi9zcmdzXCI6W1wiZ3JhbVwiXSxcImFwcGxpY2F0aW9uL3NyZ3MreG1sXCI6W1wiZ3J4bWxcIl0sXCJhcHBsaWNhdGlvbi9zcnUreG1sXCI6W1wic3J1XCJdLFwiYXBwbGljYXRpb24vc3NkbCt4bWxcIjpbXCJzc2RsXCJdLFwiYXBwbGljYXRpb24vc3NtbCt4bWxcIjpbXCJzc21sXCJdLFwiYXBwbGljYXRpb24vc3dpZCt4bWxcIjpbXCJzd2lkdGFnXCJdLFwiYXBwbGljYXRpb24vdGVpK3htbFwiOltcInRlaVwiLFwidGVpY29ycHVzXCJdLFwiYXBwbGljYXRpb24vdGhyYXVkK3htbFwiOltcInRmaVwiXSxcImFwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGFcIjpbXCJ0c2RcIl0sXCJhcHBsaWNhdGlvbi90b21sXCI6W1widG9tbFwiXSxcImFwcGxpY2F0aW9uL3R0bWwreG1sXCI6W1widHRtbFwiXSxcImFwcGxpY2F0aW9uL3VianNvblwiOltcInVialwiXSxcImFwcGxpY2F0aW9uL3VyYy1yZXNzaGVldCt4bWxcIjpbXCJyc2hlZXRcIl0sXCJhcHBsaWNhdGlvbi91cmMtdGFyZ2V0ZGVzYyt4bWxcIjpbXCJ0ZFwiXSxcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiOltcInZ4bWxcIl0sXCJhcHBsaWNhdGlvbi93YXNtXCI6W1wid2FzbVwiXSxcImFwcGxpY2F0aW9uL3dpZGdldFwiOltcIndndFwiXSxcImFwcGxpY2F0aW9uL3dpbmhscFwiOltcImhscFwiXSxcImFwcGxpY2F0aW9uL3dzZGwreG1sXCI6W1wid3NkbFwiXSxcImFwcGxpY2F0aW9uL3dzcG9saWN5K3htbFwiOltcIndzcG9saWN5XCJdLFwiYXBwbGljYXRpb24veGFtbCt4bWxcIjpbXCJ4YW1sXCJdLFwiYXBwbGljYXRpb24veGNhcC1hdHQreG1sXCI6W1wieGF2XCJdLFwiYXBwbGljYXRpb24veGNhcC1jYXBzK3htbFwiOltcInhjYVwiXSxcImFwcGxpY2F0aW9uL3hjYXAtZGlmZit4bWxcIjpbXCJ4ZGZcIl0sXCJhcHBsaWNhdGlvbi94Y2FwLWVsK3htbFwiOltcInhlbFwiXSxcImFwcGxpY2F0aW9uL3hjYXAtZXJyb3IreG1sXCI6W1wieGVyXCJdLFwiYXBwbGljYXRpb24veGNhcC1ucyt4bWxcIjpbXCJ4bnNcIl0sXCJhcHBsaWNhdGlvbi94ZW5jK3htbFwiOltcInhlbmNcIl0sXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIjpbXCJ4aHRtbFwiLFwieGh0XCJdLFwiYXBwbGljYXRpb24veGxpZmYreG1sXCI6W1wieGxmXCJdLFwiYXBwbGljYXRpb24veG1sXCI6W1wieG1sXCIsXCJ4c2xcIixcInhzZFwiLFwicm5nXCJdLFwiYXBwbGljYXRpb24veG1sLWR0ZFwiOltcImR0ZFwiXSxcImFwcGxpY2F0aW9uL3hvcCt4bWxcIjpbXCJ4b3BcIl0sXCJhcHBsaWNhdGlvbi94cHJvYyt4bWxcIjpbXCJ4cGxcIl0sXCJhcHBsaWNhdGlvbi94c2x0K3htbFwiOltcIip4c2xcIixcInhzbHRcIl0sXCJhcHBsaWNhdGlvbi94c3BmK3htbFwiOltcInhzcGZcIl0sXCJhcHBsaWNhdGlvbi94dit4bWxcIjpbXCJteG1sXCIsXCJ4aHZtbFwiLFwieHZtbFwiLFwieHZtXCJdLFwiYXBwbGljYXRpb24veWFuZ1wiOltcInlhbmdcIl0sXCJhcHBsaWNhdGlvbi95aW4reG1sXCI6W1wieWluXCJdLFwiYXBwbGljYXRpb24vemlwXCI6W1wiemlwXCJdLFwiYXVkaW8vM2dwcFwiOltcIiozZ3BwXCJdLFwiYXVkaW8vYWRwY21cIjpbXCJhZHBcIl0sXCJhdWRpby9hbXJcIjpbXCJhbXJcIl0sXCJhdWRpby9iYXNpY1wiOltcImF1XCIsXCJzbmRcIl0sXCJhdWRpby9taWRpXCI6W1wibWlkXCIsXCJtaWRpXCIsXCJrYXJcIixcInJtaVwiXSxcImF1ZGlvL21vYmlsZS14bWZcIjpbXCJteG1mXCJdLFwiYXVkaW8vbXAzXCI6W1wiKm1wM1wiXSxcImF1ZGlvL21wNFwiOltcIm00YVwiLFwibXA0YVwiXSxcImF1ZGlvL21wZWdcIjpbXCJtcGdhXCIsXCJtcDJcIixcIm1wMmFcIixcIm1wM1wiLFwibTJhXCIsXCJtM2FcIl0sXCJhdWRpby9vZ2dcIjpbXCJvZ2FcIixcIm9nZ1wiLFwic3B4XCIsXCJvcHVzXCJdLFwiYXVkaW8vczNtXCI6W1wiczNtXCJdLFwiYXVkaW8vc2lsa1wiOltcInNpbFwiXSxcImF1ZGlvL3dhdlwiOltcIndhdlwiXSxcImF1ZGlvL3dhdmVcIjpbXCIqd2F2XCJdLFwiYXVkaW8vd2VibVwiOltcIndlYmFcIl0sXCJhdWRpby94bVwiOltcInhtXCJdLFwiZm9udC9jb2xsZWN0aW9uXCI6W1widHRjXCJdLFwiZm9udC9vdGZcIjpbXCJvdGZcIl0sXCJmb250L3R0ZlwiOltcInR0ZlwiXSxcImZvbnQvd29mZlwiOltcIndvZmZcIl0sXCJmb250L3dvZmYyXCI6W1wid29mZjJcIl0sXCJpbWFnZS9hY2VzXCI6W1wiZXhyXCJdLFwiaW1hZ2UvYXBuZ1wiOltcImFwbmdcIl0sXCJpbWFnZS9hdmlmXCI6W1wiYXZpZlwiXSxcImltYWdlL2JtcFwiOltcImJtcFwiXSxcImltYWdlL2NnbVwiOltcImNnbVwiXSxcImltYWdlL2RpY29tLXJsZVwiOltcImRybGVcIl0sXCJpbWFnZS9lbWZcIjpbXCJlbWZcIl0sXCJpbWFnZS9maXRzXCI6W1wiZml0c1wiXSxcImltYWdlL2czZmF4XCI6W1wiZzNcIl0sXCJpbWFnZS9naWZcIjpbXCJnaWZcIl0sXCJpbWFnZS9oZWljXCI6W1wiaGVpY1wiXSxcImltYWdlL2hlaWMtc2VxdWVuY2VcIjpbXCJoZWljc1wiXSxcImltYWdlL2hlaWZcIjpbXCJoZWlmXCJdLFwiaW1hZ2UvaGVpZi1zZXF1ZW5jZVwiOltcImhlaWZzXCJdLFwiaW1hZ2UvaGVqMmtcIjpbXCJoZWoyXCJdLFwiaW1hZ2UvaHNqMlwiOltcImhzajJcIl0sXCJpbWFnZS9pZWZcIjpbXCJpZWZcIl0sXCJpbWFnZS9qbHNcIjpbXCJqbHNcIl0sXCJpbWFnZS9qcDJcIjpbXCJqcDJcIixcImpwZzJcIl0sXCJpbWFnZS9qcGVnXCI6W1wianBlZ1wiLFwianBnXCIsXCJqcGVcIl0sXCJpbWFnZS9qcGhcIjpbXCJqcGhcIl0sXCJpbWFnZS9qcGhjXCI6W1wiamhjXCJdLFwiaW1hZ2UvanBtXCI6W1wianBtXCJdLFwiaW1hZ2UvanB4XCI6W1wianB4XCIsXCJqcGZcIl0sXCJpbWFnZS9qeHJcIjpbXCJqeHJcIl0sXCJpbWFnZS9qeHJhXCI6W1wianhyYVwiXSxcImltYWdlL2p4cnNcIjpbXCJqeHJzXCJdLFwiaW1hZ2UvanhzXCI6W1wianhzXCJdLFwiaW1hZ2UvanhzY1wiOltcImp4c2NcIl0sXCJpbWFnZS9qeHNpXCI6W1wianhzaVwiXSxcImltYWdlL2p4c3NcIjpbXCJqeHNzXCJdLFwiaW1hZ2Uva3R4XCI6W1wia3R4XCJdLFwiaW1hZ2Uva3R4MlwiOltcImt0eDJcIl0sXCJpbWFnZS9wbmdcIjpbXCJwbmdcIl0sXCJpbWFnZS9zZ2lcIjpbXCJzZ2lcIl0sXCJpbWFnZS9zdmcreG1sXCI6W1wic3ZnXCIsXCJzdmd6XCJdLFwiaW1hZ2UvdDM4XCI6W1widDM4XCJdLFwiaW1hZ2UvdGlmZlwiOltcInRpZlwiLFwidGlmZlwiXSxcImltYWdlL3RpZmYtZnhcIjpbXCJ0ZnhcIl0sXCJpbWFnZS93ZWJwXCI6W1wid2VicFwiXSxcImltYWdlL3dtZlwiOltcIndtZlwiXSxcIm1lc3NhZ2UvZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6W1wiZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCJdLFwibWVzc2FnZS9nbG9iYWxcIjpbXCJ1OG1zZ1wiXSxcIm1lc3NhZ2UvZ2xvYmFsLWRlbGl2ZXJ5LXN0YXR1c1wiOltcInU4ZHNuXCJdLFwibWVzc2FnZS9nbG9iYWwtZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6W1widThtZG5cIl0sXCJtZXNzYWdlL2dsb2JhbC1oZWFkZXJzXCI6W1widThoZHJcIl0sXCJtZXNzYWdlL3JmYzgyMlwiOltcImVtbFwiLFwibWltZVwiXSxcIm1vZGVsLzNtZlwiOltcIjNtZlwiXSxcIm1vZGVsL2dsdGYranNvblwiOltcImdsdGZcIl0sXCJtb2RlbC9nbHRmLWJpbmFyeVwiOltcImdsYlwiXSxcIm1vZGVsL2lnZXNcIjpbXCJpZ3NcIixcImlnZXNcIl0sXCJtb2RlbC9tZXNoXCI6W1wibXNoXCIsXCJtZXNoXCIsXCJzaWxvXCJdLFwibW9kZWwvbXRsXCI6W1wibXRsXCJdLFwibW9kZWwvb2JqXCI6W1wib2JqXCJdLFwibW9kZWwvc3RsXCI6W1wic3RsXCJdLFwibW9kZWwvdnJtbFwiOltcIndybFwiLFwidnJtbFwiXSxcIm1vZGVsL3gzZCtiaW5hcnlcIjpbXCIqeDNkYlwiLFwieDNkYnpcIl0sXCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIjpbXCJ4M2RiXCJdLFwibW9kZWwveDNkK3ZybWxcIjpbXCIqeDNkdlwiLFwieDNkdnpcIl0sXCJtb2RlbC94M2QreG1sXCI6W1wieDNkXCIsXCJ4M2R6XCJdLFwibW9kZWwveDNkLXZybWxcIjpbXCJ4M2R2XCJdLFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiOltcImFwcGNhY2hlXCIsXCJtYW5pZmVzdFwiXSxcInRleHQvY2FsZW5kYXJcIjpbXCJpY3NcIixcImlmYlwiXSxcInRleHQvY29mZmVlc2NyaXB0XCI6W1wiY29mZmVlXCIsXCJsaXRjb2ZmZWVcIl0sXCJ0ZXh0L2Nzc1wiOltcImNzc1wiXSxcInRleHQvY3N2XCI6W1wiY3N2XCJdLFwidGV4dC9odG1sXCI6W1wiaHRtbFwiLFwiaHRtXCIsXCJzaHRtbFwiXSxcInRleHQvamFkZVwiOltcImphZGVcIl0sXCJ0ZXh0L2pzeFwiOltcImpzeFwiXSxcInRleHQvbGVzc1wiOltcImxlc3NcIl0sXCJ0ZXh0L21hcmtkb3duXCI6W1wibWFya2Rvd25cIixcIm1kXCJdLFwidGV4dC9tYXRobWxcIjpbXCJtbWxcIl0sXCJ0ZXh0L21keFwiOltcIm1keFwiXSxcInRleHQvbjNcIjpbXCJuM1wiXSxcInRleHQvcGxhaW5cIjpbXCJ0eHRcIixcInRleHRcIixcImNvbmZcIixcImRlZlwiLFwibGlzdFwiLFwibG9nXCIsXCJpblwiLFwiaW5pXCJdLFwidGV4dC9yaWNodGV4dFwiOltcInJ0eFwiXSxcInRleHQvcnRmXCI6W1wiKnJ0ZlwiXSxcInRleHQvc2dtbFwiOltcInNnbWxcIixcInNnbVwiXSxcInRleHQvc2hleFwiOltcInNoZXhcIl0sXCJ0ZXh0L3NsaW1cIjpbXCJzbGltXCIsXCJzbG1cIl0sXCJ0ZXh0L3NwZHhcIjpbXCJzcGR4XCJdLFwidGV4dC9zdHlsdXNcIjpbXCJzdHlsdXNcIixcInN0eWxcIl0sXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCI6W1widHN2XCJdLFwidGV4dC90cm9mZlwiOltcInRcIixcInRyXCIsXCJyb2ZmXCIsXCJtYW5cIixcIm1lXCIsXCJtc1wiXSxcInRleHQvdHVydGxlXCI6W1widHRsXCJdLFwidGV4dC91cmktbGlzdFwiOltcInVyaVwiLFwidXJpc1wiLFwidXJsc1wiXSxcInRleHQvdmNhcmRcIjpbXCJ2Y2FyZFwiXSxcInRleHQvdnR0XCI6W1widnR0XCJdLFwidGV4dC94bWxcIjpbXCIqeG1sXCJdLFwidGV4dC95YW1sXCI6W1wieWFtbFwiLFwieW1sXCJdLFwidmlkZW8vM2dwcFwiOltcIjNncFwiLFwiM2dwcFwiXSxcInZpZGVvLzNncHAyXCI6W1wiM2cyXCJdLFwidmlkZW8vaDI2MVwiOltcImgyNjFcIl0sXCJ2aWRlby9oMjYzXCI6W1wiaDI2M1wiXSxcInZpZGVvL2gyNjRcIjpbXCJoMjY0XCJdLFwidmlkZW8vaXNvLnNlZ21lbnRcIjpbXCJtNHNcIl0sXCJ2aWRlby9qcGVnXCI6W1wianBndlwiXSxcInZpZGVvL2pwbVwiOltcIipqcG1cIixcImpwZ21cIl0sXCJ2aWRlby9tajJcIjpbXCJtajJcIixcIm1qcDJcIl0sXCJ2aWRlby9tcDJ0XCI6W1widHNcIl0sXCJ2aWRlby9tcDRcIjpbXCJtcDRcIixcIm1wNHZcIixcIm1wZzRcIl0sXCJ2aWRlby9tcGVnXCI6W1wibXBlZ1wiLFwibXBnXCIsXCJtcGVcIixcIm0xdlwiLFwibTJ2XCJdLFwidmlkZW8vb2dnXCI6W1wib2d2XCJdLFwidmlkZW8vcXVpY2t0aW1lXCI6W1wicXRcIixcIm1vdlwiXSxcInZpZGVvL3dlYm1cIjpbXCJ3ZWJtXCJdfTsiLCIvLyAncGF0aCcgbW9kdWxlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSAob25seSB0aGUgcG9zaXggcGFydClcbi8vIHRyYW5zcGxpdGVkIHdpdGggQmFiZWxcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gIH1cbn1cblxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCBhbGxvd0Fib3ZlUm9vdCkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIHZhciBsYXN0U2xhc2ggPSAtMTtcbiAgdmFyIGRvdHMgPSAwO1xuICB2YXIgY29kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgY29kZSA9IDQ3IC8qLyovO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAvLyBOT09QXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiAvKi4qLyB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMgPSAnLi4nO1xuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJlcyArPSAnLycgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2IC8qLiovICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgdmFyIGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgKHBhdGhPYmplY3QubmFtZSB8fCAnJykgKyAocGF0aE9iamVjdC5leHQgfHwgJycpO1xuICBpZiAoIWRpcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChkaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG4gIHJldHVybiBkaXIgKyBzZXAgKyBiYXNlO1xufVxuXG52YXIgcG9zaXggPSB7XG4gIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgY3dkO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3dkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgcGF0aCA9IGN3ZDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcblxuICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3IC8qLyovO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsICFpc0Fic29sdXRlKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkgcGF0aCA9ICcuJztcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKSBwYXRoICs9ICcvJztcblxuICAgIGlmIChpc0Fic29sdXRlKSByZXR1cm4gJy8nICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICcuJztcbiAgICB2YXIgam9pbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBqb2luZWQgKz0gJy8nICsgYXJnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcblxuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBhc3NlcnRQYXRoKGZyb20pO1xuICAgIGFzc2VydFBhdGgodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICB0byA9IHBvc2l4LnJlc29sdmUodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIGZyb21TdGFydCA9IDE7XG4gICAgZm9yICg7IGZyb21TdGFydCA8IGZyb20ubGVuZ3RoOyArK2Zyb21TdGFydCkge1xuICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciB0b1N0YXJ0ID0gMTtcbiAgICBmb3IgKDsgdG9TdGFydCA8IHRvLmxlbmd0aDsgKyt0b1N0YXJ0KSB7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgdG9FbmQgPSB0by5sZW5ndGg7XG4gICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuXG4gICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgdmFyIGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vJzsgdG89Jy8nXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICB2YXIgdG9Db2RlID0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSk7XG4gICAgICBpZiAoZnJvbUNvZGUgIT09IHRvQ29kZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gNDcgLyovKi8pXG4gICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgIC8vIGFuZCBgZnJvbWBcbiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgb3V0ICs9ICcuLic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXQgKz0gJy8uLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gb3V0ICsgdG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApO1xuICAgIGVsc2Uge1xuICAgICAgdG9TdGFydCArPSBsYXN0Q29tbW9uU2VwO1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IDQ3IC8qLyovKVxuICAgICAgICArK3RvU3RhcnQ7XG4gICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCk7XG4gICAgfVxuICB9LFxuXG4gIF9tYWtlTG9uZzogZnVuY3Rpb24gX21ha2VMb25nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSByZXR1cm4gJy8vJztcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICB9LFxuXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aC5sZW5ndGggJiYgZXh0ID09PSBwYXRoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7ZWxzZSBpZiAoZW5kID09PSAtMSkgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcblxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChwYXRoT2JqZWN0KSB7XG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHBhdGhPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdCgnLycsIHBhdGhPYmplY3QpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgc3RhcnQ7XG4gICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgIHJldC5yb290ID0gJy8nO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcblxuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG5cbiAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSBzdGFydERvdCA9IGk7ZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHByZURvdFN0YXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIGVuZCk7ZWxzZSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhcnQgPiAwKSByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtlbHNlIGlmIChpc0Fic29sdXRlKSByZXQuZGlyID0gJy8nO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIHdpbjMyOiBudWxsLFxuICBwb3NpeDogbnVsbFxufTtcblxucG9zaXgucG9zaXggPSBwb3NpeDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpeDtcbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwiUG9zdE1lXCIsIFtcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kLmV4cG9ydHMpO1xuICAgIGdsb2JhbC5Qb3N0TWUgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgX2V4cG9ydHMuQ2hpbGRIYW5kc2hha2UgPSBDaGlsZEhhbmRzaGFrZTtcbiAgX2V4cG9ydHMuRGVidWdNZXNzZW5nZXIgPSBEZWJ1Z01lc3NlbmdlcjtcbiAgX2V4cG9ydHMuUGFyZW50SGFuZHNoYWtlID0gUGFyZW50SGFuZHNoYWtlO1xuICBfZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnO1xuICBfZXhwb3J0cy5Xb3JrZXJNZXNzZW5nZXIgPSBfZXhwb3J0cy5XaW5kb3dNZXNzZW5nZXIgPSBfZXhwb3J0cy5Qb3J0TWVzc2VuZ2VyID0gX2V4cG9ydHMuQ29uY3JldGVFbWl0dGVyID0gX2V4cG9ydHMuQmFyZU1lc3NlbmdlciA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbiAgdmFyIE1BUktFUiA9ICdAcG9zdC1tZSc7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pcXVlSWRGbigpIHtcbiAgICB2YXIgX19pZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZCA9IF9faWQ7XG4gICAgICBfX2lkICs9IDE7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEVtaXR0ZXJ9IGludGVyZmFjZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgdmFyIENvbmNyZXRlRW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVFbWl0dGVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNyZXRlRW1pdHRlcik7XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0RG9jIEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcn0gKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbmNyZXRlRW1pdHRlciwgW3tcbiAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgLyoqIHtAaW5oZXJpdERvYyBFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXJ9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnNbXCJkZWxldGVcIl0obGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgLyoqIHtAaW5oZXJpdERvYyBFbWl0dGVyLm9uY2V9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25jZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKiogQGludGVybmFsICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW1pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbGxMaXN0ZW5lcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fbGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25jcmV0ZUVtaXR0ZXI7XG4gIH0oKTtcblxuICBfZXhwb3J0cy5Db25jcmV0ZUVtaXR0ZXIgPSBDb25jcmV0ZUVtaXR0ZXI7XG4gIHZhciBNZXNzYWdlVHlwZTtcblxuICAoZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbXCJIYW5kc2hha2VSZXF1ZXN0XCJdID0gXCJoYW5kc2hha2UtcmVxdWVzdFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiSGFuZHNoYWtlUmVzcG9uc2VcIl0gPSBcImhhbmRzaGFrZS1yZXNwb25zZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ2FsbFwiXSA9IFwiY2FsbFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiUmVzcG9uc2VcIl0gPSBcInJlc3BvbnNlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkV2ZW50XCJdID0gXCJldmVudFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ2FsbGJhY2tcIl0gPSBcImNhbGxiYWNrXCI7XG4gIH0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7IC8vIE1lc3NhZ2UgQ3JlYXRvcnNcblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhbmRzaGFrZVJlcXVlc3RNZXNzYWdlKHNlc3Npb25JZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkhhbmRzaGFrZVJlcXVlc3QsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIYW5kc2hha2VSZXNwb25zZU1lc3NhZ2Uoc2Vzc2lvbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVzcG9uc2UsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDYWxsTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkNhbGwsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc01lc3NhZ2Uoc2Vzc2lvbklkLCByZXF1ZXN0SWQsIHJlc3VsdCwgZXJyb3IpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6IE1BUktFUixcbiAgICAgIGFjdGlvbjogTWVzc2FnZVR5cGUuUmVzcG9uc2UsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkXG4gICAgfTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lc3NhZ2UuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrTWVzc2FnZShzZXNzaW9uSWQsIHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkNhbGxiYWNrLFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcbiAgICAgIGNhbGxiYWNrSWQ6IGNhbGxiYWNrSWQsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50TWVzc2FnZShzZXNzaW9uSWQsIGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBNQVJLRVIsXG4gICAgICBhY3Rpb246IE1lc3NhZ2VUeXBlLkV2ZW50LFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9O1xuICB9IC8vIFR5cGUgR3VhcmRzXG5cblxuICBmdW5jdGlvbiBpc01lc3NhZ2UobSkge1xuICAgIHJldHVybiBtICYmIG0udHlwZSA9PT0gTUFSS0VSO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYW5kc2hha2VSZXF1ZXN0TWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFuZHNoYWtlUmVzcG9uc2VNZXNzYWdlKG0pIHtcbiAgICByZXR1cm4gaXNNZXNzYWdlKG0pICYmIG0uYWN0aW9uID09PSBNZXNzYWdlVHlwZS5IYW5kc2hha2VSZXNwb25zZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FsbE1lc3NhZ2UobSkge1xuICAgIHJldHVybiBpc01lc3NhZ2UobSkgJiYgbS5hY3Rpb24gPT09IE1lc3NhZ2VUeXBlLkNhbGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jlc3BvbnNlTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuUmVzcG9uc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NhbGxiYWNrTWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuQ2FsbGJhY2s7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V2ZW50TWVzc2FnZShtKSB7XG4gICAgcmV0dXJuIGlzTWVzc2FnZShtKSAmJiBtLmFjdGlvbiA9PT0gTWVzc2FnZVR5cGUuRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2tFdmVudChyZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gXCJjYWxsYmFja19cIi5jb25jYXQocmVxdWVzdElkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZXNwb25zZUV2ZW50KHJlcXVlc3RJZCkge1xuICAgIHJldHVybiBcInJlc3BvbnNlX1wiLmNvbmNhdChyZXF1ZXN0SWQpO1xuICB9XG5cbiAgdmFyIERpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERpc3BhdGNoZXIpO1xuXG4gICAgZnVuY3Rpb24gRGlzcGF0Y2hlcihtZXNzZW5nZXIsIHNlc3Npb25JZCkge1xuICAgICAgdmFyIF90aGlzMjtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgICBfdGhpczIgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzMi51bmlxdWVJZCA9IGNyZWF0ZVVuaXF1ZUlkRm4oKTtcbiAgICAgIF90aGlzMi5tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICBfdGhpczIuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgX3RoaXMyLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXMyLm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXMyLm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKSk7XG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEaXNwYXRjaGVyLCBbe1xuICAgICAga2V5OiBcIm1lc3Nlbmdlckxpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2VuZ2VyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmICghaXNNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkICE9PSBkYXRhLnNlc3Npb25JZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NhbGxNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KE1lc3NhZ2VUeXBlLkNhbGwsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVzcG9uc2VNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KG1ha2VSZXNwb25zZUV2ZW50KGRhdGEucmVxdWVzdElkKSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudE1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVR5cGUuRXZlbnQsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsbGJhY2tNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KG1ha2VDYWxsYmFja0V2ZW50KGRhdGEucmVxdWVzdElkKSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsbE9uUmVtb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbE9uUmVtb3RlKG1ldGhvZE5hbWUsIGFyZ3MsIHRyYW5zZmVyKSB7XG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSB0aGlzLnVuaXF1ZUlkKCk7XG4gICAgICAgIHZhciBjYWxsYmFja0V2ZW50ID0gbWFrZUNhbGxiYWNrRXZlbnQocmVxdWVzdElkKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlRXZlbnQgPSBtYWtlUmVzcG9uc2VFdmVudChyZXF1ZXN0SWQpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUNhbGxNZXNzYWdlKHRoaXMuc2Vzc2lvbklkLCByZXF1ZXN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FsbGJhY2tFdmVudDogY2FsbGJhY2tFdmVudCxcbiAgICAgICAgICByZXNwb25zZUV2ZW50OiByZXNwb25zZUV2ZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc3BvbmRUb1JlbW90ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3BvbmRUb1JlbW90ZShyZXF1ZXN0SWQsIHZhbHVlLCBlcnJvciwgdHJhbnNmZXIpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXNzYWdlID0gY3JlYXRlUmVzcG9uc01lc3NhZ2UodGhpcy5zZXNzaW9uSWQsIHJlcXVlc3RJZCwgdmFsdWUsIGVycm9yKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxsYmFja1RvUmVtb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbGJhY2tUb1JlbW90ZShyZXF1ZXN0SWQsIGNhbGxiYWNrSWQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjcmVhdGVDYWxsYmFja01lc3NhZ2UodGhpcy5zZXNzaW9uSWQsIHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncyk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbWl0VG9SZW1vdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0VG9SZW1vdGUoZXZlbnROYW1lLCBwYXlsb2FkLCB0cmFuc2Zlcikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUV2ZW50TWVzc2FnZSh0aGlzLnNlc3Npb25JZCwgZXZlbnROYW1lLCBwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5tZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERpc3BhdGNoZXI7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbmNyZXRlRW1pdHRlcjIpIHtcbiAgICBfaW5oZXJpdHMoUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcjIpO1xuXG4gICAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcik7XG5cbiAgICBmdW5jdGlvbiBQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyKG1lc3Nlbmdlciwgc2Vzc2lvbklkKSB7XG4gICAgICB2YXIgX3RoaXMzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcik7XG5cbiAgICAgIF90aGlzMyA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICAgIF90aGlzMy5tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICBfdGhpczMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgX3RoaXMzLnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXMzLm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXMzLm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSk7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQYXJlbnRIYW5kc2hha2VEaXNwYXRjaGVyLCBbe1xuICAgICAga2V5OiBcIm1lc3Nlbmdlckxpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2VuZ2VyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmICghaXNNZXNzYWdlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkICE9PSBkYXRhLnNlc3Npb25JZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hhbmRzaGFrZVJlc3BvbnNlTWVzc2FnZShkYXRhKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChkYXRhLnNlc3Npb25JZCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdGlhdGVIYW5kc2hha2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWF0ZUhhbmRzaGFrZSgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjcmVhdGVIYW5kc2hha2VSZXF1ZXN0TWVzc2FnZSh0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgIHRoaXMubWVzc2VuZ2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uSWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWVzc2VuZ2VyTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGFyZW50SGFuZHNoYWtlRGlzcGF0Y2hlcjtcbiAgfShDb25jcmV0ZUVtaXR0ZXIpO1xuXG4gIHZhciBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXIzKSB7XG4gICAgX2luaGVyaXRzKENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlciwgX0NvbmNyZXRlRW1pdHRlcjMpO1xuXG4gICAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyKTtcblxuICAgIGZ1bmN0aW9uIENoaWxkSGFuZHNoYWtlRGlzcGF0Y2hlcihtZXNzZW5nZXIpIHtcbiAgICAgIHZhciBfdGhpczQ7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIpO1xuXG4gICAgICBfdGhpczQgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgICBfdGhpczQubWVzc2VuZ2VyID0gbWVzc2VuZ2VyO1xuICAgICAgX3RoaXM0LnJlbW92ZU1lc3Nlbmdlckxpc3RlbmVyID0gX3RoaXM0Lm1lc3Nlbmdlci5hZGRNZXNzYWdlTGlzdGVuZXIoX3RoaXM0Lm1lc3Nlbmdlckxpc3RlbmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczQpKSk7XG4gICAgICByZXR1cm4gX3RoaXM0O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXIsIFt7XG4gICAgICBrZXk6IFwibWVzc2VuZ2VyTGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXNzZW5nZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKGlzSGFuZHNoYWtlUmVxdWVzdE1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWNjZXB0SGFuZHNoYWtlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0SGFuZHNoYWtlKHNlc3Npb25JZCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNyZWF0ZUhhbmRzaGFrZVJlc3BvbnNlTWVzc2FnZShzZXNzaW9uSWQpO1xuICAgICAgICB0aGlzLm1lc3Nlbmdlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNZXNzZW5nZXJMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGlsZEhhbmRzaGFrZURpc3BhdGNoZXI7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgUHJveHlUeXBlO1xuXG4gIChmdW5jdGlvbiAoUHJveHlUeXBlKSB7XG4gICAgUHJveHlUeXBlW1wiQ2FsbGJhY2tcIl0gPSBcImNhbGxiYWNrXCI7XG4gIH0pKFByb3h5VHlwZSB8fCAoUHJveHlUeXBlID0ge30pKTtcblxuICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja1Byb3h5KGNhbGxiYWNrSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogTUFSS0VSLFxuICAgICAgcHJveHk6IFByb3h5VHlwZS5DYWxsYmFjayxcbiAgICAgIGNhbGxiYWNrSWQ6IGNhbGxiYWNrSWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWxsYmFja1Byb3h5KHApIHtcbiAgICByZXR1cm4gcCAmJiBwLnR5cGUgPT09IE1BUktFUiAmJiBwLnByb3h5ID09PSBQcm94eVR5cGUuQ2FsbGJhY2s7XG4gIH1cblxuICB2YXIgQ29uY3JldGVSZW1vdGVIYW5kbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25jcmV0ZUVtaXR0ZXI0KSB7XG4gICAgX2luaGVyaXRzKENvbmNyZXRlUmVtb3RlSGFuZGxlLCBfQ29uY3JldGVFbWl0dGVyNCk7XG5cbiAgICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihDb25jcmV0ZVJlbW90ZUhhbmRsZSk7XG5cbiAgICBmdW5jdGlvbiBDb25jcmV0ZVJlbW90ZUhhbmRsZShkaXNwYXRjaGVyKSB7XG4gICAgICB2YXIgX3RoaXM1O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uY3JldGVSZW1vdGVIYW5kbGUpO1xuXG4gICAgICBfdGhpczUgPSBfc3VwZXI0LmNhbGwodGhpcyk7XG4gICAgICBfdGhpczUuX2Rpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgX3RoaXM1Ll9jYWxsVHJhbnNmZXIgPSB7fTtcblxuICAgICAgX3RoaXM1Ll9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoTWVzc2FnZVR5cGUuRXZlbnQsIF90aGlzNS5faGFuZGxlRXZlbnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNSkpKTtcblxuICAgICAgcmV0dXJuIF90aGlzNTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uY3JldGVSZW1vdGVIYW5kbGUsIFt7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q2FsbFRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FsbFRyYW5zZmVyKG1ldGhvZE5hbWUsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuX2NhbGxUcmFuc2ZlclttZXRob2ROYW1lXSA9IHRyYW5zZmVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbChtZXRob2ROYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUNhbGwobWV0aG9kTmFtZSwgYXJncyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImN1c3RvbUNhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21DYWxsKG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBzYW5pdGl6ZWRBcmdzID0gW107XG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gMDtcbiAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgc2FuaXRpemVkQXJncy5wdXNoKGNyZWF0ZUNhbGxiYWNrUHJveHkoY2FsbGJhY2tJZCkpO1xuICAgICAgICAgICAgICBjYWxsYmFja0lkICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYW5pdGl6ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaGFzQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3RlbmVyID0gZnVuY3Rpb24gY2FsbGJhY2tMaXN0ZW5lcihkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgICAgICAgYXJncyA9IGRhdGEuYXJncztcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW2NhbGxiYWNrSWRdLmFwcGx5KGNhbGxiYWNrcywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRyYW5zZmVyID0gb3B0aW9ucy50cmFuc2ZlcjtcblxuICAgICAgICAgIGlmICh0cmFuc2ZlciA9PT0gdW5kZWZpbmVkICYmIF90aGlzNi5fY2FsbFRyYW5zZmVyW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2JF9jYWxsVHJhbnNmZXI7XG5cbiAgICAgICAgICAgIHRyYW5zZmVyID0gKF90aGlzNiRfY2FsbFRyYW5zZmVyID0gX3RoaXM2Ll9jYWxsVHJhbnNmZXIpW21ldGhvZE5hbWVdLmFwcGx5KF90aGlzNiRfY2FsbFRyYW5zZmVyLCBzYW5pdGl6ZWRBcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RoaXM2JF9kaXNwYXRjaGVyJGNhID0gX3RoaXM2Ll9kaXNwYXRjaGVyLmNhbGxPblJlbW90ZShtZXRob2ROYW1lLCBzYW5pdGl6ZWRBcmdzLCB0cmFuc2ZlciksXG4gICAgICAgICAgICAgIGNhbGxiYWNrRXZlbnQgPSBfdGhpczYkX2Rpc3BhdGNoZXIkY2EuY2FsbGJhY2tFdmVudCxcbiAgICAgICAgICAgICAgcmVzcG9uc2VFdmVudCA9IF90aGlzNiRfZGlzcGF0Y2hlciRjYS5yZXNwb25zZUV2ZW50O1xuXG4gICAgICAgICAgaWYgKGhhc0NhbGxiYWNrcykge1xuICAgICAgICAgICAgX3RoaXM2Ll9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoY2FsbGJhY2tFdmVudCwgY2FsbGJhY2tMaXN0ZW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM2Ll9kaXNwYXRjaGVyLm9uY2UocmVzcG9uc2VFdmVudCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5fZGlzcGF0Y2hlci5yZW1vdmVFdmVudExpc3RlbmVyKGNhbGxiYWNrRXZlbnQsIGNhbGxiYWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0LFxuICAgICAgICAgICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cbiAgICAgICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRXZlbnQoZGF0YSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZGF0YS5ldmVudE5hbWUsXG4gICAgICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uY3JldGVSZW1vdGVIYW5kbGU7XG4gIH0oQ29uY3JldGVFbWl0dGVyKTtcblxuICB2YXIgQ29uY3JldGVMb2NhbEhhbmRsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVMb2NhbEhhbmRsZShkaXNwYXRjaGVyLCBsb2NhbE1ldGhvZHMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25jcmV0ZUxvY2FsSGFuZGxlKTtcblxuICAgICAgdGhpcy5fZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICB0aGlzLl9tZXRob2RzID0gbG9jYWxNZXRob2RzO1xuICAgICAgdGhpcy5fcmV0dXJuVHJhbnNmZXIgPSB7fTtcbiAgICAgIHRoaXMuX2VtaXRUcmFuc2ZlciA9IHt9O1xuXG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoTWVzc2FnZVR5cGUuQ2FsbCwgdGhpcy5faGFuZGxlQ2FsbC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uY3JldGVMb2NhbEhhbmRsZSwgW3tcbiAgICAgIGtleTogXCJlbWl0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICB2YXIgdHJhbnNmZXIgPSBvcHRpb25zLnRyYW5zZmVyO1xuXG4gICAgICAgIGlmICh0cmFuc2ZlciA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2VtaXRUcmFuc2ZlcltldmVudE5hbWVdKSB7XG4gICAgICAgICAgdHJhbnNmZXIgPSB0aGlzLl9lbWl0VHJhbnNmZXJbZXZlbnROYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZW1pdFRvUmVtb3RlKGV2ZW50TmFtZSwgcGF5bG9hZCwgdHJhbnNmZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRNZXRob2RzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRNZXRob2RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNZXRob2QobWV0aG9kTmFtZSwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZHNbbWV0aG9kTmFtZV0gPSBtZXRob2Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFJldHVyblRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmV0dXJuVHJhbnNmZXIobWV0aG9kTmFtZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5fcmV0dXJuVHJhbnNmZXJbbWV0aG9kTmFtZV0gPSB0cmFuc2ZlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RW1pdFRyYW5zZmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RW1pdFRyYW5zZmVyKGV2ZW50TmFtZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRyYW5zZmVyW2V2ZW50TmFtZV0gPSB0cmFuc2ZlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUNhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2FsbChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSBkYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSBkYXRhLm1ldGhvZE5hbWUsXG4gICAgICAgICAgICBhcmdzID0gZGF0YS5hcmdzO1xuICAgICAgICB2YXIgY2FsbE1ldGhvZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgX3RoaXM3JF9tZXRob2RzO1xuXG4gICAgICAgICAgdmFyIG1ldGhvZCA9IF90aGlzNy5fbWV0aG9kc1ttZXRob2ROYW1lXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGhlIG1ldGhvZCBcXFwiXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiXFxcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQuXCIpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlc2FuaXRpemVkQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxiYWNrUHJveHkoYXJnKSkge1xuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tJZCA9IGFyZy5jYWxsYmFja0lkO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzNy5fZGlzcGF0Y2hlci5jYWxsYmFja1RvUmVtb3RlKHJlcXVlc3RJZCwgY2FsbGJhY2tJZCwgYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgoX3RoaXM3JF9tZXRob2RzID0gX3RoaXM3Ll9tZXRob2RzKVttZXRob2ROYW1lXS5hcHBseShfdGhpczckX21ldGhvZHMsIF90b0NvbnN1bWFibGVBcnJheShkZXNhbml0aXplZEFyZ3MpKSkudGhlbihyZXNvbHZlKVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsTWV0aG9kLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHZhciB0cmFuc2ZlcjtcblxuICAgICAgICAgIGlmIChfdGhpczcuX3JldHVyblRyYW5zZmVyW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICB0cmFuc2ZlciA9IF90aGlzNy5fcmV0dXJuVHJhbnNmZXJbbWV0aG9kTmFtZV0ocmVzdWx0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczcuX2Rpc3BhdGNoZXIucmVzcG9uZFRvUmVtb3RlKHJlcXVlc3RJZCwgcmVzdWx0LCB1bmRlZmluZWQsIHRyYW5zZmVyKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczcuX2Rpc3BhdGNoZXIucmVzcG9uZFRvUmVtb3RlKHJlcXVlc3RJZCwgdW5kZWZpbmVkLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25jcmV0ZUxvY2FsSGFuZGxlO1xuICB9KCk7XG5cbiAgdmFyIENvbmNyZXRlQ29ubmVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY3JldGVDb25uZWN0aW9uKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNyZXRlQ29ubmVjdGlvbik7XG5cbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgdGhpcy5fbG9jYWxIYW5kbGUgPSBuZXcgQ29uY3JldGVMb2NhbEhhbmRsZShkaXNwYXRjaGVyLCBsb2NhbE1ldGhvZHMpO1xuICAgICAgdGhpcy5fcmVtb3RlSGFuZGxlID0gbmV3IENvbmNyZXRlUmVtb3RlSGFuZGxlKGRpc3BhdGNoZXIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb25jcmV0ZUNvbm5lY3Rpb24sIFt7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMucmVtb3RlSGFuZGxlKCkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibG9jYWxIYW5kbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbEhhbmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsSGFuZGxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdGVIYW5kbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdGVIYW5kbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVIYW5kbGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbmNyZXRlQ29ubmVjdGlvbjtcbiAgfSgpO1xuXG4gIHZhciB1bmlxdWVTZXNzaW9uSWQgPSBjcmVhdGVVbmlxdWVJZEZuKCk7XG5cbiAgdmFyIHJ1blVudGlsID0gZnVuY3Rpb24gcnVuVW50aWwod29ya2VyLCBjb25kaXRpb24sIHVuZnVsZmlsbGVkLCBtYXhBdHRlbXB0cywgYXR0ZW1wdEludGVydmFsKSB7XG4gICAgdmFyIGF0dGVtcHQgPSAwO1xuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbigpICYmIChhdHRlbXB0IDwgbWF4QXR0ZW1wdHMgfHwgbWF4QXR0ZW1wdHMgPCAxKSkge1xuICAgICAgICB3b3JrZXIoKTtcbiAgICAgICAgYXR0ZW1wdCArPSAxO1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCBhdHRlbXB0SW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIGlmICghY29uZGl0aW9uKCkgJiYgYXR0ZW1wdCA+PSBtYXhBdHRlbXB0cyAmJiBtYXhBdHRlbXB0cyA+PSAxKSB7XG4gICAgICAgIHVuZnVsZmlsbGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZuKCk7XG4gIH07XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgaGFuZHNoYWtlIGZyb20gdGhlIFBhcmVudCBzaWRlXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzZW5nZXIgLSBUaGUgTWVzc2VuZ2VyIHVzZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvdGhlciBlbmRcbiAgICogQHBhcmFtIGxvY2FsTWV0aG9kcyAtIFRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBleHBvc2VkIHRvIHRoZSBvdGhlciBlbmRcbiAgICogQHBhcmFtIG1heEF0dGVtcHRzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGhhbmRzaGFrZSBhdHRlbXB0c1xuICAgKiBAcGFyYW0gYXR0ZW1wdHNJbnRlcnZhbCAtIFRoZSBpbnRlcnZhbCBiZXR3ZWVuIGhhbmRzaGFrZSBhdHRlbXB0c1xuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdG8gYW4gYWN0aXZlIHtAbGluayBDb25uZWN0aW9ufSB0byB0aGUgb3RoZXIgZW5kXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBmdW5jdGlvbiBQYXJlbnRIYW5kc2hha2UobWVzc2VuZ2VyKSB7XG4gICAgdmFyIGxvY2FsTWV0aG9kcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIG1heEF0dGVtcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1O1xuICAgIHZhciBhdHRlbXB0c0ludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxMDA7XG4gICAgdmFyIHRoaXNTZXNzaW9uSWQgPSB1bmlxdWVTZXNzaW9uSWQoKTtcbiAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBoYW5kc2hha2VEaXNwYXRjaGVyID0gbmV3IFBhcmVudEhhbmRzaGFrZURpc3BhdGNoZXIobWVzc2VuZ2VyLCB0aGlzU2Vzc2lvbklkKTtcbiAgICAgIGhhbmRzaGFrZURpc3BhdGNoZXIub25jZSh0aGlzU2Vzc2lvbklkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLmNsb3NlKCk7XG4gICAgICAgIHZhciBzZXNzaW9uSWQgPSByZXNwb25zZS5zZXNzaW9uSWQ7XG4gICAgICAgIHZhciBkaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIobWVzc2VuZ2VyLCBzZXNzaW9uSWQpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBDb25jcmV0ZUNvbm5lY3Rpb24oZGlzcGF0Y2hlciwgbG9jYWxNZXRob2RzKTtcbiAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcnVuVW50aWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFuZHNoYWtlRGlzcGF0Y2hlci5pbml0aWF0ZUhhbmRzaGFrZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGVkO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkhhbmRzaGFrZSBmYWlsZWQsIHJlYWNoZWQgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHNcIikpO1xuICAgICAgfSwgbWF4QXR0ZW1wdHMsIGF0dGVtcHRzSW50ZXJ2YWwpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgaGFuZHNoYWtlIGZyb20gdGhlIENoaWxkIHNpZGVcbiAgICpcbiAgICogQHBhcmFtIG1lc3NlbmdlciAtIFRoZSBNZXNzZW5nZXIgdXNlZCB0byBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIGZyb20gdGhlIG90aGVyIGVuZFxuICAgKiBAcGFyYW0gbG9jYWxNZXRob2RzIC0gVGhlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIG90aGVyIGVuZFxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdG8gYW4gYWN0aXZlIHtAbGluayBDb25uZWN0aW9ufSB0byB0aGUgb3RoZXIgZW5kXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBmdW5jdGlvbiBDaGlsZEhhbmRzaGFrZShtZXNzZW5nZXIpIHtcbiAgICB2YXIgbG9jYWxNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGhhbmRzaGFrZURpc3BhdGNoZXIgPSBuZXcgQ2hpbGRIYW5kc2hha2VEaXNwYXRjaGVyKG1lc3Nlbmdlcik7XG4gICAgICBoYW5kc2hha2VEaXNwYXRjaGVyLm9uY2UoTWVzc2FnZVR5cGUuSGFuZHNoYWtlUmVxdWVzdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHNlc3Npb25JZCA9IHJlc3BvbnNlLnNlc3Npb25JZDtcbiAgICAgICAgaGFuZHNoYWtlRGlzcGF0Y2hlci5hY2NlcHRIYW5kc2hha2Uoc2Vzc2lvbklkKTtcbiAgICAgICAgaGFuZHNoYWtlRGlzcGF0Y2hlci5jbG9zZSgpO1xuICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKG1lc3Nlbmdlciwgc2Vzc2lvbklkKTtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgQ29uY3JldGVDb25uZWN0aW9uKGRpc3BhdGNoZXIsIGxvY2FsTWV0aG9kcyk7XG4gICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhY2NlcHRhYmxlTWVzc2FnZUV2ZW50ID0gZnVuY3Rpb24gYWNjZXB0YWJsZU1lc3NhZ2VFdmVudChldmVudCwgcmVtb3RlV2luZG93LCBhY2NlcHRlZE9yaWdpbikge1xuICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UsXG4gICAgICAgIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbjtcblxuICAgIGlmIChzb3VyY2UgIT09IHJlbW90ZVdpbmRvdykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGFjY2VwdGVkT3JpZ2luICYmIGFjY2VwdGVkT3JpZ2luICE9PSAnKicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIE1lc3Nlbmdlcn0gdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIGFub3RoZXIgV2luZG93LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIFdpbmRvd01lc3NlbmdlciA9IGZ1bmN0aW9uIFdpbmRvd01lc3NlbmdlcihfcmVmKSB7XG4gICAgdmFyIGxvY2FsV2luZG93ID0gX3JlZi5sb2NhbFdpbmRvdyxcbiAgICAgICAgcmVtb3RlV2luZG93ID0gX3JlZi5yZW1vdGVXaW5kb3csXG4gICAgICAgIHJlbW90ZU9yaWdpbiA9IF9yZWYucmVtb3RlT3JpZ2luO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpbmRvd01lc3Nlbmdlcik7XG5cbiAgICBsb2NhbFdpbmRvdyA9IGxvY2FsV2luZG93IHx8IHdpbmRvdztcblxuICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXIpIHtcbiAgICAgIHJlbW90ZVdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCByZW1vdGVPcmlnaW4sIHRyYW5zZmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHZhciBvdXRlckxpc3RlbmVyID0gZnVuY3Rpb24gb3V0ZXJMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoYWNjZXB0YWJsZU1lc3NhZ2VFdmVudChldmVudCwgcmVtb3RlV2luZG93LCByZW1vdGVPcmlnaW4pKSB7XG4gICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsb2NhbFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG5cbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBsb2NhbFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb3V0ZXJMaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gICAgfTtcbiAgfTtcbiAgLyoqIEBwdWJsaWMgKi9cblxuXG4gIF9leHBvcnRzLldpbmRvd01lc3NlbmdlciA9IFdpbmRvd01lc3NlbmdlcjtcblxuICB2YXIgQmFyZU1lc3NlbmdlciA9IGZ1bmN0aW9uIEJhcmVNZXNzZW5nZXIocG9zdGFibGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyZU1lc3Nlbmdlcik7XG5cbiAgICB0aGlzLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciB0cmFuc2ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICBwb3N0YWJsZS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgb3V0ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIG91dGVyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgcG9zdGFibGUuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG91dGVyTGlzdGVuZXIpO1xuXG4gICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgcG9zdGFibGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG91dGVyTGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBNZXNzZW5nZXJ9IHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCBhIFdvcmtlci5cbiAgICpcbiAgICogVGFrZXMgYSB7QGxpbmsgUG9zdGFibGV9IHJlcHJlc2VudGluZyB0aGUgYFdvcmtlcmAgKHdoZW4gY2FsbGluZyBmcm9tXG4gICAqIHRoZSBwYXJlbnQgY29udGV4dCkgb3IgdGhlIGBzZWxmYCBgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVgIG9iamVjdFxuICAgKiAod2hlbiBjYWxsaW5nIGZyb20gdGhlIGNoaWxkIGNvbnRleHQpLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgX2V4cG9ydHMuQmFyZU1lc3NlbmdlciA9IEJhcmVNZXNzZW5nZXI7XG5cbiAgdmFyIFdvcmtlck1lc3NlbmdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JhcmVNZXNzZW5nZXIpIHtcbiAgICBfaW5oZXJpdHMoV29ya2VyTWVzc2VuZ2VyLCBfQmFyZU1lc3Nlbmdlcik7XG5cbiAgICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihXb3JrZXJNZXNzZW5nZXIpO1xuXG4gICAgZnVuY3Rpb24gV29ya2VyTWVzc2VuZ2VyKF9yZWYyKSB7XG4gICAgICB2YXIgd29ya2VyID0gX3JlZjIud29ya2VyO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV29ya2VyTWVzc2VuZ2VyKTtcblxuICAgICAgcmV0dXJuIF9zdXBlcjUuY2FsbCh0aGlzLCB3b3JrZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBXb3JrZXJNZXNzZW5nZXI7XG4gIH0oQmFyZU1lc3Nlbmdlcik7XG4gIC8qKlxuICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBNZXNzZW5nZXJ9IHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCBhIE1lc3NhZ2VQb3J0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqL1xuXG5cbiAgX2V4cG9ydHMuV29ya2VyTWVzc2VuZ2VyID0gV29ya2VyTWVzc2VuZ2VyO1xuXG4gIHZhciBQb3J0TWVzc2VuZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyZU1lc3NlbmdlcjIpIHtcbiAgICBfaW5oZXJpdHMoUG9ydE1lc3NlbmdlciwgX0JhcmVNZXNzZW5nZXIyKTtcblxuICAgIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKFBvcnRNZXNzZW5nZXIpO1xuXG4gICAgZnVuY3Rpb24gUG9ydE1lc3NlbmdlcihfcmVmMykge1xuICAgICAgdmFyIHBvcnQgPSBfcmVmMy5wb3J0O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9ydE1lc3Nlbmdlcik7XG5cbiAgICAgIHBvcnQuc3RhcnQoKTtcbiAgICAgIHJldHVybiBfc3VwZXI2LmNhbGwodGhpcywgcG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBvcnRNZXNzZW5nZXI7XG4gIH0oQmFyZU1lc3Nlbmdlcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2dnZXIgZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSB3aWxsIGJlIHByZXBlbmRlZCB0byBhbGwgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGxvZ2dlciBmdW5jdGlvblxuICAgKiBAcGFyYW0gbG9nIC0gVGhlIHVuZGVybHlpbmcgbG9nZ2VyIChgY29uc29sZS5sb2dgIGJ5IGRlZmF1bHQpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICovXG5cblxuICBfZXhwb3J0cy5Qb3J0TWVzc2VuZ2VyID0gUG9ydE1lc3NlbmdlcjtcblxuICBmdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UsIGxvZykge1xuICAgIGxvZyA9IGxvZyB8fCBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBkYXRhW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIGxvZy5hcHBseSh2b2lkIDAsIFtuYW1lc3BhY2VdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVjb3JhdGUgYSB7QGxpbmsgTWVzc2VuZ2VyfSBzbyB0aGF0IGl0IHdpbGwgbG9nIGFueSBtZXNzYWdlIGV4Y2hhbmdlZFxuICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIE1lc3NlbmdlciB0aGF0IHdpbGwgYmUgZGVjb3JhdGVkXG4gICAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nZ2VyIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWNlaXZlIGVhY2ggbWVzc2FnZVxuICAgKiBAcmV0dXJucyBBIGRlY29yYXRlZCBNZXNzZW5nZXJcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIERlYnVnTWVzc2VuZ2VyKG1lc3NlbmdlciwgbG9nKSB7XG4gICAgbG9nID0gbG9nIHx8IGRlYnVnKCdwb3N0LW1lJyk7XG5cbiAgICB2YXIgZGVidWdMaXN0ZW5lciA9IGZ1bmN0aW9uIGRlYnVnTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIGxvZygn4qyF77iPIHJlY2VpdmVkIG1lc3NhZ2UnLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgbWVzc2VuZ2VyLmFkZE1lc3NhZ2VMaXN0ZW5lcihkZWJ1Z0xpc3RlbmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKSB7XG4gICAgICAgIGxvZygn4p6h77iPIHNlbmRpbmcgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICBtZXNzZW5nZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgfSxcbiAgICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBtZXNzZW5nZXIuYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIlwidXNlIHN0cmljdFwiO3ZhciBzamNsPXtjaXBoZXI6e30saGFzaDp7fSxrZXlleGNoYW5nZTp7fSxtb2RlOnt9LG1pc2M6e30sY29kZWM6e30sZXhjZXB0aW9uOntjb3JydXB0OmZ1bmN0aW9uKGEpe3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkNPUlJVUFQ6IFwiK3RoaXMubWVzc2FnZX07dGhpcy5tZXNzYWdlPWF9LGludmFsaWQ6ZnVuY3Rpb24oYSl7dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiSU5WQUxJRDogXCIrdGhpcy5tZXNzYWdlfTt0aGlzLm1lc3NhZ2U9YX0sYnVnOmZ1bmN0aW9uKGEpe3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkJVRzogXCIrdGhpcy5tZXNzYWdlfTt0aGlzLm1lc3NhZ2U9YX0sbm90UmVhZHk6ZnVuY3Rpb24oYSl7dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTk9UIFJFQURZOiBcIit0aGlzLm1lc3NhZ2V9O3RoaXMubWVzc2FnZT1hfX19O1xuc2pjbC5jaXBoZXIuYWVzPWZ1bmN0aW9uKGEpe3RoaXMuc1swXVswXVswXXx8dGhpcy5PKCk7dmFyIGIsYyxkLGUsZj10aGlzLnNbMF1bNF0sZz10aGlzLnNbMV07Yj1hLmxlbmd0aDt2YXIgaD0xO2lmKDQhPT1iJiY2IT09YiYmOCE9PWIpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJpbnZhbGlkIGFlcyBrZXkgc2l6ZVwiKTt0aGlzLmI9W2Q9YS5zbGljZSgwKSxlPVtdXTtmb3IoYT1iO2E8NCpiKzI4O2ErKyl7Yz1kW2EtMV07aWYoMD09PWElYnx8OD09PWImJjQ9PT1hJWIpYz1mW2M+Pj4yNF08PDI0XmZbYz4+MTYmMjU1XTw8MTZeZltjPj44JjI1NV08PDheZltjJjI1NV0sMD09PWElYiYmKGM9Yzw8OF5jPj4+MjReaDw8MjQsaD1oPDwxXjI4MyooaD4+NykpO2RbYV09ZFthLWJdXmN9Zm9yKGI9MDthO2IrKyxhLS0pYz1kW2ImMz9hOmEtNF0sZVtiXT00Pj1hfHw0PmI/YzpnWzBdW2ZbYz4+PjI0XV1eZ1sxXVtmW2M+PjE2JjI1NV1dXmdbMl1bZltjPj44JjI1NV1dXmdbM11bZltjJlxuMjU1XV19O1xuc2pjbC5jaXBoZXIuYWVzLnByb3RvdHlwZT17ZW5jcnlwdDpmdW5jdGlvbihhKXtyZXR1cm4gdCh0aGlzLGEsMCl9LGRlY3J5cHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHQodGhpcyxhLDEpfSxzOltbW10sW10sW10sW10sW11dLFtbXSxbXSxbXSxbXSxbXV1dLE86ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNbMF0sYj10aGlzLnNbMV0sYz1hWzRdLGQ9Yls0XSxlLGYsZyxoPVtdLGs9W10sbCxuLG0scDtmb3IoZT0wOzB4MTAwPmU7ZSsrKWtbKGhbZV09ZTw8MV4yODMqKGU+PjcpKV5lXT1lO2ZvcihmPWc9MDshY1tmXTtmXj1sfHwxLGc9a1tnXXx8MSlmb3IobT1nXmc8PDFeZzw8Ml5nPDwzXmc8PDQsbT1tPj44Xm0mMjU1Xjk5LGNbZl09bSxkW21dPWYsbj1oW2U9aFtsPWhbZl1dXSxwPTB4MTAxMDEwMSpuXjB4MTAwMDEqZV4weDEwMSpsXjB4MTAxMDEwMCpmLG49MHgxMDEqaFttXV4weDEwMTAxMDAqbSxlPTA7ND5lO2UrKylhW2VdW2ZdPW49bjw8MjRebj4+PjgsYltlXVttXT1wPXA8PDI0XnA+Pj44O2ZvcihlPVxuMDs1PmU7ZSsrKWFbZV09YVtlXS5zbGljZSgwKSxiW2VdPWJbZV0uc2xpY2UoMCl9fTtcbmZ1bmN0aW9uIHQoYSxiLGMpe2lmKDQhPT1iLmxlbmd0aCl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImludmFsaWQgYWVzIGJsb2NrIHNpemVcIik7dmFyIGQ9YS5iW2NdLGU9YlswXV5kWzBdLGY9YltjPzM6MV1eZFsxXSxnPWJbMl1eZFsyXTtiPWJbYz8xOjNdXmRbM107dmFyIGgsayxsLG49ZC5sZW5ndGgvNC0yLG0scD00LHI9WzAsMCwwLDBdO2g9YS5zW2NdO2E9aFswXTt2YXIgcT1oWzFdLHY9aFsyXSx3PWhbM10seD1oWzRdO2ZvcihtPTA7bTxuO20rKyloPWFbZT4+PjI0XV5xW2Y+PjE2JjI1NV1edltnPj44JjI1NV1ed1tiJjI1NV1eZFtwXSxrPWFbZj4+PjI0XV5xW2c+PjE2JjI1NV1edltiPj44JjI1NV1ed1tlJjI1NV1eZFtwKzFdLGw9YVtnPj4+MjRdXnFbYj4+MTYmMjU1XV52W2U+PjgmMjU1XV53W2YmMjU1XV5kW3ArMl0sYj1hW2I+Pj4yNF1ecVtlPj4xNiYyNTVdXnZbZj4+OCYyNTVdXndbZyYyNTVdXmRbcCszXSxwKz00LGU9aCxmPWssZz1sO2ZvcihtPVxuMDs0Pm07bSsrKXJbYz8zJi1tOm1dPXhbZT4+PjI0XTw8MjReeFtmPj4xNiYyNTVdPDwxNl54W2c+PjgmMjU1XTw8OF54W2ImMjU1XV5kW3ArK10saD1lLGU9ZixmPWcsZz1iLGI9aDtyZXR1cm4gcn1cbnNqY2wuYml0QXJyYXk9e2JpdFNsaWNlOmZ1bmN0aW9uKGEsYixjKXthPXNqY2wuYml0QXJyYXkuJChhLnNsaWNlKGIvMzIpLDMyLShiJjMxKSkuc2xpY2UoMSk7cmV0dXJuIHZvaWQgMD09PWM/YTpzamNsLmJpdEFycmF5LmNsYW1wKGEsYy1iKX0sZXh0cmFjdDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9TWF0aC5mbG9vcigtYi1jJjMxKTtyZXR1cm4oKGIrYy0xXmIpJi0zMj9hW2IvMzJ8MF08PDMyLWReYVtiLzMyKzF8MF0+Pj5kOmFbYi8zMnwwXT4+PmQpJigxPDxjKS0xfSxjb25jYXQ6ZnVuY3Rpb24oYSxiKXtpZigwPT09YS5sZW5ndGh8fDA9PT1iLmxlbmd0aClyZXR1cm4gYS5jb25jYXQoYik7dmFyIGM9YVthLmxlbmd0aC0xXSxkPXNqY2wuYml0QXJyYXkuZ2V0UGFydGlhbChjKTtyZXR1cm4gMzI9PT1kP2EuY29uY2F0KGIpOnNqY2wuYml0QXJyYXkuJChiLGQsY3wwLGEuc2xpY2UoMCxhLmxlbmd0aC0xKSl9LGJpdExlbmd0aDpmdW5jdGlvbihhKXt2YXIgYj1hLmxlbmd0aDtyZXR1cm4gMD09PVxuYj8wOjMyKihiLTEpK3NqY2wuYml0QXJyYXkuZ2V0UGFydGlhbChhW2ItMV0pfSxjbGFtcDpmdW5jdGlvbihhLGIpe2lmKDMyKmEubGVuZ3RoPGIpcmV0dXJuIGE7YT1hLnNsaWNlKDAsTWF0aC5jZWlsKGIvMzIpKTt2YXIgYz1hLmxlbmd0aDtiPWImMzE7MDxjJiZiJiYoYVtjLTFdPXNqY2wuYml0QXJyYXkucGFydGlhbChiLGFbYy0xXSYyMTQ3NDgzNjQ4Pj5iLTEsMSkpO3JldHVybiBhfSxwYXJ0aWFsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gMzI9PT1hP2I6KGM/YnwwOmI8PDMyLWEpKzB4MTAwMDAwMDAwMDAqYX0sZ2V0UGFydGlhbDpmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZChhLzB4MTAwMDAwMDAwMDApfHwzMn0sZXF1YWw6ZnVuY3Rpb24oYSxiKXtpZihzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKSE9PXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGIpKXJldHVybiExO3ZhciBjPTAsZDtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWN8PWFbZF1eYltkXTtyZXR1cm4gMD09PVxuY30sJDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZTtlPTA7Zm9yKHZvaWQgMD09PWQmJihkPVtdKTszMjw9YjtiLT0zMilkLnB1c2goYyksYz0wO2lmKDA9PT1iKXJldHVybiBkLmNvbmNhdChhKTtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKWQucHVzaChjfGFbZV0+Pj5iKSxjPWFbZV08PDMyLWI7ZT1hLmxlbmd0aD9hW2EubGVuZ3RoLTFdOjA7YT1zamNsLmJpdEFycmF5LmdldFBhcnRpYWwoZSk7ZC5wdXNoKHNqY2wuYml0QXJyYXkucGFydGlhbChiK2EmMzEsMzI8YithP2M6ZC5wb3AoKSwxKSk7cmV0dXJuIGR9LGk6ZnVuY3Rpb24oYSxiKXtyZXR1cm5bYVswXV5iWzBdLGFbMV1eYlsxXSxhWzJdXmJbMl0sYVszXV5iWzNdXX0sYnl0ZXN3YXBNOmZ1bmN0aW9uKGEpe3ZhciBiLGM7Zm9yKGI9MDtiPGEubGVuZ3RoOysrYiljPWFbYl0sYVtiXT1jPj4+MjR8Yz4+PjgmMHhmZjAwfChjJjB4ZmYwMCk8PDh8Yzw8MjQ7cmV0dXJuIGF9fTtcbnNqY2wuY29kZWMudXRmOFN0cmluZz17ZnJvbUJpdHM6ZnVuY3Rpb24oYSl7dmFyIGI9XCJcIixjPXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGEpLGQsZTtmb3IoZD0wO2Q8Yy84O2QrKykwPT09KGQmMykmJihlPWFbZC80XSksYis9U3RyaW5nLmZyb21DaGFyQ29kZShlPj4+OD4+Pjg+Pj44KSxlPDw9ODtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShiKSl9LHRvQml0czpmdW5jdGlvbihhKXthPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhKSk7dmFyIGI9W10sYyxkPTA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKylkPWQ8PDh8YS5jaGFyQ29kZUF0KGMpLDM9PT0oYyYzKSYmKGIucHVzaChkKSxkPTApO2MmMyYmYi5wdXNoKHNqY2wuYml0QXJyYXkucGFydGlhbCg4KihjJjMpLGQpKTtyZXR1cm4gYn19O1xuc2pjbC5jb2RlYy5oZXg9e2Zyb21CaXRzOmZ1bmN0aW9uKGEpe3ZhciBiPVwiXCIsYztmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWIrPSgoYVtjXXwwKSsweGYwMDAwMDAwMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cig0KTtyZXR1cm4gYi5zdWJzdHIoMCxzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKS80KX0sdG9CaXRzOmZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZDthPWEucmVwbGFjZSgvXFxzfDB4L2csXCJcIik7ZD1hLmxlbmd0aDthPWErXCIwMDAwMDAwMFwiO2ZvcihiPTA7YjxhLmxlbmd0aDtiKz04KWMucHVzaChwYXJzZUludChhLnN1YnN0cihiLDgpLDE2KV4wKTtyZXR1cm4gc2pjbC5iaXRBcnJheS5jbGFtcChjLDQqZCl9fTtcbnNqY2wuY29kZWMuYmFzZTMyPXtCOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIixYOlwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIixCSVRTOjMyLEJBU0U6NSxSRU1BSU5JTkc6MjcsZnJvbUJpdHM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXNqY2wuY29kZWMuYmFzZTMyLkJBU0UsZT1zamNsLmNvZGVjLmJhc2UzMi5SRU1BSU5JTkcsZj1cIlwiLGc9MCxoPXNqY2wuY29kZWMuYmFzZTMyLkIsaz0wLGw9c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYSk7YyYmKGg9c2pjbC5jb2RlYy5iYXNlMzIuWCk7Zm9yKGM9MDtmLmxlbmd0aCpkPGw7KWYrPWguY2hhckF0KChrXmFbY10+Pj5nKT4+PmUpLGc8ZD8oaz1hW2NdPDxkLWcsZys9ZSxjKyspOihrPDw9ZCxnLT1kKTtmb3IoO2YubGVuZ3RoJjcmJiFiOylmKz1cIj1cIjtyZXR1cm4gZn0sdG9CaXRzOmZ1bmN0aW9uKGEsYil7YT1hLnJlcGxhY2UoL1xcc3w9L2csXCJcIikudG9VcHBlckNhc2UoKTt2YXIgYz1zamNsLmNvZGVjLmJhc2UzMi5CSVRTLFxuZD1zamNsLmNvZGVjLmJhc2UzMi5CQVNFLGU9c2pjbC5jb2RlYy5iYXNlMzIuUkVNQUlOSU5HLGY9W10sZyxoPTAsaz1zamNsLmNvZGVjLmJhc2UzMi5CLGw9MCxuLG09XCJiYXNlMzJcIjtiJiYoaz1zamNsLmNvZGVjLmJhc2UzMi5YLG09XCJiYXNlMzJoZXhcIik7Zm9yKGc9MDtnPGEubGVuZ3RoO2crKyl7bj1rLmluZGV4T2YoYS5jaGFyQXQoZykpO2lmKDA+bil7aWYoIWIpdHJ5e3JldHVybiBzamNsLmNvZGVjLmJhc2UzMmhleC50b0JpdHMoYSl9Y2F0Y2gocCl7fXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwidGhpcyBpc24ndCBcIittK1wiIVwiKTt9aD5lPyhoLT1lLGYucHVzaChsXm4+Pj5oKSxsPW48PGMtaCk6KGgrPWQsbF49bjw8Yy1oKX1oJjU2JiZmLnB1c2goc2pjbC5iaXRBcnJheS5wYXJ0aWFsKGgmNTYsbCwxKSk7cmV0dXJuIGZ9fTtcbnNqY2wuY29kZWMuYmFzZTMyaGV4PXtmcm9tQml0czpmdW5jdGlvbihhLGIpe3JldHVybiBzamNsLmNvZGVjLmJhc2UzMi5mcm9tQml0cyhhLGIsMSl9LHRvQml0czpmdW5jdGlvbihhKXtyZXR1cm4gc2pjbC5jb2RlYy5iYXNlMzIudG9CaXRzKGEsMSl9fTtcbnNqY2wuY29kZWMuYmFzZTY0PXtCOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLGZyb21CaXRzOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1cIlwiLGU9MCxmPXNqY2wuY29kZWMuYmFzZTY0LkIsZz0wLGg9c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYSk7YyYmKGY9Zi5zdWJzdHIoMCw2MikrXCItX1wiKTtmb3IoYz0wOzYqZC5sZW5ndGg8aDspZCs9Zi5jaGFyQXQoKGdeYVtjXT4+PmUpPj4+MjYpLDY+ZT8oZz1hW2NdPDw2LWUsZSs9MjYsYysrKTooZzw8PTYsZS09Nik7Zm9yKDtkLmxlbmd0aCYzJiYhYjspZCs9XCI9XCI7cmV0dXJuIGR9LHRvQml0czpmdW5jdGlvbihhLGIpe2E9YS5yZXBsYWNlKC9cXHN8PS9nLFwiXCIpO3ZhciBjPVtdLGQsZT0wLGY9c2pjbC5jb2RlYy5iYXNlNjQuQixnPTAsaDtiJiYoZj1mLnN1YnN0cigwLDYyKStcIi1fXCIpO2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspe2g9Zi5pbmRleE9mKGEuY2hhckF0KGQpKTtcbmlmKDA+aCl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcInRoaXMgaXNuJ3QgYmFzZTY0IVwiKTsyNjxlPyhlLT0yNixjLnB1c2goZ15oPj4+ZSksZz1oPDwzMi1lKTooZSs9NixnXj1oPDwzMi1lKX1lJjU2JiZjLnB1c2goc2pjbC5iaXRBcnJheS5wYXJ0aWFsKGUmNTYsZywxKSk7cmV0dXJuIGN9fTtzamNsLmNvZGVjLmJhc2U2NHVybD17ZnJvbUJpdHM6ZnVuY3Rpb24oYSl7cmV0dXJuIHNqY2wuY29kZWMuYmFzZTY0LmZyb21CaXRzKGEsMSwxKX0sdG9CaXRzOmZ1bmN0aW9uKGEpe3JldHVybiBzamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoYSwxKX19O3NqY2wuaGFzaC5zaGEyNTY9ZnVuY3Rpb24oYSl7dGhpcy5iWzBdfHx0aGlzLk8oKTthPyh0aGlzLkY9YS5GLnNsaWNlKDApLHRoaXMuQT1hLkEuc2xpY2UoMCksdGhpcy5sPWEubCk6dGhpcy5yZXNldCgpfTtzamNsLmhhc2guc2hhMjU2Lmhhc2g9ZnVuY3Rpb24oYSl7cmV0dXJuKG5ldyBzamNsLmhhc2guc2hhMjU2KS51cGRhdGUoYSkuZmluYWxpemUoKX07XG5zamNsLmhhc2guc2hhMjU2LnByb3RvdHlwZT17YmxvY2tTaXplOjUxMixyZXNldDpmdW5jdGlvbigpe3RoaXMuRj10aGlzLlkuc2xpY2UoMCk7dGhpcy5BPVtdO3RoaXMubD0wO3JldHVybiB0aGlzfSx1cGRhdGU6ZnVuY3Rpb24oYSl7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1zamNsLmNvZGVjLnV0ZjhTdHJpbmcudG9CaXRzKGEpKTt2YXIgYixjPXRoaXMuQT1zamNsLmJpdEFycmF5LmNvbmNhdCh0aGlzLkEsYSk7Yj10aGlzLmw7YT10aGlzLmw9YitzamNsLmJpdEFycmF5LmJpdExlbmd0aChhKTtpZigweDFmZmZmZmZmZmZmZmZmPGEpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJDYW5ub3QgaGFzaCBtb3JlIHRoYW4gMl41MyAtIDEgYml0c1wiKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5KXt2YXIgZD1uZXcgVWludDMyQXJyYXkoYyksZT0wO2ZvcihiPTUxMitiLSg1MTIrYiYweDFmZik7Yjw9YTtiKz01MTIpdSh0aGlzLGQuc3ViYXJyYXkoMTYqZSxcbjE2KihlKzEpKSksZSs9MTtjLnNwbGljZSgwLDE2KmUpfWVsc2UgZm9yKGI9NTEyK2ItKDUxMitiJjB4MWZmKTtiPD1hO2IrPTUxMil1KHRoaXMsYy5zcGxpY2UoMCwxNikpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBhLGI9dGhpcy5BLGM9dGhpcy5GLGI9c2pjbC5iaXRBcnJheS5jb25jYXQoYixbc2pjbC5iaXRBcnJheS5wYXJ0aWFsKDEsMSldKTtmb3IoYT1iLmxlbmd0aCsyO2EmMTU7YSsrKWIucHVzaCgwKTtiLnB1c2goTWF0aC5mbG9vcih0aGlzLmwvMHgxMDAwMDAwMDApKTtmb3IoYi5wdXNoKHRoaXMubHwwKTtiLmxlbmd0aDspdSh0aGlzLGIuc3BsaWNlKDAsMTYpKTt0aGlzLnJlc2V0KCk7cmV0dXJuIGN9LFk6W10sYjpbXSxPOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4gMHgxMDAwMDAwMDAqKGEtTWF0aC5mbG9vcihhKSl8MH1mb3IodmFyIGI9MCxjPTIsZCxlOzY0PmI7YysrKXtlPSEwO2ZvcihkPTI7ZCpkPD1jO2QrKylpZigwPT09YyVkKXtlPVxuITE7YnJlYWt9ZSYmKDg+YiYmKHRoaXMuWVtiXT1hKE1hdGgucG93KGMsLjUpKSksdGhpcy5iW2JdPWEoTWF0aC5wb3coYywxLzMpKSxiKyspfX19O1xuZnVuY3Rpb24gdShhLGIpe3ZhciBjLGQsZSxmPWEuRixnPWEuYixoPWZbMF0saz1mWzFdLGw9ZlsyXSxuPWZbM10sbT1mWzRdLHA9Zls1XSxyPWZbNl0scT1mWzddO2ZvcihjPTA7NjQ+YztjKyspMTY+Yz9kPWJbY106KGQ9YltjKzEmMTVdLGU9YltjKzE0JjE1XSxkPWJbYyYxNV09KGQ+Pj43XmQ+Pj4xOF5kPj4+M15kPDwyNV5kPDwxNCkrKGU+Pj4xN15lPj4+MTleZT4+PjEwXmU8PDE1XmU8PDEzKStiW2MmMTVdK2JbYys5JjE1XXwwKSxkPWQrcSsobT4+PjZebT4+PjExXm0+Pj4yNV5tPDwyNl5tPDwyMV5tPDw3KSsocl5tJihwXnIpKStnW2NdLHE9cixyPXAscD1tLG09bitkfDAsbj1sLGw9ayxrPWgsaD1kKyhrJmxebiYoa15sKSkrKGs+Pj4yXms+Pj4xM15rPj4+MjJeazw8MzBeazw8MTleazw8MTApfDA7ZlswXT1mWzBdK2h8MDtmWzFdPWZbMV0ra3wwO2ZbMl09ZlsyXStsfDA7ZlszXT1mWzNdK258MDtmWzRdPWZbNF0rbXwwO2ZbNV09Zls1XStwfDA7Zls2XT1mWzZdK3J8MDtmWzddPVxuZls3XStxfDB9XG5zamNsLm1vZGUuY2NtPXtuYW1lOlwiY2NtXCIsRzpbXSxsaXN0ZW5Qcm9ncmVzczpmdW5jdGlvbihhKXtzamNsLm1vZGUuY2NtLkcucHVzaChhKX0sdW5MaXN0ZW5Qcm9ncmVzczpmdW5jdGlvbihhKXthPXNqY2wubW9kZS5jY20uRy5pbmRleE9mKGEpOy0xPGEmJnNqY2wubW9kZS5jY20uRy5zcGxpY2UoYSwxKX0sZmE6ZnVuY3Rpb24oYSl7dmFyIGI9c2pjbC5tb2RlLmNjbS5HLnNsaWNlKCksYztmb3IoYz0wO2M8Yi5sZW5ndGg7Yys9MSliW2NdKGEpfSxlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZz1iLnNsaWNlKDApLGg9c2pjbC5iaXRBcnJheSxrPWguYml0TGVuZ3RoKGMpLzgsbD1oLmJpdExlbmd0aChnKS84O2U9ZXx8NjQ7ZD1kfHxbXTtpZig3PmspdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJjY206IGl2IG11c3QgYmUgYXQgbGVhc3QgNyBieXRlc1wiKTtmb3IoZj0yOzQ+ZiYmbD4+PjgqZjtmKyspO2Y8MTUtayYmKGY9MTUtayk7Yz1oLmNsYW1wKGMsXG44KigxNS1mKSk7Yj1zamNsLm1vZGUuY2NtLlYoYSxiLGMsZCxlLGYpO2c9c2pjbC5tb2RlLmNjbS5DKGEsZyxjLGIsZSxmKTtyZXR1cm4gaC5jb25jYXQoZy5kYXRhLGcudGFnKX0sZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkLGUpe2U9ZXx8NjQ7ZD1kfHxbXTt2YXIgZj1zamNsLmJpdEFycmF5LGc9Zi5iaXRMZW5ndGgoYykvOCxoPWYuYml0TGVuZ3RoKGIpLGs9Zi5jbGFtcChiLGgtZSksbD1mLmJpdFNsaWNlKGIsaC1lKSxoPShoLWUpLzg7aWYoNz5nKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiY2NtOiBpdiBtdXN0IGJlIGF0IGxlYXN0IDcgYnl0ZXNcIik7Zm9yKGI9Mjs0PmImJmg+Pj44KmI7YisrKTtiPDE1LWcmJihiPTE1LWcpO2M9Zi5jbGFtcChjLDgqKDE1LWIpKTtrPXNqY2wubW9kZS5jY20uQyhhLGssYyxsLGUsYik7YT1zamNsLm1vZGUuY2NtLlYoYSxrLmRhdGEsYyxkLGUsYik7aWYoIWYuZXF1YWwoay50YWcsYSkpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmNvcnJ1cHQoXCJjY206IHRhZyBkb2Vzbid0IG1hdGNoXCIpO1xucmV0dXJuIGsuZGF0YX0sbmE6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPVtdLGg9c2pjbC5iaXRBcnJheSxrPWguaTtkPVtoLnBhcnRpYWwoOCwoYi5sZW5ndGg/NjQ6MCl8ZC0yPDwyfGYtMSldO2Q9aC5jb25jYXQoZCxjKTtkWzNdfD1lO2Q9YS5lbmNyeXB0KGQpO2lmKGIubGVuZ3RoKWZvcihjPWguYml0TGVuZ3RoKGIpLzgsNjUyNzk+PWM/Zz1baC5wYXJ0aWFsKDE2LGMpXToweGZmZmZmZmZmPj1jJiYoZz1oLmNvbmNhdChbaC5wYXJ0aWFsKDE2LDY1NTM0KV0sW2NdKSksZz1oLmNvbmNhdChnLGIpLGI9MDtiPGcubGVuZ3RoO2IrPTQpZD1hLmVuY3J5cHQoayhkLGcuc2xpY2UoYixiKzQpLmNvbmNhdChbMCwwLDBdKSkpO3JldHVybiBkfSxWOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1zamNsLmJpdEFycmF5LGg9Zy5pO2UvPTg7aWYoZSUyfHw0PmV8fDE2PGUpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJjY206IGludmFsaWQgdGFnIGxlbmd0aFwiKTtcbmlmKDB4ZmZmZmZmZmY8ZC5sZW5ndGh8fDB4ZmZmZmZmZmY8Yi5sZW5ndGgpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmJ1ZyhcImNjbTogY2FuJ3QgZGVhbCB3aXRoIDRHaUIgb3IgbW9yZSBkYXRhXCIpO2M9c2pjbC5tb2RlLmNjbS5uYShhLGQsYyxlLGcuYml0TGVuZ3RoKGIpLzgsZik7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrPTQpYz1hLmVuY3J5cHQoaChjLGIuc2xpY2UoZCxkKzQpLmNvbmNhdChbMCwwLDBdKSkpO3JldHVybiBnLmNsYW1wKGMsOCplKX0sQzpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaD1zamNsLmJpdEFycmF5O2c9aC5pO3ZhciBrPWIubGVuZ3RoLGw9aC5iaXRMZW5ndGgoYiksbj1rLzUwLG09bjtjPWguY29uY2F0KFtoLnBhcnRpYWwoOCxmLTEpXSxjKS5jb25jYXQoWzAsMCwwXSkuc2xpY2UoMCw0KTtkPWguYml0U2xpY2UoZyhkLGEuZW5jcnlwdChjKSksMCxlKTtpZighaylyZXR1cm57dGFnOmQsZGF0YTpbXX07Zm9yKGc9MDtnPGs7Zys9NClnPm4mJihzamNsLm1vZGUuY2NtLmZhKGcvXG5rKSxuKz1tKSxjWzNdKyssZT1hLmVuY3J5cHQoYyksYltnXV49ZVswXSxiW2crMV1ePWVbMV0sYltnKzJdXj1lWzJdLGJbZyszXV49ZVszXTtyZXR1cm57dGFnOmQsZGF0YTpoLmNsYW1wKGIsbCl9fX07XG5zamNsLm1vZGUub2NiMj17bmFtZTpcIm9jYjJcIixlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZigxMjghPT1zamNsLmJpdEFycmF5LmJpdExlbmd0aChjKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcIm9jYiBpdiBtdXN0IGJlIDEyOCBiaXRzXCIpO3ZhciBnLGg9c2pjbC5tb2RlLm9jYjIuUyxrPXNqY2wuYml0QXJyYXksbD1rLmksbj1bMCwwLDAsMF07Yz1oKGEuZW5jcnlwdChjKSk7dmFyIG0scD1bXTtkPWR8fFtdO2U9ZXx8NjQ7Zm9yKGc9MDtnKzQ8Yi5sZW5ndGg7Zys9NCltPWIuc2xpY2UoZyxnKzQpLG49bChuLG0pLHA9cC5jb25jYXQobChjLGEuZW5jcnlwdChsKGMsbSkpKSksYz1oKGMpO209Yi5zbGljZShnKTtiPWsuYml0TGVuZ3RoKG0pO2c9YS5lbmNyeXB0KGwoYyxbMCwwLDAsYl0pKTttPWsuY2xhbXAobChtLmNvbmNhdChbMCwwLDBdKSxnKSxiKTtuPWwobixsKG0uY29uY2F0KFswLDAsMF0pLGcpKTtuPWEuZW5jcnlwdChsKG4sbChjLGgoYykpKSk7XG5kLmxlbmd0aCYmKG49bChuLGY/ZDpzamNsLm1vZGUub2NiMi5wbWFjKGEsZCkpKTtyZXR1cm4gcC5jb25jYXQoay5jb25jYXQobSxrLmNsYW1wKG4sZSkpKX0sZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7aWYoMTI4IT09c2pjbC5iaXRBcnJheS5iaXRMZW5ndGgoYykpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJvY2IgaXYgbXVzdCBiZSAxMjggYml0c1wiKTtlPWV8fDY0O3ZhciBnPXNqY2wubW9kZS5vY2IyLlMsaD1zamNsLmJpdEFycmF5LGs9aC5pLGw9WzAsMCwwLDBdLG49ZyhhLmVuY3J5cHQoYykpLG0scCxyPXNqY2wuYml0QXJyYXkuYml0TGVuZ3RoKGIpLWUscT1bXTtkPWR8fFtdO2ZvcihjPTA7Yys0PHIvMzI7Yys9NCltPWsobixhLmRlY3J5cHQoayhuLGIuc2xpY2UoYyxjKzQpKSkpLGw9ayhsLG0pLHE9cS5jb25jYXQobSksbj1nKG4pO3A9ci0zMipjO209YS5lbmNyeXB0KGsobixbMCwwLDAscF0pKTttPWsobSxoLmNsYW1wKGIuc2xpY2UoYykscCkuY29uY2F0KFswLFxuMCwwXSkpO2w9ayhsLG0pO2w9YS5lbmNyeXB0KGsobCxrKG4sZyhuKSkpKTtkLmxlbmd0aCYmKGw9ayhsLGY/ZDpzamNsLm1vZGUub2NiMi5wbWFjKGEsZCkpKTtpZighaC5lcXVhbChoLmNsYW1wKGwsZSksaC5iaXRTbGljZShiLHIpKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uY29ycnVwdChcIm9jYjogdGFnIGRvZXNuJ3QgbWF0Y2hcIik7cmV0dXJuIHEuY29uY2F0KGguY2xhbXAobSxwKSl9LHBtYWM6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXNqY2wubW9kZS5vY2IyLlMsZT1zamNsLmJpdEFycmF5LGY9ZS5pLGc9WzAsMCwwLDBdLGg9YS5lbmNyeXB0KFswLDAsMCwwXSksaD1mKGgsZChkKGgpKSk7Zm9yKGM9MDtjKzQ8Yi5sZW5ndGg7Yys9NCloPWQoaCksZz1mKGcsYS5lbmNyeXB0KGYoaCxiLnNsaWNlKGMsYys0KSkpKTtjPWIuc2xpY2UoYyk7MTI4PmUuYml0TGVuZ3RoKGMpJiYoaD1mKGgsZChoKSksYz1lLmNvbmNhdChjLFstMjE0NzQ4MzY0OCwwLDAsMF0pKTtnPWYoZyxjKTtcbnJldHVybiBhLmVuY3J5cHQoZihkKGYoaCxkKGgpKSksZykpfSxTOmZ1bmN0aW9uKGEpe3JldHVyblthWzBdPDwxXmFbMV0+Pj4zMSxhWzFdPDwxXmFbMl0+Pj4zMSxhWzJdPDwxXmFbM10+Pj4zMSxhWzNdPDwxXjEzNSooYVswXT4+PjMxKV19fTtcbnNqY2wubW9kZS5nY209e25hbWU6XCJnY21cIixlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9Yi5zbGljZSgwKTtiPXNqY2wuYml0QXJyYXk7ZD1kfHxbXTthPXNqY2wubW9kZS5nY20uQyghMCxhLGYsZCxjLGV8fDEyOCk7cmV0dXJuIGIuY29uY2F0KGEuZGF0YSxhLnRhZyl9LGRlY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1iLnNsaWNlKDApLGc9c2pjbC5iaXRBcnJheSxoPWcuYml0TGVuZ3RoKGYpO2U9ZXx8MTI4O2Q9ZHx8W107ZTw9aD8oYj1nLmJpdFNsaWNlKGYsaC1lKSxmPWcuYml0U2xpY2UoZiwwLGgtZSkpOihiPWYsZj1bXSk7YT1zamNsLm1vZGUuZ2NtLkMoITEsYSxmLGQsYyxlKTtpZighZy5lcXVhbChhLnRhZyxiKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uY29ycnVwdChcImdjbTogdGFnIGRvZXNuJ3QgbWF0Y2hcIik7cmV0dXJuIGEuZGF0YX0sa2E6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg9c2pjbC5iaXRBcnJheS5pO2U9WzAsMCxcbjAsMF07Zj1iLnNsaWNlKDApO2ZvcihjPTA7MTI4PmM7YysrKXsoZD0wIT09KGFbTWF0aC5mbG9vcihjLzMyKV0mMTw8MzEtYyUzMikpJiYoZT1oKGUsZikpO2c9MCE9PShmWzNdJjEpO2ZvcihkPTM7MDxkO2QtLSlmW2RdPWZbZF0+Pj4xfChmW2QtMV0mMSk8PDMxO2ZbMF0+Pj49MTtnJiYoZlswXV49LTB4MWYwMDAwMDApfXJldHVybiBlfSxqOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPWMubGVuZ3RoO2I9Yi5zbGljZSgwKTtmb3IoZD0wO2Q8ZTtkKz00KWJbMF1ePTB4ZmZmZmZmZmYmY1tkXSxiWzFdXj0weGZmZmZmZmZmJmNbZCsxXSxiWzJdXj0weGZmZmZmZmZmJmNbZCsyXSxiWzNdXj0weGZmZmZmZmZmJmNbZCszXSxiPXNqY2wubW9kZS5nY20ua2EoYixhKTtyZXR1cm4gYn0sQzpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaCxrLGwsbixtLHAscixxPXNqY2wuYml0QXJyYXk7bT1jLmxlbmd0aDtwPXEuYml0TGVuZ3RoKGMpO3I9cS5iaXRMZW5ndGgoZCk7aD1xLmJpdExlbmd0aChlKTtcbmc9Yi5lbmNyeXB0KFswLDAsMCwwXSk7OTY9PT1oPyhlPWUuc2xpY2UoMCksZT1xLmNvbmNhdChlLFsxXSkpOihlPXNqY2wubW9kZS5nY20uaihnLFswLDAsMCwwXSxlKSxlPXNqY2wubW9kZS5nY20uaihnLGUsWzAsMCxNYXRoLmZsb29yKGgvMHgxMDAwMDAwMDApLGgmMHhmZmZmZmZmZl0pKTtoPXNqY2wubW9kZS5nY20uaihnLFswLDAsMCwwXSxkKTtuPWUuc2xpY2UoMCk7ZD1oLnNsaWNlKDApO2F8fChkPXNqY2wubW9kZS5nY20uaihnLGgsYykpO2ZvcihsPTA7bDxtO2wrPTQpblszXSsrLGs9Yi5lbmNyeXB0KG4pLGNbbF1ePWtbMF0sY1tsKzFdXj1rWzFdLGNbbCsyXV49a1syXSxjW2wrM11ePWtbM107Yz1xLmNsYW1wKGMscCk7YSYmKGQ9c2pjbC5tb2RlLmdjbS5qKGcsaCxjKSk7YT1bTWF0aC5mbG9vcihyLzB4MTAwMDAwMDAwKSxyJjB4ZmZmZmZmZmYsTWF0aC5mbG9vcihwLzB4MTAwMDAwMDAwKSxwJjB4ZmZmZmZmZmZdO2Q9c2pjbC5tb2RlLmdjbS5qKGcsZCxhKTtrPWIuZW5jcnlwdChlKTtcbmRbMF1ePWtbMF07ZFsxXV49a1sxXTtkWzJdXj1rWzJdO2RbM11ePWtbM107cmV0dXJue3RhZzpxLmJpdFNsaWNlKGQsMCxmKSxkYXRhOmN9fX07c2pjbC5taXNjLmhtYWM9ZnVuY3Rpb24oYSxiKXt0aGlzLlc9Yj1ifHxzamNsLmhhc2guc2hhMjU2O3ZhciBjPVtbXSxbXV0sZCxlPWIucHJvdG90eXBlLmJsb2NrU2l6ZS8zMjt0aGlzLnc9W25ldyBiLG5ldyBiXTthLmxlbmd0aD5lJiYoYT1iLmhhc2goYSkpO2ZvcihkPTA7ZDxlO2QrKyljWzBdW2RdPWFbZF1eOTA5NTIyNDg2LGNbMV1bZF09YVtkXV4xNTQ5NTU2ODI4O3RoaXMud1swXS51cGRhdGUoY1swXSk7dGhpcy53WzFdLnVwZGF0ZShjWzFdKTt0aGlzLlI9bmV3IGIodGhpcy53WzBdKX07XG5zamNsLm1pc2MuaG1hYy5wcm90b3R5cGUuZW5jcnlwdD1zamNsLm1pc2MuaG1hYy5wcm90b3R5cGUubWFjPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYWEpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJlbmNyeXB0IG9uIGFscmVhZHkgdXBkYXRlZCBobWFjIGNhbGxlZCFcIik7dGhpcy51cGRhdGUoYSk7cmV0dXJuIHRoaXMuZGlnZXN0KGEpfTtzamNsLm1pc2MuaG1hYy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLlI9bmV3IHRoaXMuVyh0aGlzLndbMF0pO3RoaXMuYWE9ITF9O3NqY2wubWlzYy5obWFjLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy5hYT0hMDt0aGlzLlIudXBkYXRlKGEpfTtzamNsLm1pc2MuaG1hYy5wcm90b3R5cGUuZGlnZXN0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5SLmZpbmFsaXplKCksYT0obmV3IHRoaXMuVyh0aGlzLndbMV0pKS51cGRhdGUoYSkuZmluYWxpemUoKTt0aGlzLnJlc2V0KCk7cmV0dXJuIGF9O1xuc2pjbC5taXNjLnBia2RmMj1mdW5jdGlvbihhLGIsYyxkLGUpe2M9Y3x8MUU0O2lmKDA+ZHx8MD5jKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiaW52YWxpZCBwYXJhbXMgdG8gcGJrZGYyXCIpO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhhKSk7XCJzdHJpbmdcIj09PXR5cGVvZiBiJiYoYj1zamNsLmNvZGVjLnV0ZjhTdHJpbmcudG9CaXRzKGIpKTtlPWV8fHNqY2wubWlzYy5obWFjO2E9bmV3IGUoYSk7dmFyIGYsZyxoLGssbD1bXSxuPXNqY2wuYml0QXJyYXk7Zm9yKGs9MTszMipsLmxlbmd0aDwoZHx8MSk7aysrKXtlPWY9YS5lbmNyeXB0KG4uY29uY2F0KGIsW2tdKSk7Zm9yKGc9MTtnPGM7ZysrKWZvcihmPWEuZW5jcnlwdChmKSxoPTA7aDxmLmxlbmd0aDtoKyspZVtoXV49ZltoXTtsPWwuY29uY2F0KGUpfWQmJihsPW4uY2xhbXAobCxkKSk7cmV0dXJuIGx9O1xuc2pjbC5wcm5nPWZ1bmN0aW9uKGEpe3RoaXMuYz1bbmV3IHNqY2wuaGFzaC5zaGEyNTZdO3RoaXMubT1bMF07dGhpcy5QPTA7dGhpcy5IPXt9O3RoaXMuTj0wO3RoaXMuVT17fTt0aGlzLlo9dGhpcy5mPXRoaXMubz10aGlzLmhhPTA7dGhpcy5iPVswLDAsMCwwLDAsMCwwLDBdO3RoaXMuaD1bMCwwLDAsMF07dGhpcy5MPXZvaWQgMDt0aGlzLk09YTt0aGlzLkQ9ITE7dGhpcy5LPXtwcm9ncmVzczp7fSxzZWVkZWQ6e319O3RoaXMudT10aGlzLmdhPTA7dGhpcy5JPTE7dGhpcy5KPTI7dGhpcy5jYT0weDEwMDAwO3RoaXMuVD1bMCw0OCw2NCw5NiwxMjgsMTkyLDB4MTAwLDM4NCw1MTIsNzY4LDEwMjRdO3RoaXMuZGE9M0U0O3RoaXMuYmE9ODB9O1xuc2pjbC5wcm5nLnByb3RvdHlwZT17cmFuZG9tV29yZHM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkO2Q9dGhpcy5pc1JlYWR5KGIpO3ZhciBlO2lmKGQ9PT10aGlzLnUpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLm5vdFJlYWR5KFwiZ2VuZXJhdG9yIGlzbid0IHNlZWRlZFwiKTtpZihkJnRoaXMuSil7ZD0hKGQmdGhpcy5JKTtlPVtdO3ZhciBmPTAsZzt0aGlzLlo9ZVswXT0obmV3IERhdGUpLnZhbHVlT2YoKSt0aGlzLmRhO2ZvcihnPTA7MTY+ZztnKyspZS5wdXNoKDB4MTAwMDAwMDAwKk1hdGgucmFuZG9tKCl8MCk7Zm9yKGc9MDtnPHRoaXMuYy5sZW5ndGgmJihlPWUuY29uY2F0KHRoaXMuY1tnXS5maW5hbGl6ZSgpKSxmKz10aGlzLm1bZ10sdGhpcy5tW2ddPTAsZHx8ISh0aGlzLlAmMTw8ZykpO2crKyk7dGhpcy5QPj0xPDx0aGlzLmMubGVuZ3RoJiYodGhpcy5jLnB1c2gobmV3IHNqY2wuaGFzaC5zaGEyNTYpLHRoaXMubS5wdXNoKDApKTt0aGlzLmYtPWY7Zj50aGlzLm8mJih0aGlzLm89XG5mKTt0aGlzLlArKzt0aGlzLmI9c2pjbC5oYXNoLnNoYTI1Ni5oYXNoKHRoaXMuYi5jb25jYXQoZSkpO3RoaXMuTD1uZXcgc2pjbC5jaXBoZXIuYWVzKHRoaXMuYik7Zm9yKGQ9MDs0PmQmJih0aGlzLmhbZF09dGhpcy5oW2RdKzF8MCwhdGhpcy5oW2RdKTtkKyspO31mb3IoZD0wO2Q8YTtkKz00KTA9PT0oZCsxKSV0aGlzLmNhJiZ5KHRoaXMpLGU9eih0aGlzKSxjLnB1c2goZVswXSxlWzFdLGVbMl0sZVszXSk7eSh0aGlzKTtyZXR1cm4gYy5zbGljZSgwLGEpfSxzZXREZWZhdWx0UGFyYW5vaWE6ZnVuY3Rpb24oYSxiKXtpZigwPT09YSYmXCJTZXR0aW5nIHBhcmFub2lhPTAgd2lsbCBydWluIHlvdXIgc2VjdXJpdHk7IHVzZSBpdCBvbmx5IGZvciB0ZXN0aW5nXCIhPT1iKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwiU2V0dGluZyBwYXJhbm9pYT0wIHdpbGwgcnVpbiB5b3VyIHNlY3VyaXR5OyB1c2UgaXQgb25seSBmb3IgdGVzdGluZ1wiKTt0aGlzLk09YX0sYWRkRW50cm9weTpmdW5jdGlvbihhLFxuYixjKXtjPWN8fFwidXNlclwiO3ZhciBkLGUsZj0obmV3IERhdGUpLnZhbHVlT2YoKSxnPXRoaXMuSFtjXSxoPXRoaXMuaXNSZWFkeSgpLGs9MDtkPXRoaXMuVVtjXTt2b2lkIDA9PT1kJiYoZD10aGlzLlVbY109dGhpcy5oYSsrKTt2b2lkIDA9PT1nJiYoZz10aGlzLkhbY109MCk7dGhpcy5IW2NdPSh0aGlzLkhbY10rMSkldGhpcy5jLmxlbmd0aDtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJudW1iZXJcIjp2b2lkIDA9PT1iJiYoYj0xKTt0aGlzLmNbZ10udXBkYXRlKFtkLHRoaXMuTisrLDEsYixmLDEsYXwwXSk7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOmM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBVaW50MzJBcnJheV1cIj09PWMpe2U9W107Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllLnB1c2goYVtjXSk7YT1lfWVsc2UgZm9yKFwiW29iamVjdCBBcnJheV1cIiE9PWMmJihrPTEpLGM9MDtjPGEubGVuZ3RoJiYhaztjKyspXCJudW1iZXJcIiE9PXR5cGVvZiBhW2NdJiZcbihrPTEpO2lmKCFrKXtpZih2b2lkIDA9PT1iKWZvcihjPWI9MDtjPGEubGVuZ3RoO2MrKylmb3IoZT1hW2NdOzA8ZTspYisrLGU9ZT4+PjE7dGhpcy5jW2ddLnVwZGF0ZShbZCx0aGlzLk4rKywyLGIsZixhLmxlbmd0aF0uY29uY2F0KGEpKX1icmVhaztjYXNlIFwic3RyaW5nXCI6dm9pZCAwPT09YiYmKGI9YS5sZW5ndGgpO3RoaXMuY1tnXS51cGRhdGUoW2QsdGhpcy5OKyssMyxiLGYsYS5sZW5ndGhdKTt0aGlzLmNbZ10udXBkYXRlKGEpO2JyZWFrO2RlZmF1bHQ6az0xfWlmKGspdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmJ1ZyhcInJhbmRvbTogYWRkRW50cm9weSBvbmx5IHN1cHBvcnRzIG51bWJlciwgYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdcIik7dGhpcy5tW2ddKz1iO3RoaXMuZis9YjtoPT09dGhpcy51JiYodGhpcy5pc1JlYWR5KCkhPT10aGlzLnUmJkEoXCJzZWVkZWRcIixNYXRoLm1heCh0aGlzLm8sdGhpcy5mKSksQShcInByb2dyZXNzXCIsdGhpcy5nZXRQcm9ncmVzcygpKSl9LFxuaXNSZWFkeTpmdW5jdGlvbihhKXthPXRoaXMuVFt2b2lkIDAhPT1hP2E6dGhpcy5NXTtyZXR1cm4gdGhpcy5vJiZ0aGlzLm8+PWE/dGhpcy5tWzBdPnRoaXMuYmEmJihuZXcgRGF0ZSkudmFsdWVPZigpPnRoaXMuWj90aGlzLkp8dGhpcy5JOnRoaXMuSTp0aGlzLmY+PWE/dGhpcy5KfHRoaXMudTp0aGlzLnV9LGdldFByb2dyZXNzOmZ1bmN0aW9uKGEpe2E9dGhpcy5UW2E/YTp0aGlzLk1dO3JldHVybiB0aGlzLm8+PWE/MTp0aGlzLmY+YT8xOnRoaXMuZi9hfSxzdGFydENvbGxlY3RvcnM6ZnVuY3Rpb24oKXtpZighdGhpcy5EKXt0aGlzLmE9e2xvYWRUaW1lQ29sbGVjdG9yOkIodGhpcyx0aGlzLm1hKSxtb3VzZUNvbGxlY3RvcjpCKHRoaXMsdGhpcy5vYSksa2V5Ym9hcmRDb2xsZWN0b3I6Qih0aGlzLHRoaXMubGEpLGFjY2VsZXJvbWV0ZXJDb2xsZWN0b3I6Qih0aGlzLHRoaXMuZWEpLHRvdWNoQ29sbGVjdG9yOkIodGhpcyx0aGlzLnFhKX07aWYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsXG50aGlzLmEubG9hZFRpbWVDb2xsZWN0b3IsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5hLm1vdXNlQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsdGhpcy5hLmtleWJvYXJkQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLHRoaXMuYS5hY2NlbGVyb21ldGVyQ29sbGVjdG9yLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuYS50b3VjaENvbGxlY3RvciwhMSk7ZWxzZSBpZihkb2N1bWVudC5hdHRhY2hFdmVudClkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ubG9hZFwiLHRoaXMuYS5sb2FkVGltZUNvbGxlY3RvciksZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbm1vdXNlbW92ZVwiLHRoaXMuYS5tb3VzZUNvbGxlY3RvciksZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJrZXlwcmVzc1wiLHRoaXMuYS5rZXlib2FyZENvbGxlY3Rvcik7ZWxzZSB0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uYnVnKFwiY2FuJ3QgYXR0YWNoIGV2ZW50XCIpO1xudGhpcy5EPSEwfX0sc3RvcENvbGxlY3RvcnM6ZnVuY3Rpb24oKXt0aGlzLkQmJih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcj8od2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdGhpcy5hLmxvYWRUaW1lQ29sbGVjdG9yLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuYS5tb3VzZUNvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLHRoaXMuYS5rZXlib2FyZENvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIix0aGlzLmEuYWNjZWxlcm9tZXRlckNvbGxlY3RvciwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLmEudG91Y2hDb2xsZWN0b3IsITEpKTpkb2N1bWVudC5kZXRhY2hFdmVudCYmKGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25sb2FkXCIsdGhpcy5hLmxvYWRUaW1lQ29sbGVjdG9yKSxkb2N1bWVudC5kZXRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsXG50aGlzLmEubW91c2VDb2xsZWN0b3IpLGRvY3VtZW50LmRldGFjaEV2ZW50KFwia2V5cHJlc3NcIix0aGlzLmEua2V5Ym9hcmRDb2xsZWN0b3IpKSx0aGlzLkQ9ITEpfSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKGEsYil7dGhpcy5LW2FdW3RoaXMuZ2ErK109Yn0scmVtb3ZlRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT10aGlzLktbYV0sZj1bXTtmb3IoZCBpbiBlKWUuaGFzT3duUHJvcGVydHkoZCkmJmVbZF09PT1iJiZmLnB1c2goZCk7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylkPWZbY10sZGVsZXRlIGVbZF19LGxhOmZ1bmN0aW9uKCl7Qyh0aGlzLDEpfSxvYTpmdW5jdGlvbihhKXt2YXIgYixjO3RyeXtiPWEueHx8YS5jbGllbnRYfHxhLm9mZnNldFh8fDAsYz1hLnl8fGEuY2xpZW50WXx8YS5vZmZzZXRZfHwwfWNhdGNoKGQpe2M9Yj0wfTAhPWImJjAhPWMmJnRoaXMuYWRkRW50cm9weShbYixjXSwyLFwibW91c2VcIik7Qyh0aGlzLDApfSxxYTpmdW5jdGlvbihhKXthPVxuYS50b3VjaGVzWzBdfHxhLmNoYW5nZWRUb3VjaGVzWzBdO3RoaXMuYWRkRW50cm9weShbYS5wYWdlWHx8YS5jbGllbnRYLGEucGFnZVl8fGEuY2xpZW50WV0sMSxcInRvdWNoXCIpO0ModGhpcywwKX0sbWE6ZnVuY3Rpb24oKXtDKHRoaXMsMil9LGVhOmZ1bmN0aW9uKGEpe2E9YS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5Lnh8fGEuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS55fHxhLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkuejtpZih3aW5kb3cub3JpZW50YXRpb24pe3ZhciBiPXdpbmRvdy5vcmllbnRhdGlvbjtcIm51bWJlclwiPT09dHlwZW9mIGImJnRoaXMuYWRkRW50cm9weShiLDEsXCJhY2NlbGVyb21ldGVyXCIpfWEmJnRoaXMuYWRkRW50cm9weShhLDIsXCJhY2NlbGVyb21ldGVyXCIpO0ModGhpcywwKX19O1xuZnVuY3Rpb24gQShhLGIpe3ZhciBjLGQ9c2pjbC5yYW5kb20uS1thXSxlPVtdO2ZvcihjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmZS5wdXNoKGRbY10pO2ZvcihjPTA7YzxlLmxlbmd0aDtjKyspZVtjXShiKX1mdW5jdGlvbiBDKGEsYil7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3c/YS5hZGRFbnRyb3B5KHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSxiLFwibG9hZHRpbWVcIik6YS5hZGRFbnRyb3B5KChuZXcgRGF0ZSkudmFsdWVPZigpLGIsXCJsb2FkdGltZVwiKX1mdW5jdGlvbiB5KGEpe2EuYj16KGEpLmNvbmNhdCh6KGEpKTthLkw9bmV3IHNqY2wuY2lwaGVyLmFlcyhhLmIpfWZ1bmN0aW9uIHooYSl7Zm9yKHZhciBiPTA7ND5iJiYoYS5oW2JdPWEuaFtiXSsxfDAsIWEuaFtiXSk7YisrKTtyZXR1cm4gYS5MLmVuY3J5cHQoYS5oKX1cbmZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtiLmFwcGx5KGEsYXJndW1lbnRzKX19c2pjbC5yYW5kb209bmV3IHNqY2wucHJuZyg2KTtcbmE6dHJ5e3ZhciBELEUsRixHO2lmKEc9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzKXt2YXIgSDt0cnl7SD1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKGEpe0g9bnVsbH1HPUU9SH1pZihHJiZFLnJhbmRvbUJ5dGVzKUQ9RS5yYW5kb21CeXRlcygxMjgpLEQ9bmV3IFVpbnQzMkFycmF5KChuZXcgVWludDhBcnJheShEKSkuYnVmZmVyKSxzamNsLnJhbmRvbS5hZGRFbnRyb3B5KEQsMTAyNCxcImNyeXB0b1sncmFuZG9tQnl0ZXMnXVwiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5KXtGPW5ldyBVaW50MzJBcnJheSgzMik7aWYod2luZG93LmNyeXB0byYmd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoRik7ZWxzZSBpZih3aW5kb3cubXNDcnlwdG8mJndpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhGKTtcbmVsc2UgYnJlYWsgYTtzamNsLnJhbmRvbS5hZGRFbnRyb3B5KEYsMTAyNCxcImNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ11cIil9fWNhdGNoKGEpe1widW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKGNvbnNvbGUubG9nKFwiVGhlcmUgd2FzIGFuIGVycm9yIGNvbGxlY3RpbmcgZW50cm9weSBmcm9tIHRoZSBicm93c2VyOlwiKSxjb25zb2xlLmxvZyhhKSl9XG5zamNsLmpzb249e2RlZmF1bHRzOnt2OjEsaXRlcjoxRTQsa3M6MTI4LHRzOjY0LG1vZGU6XCJjY21cIixhZGF0YTpcIlwiLGNpcGhlcjpcImFlc1wifSxqYTpmdW5jdGlvbihhLGIsYyxkKXtjPWN8fHt9O2Q9ZHx8e307dmFyIGU9c2pjbC5qc29uLGY9ZS5nKHtpdjpzamNsLnJhbmRvbS5yYW5kb21Xb3Jkcyg0LDApfSxlLmRlZmF1bHRzKSxnO2UuZyhmLGMpO2M9Zi5hZGF0YTtcInN0cmluZ1wiPT09dHlwZW9mIGYuc2FsdCYmKGYuc2FsdD1zamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoZi5zYWx0KSk7XCJzdHJpbmdcIj09PXR5cGVvZiBmLml2JiYoZi5pdj1zamNsLmNvZGVjLmJhc2U2NC50b0JpdHMoZi5pdikpO2lmKCFzamNsLm1vZGVbZi5tb2RlXXx8IXNqY2wuY2lwaGVyW2YuY2lwaGVyXXx8XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYxMDA+PWYuaXRlcnx8NjQhPT1mLnRzJiY5NiE9PWYudHMmJjEyOCE9PWYudHN8fDEyOCE9PWYua3MmJjE5MiE9PWYua3MmJjB4MTAwIT09Zi5rc3x8Mj5mLml2Lmxlbmd0aHx8XG40PGYuaXYubGVuZ3RoKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwianNvbiBlbmNyeXB0OiBpbnZhbGlkIHBhcmFtZXRlcnNcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBhPyhnPXNqY2wubWlzYy5jYWNoZWRQYmtkZjIoYSxmKSxhPWcua2V5LnNsaWNlKDAsZi5rcy8zMiksZi5zYWx0PWcuc2FsdCk6c2pjbC5lY2MmJmEgaW5zdGFuY2VvZiBzamNsLmVjYy5lbEdhbWFsLnB1YmxpY0tleSYmKGc9YS5rZW0oKSxmLmtlbXRhZz1nLnRhZyxhPWcua2V5LnNsaWNlKDAsZi5rcy8zMikpO1wic3RyaW5nXCI9PT10eXBlb2YgYiYmKGI9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhiKSk7XCJzdHJpbmdcIj09PXR5cGVvZiBjJiYoZi5hZGF0YT1jPXNqY2wuY29kZWMudXRmOFN0cmluZy50b0JpdHMoYykpO2c9bmV3IHNqY2wuY2lwaGVyW2YuY2lwaGVyXShhKTtlLmcoZCxmKTtkLmtleT1hO2YuY3Q9XCJjY21cIj09PWYubW9kZSYmc2pjbC5hcnJheUJ1ZmZlciYmc2pjbC5hcnJheUJ1ZmZlci5jY20mJlxuYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP3NqY2wuYXJyYXlCdWZmZXIuY2NtLmVuY3J5cHQoZyxiLGYuaXYsYyxmLnRzKTpzamNsLm1vZGVbZi5tb2RlXS5lbmNyeXB0KGcsYixmLml2LGMsZi50cyk7cmV0dXJuIGZ9LGVuY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9c2pjbC5qc29uLGY9ZS5qYS5hcHBseShlLGFyZ3VtZW50cyk7cmV0dXJuIGUuZW5jb2RlKGYpfSxpYTpmdW5jdGlvbihhLGIsYyxkKXtjPWN8fHt9O2Q9ZHx8e307dmFyIGU9c2pjbC5qc29uO2I9ZS5nKGUuZyhlLmcoe30sZS5kZWZhdWx0cyksYiksYywhMCk7dmFyIGYsZztmPWIuYWRhdGE7XCJzdHJpbmdcIj09PXR5cGVvZiBiLnNhbHQmJihiLnNhbHQ9c2pjbC5jb2RlYy5iYXNlNjQudG9CaXRzKGIuc2FsdCkpO1wic3RyaW5nXCI9PT10eXBlb2YgYi5pdiYmKGIuaXY9c2pjbC5jb2RlYy5iYXNlNjQudG9CaXRzKGIuaXYpKTtpZighc2pjbC5tb2RlW2IubW9kZV18fCFzamNsLmNpcGhlcltiLmNpcGhlcl18fFwic3RyaW5nXCI9PT1cbnR5cGVvZiBhJiYxMDA+PWIuaXRlcnx8NjQhPT1iLnRzJiY5NiE9PWIudHMmJjEyOCE9PWIudHN8fDEyOCE9PWIua3MmJjE5MiE9PWIua3MmJjB4MTAwIT09Yi5rc3x8IWIuaXZ8fDI+Yi5pdi5sZW5ndGh8fDQ8Yi5pdi5sZW5ndGgpdGhyb3cgbmV3IHNqY2wuZXhjZXB0aW9uLmludmFsaWQoXCJqc29uIGRlY3J5cHQ6IGludmFsaWQgcGFyYW1ldGVyc1wiKTtcInN0cmluZ1wiPT09dHlwZW9mIGE/KGc9c2pjbC5taXNjLmNhY2hlZFBia2RmMihhLGIpLGE9Zy5rZXkuc2xpY2UoMCxiLmtzLzMyKSxiLnNhbHQ9Zy5zYWx0KTpzamNsLmVjYyYmYSBpbnN0YW5jZW9mIHNqY2wuZWNjLmVsR2FtYWwuc2VjcmV0S2V5JiYoYT1hLnVua2VtKHNqY2wuY29kZWMuYmFzZTY0LnRvQml0cyhiLmtlbXRhZykpLnNsaWNlKDAsYi5rcy8zMikpO1wic3RyaW5nXCI9PT10eXBlb2YgZiYmKGY9c2pjbC5jb2RlYy51dGY4U3RyaW5nLnRvQml0cyhmKSk7Zz1uZXcgc2pjbC5jaXBoZXJbYi5jaXBoZXJdKGEpO2Y9XCJjY21cIj09PVxuYi5tb2RlJiZzamNsLmFycmF5QnVmZmVyJiZzamNsLmFycmF5QnVmZmVyLmNjbSYmYi5jdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP3NqY2wuYXJyYXlCdWZmZXIuY2NtLmRlY3J5cHQoZyxiLmN0LGIuaXYsYi50YWcsZixiLnRzKTpzamNsLm1vZGVbYi5tb2RlXS5kZWNyeXB0KGcsYi5jdCxiLml2LGYsYi50cyk7ZS5nKGQsYik7ZC5rZXk9YTtyZXR1cm4gMT09PWMucmF3P2Y6c2pjbC5jb2RlYy51dGY4U3RyaW5nLmZyb21CaXRzKGYpfSxkZWNyeXB0OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXNqY2wuanNvbjtyZXR1cm4gZS5pYShhLGUuZGVjb2RlKGIpLGMsZCl9LGVuY29kZTpmdW5jdGlvbihhKXt2YXIgYixjPVwie1wiLGQ9XCJcIjtmb3IoYiBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYikpe2lmKCFiLm1hdGNoKC9eW2EtejAtOV0rJC9pKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImpzb24gZW5jb2RlOiBpbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7Yys9ZCsnXCInK1xuYisnXCI6JztkPVwiLFwiO3N3aXRjaCh0eXBlb2YgYVtiXSl7Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJib29sZWFuXCI6Yys9YVtiXTticmVhaztjYXNlIFwic3RyaW5nXCI6Yys9J1wiJytlc2NhcGUoYVtiXSkrJ1wiJzticmVhaztjYXNlIFwib2JqZWN0XCI6Yys9J1wiJytzamNsLmNvZGVjLmJhc2U2NC5mcm9tQml0cyhhW2JdLDApKydcIic7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uYnVnKFwianNvbiBlbmNvZGU6IHVuc3VwcG9ydGVkIHR5cGVcIik7fX1yZXR1cm4gYytcIn1cIn0sZGVjb2RlOmZ1bmN0aW9uKGEpe2E9YS5yZXBsYWNlKC9cXHMvZyxcIlwiKTtpZighYS5tYXRjaCgvXlxcey4qXFx9JC8pKXRocm93IG5ldyBzamNsLmV4Y2VwdGlvbi5pbnZhbGlkKFwianNvbiBkZWNvZGU6IHRoaXMgaXNuJ3QganNvbiFcIik7YT1hLnJlcGxhY2UoL15cXHt8XFx9JC9nLFwiXCIpLnNwbGl0KC8sLyk7dmFyIGI9e30sYyxkO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspe2lmKCEoZD1hW2NdLm1hdGNoKC9eXFxzKig/OihbXCInXT8pKFthLXpdW2EtejAtOV0qKVxcMSlcXHMqOlxccyooPzooLT9cXGQrKXxcIihbYS16MC05K1xcLyUqXy5APVxcLV0qKVwifCh0cnVlfGZhbHNlKSkkL2kpKSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcImpzb24gZGVjb2RlOiB0aGlzIGlzbid0IGpzb24hXCIpO1xubnVsbCE9ZFszXT9iW2RbMl1dPXBhcnNlSW50KGRbM10sMTApOm51bGwhPWRbNF0/YltkWzJdXT1kWzJdLm1hdGNoKC9eKGN0fGFkYXRhfHNhbHR8aXYpJC8pP3NqY2wuY29kZWMuYmFzZTY0LnRvQml0cyhkWzRdKTp1bmVzY2FwZShkWzRdKTpudWxsIT1kWzVdJiYoYltkWzJdXT1cInRydWVcIj09PWRbNV0pfXJldHVybiBifSxnOmZ1bmN0aW9uKGEsYixjKXt2b2lkIDA9PT1hJiYoYT17fSk7aWYodm9pZCAwPT09YilyZXR1cm4gYTtmb3IodmFyIGQgaW4gYilpZihiLmhhc093blByb3BlcnR5KGQpKXtpZihjJiZ2b2lkIDAhPT1hW2RdJiZhW2RdIT09YltkXSl0aHJvdyBuZXcgc2pjbC5leGNlcHRpb24uaW52YWxpZChcInJlcXVpcmVkIHBhcmFtZXRlciBvdmVycmlkZGVuXCIpO2FbZF09YltkXX1yZXR1cm4gYX0sc2E6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fSxkO2ZvcihkIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShkKSYmYVtkXSE9PWJbZF0mJihjW2RdPWFbZF0pO3JldHVybiBjfSxyYTpmdW5jdGlvbihhLFxuYil7dmFyIGM9e30sZDtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKXZvaWQgMCE9PWFbYltkXV0mJihjW2JbZF1dPWFbYltkXV0pO3JldHVybiBjfX07c2pjbC5lbmNyeXB0PXNqY2wuanNvbi5lbmNyeXB0O3NqY2wuZGVjcnlwdD1zamNsLmpzb24uZGVjcnlwdDtzamNsLm1pc2MucGE9e307c2pjbC5taXNjLmNhY2hlZFBia2RmMj1mdW5jdGlvbihhLGIpe3ZhciBjPXNqY2wubWlzYy5wYSxkO2I9Ynx8e307ZD1iLml0ZXJ8fDFFMztjPWNbYV09Y1thXXx8e307ZD1jW2RdPWNbZF18fHtmaXJzdFNhbHQ6Yi5zYWx0JiZiLnNhbHQubGVuZ3RoP2Iuc2FsdC5zbGljZSgwKTpzamNsLnJhbmRvbS5yYW5kb21Xb3JkcygyLDApfTtjPXZvaWQgMD09PWIuc2FsdD9kLmZpcnN0U2FsdDpiLnNhbHQ7ZFtjXT1kW2NdfHxzamNsLm1pc2MucGJrZGYyKGEsYyxiLml0ZXIpO3JldHVybntrZXk6ZFtjXS5zbGljZSgwKSxzYWx0OmMuc2xpY2UoMCl9fTtcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPXNqY2wpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZShbXSxmdW5jdGlvbigpe3JldHVybiBzamNsfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0SGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbCA9IGV4cG9ydHMuZGVmYXVsdEhhbmRzaGFrZU1heEF0dGVtcHRzID0gZXhwb3J0cy5tb25pdG9yV2luZG93RXJyb3IgPSBleHBvcnRzLmVycm9yV2luZG93Q2xvc2VkID0gZXhwb3J0cy5kaXNwYXRjaGVkRXJyb3JFdmVudCA9IGV4cG9ydHMudHJpbVN1ZmZpeCA9IGV4cG9ydHMucmVtb3ZlQWRqYWNlbnRDaGFycyA9IGV4cG9ydHMuZW5zdXJlVXJsID0gZXhwb3J0cy5jcmVhdGVJZnJhbWUgPSBleHBvcnRzLmNyZWF0ZUZ1bGxTY3JlZW5JZnJhbWUgPSBleHBvcnRzLlBlcm1Xcml0ZSA9IGV4cG9ydHMuUGVybVJlYWQgPSBleHBvcnRzLlBlcm1MZWdhY3lTa3lJRCA9IGV4cG9ydHMuUGVybUhpZGRlbiA9IGV4cG9ydHMuUGVybURpc2NvdmVyYWJsZSA9IGV4cG9ydHMucGVybVR5cGVUb1N0cmluZyA9IGV4cG9ydHMucGVybUNhdGVnb3J5VG9TdHJpbmcgPSBleHBvcnRzLlBlcm1UeXBlID0gZXhwb3J0cy5QZXJtQ2F0ZWdvcnkgPSBleHBvcnRzLlBlcm1pc3Npb24gPSBleHBvcnRzLnNhbml0aXplUGF0aCA9IGV4cG9ydHMuZ2V0UGFyZW50UGF0aCA9IGV4cG9ydHMuZ2V0UGF0aERvbWFpbiA9IHZvaWQgMDtcbnZhciBwYXRoc18xID0gcmVxdWlyZShcIi4vcGF0aHNcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGF0aHNfMSwgXCJnZXRQYXRoRG9tYWluXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBhdGhzXzEsIFwiZ2V0UGFyZW50UGF0aFwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwYXRoc18xLCBcInNhbml0aXplUGF0aFwiKTtcbnZhciBwZXJtaXNzaW9uc18xID0gcmVxdWlyZShcIi4vcGVybWlzc2lvbnNcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtaXNzaW9uXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwiUGVybUNhdGVnb3J5XCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwiUGVybVR5cGVcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJwZXJtQ2F0ZWdvcnlUb1N0cmluZ1wiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcInBlcm1UeXBlVG9TdHJpbmdcIik7XG4vLyBDb25zdGFudHNcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBwZXJtaXNzaW9uc18xLCBcIlBlcm1EaXNjb3ZlcmFibGVcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtSGlkZGVuXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwiUGVybUxlZ2FjeVNreUlEXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBlcm1pc3Npb25zXzEsIFwiUGVybVJlYWRcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGVybWlzc2lvbnNfMSwgXCJQZXJtV3JpdGVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHV0aWxzXzEsIFwiY3JlYXRlRnVsbFNjcmVlbklmcmFtZVwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB1dGlsc18xLCBcImNyZWF0ZUlmcmFtZVwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB1dGlsc18xLCBcImVuc3VyZVVybFwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCB1dGlsc18xLCBcInJlbW92ZUFkamFjZW50Q2hhcnNcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgdXRpbHNfMSwgXCJ0cmltU3VmZml4XCIpO1xudmFyIHdpbmRvd19saXN0ZW5lcl8xID0gcmVxdWlyZShcIi4vd2luZG93LWxpc3RlbmVyXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHdpbmRvd19saXN0ZW5lcl8xLCBcImRpc3BhdGNoZWRFcnJvckV2ZW50XCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHdpbmRvd19saXN0ZW5lcl8xLCBcImVycm9yV2luZG93Q2xvc2VkXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHdpbmRvd19saXN0ZW5lcl8xLCBcIm1vbml0b3JXaW5kb3dFcnJvclwiKTtcbmV4cG9ydHMuZGVmYXVsdEhhbmRzaGFrZU1heEF0dGVtcHRzID0gMTUwO1xuZXhwb3J0cy5kZWZhdWx0SGFuZHNoYWtlQXR0ZW1wdHNJbnRlcnZhbCA9IDEwMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2FuaXRpemVQYXRoID0gZXhwb3J0cy5nZXRQYXJlbnRQYXRoID0gZXhwb3J0cy5nZXRQYXRoRG9tYWluID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogR2V0cyB0aGUgcm9vdCBwYXRoIGRvbWFpbiBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtIHBhdGggLSBUaGUgZ2l2ZW4gcGF0aC5cbiAqIEByZXR1cm5zIC0gVGhlIHBhdGggZG9tYWluLlxuICovXG5mdW5jdGlvbiBnZXRQYXRoRG9tYWluKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIilbMF07XG59XG5leHBvcnRzLmdldFBhdGhEb21haW4gPSBnZXRQYXRoRG9tYWluO1xuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgcGF0aCBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtIHBhdGggLSBUaGUgZ2l2ZW4gcGF0aC5cbiAqIEByZXR1cm5zIC0gVGhlIHBhcmVudCBwYXRoLCBvciBudWxsIGlmIG5vIHBhcmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50UGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHNhbml0aXplUGF0aChwYXRoKTtcbiAgICB2YXIgcGF0aEFycmF5ID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGF0aEFycmF5LnBvcCgpO1xuICAgIHBhdGggPSBwYXRoQXJyYXkuam9pbihcIi9cIik7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLmdldFBhcmVudFBhdGggPSBnZXRQYXJlbnRQYXRoO1xuLyoqXG4gKiBTYW5pdGl6ZXMgdGhlIHBhdGggYnkgcmVtb3ZpbmcgdHJhaWxpbmcgc2xhc2hlcyBhbmQgcmVtb3ZpbmcgcmVwZWF0aW5nIGFkamFjZW50IHNsYXNoZXMuXG4gKlxuICogQHBhcmFtIHBhdGggLSBUaGUgZ2l2ZW4gcGF0aFxuICogQHJldHVybnMgLSBUaGUgc2FuaXRpemVkIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplUGF0aChwYXRoKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgcGF0aCA9IHV0aWxzXzEudHJpbVN1ZmZpeChwYXRoLCBcIi9cIik7XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBhZGphY2VudCBzbGFzaGVzLlxuICAgIHBhdGggPSB1dGlsc18xLnJlbW92ZUFkamFjZW50Q2hhcnMocGF0aCwgXCIvXCIpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5zYW5pdGl6ZVBhdGggPSBzYW5pdGl6ZVBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRocy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnBlcm1UeXBlVG9TdHJpbmcgPSBleHBvcnRzLnBlcm1DYXRlZ29yeVRvU3RyaW5nID0gZXhwb3J0cy5QZXJtVHlwZSA9IGV4cG9ydHMuUGVybVdyaXRlID0gZXhwb3J0cy5QZXJtUmVhZCA9IGV4cG9ydHMuUGVybUNhdGVnb3J5ID0gZXhwb3J0cy5QZXJtTGVnYWN5U2t5SUQgPSBleHBvcnRzLlBlcm1IaWRkZW4gPSBleHBvcnRzLlBlcm1EaXNjb3ZlcmFibGUgPSBleHBvcnRzLlBlcm1pc3Npb24gPSB2b2lkIDA7XG52YXIgUGVybWlzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJtaXNzaW9uKHJlcXVlc3RvciwgcGF0aCwgY2F0ZWdvcnksIHBlcm1UeXBlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdG9yID0gcmVxdWVzdG9yO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMucGVybVR5cGUgPSBwZXJtVHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSAhPT0gXCJudW1iZXJcIiB8fCAhKGNhdGVnb3J5IGluIFBlcm1DYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgJ2NhdGVnb3J5JyBlbnVtIHZhbHVlIFwiICsgY2F0ZWdvcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybVR5cGUgIT09IFwibnVtYmVyXCIgfHwgIShwZXJtVHlwZSBpbiBQZXJtVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgJ3Blcm1UeXBlJyBlbnVtIHZhbHVlIFwiICsgcGVybVR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQZXJtaXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuUGVybWlzc2lvbiA9IFBlcm1pc3Npb247XG4vLyBEZWZpbmUgY2F0ZWdvcnkgY29uc3RhbnRzIGZvciBub24tVFMgdXNlcnMuXG5leHBvcnRzLlBlcm1EaXNjb3ZlcmFibGUgPSAxO1xuZXhwb3J0cy5QZXJtSGlkZGVuID0gMjtcbmV4cG9ydHMuUGVybUxlZ2FjeVNreUlEID0gMztcbi8qKlxuICogRGVmaW5lcyB3aGF0IHR5cGUgb2YgZmlsZSBpcyBiZWluZyByZXF1ZXN0ZWQuIERpc2NvdmVyYWJsZSBmaWxlcyBhcmUgdmlzaWJsZVxuICogdG8gdGhlIGVudGlyZSB3b3JsZCwgaGlkZGVuIGZpbGVzIGFyZSBvbmx5IHZpc2libGUgdG8gdGhlIHVzZXIgKHVubGVzc1xuICogc2hhcmVkKSwgYW5kIExlZ2FjeVNreUlEIGZpbGVzIGFyZSBzdXBwb3J0ZWQgZmlsZXMgZnJvbSB0aGUgbGVnYWN5IFNreUlEXG4gKiBsb2dpbiBzeXN0ZW0uXG4gKi9cbnZhciBQZXJtQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKFBlcm1DYXRlZ29yeSkge1xuICAgIFBlcm1DYXRlZ29yeVtQZXJtQ2F0ZWdvcnlbXCJEaXNjb3ZlcmFibGVcIl0gPSBleHBvcnRzLlBlcm1EaXNjb3ZlcmFibGVdID0gXCJEaXNjb3ZlcmFibGVcIjtcbiAgICBQZXJtQ2F0ZWdvcnlbUGVybUNhdGVnb3J5W1wiSGlkZGVuXCJdID0gZXhwb3J0cy5QZXJtSGlkZGVuXSA9IFwiSGlkZGVuXCI7XG4gICAgUGVybUNhdGVnb3J5W1Blcm1DYXRlZ29yeVtcIkxlZ2FjeVNreUlEXCJdID0gZXhwb3J0cy5QZXJtTGVnYWN5U2t5SURdID0gXCJMZWdhY3lTa3lJRFwiO1xufSkoUGVybUNhdGVnb3J5ID0gZXhwb3J0cy5QZXJtQ2F0ZWdvcnkgfHwgKGV4cG9ydHMuUGVybUNhdGVnb3J5ID0ge30pKTtcbi8vIERlZmluZSB0eXBlIGNvbnN0YW50cyBmb3Igbm9uLVRTIHVzZXJzLlxuZXhwb3J0cy5QZXJtUmVhZCA9IDQ7XG5leHBvcnRzLlBlcm1Xcml0ZSA9IDU7XG52YXIgUGVybVR5cGU7XG4oZnVuY3Rpb24gKFBlcm1UeXBlKSB7XG4gICAgUGVybVR5cGVbUGVybVR5cGVbXCJSZWFkXCJdID0gZXhwb3J0cy5QZXJtUmVhZF0gPSBcIlJlYWRcIjtcbiAgICBQZXJtVHlwZVtQZXJtVHlwZVtcIldyaXRlXCJdID0gZXhwb3J0cy5QZXJtV3JpdGVdID0gXCJXcml0ZVwiO1xufSkoUGVybVR5cGUgPSBleHBvcnRzLlBlcm1UeXBlIHx8IChleHBvcnRzLlBlcm1UeXBlID0ge30pKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHBlcm1pc3Npb24gY2F0ZWdvcnkgdG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGNhdGVnb3J5IC0gVGhlIGdpdmVuIGNhdGVnb3J5LlxuICogQHJldHVybnMgLSBUaGUgc3RyaW5nLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIGNhdGVnb3J5IGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gcGVybUNhdGVnb3J5VG9TdHJpbmcoY2F0ZWdvcnkpIHtcbiAgICBpZiAoY2F0ZWdvcnkgPT09IFBlcm1DYXRlZ29yeS5EaXNjb3ZlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIFwiRGlzY292ZXJhYmxlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhdGVnb3J5ID09PSBQZXJtQ2F0ZWdvcnkuSGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBcIkhpZGRlblwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXRlZ29yeSA9PT0gUGVybUNhdGVnb3J5LkxlZ2FjeVNreUlEKSB7XG4gICAgICAgIHJldHVybiBcIkxlZ2FjeVNreUlEXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBlcm1pc3Npb24gY2F0ZWdvcnkgXCIgKyBjYXRlZ29yeSk7XG4gICAgfVxufVxuZXhwb3J0cy5wZXJtQ2F0ZWdvcnlUb1N0cmluZyA9IHBlcm1DYXRlZ29yeVRvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gcGVybWlzc2lvbiB0eXBlIHRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBwZXJtVHlwZSAtIFRoZSBnaXZlbiB0eXBlLlxuICogQHJldHVybnMgLSBUaGUgc3RyaW5nLlxuICogQHRocm93cyAtIFdpbGwgdGhyb3cgaWYgdGhlIHR5cGUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBwZXJtVHlwZVRvU3RyaW5nKHBlcm1UeXBlKSB7XG4gICAgaWYgKHBlcm1UeXBlID09PSBQZXJtVHlwZS5SZWFkKSB7XG4gICAgICAgIHJldHVybiBcIlJlYWRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocGVybVR5cGUgPT09IFBlcm1UeXBlLldyaXRlKSB7XG4gICAgICAgIHJldHVybiBcIldyaXRlXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBlcm1pc3Npb24gdHlwZSBcIiArIHBlcm1UeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLnBlcm1UeXBlVG9TdHJpbmcgPSBwZXJtVHlwZVRvU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVybWlzc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy50cmltU3VmZml4ID0gZXhwb3J0cy5yZW1vdmVBZGphY2VudENoYXJzID0gZXhwb3J0cy5lbnN1cmVVcmwgPSBleHBvcnRzLmNyZWF0ZUZ1bGxTY3JlZW5JZnJhbWUgPSBleHBvcnRzLmNyZWF0ZUlmcmFtZSA9IHZvaWQgMDtcbi8qKlxuICogQ3JlYXRlcyBhbiBpbnZpc2libGUgaWZyYW1lIHdpdGggdGhlIGdpdmVuIHNyYyBhbmQgYWRkcyBpdCB0byB0aGUgcGFnZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKHNyY1VybCwgbmFtZSkge1xuICAgIHNyY1VybCA9IGVuc3VyZVVybChzcmNVcmwpO1xuICAgIHZhciBjaGlsZEZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBjaGlsZEZyYW1lLnNyYyA9IHNyY1VybDtcbiAgICBjaGlsZEZyYW1lLm5hbWUgPSBuYW1lO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIC8vIFNldCBzYW5kYm94IHBlcm1pc3Npb25zLlxuICAgIC8vIFRPRE86IEVuYWJsZSBzYW5kYm94aW5nP1xuICAgIC8vIGNoaWxkRnJhbWUuc2FuZGJveC5hZGQoXCJhbGxvdy1zYW1lLW9yaWdpblwiKTtcbiAgICAvLyBjaGlsZEZyYW1lLnNhbmRib3guYWRkKFwiYWxsb3ctc2NyaXB0c1wiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNoaWxkRnJhbWUpO1xuICAgIHJldHVybiBjaGlsZEZyYW1lO1xufVxuZXhwb3J0cy5jcmVhdGVJZnJhbWUgPSBjcmVhdGVJZnJhbWU7XG4vKipcbiAqIENyZWF0ZXMgYSBmdWxsLXNjcmVlbiBpZnJhbWUgd2l0aCB0aGUgZ2l2ZW4gc3JjIGFuZCBhZGRzIGl0IHRvIHRoZSBwYWdlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdWxsU2NyZWVuSWZyYW1lKHNyY1VybCwgbmFtZSkge1xuICAgIHNyY1VybCA9IGVuc3VyZVVybChzcmNVcmwpO1xuICAgIHZhciBjaGlsZEZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBjaGlsZEZyYW1lLnNyYyA9IHNyY1VybDtcbiAgICBjaGlsZEZyYW1lLm5hbWUgPSBuYW1lO1xuICAgIC8vIFNldCBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhlIGlmcmFtZSBmdWxsLXNjcmVlbi5cbiAgICBjaGlsZEZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgY2hpbGRGcmFtZS5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgICBjaGlsZEZyYW1lLnN0eWxlLm1hcmdpbiA9IFwiMFwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIGNoaWxkRnJhbWUuc3R5bGUuekluZGV4ID0gXCI5OTk5OTlcIjtcbiAgICAvLyBTZXQgc2FuZGJveCBwZXJtaXNzaW9ucy5cbiAgICAvLyBUT0RPOiBFbmFibGUgc2FuZGJveGluZz9cbiAgICAvLyBjaGlsZEZyYW1lLnNhbmRib3guYWRkKFwiYWxsb3ctc2FtZS1vcmlnaW5cIik7XG4gICAgLy8gY2hpbGRGcmFtZS5zYW5kYm94LmFkZChcImFsbG93LXNjcmlwdHNcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZEZyYW1lKTtcbiAgICByZXR1cm4gY2hpbGRGcmFtZTtcbn1cbmV4cG9ydHMuY3JlYXRlRnVsbFNjcmVlbklmcmFtZSA9IGNyZWF0ZUZ1bGxTY3JlZW5JZnJhbWU7XG5mdW5jdGlvbiBlbnN1cmVVcmwodXJsKSB7XG4gICAgcmV0dXJuIGVuc3VyZVByZWZpeCh1cmwsIFwiaHR0cHM6Ly9cIik7XG59XG5leHBvcnRzLmVuc3VyZVVybCA9IGVuc3VyZVVybDtcbmZ1bmN0aW9uIHJlbW92ZUFkamFjZW50Q2hhcnMoc3RyLCBjaGFyKSB7XG4gICAgdmFyIHBhdGhBcnJheSA9IEFycmF5LmZyb20oc3RyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGggLSAxOykge1xuICAgICAgICBpZiAocGF0aEFycmF5W2ldID09PSBjaGFyICYmIHBhdGhBcnJheVtpICsgMV0gPT09IGNoYXIpIHtcbiAgICAgICAgICAgIHBhdGhBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGhBcnJheS5qb2luKFwiXCIpO1xufVxuZXhwb3J0cy5yZW1vdmVBZGphY2VudENoYXJzID0gcmVtb3ZlQWRqYWNlbnRDaGFycztcbi8qKlxuICogUmVtb3ZlcyBhIHN1ZmZpeCBmcm9tIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZyB0byBwcm9jZXNzLlxuICogQHBhcmFtIHN1ZmZpeCAtIFRoZSBzdWZmaXggdG8gcmVtb3ZlLlxuICogQHBhcmFtIFtsaW1pdF0gLSBNYXhpbXVtIGFtb3VudCBvZiB0aW1lcyB0byB0cmltLiBObyBsaW1pdCBieSBkZWZhdWx0LlxuICogQHJldHVybnMgLSBUaGUgcHJvY2Vzc2VkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdHJpbVN1ZmZpeChzdHIsIHN1ZmZpeCwgbGltaXQpIHtcbiAgICB3aGlsZSAoc3RyLmVuZHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgbGltaXQgLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0cy50cmltU3VmZml4ID0gdHJpbVN1ZmZpeDtcbmZ1bmN0aW9uIGVuc3VyZVByZWZpeChzLCBwcmVmaXgpIHtcbiAgICBpZiAoIXMuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIHMgPSBcIlwiICsgcHJlZml4ICsgcztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm1vbml0b3JXaW5kb3dFcnJvciA9IGV4cG9ydHMuUHJvbWlzZUNvbnRyb2xsZXIgPSBleHBvcnRzLmRpc3BhdGNoZWRFcnJvckV2ZW50ID0gZXhwb3J0cy5lcnJvcldpbmRvd0Nsb3NlZCA9IHZvaWQgMDtcbmV4cG9ydHMuZXJyb3JXaW5kb3dDbG9zZWQgPSBcIndpbmRvdy1jbG9zZWRcIjtcbmV4cG9ydHMuZGlzcGF0Y2hlZEVycm9yRXZlbnQgPSBcImNhdGNoRXJyb3JcIjtcbnZhciBQcm9taXNlQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9taXNlQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgUHJvbWlzZUNvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEVtcHR5IHVudGlsIGltcGxlbWVudGVkIGluIG1vbml0b3JXaW5kb3dFcnJvci5cbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnRzLlByb21pc2VDb250cm9sbGVyID0gUHJvbWlzZUNvbnRyb2xsZXI7XG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvciBmcm9tIHRoZSB3aW5kb3cgb24gYW4gaW50ZXJ2YWwuXG4gKi9cbmZ1bmN0aW9uIG1vbml0b3JXaW5kb3dFcnJvcigpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyBQcm9taXNlQ29udHJvbGxlcigpO1xuICAgIHZhciBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihleHBvcnRzLmRpc3BhdGNoZWRFcnJvckV2ZW50LCBoYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB2YXIgZXJyID0gZS5kZXRhaWw7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBkb2Vzbid0IHJlY29nbml6ZSBzaWduYWwgb3B0aW9uLlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihleHBvcnRzLmRpc3BhdGNoZWRFcnJvckV2ZW50LCBoYW5kbGVFdmVudCwge1xuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNsZWFudXAgZnVuY3Rpb24uXG4gICAgICAgIGNvbnRyb2xsZXIuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgLy8gQ2xlYW51cCB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9taXNlOiBwcm9taXNlLCBjb250cm9sbGVyOiBjb250cm9sbGVyIH07XG59XG5leHBvcnRzLm1vbml0b3JXaW5kb3dFcnJvciA9IG1vbml0b3JXaW5kb3dFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy1saXN0ZW5lci5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvRGF0YVZpZXcgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGRhdGFgIHRvIGJlIGFuIEFycmF5QnVmZmVyLCBCdWZmZXIsIEludDhBcnJheSwgVWludDhBcnJheSBvciBVaW50OENsYW1wZWRBcnJheScpXG59XG4iLCIoZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG4iLCIoZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZGVmaW5pdGlvbik7XG4gIGVsc2UgY29udGV4dFtuYW1lXSA9IGRlZmluaXRpb24oKTtcbn0pKCd1cmxqb2luJywgdGhpcywgZnVuY3Rpb24gKCkge1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSAoc3RyQXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICBpZiAoc3RyQXJyYXkubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuXG4gICAgaWYgKHR5cGVvZiBzdHJBcnJheVswXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VybCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgc3RyQXJyYXlbMF0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBmaXJzdCBwYXJ0IGlzIGEgcGxhaW4gcHJvdG9jb2wsIHdlIGNvbWJpbmUgaXQgd2l0aCB0aGUgbmV4dCBwYXJ0LlxuICAgIGlmIChzdHJBcnJheVswXS5tYXRjaCgvXlteLzpdKzpcXC8qJC8pICYmIHN0ckFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBmaXJzdCA9IHN0ckFycmF5LnNoaWZ0KCk7XG4gICAgICBzdHJBcnJheVswXSA9IGZpcnN0ICsgc3RyQXJyYXlbMF07XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgbXVzdCBiZSB0d28gb3IgdGhyZWUgc2xhc2hlcyBpbiB0aGUgZmlsZSBwcm90b2NvbCwgdHdvIHNsYXNoZXMgaW4gYW55dGhpbmcgZWxzZS5cbiAgICBpZiAoc3RyQXJyYXlbMF0ubWF0Y2goL15maWxlOlxcL1xcL1xcLy8pKSB7XG4gICAgICBzdHJBcnJheVswXSA9IHN0ckFycmF5WzBdLnJlcGxhY2UoL14oW14vOl0rKTpcXC8qLywgJyQxOi8vLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJBcnJheVswXSA9IHN0ckFycmF5WzBdLnJlcGxhY2UoL14oW14vOl0rKTpcXC8qLywgJyQxOi8vJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHN0ckFycmF5W2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVXJsIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBjb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50ID09PSAnJykgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIHN0YXJ0aW5nIHNsYXNoZXMgZm9yIGVhY2ggY29tcG9uZW50IGJ1dCB0aGUgZmlyc3QuXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5yZXBsYWNlKC9eW1xcL10rLywgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBzdHJBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIFJlbW92aW5nIHRoZSBlbmRpbmcgc2xhc2hlcyBmb3IgZWFjaCBjb21wb25lbnQgYnV0IHRoZSBsYXN0LlxuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQucmVwbGFjZSgvW1xcL10rJC8sICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciB0aGUgbGFzdCBjb21wb25lbnQgd2Ugd2lsbCBjb21iaW5lIG11bHRpcGxlIHNsYXNoZXMgdG8gYSBzaW5nbGUgb25lLlxuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQucmVwbGFjZSgvW1xcL10rJC8sICcvJyk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdEFycmF5LnB1c2goY29tcG9uZW50KTtcblxuICAgIH1cblxuICAgIHZhciBzdHIgPSByZXN1bHRBcnJheS5qb2luKCcvJyk7XG4gICAgLy8gRWFjaCBpbnB1dCBjb21wb25lbnQgaXMgbm93IHNlcGFyYXRlZCBieSBhIHNpbmdsZSBzbGFzaCBleGNlcHQgdGhlIHBvc3NpYmxlIGZpcnN0IHBsYWluIHByb3RvY29sIHBhcnQuXG5cbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2ggYmVmb3JlIHBhcmFtZXRlcnMgb3IgaGFzaFxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csICckMScpO1xuXG4gICAgLy8gcmVwbGFjZSA/IGluIHBhcmFtZXRlcnMgd2l0aCAmXG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCc/Jyk7XG4gICAgc3RyID0gcGFydHMuc2hpZnQoKSArIChwYXJ0cy5sZW5ndGggPiAwID8gJz8nOiAnJykgKyBwYXJ0cy5qb2luKCcmJyk7XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlucHV0ID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dCA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplKGlucHV0KTtcbiAgfTtcblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgd2hpdGVzcGFjZSA9ICdbXFxcXHgwOVxcXFx4MEFcXFxceDBCXFxcXHgwQ1xcXFx4MERcXFxceDIwXFxcXHhBMFxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1RkVGRl0nXG4gICwgbGVmdCA9IG5ldyBSZWdFeHAoJ14nKyB3aGl0ZXNwYWNlICsnKycpO1xuXG4vKipcbiAqIFRyaW0gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShsZWZ0LCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIlxuaW1wb3J0IHsgU2t5bmV0Q2xpZW50LCBNeVNreSwgSnNvbkRhdGEsIEpTT05SZXNwb25zZSB9IGZyb20gXCJza3luZXQtanNcIjtcbmltcG9ydCB7IHVpbnQ4QXJyYXlUb0Jhc2U2NFJhd1VybCwgYmFzZTY0UmF3VXJsVG9VaW50OEFycmF5LCB0cmltU3VmZml4LCB0cmltVXJpUHJlZml4LCB1cmlTa3luZXRQcmVmaXggfSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQgeyBDaGlsZEhhbmRzaGFrZSwgQ29ubmVjdGlvbiwgV2luZG93TWVzc2VuZ2VyIH0gZnJvbSBcInBvc3QtbWVcIjtcbmltcG9ydCB7XG4gIElTa2FwcERBQywgSURBQ1Jlc3BvbnNlLCBJRmlsZVBhdGhzLCBza2FwcEFjdGlvblR5cGUsIElEZXBsb3llZEFwcHNERElEWCwgREVGQVVMVF9TRF9ERVBMT1lFRF9BUFBTX0lOREVYLFxuICBERUZBVUxUX0REX0RFUExPWUVEX0FQUFNfSU5ERVgsIElEZXBsb3llZEFwcHNTRElEWCwgSURlcGxveW1lbnRSZWNvcmQsIElEZXBsb3llZEFwcHNERElEWFJlY29yZCwgSURlcGxveWVkQXBwc1NESURYUmVjb3JkLFxuICBJUHVibGlzaGVkQXBwUmVjb3JkLCBJUHVibGlzaGVkQXBwc0RESURYLCBERUZBVUxUX0REX1BVQkxJU0hFRF9BUFBTX0lOREVYLCBERUZBVUxUX1NEX1BVQkxJU0hFRF9BUFBTX0lOREVYLCBJUHVibGlzaGVkQXBwc1NESURYLFxuICBJUHVibGlzaGVkQXBwc0RESURYUmVjb3JkLCBJUHVibGlzaGVkQXBwc1NESURYUmVjb3JkLCBJUHVibGlzaGVkQXBwc1N0YXRzRERJRFgsIElQdWJsaXNoZWRBcHBzU3RhdHNTRElEWCwgSVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYUmVjb3JkLFxuICBERUZBVUxUX1BVQkxJU0hFRF9BUFBTX1NUQVRTX1JFQ09SRCwgSVB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkLCBJUHVibGlzaGVkQXBwc1N0YXRzU0RJRFhSZWNvcmRcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gREFDIGNvbnN0c1xuY29uc3QgREFUQV9ET01BSU4gPSBcInNrYXBwLWRhYy5obnNcIjtcbmNvbnN0IERBQ19WRVJTSU9OID0gXCIwLjEuNi1iZXRhXCI7XG5cbi8vY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbmNvbnN0IERFQlVHX0VOQUJMRUQgPSB0cnVlO1xuY29uc3QgREVWX0VOQUJMRUQgPSBmYWxzZTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNrYXBwREFDIGltcGxlbWVudHMgSVNrYXBwREFDIHtcbiAgcHJvdGVjdGVkIGNvbm5lY3Rpb246IFByb21pc2U8Q29ubmVjdGlvbj47XG5cbiAgcHJpdmF0ZSBjbGllbnQ6IFNreW5ldENsaWVudFxuICBwcml2YXRlIG15U2t5OiBNeVNreTtcbiAgcHJpdmF0ZSBwYXRoczogSUZpbGVQYXRocztcbiAgcHJpdmF0ZSBza2FwcDogc3RyaW5nO1xuICBwcml2YXRlIHNrYXBwRGljdDogYW55ID0ge307XG5cbiAgLy8gd2lsbCBiZSBmbGlwcGVkIHRvIHRydWUgaWYgYWxsIGZpbGVzIGFyZSBjcmVhdGVkXG4gIHByaXZhdGUgZmlsZUhpZXJhcmNoeUVuc3VyZWQ6IGJvb2xlYW47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICApIHtcbiAgICAvLyBjcmVhdGUgY2xpZW50XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgU2t5bmV0Q2xpZW50KCk7XG5cbiAgICAvLyBkZWZpbmUgQVBJXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgIGluaXQ6IHRoaXMuaW5pdC5iaW5kKHRoaXMpLFxuICAgICAgb25Vc2VyTG9naW46IHRoaXMub25Vc2VyTG9naW4uYmluZCh0aGlzKSxcblxuICAgICAgc2V0RGVwbG95bWVudDogdGhpcy5zZXREZXBsb3ltZW50LmJpbmQodGhpcyksXG4gICAgICBnZXREZXBsb3ltZW50czogdGhpcy5nZXREZXBsb3ltZW50cy5iaW5kKHRoaXMpLFxuXG4gICAgICBzZXRQdWJsaXNoZWRBcHA6IHRoaXMuc2V0UHVibGlzaGVkQXBwLmJpbmQodGhpcyksXG4gICAgICBnZXRQdWJsaXNoZWRBcHBzOiB0aGlzLmdldFB1Ymxpc2hlZEFwcHMuYmluZCh0aGlzKSxcbiAgICAgIGdldFB1Ymxpc2hlZEFwcElkczogdGhpcy5nZXRQdWJsaXNoZWRBcHBJZHMuYmluZCh0aGlzKSxcblxuICAgICAgc2thcHBBY3Rpb246IHRoaXMuc2thcHBBY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGdldFN0YXRzOiB0aGlzLmdldFN0YXRzLmJpbmQodGhpcyksXG5cbiAgICAgIC8vZ2V0U2thcHBDb21tZW50czogdGhpcy5nZXRTa2FwcENvbW1lbnRzLmJpbmQodGhpcyksXG5cbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBjb25uZWN0aW9uXG4gICAgdGhpcy5jb25uZWN0aW9uID0gQ2hpbGRIYW5kc2hha2UoXG4gICAgICBuZXcgV2luZG93TWVzc2VuZ2VyKHtcbiAgICAgICAgbG9jYWxXaW5kb3c6IHdpbmRvdyxcbiAgICAgICAgcmVtb3RlV2luZG93OiB3aW5kb3cucGFyZW50LFxuICAgICAgICByZW1vdGVPcmlnaW46IFwiKlwiLFxuICAgICAgfSksXG4gICAgICBtZXRob2RzLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gZXh0cmFjdCB0aGUgc2thcHBuYW1lIGFuZCB1c2UgaXQgdG8gc2V0IHRoZSBmaWxlcGF0aHNcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gbmV3IFVSTChkb2N1bWVudC5yZWZlcnJlcikuaG9zdG5hbWVcbiAgICAgIGNvbnN0IHNrYXBwID0gYXdhaXQgdGhpcy5jbGllbnQuZXh0cmFjdERvbWFpbihob3N0bmFtZSlcbiAgICAgIHRoaXMubG9nKFwibG9hZGVkIGZyb20gc2thcHBcIiwgc2thcHApXG4gICAgICB0aGlzLnNrYXBwID0gc2thcHA7XG5cbiAgICAgIHRoaXMucGF0aHMgPSB7XG4gICAgICAgIC8vIERlcGxveVxuICAgICAgICBERF9ERVBMT1lFRF9BUFBTX0lOREVYX1BBVEg6IGAke0RBVEFfRE9NQUlOfS9kZXBsb3llZC9pbmRleC5qc29uYCwgLy8gSURlcGxveWVkQXBwc0RESURYXG4gICAgICAgIEREX0RFUExPWUVEX0FQUF9QQVRIOiBgJHtEQVRBX0RPTUFJTn0vZGVwbG95ZWQvJEFQUF9JRC8kTEFURVNUL2RlcGxveW1lbnRSZWNvcmQuanNvbmAsIC8vSURlcGxveW1lbnRSZWNvcmRcbiAgICAgICAgU0RfREVQTE9ZRURfQVBQU19JTkRFWF9QQVRIOiBgJHtEQVRBX0RPTUFJTn0vJHtza2FwcH0vZGVwbG95ZWQvaW5kZXguanNvbmAsIC8vIElEZXBsb3llZEFwcHNTRElEWFxuICAgICAgICBTRF9ERVBMT1lFRF9BUFBfUEFUSDogYCR7REFUQV9ET01BSU59LyR7c2thcHB9L2RlcGxveWVkLyRBUFBfSUQvJExBVEVTVC9kZXBsb3ltZW50UmVjb3JkLmpzb25gLCAvL0lEZXBsb3ltZW50UmVjb3JkXG5cbiAgICAgICAgLy8gUHVibGlzaFxuICAgICAgICBERF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIOiBgJHtEQVRBX0RPTUFJTn0vcHVibGlzaGVkL2luZGV4Lmpzb25gLCAvLyBJUHVibGlzaGVkQXBwc0RESURYXG4gICAgICAgIEREX1BVQkxJU0hFRF9BUFBfUEFUSDogYCR7REFUQV9ET01BSU59L3B1Ymxpc2hlZC8kQVBQX0lELyRMQVRFU1QvcHVibGlzaGVkQXBwUmVjb3JkLmpzb25gLCAvL0lQdWJsaXNoZWRBcHBSZWNvcmRcbiAgICAgICAgU0RfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSDogYCR7REFUQV9ET01BSU59LyR7c2thcHB9L3B1Ymxpc2hlZC9pbmRleC5qc29uYCwvLyBJUHVibGlzaGVkQXBwc1NESURYXG4gICAgICAgIFNEX1BVQkxJU0hFRF9BUFBfUEFUSDogYCR7REFUQV9ET01BSU59LyR7c2thcHB9L3B1Ymxpc2hlZC8kQVBQX0lELyRMQVRFU1QvcHVibGlzaGVkQXBwUmVjb3JkLmpzb25gLC8vSVB1Ymxpc2hlZEFwcFJlY29yZFxuXG4gICAgICAgIC8vIFVzZXIgSW50ZXJhY3Rpb25zIC8gc3RhdHNcbiAgICAgICAgRERfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSDogYCR7REFUQV9ET01BSU59L3B1Ymxpc2hlZC9zdGF0cy9pbmRleC5qc29uYCwgLy8gSVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYXG4gICAgICAgIEREX1BVQkxJU0hFRF9BUFBfU1RBVFNfUEFUSDogYCR7REFUQV9ET01BSU59L3B1Ymxpc2hlZC9zdGF0cy8kQVBQX0lELyRMQVRFU1QvcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQuanNvbmAsIC8vSVB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkXG4gICAgICAgIFNEX1BVQkxJU0hFRF9BUFBTX1NUQVRTX0lOREVYX1BBVEg6IGAke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQvc3RhdHMvaW5kZXguanNvbmAsIC8vIElQdWJsaXNoZWRBcHBzU3RhdHNTRElEWFxuICAgICAgICBTRF9QVUJMSVNIRURfQVBQX1NUQVRTX1BBVEg6IGAke0RBVEFfRE9NQUlOfS8ke3NrYXBwfS9wdWJsaXNoZWQvc3RhdHMvJEFQUF9JRC8kTEFURVNUL3B1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkLmpzb25gLCAvL0lQdWJsaXNoZWRBcHBTdGF0c1JlY29yZFxuXG4gICAgICAgIC8vIFB1Ymxpc2ggQXBwIDogVXNlciBBY3Rpb24gLT4gQ29tbWVudHNcbiAgICAgICAgLy8gRERfUFVCTElTSEVEX0FQUFNfQ09NTUVOVFNfSU5ERVhfUEFUSDogYCR7REFUQV9ET01BSU59L3B1Ymxpc2hlZC9jb21tZW50cy9pbmRleC5qc29uYCwvLyBJUHVibGlzaGVkQXBwc0NvbW1lbnRzXG4gICAgICAgIC8vIFNEX1BVQkxJU0hFRF9BUFBfQ09NTUVOVFNfSU5ERVhfUEFUSDogYCR7REFUQV9ET01BSU59LyR7c2thcHB9L3B1Ymxpc2hlZC9jb21tZW50cy9pbmRleC5qc29uYCwgLy8gSVNrYXBwUHVibGlzaGVkQXBwc0NvbW1lbnRzSW5kZXhcbiAgICAgICAgLy8gU0RfUFVCTElTSEVEX0FQUF9DT01NRU5UU19QQVRIOiBgJHtEQVRBX0RPTUFJTn0vJHtza2FwcH0vcHVibGlzaGVkLyRBUFBfSUQvY29tbWVudHMvJExBVEVTVC9wdWJsaXNoZWRBcHBDb21tZW50UmVjb3Jkcy5qc29uYCwgLy9JU2thcHBQdWJsaXNoZWRBcHBzQ29tbWVudHNcbiAgICAgIH1cbiAgICAgIC8vIGxvYWQgbXlza3lcbiAgICAgIGNvbnN0IG9wdHMgPSB7IGRldjogREVWX0VOQUJMRUQgfVxuICAgICAgdGhpcy5teVNreSA9IGF3YWl0IHRoaXMuY2xpZW50LmxvYWRNeVNreShEQVRBX0RPTUFJTiwgb3B0cylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2coJ0ZhaWxlZCB0byBsb2FkIE15U2t5LCBlcnI6ICcsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvL3RoaXMuc2thcHBEaWN0PSBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZSh0aGlzLnBhdGhzLlNLQVBQU19ESUNUX1BBVEgpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nKCdGYWlsZWQgdG8gbG9hZCBza2FwcERpY3QsIGVycjogJywgZXJyb3IpXG4gICAgICB0aGlzLnNrYXBwRGljdFt0aGlzLnNrYXBwXSA9IHRydWU7XG4gICAgICAvL3RoaXMubXlTa3kuc2V0SlNPTih0aGlzLnBhdGhzLlNLQVBQU19ESUNUX1BBVEgsdGhpcy5za2FwcERpY3QpO1xuICAgICAgdGhpcy5sb2coJ3VwZGF0ZWQgY3VycmVudCBza2FwcCB0byBza2FwcCBkaWN0Jyk7XG4gICAgfVxuICB9XG5cbiAgLy8gb25Vc2VyTG9naW4gaXMgY2FsbGVkIGJ5IE15U2t5IHdoZW4gdGhlIHVzZXIgaGFzIGxvZ2dlZCBpbiBzdWNjZXNzZnVsbHlcbiAgcHVibGljIGFzeW5jIG9uVXNlckxvZ2luKCkge1xuICAgIHRoaXMubG9nKGA+Pj4+Pj4+PiBTS0FQUCBEQUMgOiBWUkVTSU9OIDogJHtEQUNfVkVSU0lPTn0gPDw8PDw8PDw8PDw8PDw8PGApXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgIHByb21pc2VzLnB1c2godGhpcy5lbnN1cmVERERlcGxveWVkQXBwc0luZGV4UHJlc2VudCgpXG4gICAgICAudGhlbigoKSA9PiB7IHRoaXMubG9nKGBTdWNjZXNzZnVsbHkgZW5zdXJlZCAke3RoaXMucGF0aHMuRERfREVQTE9ZRURfQVBQU19JTkRFWF9QQVRIfSBwcmVzZW50YCkgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4geyB0aGlzLmxvZygnRmFpbGVkIHRvIGVuc3VyZSBEZXBsb3ltZW50IERhdGFEb21haW4gaW5kZXguanNvbiwgZXJyOiAnLCBlcnIpIH0pXG4gICAgKVxuICAgIHByb21pc2VzLnB1c2godGhpcy5lbnN1cmVTRERlcGxveWVkQXBwc0luZGV4UHJlc2VudCgpXG4gICAgICAudGhlbigoKSA9PiB7IHRoaXMubG9nKGBTdWNjZXNzZnVsbHkgZW5zdXJlZCAke3RoaXMucGF0aHMuU0RfREVQTE9ZRURfQVBQU19JTkRFWF9QQVRIfSBwcmVzZW50YCkgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4geyB0aGlzLmxvZygnRmFpbGVkIHRvIGVuc3VyZSBEZXBsb3ltZW50IFNrYXBwRG9tYWluIGluZGV4Lmpzb24sIGVycjogJywgZXJyKSB9KSlcblxuICAgIHByb21pc2VzLnB1c2godGhpcy5lbnN1cmVERFB1Ymxpc2hlZEFwcHNJbmRleFByZXNlbnQoKVxuICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLmxvZyhgU3VjY2Vzc2Z1bGx5IGVuc3VyZWQgJHt0aGlzLnBhdGhzLkREX1BVQkxJU0hFRF9BUFBTX0lOREVYX1BBVEh9IHByZXNlbnRgKSB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7IHRoaXMubG9nKCdGYWlsZWQgdG8gZW5zdXJlIFB1Ymxpc2hlZEFwcCBEYXRhRG9tYWluIGluZGV4Lmpzb24sIGVycjogJywgZXJyKSB9KVxuICAgIClcbiAgICBwcm9taXNlcy5wdXNoKHRoaXMuZW5zdXJlU0RQdWJsaXNoZWRBcHBzSW5kZXhQcmVzZW50KClcbiAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5sb2coYFN1Y2Nlc3NmdWxseSBlbnN1cmVkICR7dGhpcy5wYXRocy5TRF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIfSBwcmVzZW50YCkgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4geyB0aGlzLmxvZygnRmFpbGVkIHRvIGVuc3VyZSBQdWJsaXNoZWRBcHAgU2thcHBEb21haW4gaW5kZXguanNvbiwgZXJyOiAnLCBlcnIpIH0pKVxuXG4gICAgcHJvbWlzZXMucHVzaCh0aGlzLmVuc3VyZUREUHVibGlzaGVkQXBwc1N0YXRzSW5kZXhQcmVzZW50KClcbiAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5sb2coYFN1Y2Nlc3NmdWxseSBlbnN1cmVkICR7dGhpcy5wYXRocy5ERF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWF9QQVRIfSBwcmVzZW50YCkgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4geyB0aGlzLmxvZygnRmFpbGVkIHRvIGVuc3VyZSBQdWJsaXNoZWRBcHBTdGF0cyBEYXRhRG9tYWluIGluZGV4Lmpzb24sIGVycjogJywgZXJyKSB9KVxuICAgIClcbiAgICBwcm9taXNlcy5wdXNoKHRoaXMuZW5zdXJlU0RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleFByZXNlbnQoKVxuICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLmxvZyhgU3VjY2Vzc2Z1bGx5IGVuc3VyZWQgJHt0aGlzLnBhdGhzLlNEX1BVQkxJU0hFRF9BUFBTX1NUQVRTX0lOREVYX1BBVEh9IHByZXNlbnRgKSB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7IHRoaXMubG9nKCdGYWlsZWQgdG8gZW5zdXJlIFB1Ymxpc2hlZEFwcFN0YXRzIFNrYXBwRG9tYWluIGluZGV4Lmpzb24sIGVycjogJywgZXJyKSB9KSlcbiAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7IHRoaXMuZmlsZUhpZXJhcmNoeUVuc3VyZWQgPSB0cnVlIH0pXG4gIH1cbiAgcHJpdmF0ZSBhc3luYyBlbnN1cmVERERlcGxveWVkQXBwc0luZGV4UHJlc2VudCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSDogcGF0aCB9ID0gdGhpcy5wYXRocztcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlPElEZXBsb3llZEFwcHNERElEWD4ocGF0aCk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVGaWxlKHBhdGgsIERFRkFVTFRfRERfREVQTE9ZRURfQVBQU19JTkRFWCkgLy8gZGVmYXVsdCBpbmRleFxuICAgIH1cbiAgfVxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVNERGVwbG95ZWRBcHBzSW5kZXhQcmVzZW50KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgU0RfREVQTE9ZRURfQVBQU19JTkRFWF9QQVRIOiBwYXRoIH0gPSB0aGlzLnBhdGhzO1xuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGU8SURlcGxveWVkQXBwc1NESURYPihwYXRoKTtcbiAgICBpZiAoIWluZGV4KSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUZpbGUocGF0aCwgREVGQVVMVF9TRF9ERVBMT1lFRF9BUFBTX0lOREVYKSAvLyBkZWZhdWx0IGluZGV4XG4gICAgfVxuICB9XG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlRERQdWJsaXNoZWRBcHBzSW5kZXhQcmVzZW50KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgRERfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSDogcGF0aCB9ID0gdGhpcy5wYXRocztcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlPElQdWJsaXNoZWRBcHBzRERJRFg+KHBhdGgpO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlRmlsZShwYXRoLCBERUZBVUxUX0REX1BVQkxJU0hFRF9BUFBTX0lOREVYKSAvLyBkZWZhdWx0IGluZGV4XG4gICAgfVxuICB9XG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlU0RQdWJsaXNoZWRBcHBzSW5kZXhQcmVzZW50KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgU0RfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSDogcGF0aCB9ID0gdGhpcy5wYXRocztcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlPElQdWJsaXNoZWRBcHBzU0RJRFg+KHBhdGgpO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlRmlsZShwYXRoLCBERUZBVUxUX1NEX1BVQkxJU0hFRF9BUFBTX0lOREVYKSAvLyBkZWZhdWx0IGluZGV4XG4gICAgfVxuICB9XG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlRERQdWJsaXNoZWRBcHBzU3RhdHNJbmRleFByZXNlbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBERF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWF9QQVRIOiBwYXRoIH0gPSB0aGlzLnBhdGhzO1xuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGU8SVB1Ymxpc2hlZEFwcHNERElEWD4ocGF0aCk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVGaWxlKHBhdGgsIERFRkFVTFRfRERfUFVCTElTSEVEX0FQUFNfSU5ERVgpIC8vIGRlZmF1bHQgaW5kZXhcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBhc3luYyBlbnN1cmVTRFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4UHJlc2VudCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IFNEX1BVQkxJU0hFRF9BUFBTX1NUQVRTX0lOREVYX1BBVEg6IHBhdGggfSA9IHRoaXMucGF0aHM7XG4gICAgY29uc3QgaW5kZXggPSBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZTxJUHVibGlzaGVkQXBwc1NESURYPihwYXRoKTtcbiAgICBpZiAoIWluZGV4KSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUZpbGUocGF0aCwgREVGQVVMVF9TRF9QVUJMSVNIRURfQVBQU19JTkRFWCkgLy8gZGVmYXVsdCBpbmRleFxuICAgIH1cbiAgfVxuICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgRGVwbG95bWVudCBNZXRob2RzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICBwdWJsaWMgYXN5bmMgc2V0RGVwbG95bWVudChkYXRhOiBJRGVwbG95bWVudFJlY29yZCk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPiB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLndhaXRVbnRpbEZpbGVzQXJlUHJlc2VudCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBEZXBsb3ltZW50IEZpbGVzLCBpbml0aWFsaXphdGlvbiB0aW1lb3V0Jyk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ6IElEQUNSZXNwb25zZSA9IHsgc3VibWl0dGVkOiBmYWxzZSwgfTtcbiAgICAvLyBUT0RPOiBBZGQgXCJWYWxpZGF0aW9uXCIgY2FsbCBoZXJlXG4gICAgbGV0IHByb21pc2VzOiBhbnkgPSBbXVxuICAgIGNvbnN0IHRpbWVzdGFtcDogbnVtYmVyID0gKG5ldyBEYXRlKCkpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB7IEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCwgRERfREVQTE9ZRURfQVBQX1BBVEgsIFNEX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCwgU0RfREVQTE9ZRURfQVBQX1BBVEggfSA9IHRoaXMucGF0aHM7XG4gICAgY29uc3QgRERfREVQTE9ZRURfQVBQX1BBVEhfVVBEQVRFRCA9IEREX0RFUExPWUVEX0FQUF9QQVRILnJlcGxhY2UoXCIkQVBQX0lEXCIsIGRhdGEuYXBwSWQpO1xuICAgIGNvbnN0IFNEX0RFUExPWUVEX0FQUF9QQVRIX1VQREFURUQgPSBTRF9ERVBMT1lFRF9BUFBfUEFUSC5yZXBsYWNlKFwiJEFQUF9JRFwiLCBkYXRhLmFwcElkKTtcbiAgICB0aGlzLmxvZygnIEREX0RFUExPWUVEX0FQUF9QQVRIX1VQREFURUQgOiAnLCBERF9ERVBMT1lFRF9BUFBfUEFUSF9VUERBVEVEKTtcbiAgICB0aGlzLmxvZygnIFNEX0RFUExPWUVEX0FQUF9QQVRIX1VQREFURUQgOiAnLCBTRF9ERVBMT1lFRF9BUFBfUEFUSF9VUERBVEVEKTtcblxuICAgIHRyeSB7XG5cbiAgICAgIC8vICMjIyMjIyMgU3RlcCAxOiBSZWFkIERhdGFEb21haW4gYW5kIFNrYXBwRG9tYWluIEluZGV4ZXMgYW5kIHVwZGF0ZSBJbmRleCB2YXJpYWJsZSwgZG9udCB3cml0ZSB5ZXQuIEluZGV4IEZpbGUgd3JpdGUgd2lsbCBiZSBpbiBsYXN0IHN0ZXBcblxuICAgICAgbGV0IGRkRGVwbG95ZWRBcHBzSW5kZXg6IElEZXBsb3llZEFwcHNERElEWCB8IG51bGwgPSBudWxsOy8vIGF0IERhdGEgRG9tYWluIExldmVsXG4gICAgICBsZXQgc2REZXBsb3llZEFwcHNJbmRleDogSURlcGxveWVkQXBwc1NESURYIHwgbnVsbCA9IG51bGw7Ly8gYXQgU2thcHAgRG9tYWluIExldmVsXG4gICAgICBsZXQgZGRDb3VudGVyOiBudW1iZXIgPSAwO1xuICAgICAgbGV0IHNkQ291bnRlcjogbnVtYmVyID0gMDtcbiAgICAgIGxldCBkZXBsb3llZEFwcFJlY29yZERhdGFMaW5rOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm9taXNlczogYW55ID0gW107XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb3dubG9hZEZpbGU8SURlcGxveWVkQXBwc0RESURYPihERF9ERVBMT1lFRF9BUFBTX0lOREVYX1BBVEgpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvd25sb2FkRmlsZTxJRGVwbG95ZWRBcHBzU0RJRFg+KFNEX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCkpXG4gICAgICAgIGNvbnN0IHByb21pc2VSZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbDxJRGVwbG95ZWRBcHBzRERJRFgsIElEZXBsb3llZEFwcHNTRElEWD4ocHJvbWlzZXMpO1xuICAgICAgICBkZERlcGxveWVkQXBwc0luZGV4ID0gcHJvbWlzZVJlc3VsdFswXTtcbiAgICAgICAgc2REZXBsb3llZEFwcHNJbmRleCA9IHByb21pc2VSZXN1bHRbMV07XG4gICAgICAgIGlmIChkZERlcGxveWVkQXBwc0luZGV4ID09IHVuZGVmaW5lZCB8fCBkZERlcGxveWVkQXBwc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgRXJyb3IgRG93bmxvYWRpbmcgRGF0YURvbWFpbiBJbmRleCBGaWxlYDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZERlcGxveWVkQXBwc0luZGV4ID09IHVuZGVmaW5lZCB8fCBzZERlcGxveWVkQXBwc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgRXJyb3IgRG93bmxvYWRpbmcgU2thcHBEb21haW4gSW5kZXggRmlsZWA7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0LmVycm9yID0gYEVycm9yIERvd25sb2FkaW5nIERhdGFEb21haW4gYW5kL29yIFNrYXBwRG9tYWluIEluZGV4IEZpbGVgO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvLyAtLT4gRGF0YURvbWFpbiBJbmRleCBGaWxlXG4gICAgICBpZiAoZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXggPT0gbnVsbCkgey8vIGZpcnN0IHRpbWUgZGVwbG95aW5nXG4gICAgICAgIGNvbnN0IGRlcGxveWVkQXBwc0RESURYUmVjb3JkOiBJRGVwbG95ZWRBcHBzRERJRFhSZWNvcmQgPSB7XG4gICAgICAgICAgYXBwSWQ6IGRhdGEuYXBwSWQsXG4gICAgICAgICAgZGRDb3VudGVyOiAwLFxuICAgICAgICAgIGxhdGVzdERhdGFMaW5rOiBcIlwiLC8vIHZhbHVlIHdpbGwgYmUgc2V0IGhlcmUgbGF0ZXIgb24uXG4gICAgICAgICAgbGFzdFVwZGF0ZWRCeTogdGhpcy5za2FwcCxcbiAgICAgICAgICBza2FwcHM6IFt0aGlzLnNrYXBwXVxuICAgICAgICB9XG4gICAgICAgIGRkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4ID0ge1xuICAgICAgICAgIFtkYXRhLmFwcElkXTogZGVwbG95ZWRBcHBzRERJRFhSZWNvcmRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7Ly9Ob3QgRmlyc3RUaW1lIFxuICAgICAgICBjb25zdCBkZEFwcElkcyA9IE9iamVjdC5rZXlzKGRkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4KTtcbiAgICAgICAgaWYgKCFkZEFwcElkcy5pbmNsdWRlcyhkYXRhLmFwcElkKSkgey8vIFwiTmV3IEFwcFwiIERlcGxveW1lbnQgIVxuICAgICAgICAgIGNvbnN0IGRlcGxveWVkQXBwc0RESURYUmVjb3JkOiBJRGVwbG95ZWRBcHBzRERJRFhSZWNvcmQgPSB7XG4gICAgICAgICAgICBhcHBJZDogZGF0YS5hcHBJZCxcbiAgICAgICAgICAgIGRkQ291bnRlcjogMCxcbiAgICAgICAgICAgIGxhdGVzdERhdGFMaW5rOiBcIlwiLC8vIHZhbHVlIHdpbGwgYmUgc2V0IGhlcmUgbGF0ZXIgb24uXG4gICAgICAgICAgICBsYXN0VXBkYXRlZEJ5OiB0aGlzLnNrYXBwLFxuICAgICAgICAgICAgc2thcHBzOiBbdGhpcy5za2FwcF1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0gPSBkZXBsb3llZEFwcHNERElEWFJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsvLyBcIkV4aXN0aW5nIEFwcFwiIERlcGxveW1lbnQgIVxuICAgICAgICAgIGRkQ291bnRlciA9IGRkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmRkQ291bnRlciArIDE7XG4gICAgICAgICAgZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0uZGRDb3VudGVyID0gZGRDb3VudGVyO1xuICAgICAgICAgIGRkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmxhc3RVcGRhdGVkQnkgPSB0aGlzLnNrYXBwO1xuICAgICAgICAgIGlmICghZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0uc2thcHBzLmluY2x1ZGVzKHRoaXMuc2thcHApKVxuICAgICAgICAgICAgZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0uc2thcHBzLnB1c2godGhpcy5za2FwcCk7XG4gICAgICAgICAgY29uc3QgbGFzdERlcGxveW1lbnREYXRhTGluayA9IGRkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmxhdGVzdERhdGFMaW5rO1xuICAgICAgICAgIGNvbnN0IGhpc3RvcnlQYXRoOiBzdHJpbmcgPSBERF9ERVBMT1lFRF9BUFBfUEFUSF9VUERBVEVELnJlcGxhY2UoXCIkTEFURVNUXCIsIGRkQ291bnRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAvLyBzZXQgRW50cnkgd2l0aCAobGFzdERlcGxveW1lbnREYXRhTGluaylcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldERhdGFMaW5rKGhpc3RvcnlQYXRoLCBsYXN0RGVwbG95bWVudERhdGFMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAtLT4gU2thcHBEb21haW4gSW5kZXggRmlsZVxuICAgICAgaWYgKHNkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4ID09IG51bGwpIHsvL2ZpcnN0IHRpbWVcbiAgICAgICAgLy8gZmlyc3QgdGltZSBkZXBsb3lpbmdcbiAgICAgICAgY29uc3QgZGVwbG95ZWRBcHBzU0RJRFhSZWNvcmQ6IElEZXBsb3llZEFwcHNTRElEWFJlY29yZCA9IHtcbiAgICAgICAgICBhcHBJZDogZGF0YS5hcHBJZCxcbiAgICAgICAgICBzZENvdW50ZXI6IDAsXG4gICAgICAgICAgbGF0ZXN0RGF0YUxpbms6IFwiXCIsLy8gdmFsdWUgd2lsbCBiZSBzZXQgaGVyZSBsYXRlciBvbi5cbiAgICAgICAgfVxuICAgICAgICBzZERlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleCA9IHtcbiAgICAgICAgICBbZGF0YS5hcHBJZF06IGRlcGxveWVkQXBwc1NESURYUmVjb3JkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Ugey8vTm90IEZpcnN0VGltZSBcbiAgICAgICAgY29uc3Qgc2RBcHBJZHMgPSBPYmplY3Qua2V5cyhzZERlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleCk7XG4gICAgICAgIGlmICghc2RBcHBJZHMuaW5jbHVkZXMoZGF0YS5hcHBJZCkpIHsvLyBcIk5ldyBBcHBcIiBEZXBsb3ltZW50ICFcbiAgICAgICAgICBjb25zdCBkZXBsb3llZEFwcHNTRElEWFJlY29yZDogSURlcGxveWVkQXBwc1NESURYUmVjb3JkID0ge1xuICAgICAgICAgICAgYXBwSWQ6IGRhdGEuYXBwSWQsXG4gICAgICAgICAgICBzZENvdW50ZXI6IDAsXG4gICAgICAgICAgICBsYXRlc3REYXRhTGluazogXCJcIiwvLyB2YWx1ZSB3aWxsIGJlIHNldCBoZXJlIGxhdGVyIG9uLlxuICAgICAgICAgIH1cbiAgICAgICAgICBzZERlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXSA9IGRlcGxveWVkQXBwc1NESURYUmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Ugey8vIFwiRXhpc3RpbmcgQXBwXCIgRGVwbG95bWVudCAhXG4gICAgICAgICAgc2RDb3VudGVyID0gc2REZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0uc2RDb3VudGVyICsgMTtcbiAgICAgICAgICBzZERlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5zZENvdW50ZXIgPSBzZENvdW50ZXI7XG4gICAgICAgICAgY29uc3QgbGFzdERlcGxveW1lbnREYXRhTGluayA9IHNkRGVwbG95ZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmxhdGVzdERhdGFMaW5rO1xuICAgICAgICAgIGNvbnN0IGhpc3RvcnlQYXRoOiBzdHJpbmcgPSBTRF9ERVBMT1lFRF9BUFBfUEFUSF9VUERBVEVELnJlcGxhY2UoXCIkTEFURVNUXCIsIHNkQ291bnRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAvLyBzZXQgRW50cnkgd2l0aCAobGFzdERlcGxveW1lbnREYXRhTGluaylcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldERhdGFMaW5rKGhpc3RvcnlQYXRoLCBsYXN0RGVwbG95bWVudERhdGFMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAjIyMjIyMjIFN0ZXAgMjogQWN0dWFsIERhdGEgV3JpdGVcblxuICAgICAgLy8gdXBkYXRlIERlcGxveW1lbnRSZWNvcmQgYW5kIHVwZGF0ZSBGaWxlXG4gICAgICBkYXRhLmRkQ291bnRlciA9IGRkQ291bnRlcjtcbiAgICAgIGRhdGEudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgY29uc3Qgc2RVcGRhdGVGaWxlUmVzdWx0ID0gYXdhaXQgdGhpcy51cGRhdGVGaWxlKFNEX0RFUExPWUVEX0FQUF9QQVRIX1VQREFURUQsIGRhdGEpO1xuICAgICAgZGVwbG95ZWRBcHBSZWNvcmREYXRhTGluayA9IHNkVXBkYXRlRmlsZVJlc3VsdC5kYXRhTGluayA/PyBcIlwiO1xuICAgICAgLy8gdXBkYXRlIEREICRMYXRlc3QgcG9pbnRlciB0byBuZXcgZGF0YUxpbmtcbiAgICAgIGlmIChkZXBsb3llZEFwcFJlY29yZERhdGFMaW5rICE9IFwiXCIpIC8vIHRoaXMgaXMgdG8gYXZvaWQgcG9pbnRpbmcgdG8gaW5jb3JyZWN0IGRlcGxveW1lbnRcbiAgICAgIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXREYXRhTGluayhERF9ERVBMT1lFRF9BUFBfUEFUSF9VUERBVEVELCBkZXBsb3llZEFwcFJlY29yZERhdGFMaW5rKSAvLyB0aGlzIFJFRy1Xcml0ZSBjYW4gYmUgZWxpbWluYXRlZCBpbiBzcGVjaWZpYyBzZW5hcmlvcyBpZiB3ZSBnZXQgU2t5bGlua1YyIHRvIFNreUxpbmtWMiByZXNvbHV0aW9uIGluIHNkay4gXG4gICAgICB9XG5cbiAgICAgIC8vICMjIyMjIyMgU3RlcCAzOiB1cGRhdGUgSW5kZXhSZWNvcmQgb2JqZWN0cyBhbmQgdXBkYXRlIEREICYgU0QgaW5kZXggZmlsZXNcblxuICAgICAgZGREZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ubGF0ZXN0RGF0YUxpbmsgPSBkZXBsb3llZEFwcFJlY29yZERhdGFMaW5rO1xuICAgICAgc2REZXBsb3llZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ubGF0ZXN0RGF0YUxpbmsgPSBkZXBsb3llZEFwcFJlY29yZERhdGFMaW5rO1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVGaWxlKEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCwgZGREZXBsb3llZEFwcHNJbmRleCk7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUZpbGUoU0RfREVQTE9ZRURfQVBQU19JTkRFWF9QQVRILCBzZERlcGxveWVkQXBwc0luZGV4KTtcbiAgICAgIHJlc3VsdC5zdWJtaXR0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXN1bHQuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIElmIG51bGwgd2lsbCByZXR1cm4gYWxsIGRlcGxveW1lbnRzXG4gIHB1YmxpYyBhc3luYyBnZXREZXBsb3ltZW50cyhhcHBJZHM/OiBzdHJpbmdbXSk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IHJlc3BvbnNlOiBhbnkgPSB7IHN0YXR1czogXCJmYWlsdXJlXCIsIHJlc3VsdDogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICBsZXQgZGVwbG95ZWRBcHBzOiBhbnkgPSBudWxsO1xuICAgIGNvbnN0IHsgRERfREVQTE9ZRURfQVBQX1BBVEgsIEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCB9ID0gdGhpcy5wYXRocztcbiAgICB0cnkge1xuICAgICAgaWYgKGFwcElkcykvLyBJZiBhcHBJZHMgYXJlIHByb3ZpZGVkXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPElEZXBsb3ltZW50UmVjb3JkIHwgbnVsbD5bXSA9IGFwcElkcy5tYXAoKGFwcElkKSA9PiB7XG4gICAgICAgICAgY29uc3QgRERfREVQTE9ZRURfQVBQX1BBVEhfVVBEQVRFRCA9IEREX0RFUExPWUVEX0FQUF9QQVRILnJlcGxhY2UoXCIkQVBQX0lEXCIsIGFwcElkKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZEZpbGUoRERfREVQTE9ZRURfQVBQX1BBVEhfVVBEQVRFRCk7XG4gICAgICAgIH0pXG4gICAgICAgIGRlcGxveWVkQXBwcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgfVxuICAgICAgZWxzZS8vIElmIE5vIEFwcElkcyBhcmUgcHJvdmlkZWQsIHRoZW4gZmV0Y2ggYWxsIGFwcHMgZGVwbG95bWVudCByZWNvcmRcbiAgICAgIHtcbiAgICAgICAgLy8gc3RlcDE6IHJlYWQgREQgSW5kZXggRmlsZVxuICAgICAgICBjb25zdCBkZXBsb3llZEFwcHNJbmRleDogSURlcGxveWVkQXBwc0RESURYIHwgbnVsbCA9IGF3YWl0IHRoaXMuZG93bmxvYWRGaWxlKEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSCk7XG4gICAgICAgIGlmIChkZXBsb3llZEFwcHNJbmRleCAhPSBudWxsICYmIGRlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgYXBwSWRzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKGRlcGxveWVkQXBwc0luZGV4LmFwcHNJbmRleCk7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8SURlcGxveW1lbnRSZWNvcmQgfCBudWxsPltdID0gYXBwSWRzLm1hcCgoYXBwSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IEREX0RFUExPWUVEX0FQUF9QQVRIX1VQREFURUQgPSBERF9ERVBMT1lFRF9BUFBfUEFUSC5yZXBsYWNlKFwiJEFQUF9JRFwiLCBhcHBJZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZEZpbGUoRERfREVQTE9ZRURfQVBQX1BBVEhfVVBEQVRFRCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICBkZXBsb3llZEFwcHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXBsb3llZEFwcHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nKCdFcnJvciBpbiBnZXREZXBsb3ltZW50cyA6JywgZXJyb3IpO1xuICAgICAgcmVzcG9uc2UuZXJyb3IgPSBgRXJyb3IgZmV0Y2hpbmcgZGVwbG95bWVudCBkYXRhLCBlcnJvciA6ICR7ZXJyb3J9YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFB1Ymxpc2hBcHAgTWV0aG9kcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICBwdWJsaWMgYXN5bmMgc2V0UHVibGlzaGVkQXBwKGRhdGE6IElQdWJsaXNoZWRBcHBSZWNvcmQpOiBQcm9taXNlPElEQUNSZXNwb25zZT4ge1xuICAgIGlmICghYXdhaXQgdGhpcy53YWl0VW50aWxGaWxlc0FyZVByZXNlbnQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbCgnQ291bGQgbm90IGluaXRpYWxpemUgUHVibGlzaGVkQXBwIEZpbGVzLCBpbml0aWFsaXphdGlvbiB0aW1lb3V0Jyk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ6IElEQUNSZXNwb25zZSA9IHsgc3VibWl0dGVkOiBmYWxzZSwgfTtcbiAgICAvLyBUT0RPOiBBZGQgXCJWYWxpZGF0aW9uXCIgY2FsbCBoZXJlXG4gICAgbGV0IHByb21pc2VzOiBhbnkgPSBbXVxuICAgIGNvbnN0IHRpbWVzdGFtcDogbnVtYmVyID0gKG5ldyBEYXRlKCkpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB7IEREX1BVQkxJU0hFRF9BUFBTX0lOREVYX1BBVEgsIEREX1BVQkxJU0hFRF9BUFBfUEFUSCwgU0RfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSCwgU0RfUFVCTElTSEVEX0FQUF9QQVRIIH0gPSB0aGlzLnBhdGhzO1xuICAgIGNvbnN0IEREX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVEID0gRERfUFVCTElTSEVEX0FQUF9QQVRILnJlcGxhY2UoXCIkQVBQX0lEXCIsIGRhdGEuYXBwSWQpO1xuICAgIGNvbnN0IFNEX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVEID0gU0RfUFVCTElTSEVEX0FQUF9QQVRILnJlcGxhY2UoXCIkQVBQX0lEXCIsIGRhdGEuYXBwSWQpO1xuICAgIHRoaXMubG9nKCcgRERfUFVCTElTSEVEX0FQUF9QQVRIX1VQREFURUQgOiAnLCBERF9QVUJMSVNIRURfQVBQX1BBVEhfVVBEQVRFRCk7XG4gICAgdGhpcy5sb2coJyBTRF9QVUJMSVNIRURfQVBQX1BBVEhfVVBEQVRFRCA6ICcsIFNEX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVEKTtcblxuICAgIHRyeSB7XG5cbiAgICAgIC8vICMjIyMjIyMgU3RlcCAxOiBSZWFkIERhdGFEb21haW4gYW5kIFNrYXBwRG9tYWluIEluZGV4ZXMgYW5kIHVwZGF0ZSBJbmRleCB2YXJpYWJsZSwgZG9udCB3cml0ZSB5ZXQuIEluZGV4IEZpbGUgd3JpdGUgd2lsbCBiZSBpbiBsYXN0IHN0ZXBcblxuICAgICAgbGV0IGRkUHVibGlzaGVkQXBwc0luZGV4OiBJUHVibGlzaGVkQXBwc0RESURYIHwgbnVsbCA9IG51bGw7Ly8gYXQgRGF0YSBEb21haW4gTGV2ZWxcbiAgICAgIGxldCBzZFB1Ymxpc2hlZEFwcHNJbmRleDogSVB1Ymxpc2hlZEFwcHNTRElEWCB8IG51bGwgPSBudWxsOy8vIGF0IFNrYXBwIERvbWFpbiBMZXZlbFxuICAgICAgbGV0IGRkQ291bnRlcjogbnVtYmVyID0gMDtcbiAgICAgIGxldCBzZENvdW50ZXI6IG51bWJlciA9IDA7XG4gICAgICBsZXQgcHVibGlzaGVkQXBwUmVjb3JkRGF0YUxpbms6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb21pc2VzOiBhbnkgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvd25sb2FkRmlsZTxJUHVibGlzaGVkQXBwc0RESURYPihERF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb3dubG9hZEZpbGU8SVB1Ymxpc2hlZEFwcHNTRElEWD4oU0RfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSCkpXG4gICAgICAgIGNvbnN0IHByb21pc2VSZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbDxJUHVibGlzaGVkQXBwc0RESURYLCBJUHVibGlzaGVkQXBwc1NESURYPihwcm9taXNlcyk7XG4gICAgICAgIGRkUHVibGlzaGVkQXBwc0luZGV4ID0gcHJvbWlzZVJlc3VsdFswXTtcbiAgICAgICAgc2RQdWJsaXNoZWRBcHBzSW5kZXggPSBwcm9taXNlUmVzdWx0WzFdO1xuICAgICAgICBpZiAoZGRQdWJsaXNoZWRBcHBzSW5kZXggPT0gdW5kZWZpbmVkIHx8IGRkUHVibGlzaGVkQXBwc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgRXJyb3IgRG93bmxvYWRpbmcgRGF0YURvbWFpbiBJbmRleCBGaWxlYDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZFB1Ymxpc2hlZEFwcHNJbmRleCA9PSB1bmRlZmluZWQgfHwgc2RQdWJsaXNoZWRBcHBzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBFcnJvciBEb3dubG9hZGluZyBTa2FwcERvbWFpbiBJbmRleCBGaWxlYDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHQuZXJyb3IgPSBgRXJyb3IgRG93bmxvYWRpbmcgRGF0YURvbWFpbiBhbmQvb3IgU2thcHBEb21haW4gSW5kZXggRmlsZWA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tPiBEYXRhRG9tYWluIEluZGV4IEZpbGVcbiAgICAgIGlmIChkZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXggPT0gbnVsbCkgey8vIGZpcnN0IHRpbWUgZGVwbG95aW5nXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlZEFwcHNERElEWFJlY29yZDogSVB1Ymxpc2hlZEFwcHNERElEWFJlY29yZCA9IHtcbiAgICAgICAgICBhcHBJZDogZGF0YS5hcHBJZCxcbiAgICAgICAgICBkZENvdW50ZXI6IDAsXG4gICAgICAgICAgbGF0ZXN0RGF0YUxpbms6IFwiXCIsLy8gdmFsdWUgd2lsbCBiZSBzZXQgaGVyZSBsYXRlciBvbi5cbiAgICAgICAgICBsYXN0VXBkYXRlZEJ5OiB0aGlzLnNrYXBwLFxuICAgICAgICAgIHNrYXBwczogW3RoaXMuc2thcHBdXG4gICAgICAgIH1cbiAgICAgICAgZGRQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4ID0ge1xuICAgICAgICAgIFtkYXRhLmFwcElkXTogcHVibGlzaGVkQXBwc0RESURYUmVjb3JkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Ugey8vTm90IEZpcnN0VGltZSBcbiAgICAgICAgY29uc3QgZGRBcHBJZHMgPSBPYmplY3Qua2V5cyhkZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXgpO1xuICAgICAgICBpZiAoIWRkQXBwSWRzLmluY2x1ZGVzKGRhdGEuYXBwSWQpKSB7Ly8gXCJOZXcgQXBwXCIgUHVibGlzaGVkIEFwcCAhXG4gICAgICAgICAgY29uc3QgcHVibGlzaGVkQXBwc0RESURYUmVjb3JkOiBJUHVibGlzaGVkQXBwc0RESURYUmVjb3JkID0ge1xuICAgICAgICAgICAgYXBwSWQ6IGRhdGEuYXBwSWQsXG4gICAgICAgICAgICBkZENvdW50ZXI6IDAsXG4gICAgICAgICAgICBsYXRlc3REYXRhTGluazogXCJcIiwvLyB2YWx1ZSB3aWxsIGJlIHNldCBoZXJlIGxhdGVyIG9uLlxuICAgICAgICAgICAgbGFzdFVwZGF0ZWRCeTogdGhpcy5za2FwcCxcbiAgICAgICAgICAgIHNrYXBwczogW3RoaXMuc2thcHBdXG4gICAgICAgICAgfVxuICAgICAgICAgIGRkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXSA9IHB1Ymxpc2hlZEFwcHNERElEWFJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsvLyBcIkV4aXN0aW5nIEFwcFwiIFB1Ymxpc2hlZCBBcHAgIVxuICAgICAgICAgIGRkQ291bnRlciA9IGRkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5kZENvdW50ZXIgKyAxO1xuICAgICAgICAgIGRkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5kZENvdW50ZXIgPSBkZENvdW50ZXI7XG4gICAgICAgICAgZGRQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmxhc3RVcGRhdGVkQnkgPSB0aGlzLnNrYXBwO1xuICAgICAgICAgIGlmICghZGRQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnNrYXBwcy5pbmNsdWRlcyh0aGlzLnNrYXBwKSlcbiAgICAgICAgICAgIGRkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5za2FwcHMucHVzaCh0aGlzLnNrYXBwKTtcbiAgICAgICAgICBjb25zdCBsYXN0UHVibGlzaGVkQXBwRGF0YUxpbmsgPSBkZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ubGF0ZXN0RGF0YUxpbms7XG4gICAgICAgICAgY29uc3QgaGlzdG9yeVBhdGg6IHN0cmluZyA9IEREX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVELnJlcGxhY2UoXCIkTEFURVNUXCIsIGRkQ291bnRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAvLyBzZXQgRW50cnkgd2l0aCAobGFzdFB1Ymxpc2hlZEFwcERhdGFMaW5rKVxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0RGF0YUxpbmsoaGlzdG9yeVBhdGgsIGxhc3RQdWJsaXNoZWRBcHBEYXRhTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0+IFNrYXBwRG9tYWluIEluZGV4IEZpbGVcbiAgICAgIGlmIChzZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXggPT0gbnVsbCkgey8vZmlyc3QgdGltZVxuICAgICAgICAvLyBmaXJzdCB0aW1lIGRlcGxveWluZ1xuICAgICAgICBjb25zdCBwdWJsaXNoZWRBcHBzU0RJRFhSZWNvcmQ6IElQdWJsaXNoZWRBcHBzU0RJRFhSZWNvcmQgPSB7XG4gICAgICAgICAgYXBwSWQ6IGRhdGEuYXBwSWQsXG4gICAgICAgICAgc2RDb3VudGVyOiAwLFxuICAgICAgICAgIGxhdGVzdERhdGFMaW5rOiBcIlwiLC8vIHZhbHVlIHdpbGwgYmUgc2V0IGhlcmUgbGF0ZXIgb24uXG4gICAgICAgIH1cbiAgICAgICAgc2RQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4ID0ge1xuICAgICAgICAgIFtkYXRhLmFwcElkXTogcHVibGlzaGVkQXBwc1NESURYUmVjb3JkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Ugey8vTm90IEZpcnN0VGltZSBcbiAgICAgICAgY29uc3Qgc2RBcHBJZHMgPSBPYmplY3Qua2V5cyhzZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXgpO1xuICAgICAgICBpZiAoIXNkQXBwSWRzLmluY2x1ZGVzKGRhdGEuYXBwSWQpKSB7Ly8gXCJOZXcgQXBwXCIgUHVibGlzaGVkQXBwICFcbiAgICAgICAgICBjb25zdCBwdWJsaXNoZWRBcHBzU0RJRFhSZWNvcmQ6IElQdWJsaXNoZWRBcHBzU0RJRFhSZWNvcmQgPSB7XG4gICAgICAgICAgICBhcHBJZDogZGF0YS5hcHBJZCxcbiAgICAgICAgICAgIHNkQ291bnRlcjogMCxcbiAgICAgICAgICAgIGxhdGVzdERhdGFMaW5rOiBcIlwiLC8vIHZhbHVlIHdpbGwgYmUgc2V0IGhlcmUgbGF0ZXIgb24uXG4gICAgICAgICAgfVxuICAgICAgICAgIHNkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXSA9IHB1Ymxpc2hlZEFwcHNTRElEWFJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsvLyBcIkV4aXN0aW5nIEFwcFwiIFB1Ymxpc2hlZEFwcCAhXG4gICAgICAgICAgc2RDb3VudGVyID0gc2RQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnNkQ291bnRlciArIDE7XG4gICAgICAgICAgc2RQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnNkQ291bnRlciA9IHNkQ291bnRlcjtcbiAgICAgICAgICBjb25zdCBsYXN0UHVibGlzaGVkQXBwRGF0YUxpbmsgPSBzZFB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ubGF0ZXN0RGF0YUxpbms7XG4gICAgICAgICAgY29uc3QgaGlzdG9yeVBhdGg6IHN0cmluZyA9IFNEX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVELnJlcGxhY2UoXCIkTEFURVNUXCIsIHNkQ291bnRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAvLyBzZXQgRW50cnkgd2l0aCAobGFzdFB1Ymxpc2hlZEFwcERhdGFMaW5rKVxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0RGF0YUxpbmsoaGlzdG9yeVBhdGgsIGxhc3RQdWJsaXNoZWRBcHBEYXRhTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gIyMjIyMjIyBTdGVwIDI6IEFjdHVhbCBEYXRhIFdyaXRlXG5cbiAgICAgIC8vIHVwZGF0ZSBQdWJsaXNoZWRBcHBSZWNvcmQgYW5kIHVwZGF0ZSBGaWxlXG4gICAgICBkYXRhLmRkQ291bnRlciA9IGRkQ291bnRlcjtcbiAgICAgIGRhdGEudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgY29uc3Qgc2RVcGRhdGVGaWxlUmVzdWx0ID0gYXdhaXQgdGhpcy51cGRhdGVGaWxlKFNEX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVELCBkYXRhKTtcbiAgICAgIHB1Ymxpc2hlZEFwcFJlY29yZERhdGFMaW5rID0gc2RVcGRhdGVGaWxlUmVzdWx0LmRhdGFMaW5rID8/IFwiXCI7XG4gICAgICAvLyB1cGRhdGUgREQgJExhdGVzdCBwb2ludGVyIHRvIG5ldyBkYXRhTGlua1xuICAgICAgaWYgKHB1Ymxpc2hlZEFwcFJlY29yZERhdGFMaW5rICE9IFwiXCIpIC8vIHRoaXMgaXMgdG8gYXZvaWQgcG9pbnRpbmcgdG8gaW5jb3JyZWN0IHB1Ymxpc2hlZEFwcFxuICAgICAge1xuICAgICAgICBhd2FpdCB0aGlzLnNldERhdGFMaW5rKEREX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVELCBwdWJsaXNoZWRBcHBSZWNvcmREYXRhTGluaykgLy8gdGhpcyBSRUctV3JpdGUgY2FuIGJlIGVsaW1pbmF0ZWQgaW4gc3BlY2lmaWMgc2VuYXJpb3MgaWYgd2UgZ2V0IFNreWxpbmtWMiB0byBTa3lMaW5rVjIgcmVzb2x1dGlvbiBpbiBzZGsuIFxuICAgICAgfVxuXG4gICAgICAvLyAjIyMjIyMjIFN0ZXAgMzogdXBkYXRlIEluZGV4UmVjb3JkIG9iamVjdHMgYW5kIHVwZGF0ZSBERCAmIFNEIGluZGV4IGZpbGVzXG5cbiAgICAgIGRkUHVibGlzaGVkQXBwc0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5sYXRlc3REYXRhTGluayA9IHB1Ymxpc2hlZEFwcFJlY29yZERhdGFMaW5rO1xuICAgICAgc2RQdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmxhdGVzdERhdGFMaW5rID0gcHVibGlzaGVkQXBwUmVjb3JkRGF0YUxpbms7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUZpbGUoRERfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSCwgZGRQdWJsaXNoZWRBcHBzSW5kZXgpO1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVGaWxlKFNEX1BVQkxJU0hFRF9BUFBTX0lOREVYX1BBVEgsIHNkUHVibGlzaGVkQXBwc0luZGV4KTtcbiAgICAgIHJlc3VsdC5zdWJtaXR0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXN1bHQuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRQdWJsaXNoZWRBcHBzKGFwcElkcz86IHN0cmluZ1tdLCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCByZXNwb25zZTogYW55ID0geyBzdGF0dXM6IFwiZmFpbHVyZVwiLCByZXN1bHQ6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgbGV0IHB1Ymxpc2hlZEFwcHM6IGFueSA9IG51bGw7XG4gICAgY29uc3QgeyBERF9QVUJMSVNIRURfQVBQX1BBVEgsIEREX1BVQkxJU0hFRF9BUFBTX0lOREVYX1BBVEggfSA9IHRoaXMucGF0aHM7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhcHBJZHMpLy8gSWYgYXBwSWRzIGFyZSBwcm92aWRlZFxuICAgICAge1xuICAgICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxJRGVwbG95bWVudFJlY29yZCB8IG51bGw+W10gPSBhcHBJZHMubWFwKChhcHBJZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IEREX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVEID0gRERfUFVCTElTSEVEX0FQUF9QQVRILnJlcGxhY2UoXCIkQVBQX0lEXCIsIGFwcElkKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZEZpbGUoRERfUFVCTElTSEVEX0FQUF9QQVRIX1VQREFURUQpO1xuICAgICAgICB9KVxuICAgICAgICBwdWJsaXNoZWRBcHBzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICB9XG4gICAgICBlbHNlLy8gSWYgTm8gQXBwSWRzIGFyZSBwcm92aWRlZCwgdGhlbiBmZXRjaCBhbGwgYXBwcyBkZXBsb3ltZW50IHJlY29yZFxuICAgICAge1xuICAgICAgICAvLyBzdGVwMTogcmVhZCBERCBJbmRleCBGaWxlXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlZEFwcHNJbmRleDogSVB1Ymxpc2hlZEFwcHNERElEWCB8IG51bGwgPSBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZShERF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIKTtcbiAgICAgICAgaWYgKHB1Ymxpc2hlZEFwcHNJbmRleCAhPSBudWxsICYmIHB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGFwcElkczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhwdWJsaXNoZWRBcHBzSW5kZXguYXBwc0luZGV4KTtcbiAgICAgICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxJRGVwbG95bWVudFJlY29yZCB8IG51bGw+W10gPSBhcHBJZHMubWFwKChhcHBJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgRERfUFVCTElTSEVEX0FQUF9QQVRIX1VQREFURUQgPSBERF9QVUJMSVNIRURfQVBQX1BBVEgucmVwbGFjZShcIiRBUFBfSURcIiwgYXBwSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRGaWxlKEREX1BVQkxJU0hFRF9BUFBfUEFUSF9VUERBVEVEKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIHB1Ymxpc2hlZEFwcHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaXNoZWRBcHBzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZygnRXJyb3IgaW4gZ2V0UHVibGlzaGVkQXBwcyA6JywgZXJyb3IpO1xuICAgICAgcmVzcG9uc2UuZXJyb3IgPSBgRXJyb3IgZmV0Y2hpbmcgUHVibGlzaGVkIEFwcHMgZGF0YSwgZXJyb3IgOiAke2Vycm9yfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBwdWJsaWMgYXN5bmMgZ2V0UHVibGlzaGVkQXBwSWRzKHVzZXJJZD86IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgLy8gVE9ETzogUGVuZGluZyBJbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHsgRERfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSCB9ID0gdGhpcy5wYXRocztcbiAgICBjb25zdCBwdWJsaXNoZWRBcHBzSW5kZXg6IElQdWJsaXNoZWRBcHBzRERJRFggfCBudWxsID0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUoRERfUFVCTElTSEVEX0FQUFNfSU5ERVhfUEFUSCk7XG4gICAgaWYgKHB1Ymxpc2hlZEFwcHNJbmRleCAhPSBudWxsICYmIHB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXggIT0gbnVsbCkge1xuICAgICAgY29uc3QgYXBwSWRzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKHB1Ymxpc2hlZEFwcHNJbmRleC5hcHBzSW5kZXgpO1xuICAgICAgcmV0dXJuIGFwcElkcztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFB1Ymxpc2hBcHAgU3RhdHMgLyBJbnRlcmFjdGlvbnMgTWV0aG9kcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICBwdWJsaWMgYXN5bmMgc2thcHBBY3Rpb24oYWN0aW9uOiBza2FwcEFjdGlvblR5cGUsIGFwcElkOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPiB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLndhaXRVbnRpbEZpbGVzQXJlUHJlc2VudCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBQdWJsaXNoZWRBcHAgU3RhdHMgRmlsZXMsIGluaXRpYWxpemF0aW9uIHRpbWVvdXQnKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDogSURBQ1Jlc3BvbnNlID0geyBzdWJtaXR0ZWQ6IGZhbHNlLCB9O1xuICAgIC8vIFRPRE86IEFkZCBcIlZhbGlkYXRpb25cIiBjYWxsIGhlcmVcbiAgICBsZXQgcHJvbWlzZXM6IGFueSA9IFtdXG4gICAgY29uc3QgdGltZXN0YW1wOiBudW1iZXIgPSAobmV3IERhdGUoKSkudmFsdWVPZigpO1xuICAgIGNvbnN0IHsgRERfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSCwgU0RfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSCB9ID0gdGhpcy5wYXRocztcbiAgICB0cnkge1xuICAgICAgLy8gIyMjIyMjIyBTdGVwIDE6IFJlYWQgRGF0YURvbWFpbiBhbmQgU2thcHBEb21haW4gSW5kZXhlcyBhbmQgdXBkYXRlIEluZGV4IHZhcmlhYmxlLCBkb250IHdyaXRlIHlldC4gSW5kZXggRmlsZSB3cml0ZSB3aWxsIGJlIGluIGxhc3Qgc3RlcFxuICAgICAgbGV0IGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXg6IElQdWJsaXNoZWRBcHBzU3RhdHNERElEWCB8IG51bGwgPSBudWxsOy8vIGF0IERhdGEgRG9tYWluIExldmVsXG4gICAgICBsZXQgc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleDogSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYIHwgbnVsbCA9IG51bGw7Ly8gYXQgU2thcHAgRG9tYWluIExldmVsXG4gICAgICBsZXQgZGRDb3VudGVyOiBudW1iZXIgPSAwO1xuICAgICAgbGV0IHNkQ291bnRlcjogbnVtYmVyID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm9taXNlczogYW55ID0gW107XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb3dubG9hZEZpbGU8SVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYPihERF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWF9QQVRIKSk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb3dubG9hZEZpbGU8SVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYPihTRF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWF9QQVRIKSlcbiAgICAgICAgY29uc3QgcHJvbWlzZVJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsPElQdWJsaXNoZWRBcHBzU3RhdHNERElEWCwgSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYPihwcm9taXNlcyk7XG4gICAgICAgIGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXggPSBwcm9taXNlUmVzdWx0WzBdO1xuICAgICAgICBzZFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4ID0gcHJvbWlzZVJlc3VsdFsxXTtcbiAgICAgICAgaWYgKGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXggPT0gdW5kZWZpbmVkIHx8IGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBFcnJvciBEb3dubG9hZGluZyBEYXRhRG9tYWluIEluZGV4IEZpbGVgO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXggPT0gdW5kZWZpbmVkIHx8IHNkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBFcnJvciBEb3dubG9hZGluZyBTa2FwcERvbWFpbiBJbmRleCBGaWxlYDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHQuZXJyb3IgPSBgRXJyb3IgRG93bmxvYWRpbmcgRGF0YURvbWFpbiBhbmQvb3IgU2thcHBEb21haW4gSW5kZXggRmlsZWA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyAtLT4gRGF0YURvbWFpbiBJbmRleCBGaWxlXG4gICAgICBpZiAoZGRQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXggPT0gbnVsbCkgey8vIGZpcnN0IHRpbWUgXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlZEFwcHNTdGF0c0RESURYUmVjb3JkOiBJUHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQgPSB7XG4gICAgICAgICAgYXBwSWQ6IGRhdGEuYXBwSWQsXG4gICAgICAgICAgZGRDb3VudGVyOiAwLFxuICAgICAgICAgIC8vbGF0ZXN0RGF0YUxpbms6IFwiXCIsLy8gdmFsdWUgd2lsbCBiZSBzZXQgaGVyZSBsYXRlciBvbi5cbiAgICAgICAgICBwdWJsaXNoZWRBcHBTdGF0c1JlY29yZDogbnVsbCxcbiAgICAgICAgICBsYXN0VXBkYXRlZEJ5OiB0aGlzLnNrYXBwLFxuICAgICAgICAgIHNrYXBwczogW3RoaXMuc2thcHBdXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gdGhpcy5nZXRVcGRhdGVzUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQoYWN0aW9uLCBERUZBVUxUX1BVQkxJU0hFRF9BUFBTX1NUQVRTX1JFQ09SRClcbiAgICAgICAgcHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQucHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgPSBwdWJsaXNoZWRBcHBTdGF0c1JlY29yZDtcbiAgICAgICAgZGRQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXggPSB7XG4gICAgICAgICAgW2RhdGEuYXBwSWRdOiBwdWJsaXNoZWRBcHBzU3RhdHNERElEWFJlY29yZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHsvL05vdCBGaXJzdFRpbWUgXG4gICAgICAgIGNvbnN0IGRkQXBwSWRzID0gT2JqZWN0LmtleXMoZGRQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXgpO1xuICAgICAgICBpZiAoIWRkQXBwSWRzLmluY2x1ZGVzKGRhdGEuYXBwSWQpKSB7Ly8gXCJOZXcgQXBwXCIgUHVibGlzaGVkIEFwcCAhXG4gICAgICAgICAgY29uc3QgcHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQ6IElQdWJsaXNoZWRBcHBzU3RhdHNERElEWFJlY29yZCA9IHtcbiAgICAgICAgICAgIGFwcElkOiBkYXRhLmFwcElkLFxuICAgICAgICAgICAgZGRDb3VudGVyOiAwLFxuICAgICAgICAgICAgLy9sYXRlc3REYXRhTGluazogXCJcIiwvLyB2YWx1ZSB3aWxsIGJlIHNldCBoZXJlIGxhdGVyIG9uLlxuICAgICAgICAgICAgcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ6IG51bGwsXG4gICAgICAgICAgICBsYXN0VXBkYXRlZEJ5OiB0aGlzLnNrYXBwLFxuICAgICAgICAgICAgc2thcHBzOiBbdGhpcy5za2FwcF1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gdGhpcy5nZXRVcGRhdGVzUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQoYWN0aW9uLCBERUZBVUxUX1BVQkxJU0hFRF9BUFBTX1NUQVRTX1JFQ09SRClcbiAgICAgICAgICBwdWJsaXNoZWRBcHBzU3RhdHNERElEWFJlY29yZC5wdWJsaXNoZWRBcHBTdGF0c1JlY29yZCA9IHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkO1xuICAgICAgICAgIGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdID0gcHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7Ly8gXCJFeGlzdGluZyBBcHBcIiBQdWJsaXNoZWQgQXBwICFcbiAgICAgICAgICBkZENvdW50ZXIgPSBkZFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5kZENvdW50ZXIgKyAxO1xuICAgICAgICAgIGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLmRkQ291bnRlciA9IGRkQ291bnRlcjtcbiAgICAgICAgICBkZFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5sYXN0VXBkYXRlZEJ5ID0gdGhpcy5za2FwcDtcbiAgICAgICAgICBpZiAoIWRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnNrYXBwcy5pbmNsdWRlcyh0aGlzLnNrYXBwKSlcbiAgICAgICAgICAgIGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnNrYXBwcy5wdXNoKHRoaXMuc2thcHApO1xuICAgICAgICAgIGxldCBwdWJsaXNoZWRBcHBTdGF0c1JlY29yZCA9IHRoaXMuZ2V0VXBkYXRlc1B1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkKGFjdGlvbiwgZGRQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ucHVibGlzaGVkQXBwU3RhdHNSZWNvcmQhKVxuICAgICAgICAgIGRkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4W2RhdGEuYXBwSWRdLnB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIC0tPiBTa2FwcERvbWFpbiBJbmRleCBGaWxlXG4gICAgICBpZiAoc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXggPT0gbnVsbCkgey8vZmlyc3QgdGltZVxuICAgICAgICAvLyBmaXJzdCB0aW1lIGRlcGxveWluZ1xuICAgICAgICBjb25zdCBwdWJsaXNoZWRBcHBzU3RhdHNTRElEWFJlY29yZDogSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYUmVjb3JkID0ge1xuICAgICAgICAgIGFwcElkOiBkYXRhLmFwcElkLFxuICAgICAgICAgIHNkQ291bnRlcjogMCxcbiAgICAgICAgICAvL2xhdGVzdERhdGFMaW5rOiBcIlwiLC8vIHZhbHVlIHdpbGwgYmUgc2V0IGhlcmUgbGF0ZXIgb24uXG4gICAgICAgICAgcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ6IERFRkFVTFRfUFVCTElTSEVEX0FQUFNfU1RBVFNfUkVDT1JELFxuICAgICAgICB9XG4gICAgICAgIGxldCBwdWJsaXNoZWRBcHBTdGF0c1JlY29yZCA9IHRoaXMuZ2V0VXBkYXRlc1B1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkKGFjdGlvbiwgREVGQVVMVF9QVUJMSVNIRURfQVBQU19TVEFUU19SRUNPUkQpXG4gICAgICAgIHB1Ymxpc2hlZEFwcHNTdGF0c1NESURYUmVjb3JkLnB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ7XG4gICAgICAgIHNkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4ID0ge1xuICAgICAgICAgIFtkYXRhLmFwcElkXTogcHVibGlzaGVkQXBwc1N0YXRzU0RJRFhSZWNvcmRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7Ly9Ob3QgRmlyc3RUaW1lIFxuICAgICAgICBjb25zdCBzZEFwcElkcyA9IE9iamVjdC5rZXlzKHNkUHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4KTtcbiAgICAgICAgaWYgKCFzZEFwcElkcy5pbmNsdWRlcyhkYXRhLmFwcElkKSkgey8vIFwiTmV3IEFwcFwiIFB1Ymxpc2hlZEFwcCAhXG4gICAgICAgICAgY29uc3QgcHVibGlzaGVkQXBwc1N0YXRzU0RJRFhSZWNvcmQ6IElQdWJsaXNoZWRBcHBzU3RhdHNTRElEWFJlY29yZCA9IHtcbiAgICAgICAgICAgIGFwcElkOiBkYXRhLmFwcElkLFxuICAgICAgICAgICAgc2RDb3VudGVyOiAwLFxuICAgICAgICAgICAgLy9sYXRlc3REYXRhTGluazogXCJcIiwvLyB2YWx1ZSB3aWxsIGJlIHNldCBoZXJlIGxhdGVyIG9uLlxuICAgICAgICAgICAgcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ6IERFRkFVTFRfUFVCTElTSEVEX0FQUFNfU1RBVFNfUkVDT1JELFxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgPSB0aGlzLmdldFVwZGF0ZXNQdWJsaXNoZWRBcHBTdGF0c1JlY29yZChhY3Rpb24sIERFRkFVTFRfUFVCTElTSEVEX0FQUFNfU1RBVFNfUkVDT1JEKVxuICAgICAgICAgIHB1Ymxpc2hlZEFwcHNTdGF0c1NESURYUmVjb3JkLnB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gcHVibGlzaGVkQXBwU3RhdHNSZWNvcmQ7XG4gICAgICAgICAgc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0gPSBwdWJsaXNoZWRBcHBzU3RhdHNTRElEWFJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsvLyBcIkV4aXN0aW5nIEFwcFwiIFB1Ymxpc2hlZEFwcCAhXG4gICAgICAgICAgc2RDb3VudGVyID0gc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0uc2RDb3VudGVyICsgMTtcbiAgICAgICAgICBzZFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5zZENvdW50ZXIgPSBzZENvdW50ZXI7XG4gICAgICAgICAgbGV0IHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkID0gdGhpcy5nZXRVcGRhdGVzUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQoYWN0aW9uLCBzZFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4LmFwcHNJbmRleFtkYXRhLmFwcElkXS5wdWJsaXNoZWRBcHBTdGF0c1JlY29yZCEpXG4gICAgICAgICAgc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleC5hcHBzSW5kZXhbZGF0YS5hcHBJZF0ucHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgPSBwdWJsaXNoZWRBcHBTdGF0c1JlY29yZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gIyMjIyMjIyBTdGVwIDI6IEFjdHVhbCBEYXRhIFdyaXRlXG4gICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnVwZGF0ZUZpbGUoRERfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSCwgZGRQdWJsaXNoZWRBcHBzU3RhdHNJbmRleCkpO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnVwZGF0ZUZpbGUoU0RfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSCwgc2RQdWJsaXNoZWRBcHBzU3RhdHNJbmRleCkpO1xuICAgICAgY29uc3QgcHJvbWlzZVJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsPEpTT05SZXNwb25zZSwgSlNPTlJlc3BvbnNlPihwcm9taXNlcyk7XG4gICAgICByZXN1bHQuc3VibWl0dGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzdWx0LmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJpdmF0ZSBnZXRVcGRhdGVzUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQoYWN0aW9uOiBza2FwcEFjdGlvblR5cGUsIGRhdGE6IElQdWJsaXNoZWRBcHBTdGF0c1JlY29yZCk6IElQdWJsaXNoZWRBcHBTdGF0c1JlY29yZCB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2Ugc2thcHBBY3Rpb25UeXBlLkxJS0VEOlxuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5VTkxJS0VEOlxuICAgICAgICAgIGRhdGEuY29udGVudC5saWtlZCA9IGFjdGlvbiA9PSBza2FwcEFjdGlvblR5cGUuTElLRUQgPyAxIDogMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBza2FwcEFjdGlvblR5cGUuRkFWT1JJVEU6XG4gICAgICAgIGNhc2Ugc2thcHBBY3Rpb25UeXBlLlVORkFWT1JJVEU6XG4gICAgICAgICAgZGF0YS5jb250ZW50LmZhdm9yaXRlID0gYWN0aW9uID09IHNrYXBwQWN0aW9uVHlwZS5GQVZPUklURSA/IDEgOiAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5WSUVXRUQ6XG4gICAgICAgICAgZGF0YS5jb250ZW50LnZpZXdlZCArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNrYXBwQWN0aW9uVHlwZS5BQ0NFU1NFRDpcbiAgICAgICAgICBkYXRhLmNvbnRlbnQuYWNjZXNzZWQgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmxvZygnTm8gc3VjaCBJbXBsZW1lbnRhdGlvbicpO1xuICAgICAgfVxuICAgICAgZGF0YS50aW1lc3RhbXAgPSAobmV3IERhdGUoKSkudmFsdWVPZigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZygnICMjIyBFcnJvciB1cGRhdGluZyBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcHVibGljIGFzeW5jIGdldFN0YXRzKGFwcElkcz86IHN0cmluZ1tdLCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCBwdWJsaXNoZWRBcHBzOiBhbnkgPSBudWxsO1xuICAgIGNvbnN0IHsgRERfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSCB9ID0gdGhpcy5wYXRocztcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHVibGlzaGVkQXBwc1N0YXRzSW5kZXg6IElQdWJsaXNoZWRBcHBzU3RhdHNERElEWCB8IG51bGwgPSBhd2FpdCB0aGlzLmRvd25sb2FkRmlsZShERF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWF9QQVRIKTtcblxuICAgICAgaWYgKHB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4ICE9IG51bGwgJiYgcHVibGlzaGVkQXBwc1N0YXRzSW5kZXguYXBwc0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHN0YXRzUmVjb3JkQXJyYXkgPSBPYmplY3QudmFsdWVzKHB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4LmFwcHNJbmRleCk7XG4gICAgICAgIGlmIChhcHBJZHMpLy8gSWYgYXBwSWRzIGFyZSBwcm92aWRlZFxuICAgICAgICB7XG4gICAgICAgICAgcHVibGlzaGVkQXBwcyA9IHN0YXRzUmVjb3JkQXJyYXkuZmlsdGVyKChpdGVtOiBJUHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQpID0+IHsgaWYgKGFwcElkcy5pbmNsdWRlcyhpdGVtLmFwcElkKSkgeyByZXR1cm4gaXRlbS5wdWJsaXNoZWRBcHBTdGF0c1JlY29yZDsgfSB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UvLyBJZiBObyBBcHBJZHMgYXJlIHByb3ZpZGVkLCB0aGVuIGZldGNoIGFsbCBhcHBzIGRlcGxveW1lbnQgcmVjb3JkXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJsaXNoZWRBcHBzID0gc3RhdHNSZWNvcmRBcnJheS5tYXAoKGl0ZW06IElQdWJsaXNoZWRBcHBzU3RhdHNERElEWFJlY29yZCkgPT4gIGl0ZW0ucHVibGlzaGVkQXBwU3RhdHNSZWNvcmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaXNoZWRBcHBzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZygnRXJyb3IgaW4gZ2V0UHVibGlzaGVkQXBwcyA6JywgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGlzaGVkQXBwcztcbiAgfVxuICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUmV2aWV3IEJlbG93IE1ldGhvZHMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4gIC8vIHB1YmxpYyBhc3luYyBnZXRQdWJsaXNoZWRBcHBzQnlVc2VySWRzKHVzZXJJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT4ge1xuICAvLyAgIGxldCByZXN1bHRzOiBhbnkgPSBbXTtcbiAgLy8gICBmb3IgKGxldCB1c2VySWQgb2YgdXNlcklkcykge1xuICAvLyAgICAgdGhpcy5sb2coJ2dldFB1Ymxpc2hlZEFwcHNCeVVzZXJJZHMgOiAnLCB1c2VySWQpO1xuICAvLyAgICAgdHJ5IHtcbiAgLy8gICAgICAgbGV0IHsgZGF0YTogcHVibGlzaGVkTGlzdCB9ID0gYXdhaXQgdGhpcy5jbGllbnQuZmlsZS5nZXRKU09OKHVzZXJJZCwgdGhpcy5wYXRocy5QVUJMSVNIRURfSU5ERVhfUEFUSCk7XG4gIC8vICAgICAgIHRoaXMubG9nKFwiZ2V0UHVibGlzaGVkQXBwc0J5VXNlcklkcyA6IFwiICsgdXNlcklkICsgXCIgLHB1Ymxpc2hlZExpc3QgXCIgKyBKU09OLnN0cmluZ2lmeShwdWJsaXNoZWRMaXN0KSk7XG4gIC8vICAgICAgIGlmIChwdWJsaXNoZWRMaXN0ICE9IG51bGwgJiYgcHVibGlzaGVkTGlzdC5wdWJsaXNoZWQgIT09IG51bGwpIHtcbiAgLy8gICAgICAgICBsZXQgYXBwSWRzTGlzdDogYW55ID0gcHVibGlzaGVkTGlzdC5wdWJsaXNoZWQ7XG4gIC8vICAgICAgICAgcmVzdWx0c1t1c2VySWRdID0gYXBwSWRzTGlzdDtcbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBlbHNlIHtcbiAgLy8gICAgICAgICByZXN1bHRzW3VzZXJJZF0gPSBbXTtcbiAgLy8gICAgICAgfVxuICAvLyAgICAgICAvL3Jlc3VsdHMucHVzaChwdWJsaXNoZWRMaXN0KTtcbiAgLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gIC8vICAgICAgIHRoaXMubG9nKCdtaXNzaW5nIGpzb24gZm9yIGFwcGlkIDonLCB1c2VySWQpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICB0aGlzLmxvZyhcImdldFB1Ymxpc2hlZEFwcHNCeVVzZXJJZHMgOiBjb25zb2xpZGF0ZWQgOiBcIiArIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAgLy8gICByZXR1cm4gcmVzdWx0cztcbiAgLy8gfVxuICAvLyBwdWJsaWMgYXN5bmMgZ2V0UHVibGlzaGVkQXBwc0NvdW50QnlVc2VySWRzKHVzZXJJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnlbXT4ge1xuICAvLyAgIGxldCByZXN1bHRzOiBhbnkgPSB7fTtcbiAgLy8gICBmb3IgKGxldCB1c2VySWQgb2YgdXNlcklkcykge1xuICAvLyAgICAgdGhpcy5sb2coJ2dldFB1Ymxpc2hlZEFwcHNDb3VudEJ5VXNlcklkcyA6ICcsIHVzZXJJZCk7XG4gIC8vICAgICB0cnkge1xuICAvLyAgICAgICBsZXQgeyBkYXRhOiBwdWJsaXNoZWRMaXN0IH0gPSBhd2FpdCB0aGlzLmNsaWVudC5maWxlLmdldEpTT04odXNlcklkLCB0aGlzLnBhdGhzLlBVQkxJU0hFRF9JTkRFWF9QQVRIKTtcbiAgLy8gICAgICAgdGhpcy5sb2coXCJnZXRQdWJsaXNoZWRBcHBzQ291bnRCeVVzZXJJZHMgOiBcIiArIHVzZXJJZCArIFwiICxwdWJsaXNoZWRMaXN0IFwiICsgSlNPTi5zdHJpbmdpZnkocHVibGlzaGVkTGlzdCkpO1xuICAvLyAgICAgICBpZiAocHVibGlzaGVkTGlzdCAhPSBudWxsICYmIHB1Ymxpc2hlZExpc3QucHVibGlzaGVkICE9PSBudWxsKSB7XG4gIC8vICAgICAgICAgbGV0IGFwcElkc0xpc3Q6IGFueSA9IHB1Ymxpc2hlZExpc3QucHVibGlzaGVkO1xuICAvLyAgICAgICAgIHJlc3VsdHNbdXNlcklkXSA9IGFwcElkc0xpc3QubGVuZ3RoO1xuICAvLyAgICAgICB9XG4gIC8vICAgICAgIGVsc2Uge1xuICAvLyAgICAgICAgIHJlc3VsdHNbdXNlcklkXSA9IDA7XG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgLy9yZXN1bHRzLnB1c2gocHVibGlzaGVkTGlzdCk7XG4gIC8vICAgICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgICB0aGlzLmxvZygnbWlzc2luZyBqc29uIGZvciBhcHBpZCA6JywgdXNlcklkKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgdGhpcy5sb2coXCJnZXRQdWJsaXNoZWRBcHBzQ291bnRCeVVzZXJJZHMgOiBjb25zb2xpZGF0ZWQgOiBcIiArIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAgLy8gICByZXR1cm4gcmVzdWx0cztcbiAgLy8gfVxuICAvLyBwdWJsaWMgYXN5bmMgZ2V0U2thcHBDb21tZW50cyhhcHBJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gICBsZXQgYXBwRGF0YTogYW55O1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBhcHBEYXRhID0gYXdhaXQgdGhpcy5kb3dubG9hZEZpbGUodGhpcy5wYXRocy5QVUJMSVNIRURfQVBQX0lORk9fUEFUSCArIGFwcElkICsgJy8nICsgJ2FwcENvbW1lbnRzLmpzb24nKTtcbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgdGhpcy5sb2coJ21pc3NpbmcganNvbiBmb3IgYXBwaWQgOicsIGFwcElkKTtcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcganNvbiBmb3IgYXBwaWQgOlwiICsgYXBwSWQpO1xuICAvLyAgIH1cbiAgLy8gICByZXR1cm4gYXBwRGF0YTtcbiAgLy8gfVxuICAvLyBkb3dubG9hZEZpbGUgbWVyZWx5IHdyYXBzIGdldEpTT04gYnV0IGlzIHR5cGVkIGluIGEgd2F5IHRoYXQgYXZvaWRzXG4gIC8vIHJlcGVhdGluZyB0aGUgYXdrd2FyZCBcImFzIHVua25vd24gYXMgVFwiIGV2ZXJ5d2hlcmVcbiAgcHJpdmF0ZSBhc3luYyBkb3dubG9hZEZpbGU8VD4ocGF0aDogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIHRoaXMubG9nKCcjIyMgU2thcHAtUmVjb3JkICMjIyA6OiBkb3dubG9hZGluZyBmaWxlIGF0IHBhdGgnLCBwYXRoKVxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5teVNreS5nZXRKU09OKHBhdGgpXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLmxvZygnbm8gZGF0YSBmb3VuZCBhdCBwYXRoJywgcGF0aClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLmxvZygnZGF0YSBmb3VuZCBhdCBwYXRoJywgcGF0aCwgZGF0YSlcbiAgICByZXR1cm4gZGF0YSBhcyB1bmtub3duIGFzIFRcbiAgfVxuICAvLyB1cGRhdGVGaWxlIG1lcmVseSB3cmFwcyBzZXRKU09OIGJ1dCBpcyB0eXBlZCBpbiBhIHdheSB0aGF0IGF2b2lkcyByZXBlYXRpbmdcbiAgLy8gdGhlIGF3a3dhcnMgXCJhcyB1bmtub3duIGFzIEpzb25EYXRhXCIgZXZlcnl3aGVyZVxuICBwcml2YXRlIGFzeW5jIHNldERhdGFMaW5rKHBhdGg6IHN0cmluZywgZGF0YUxpbms6IHN0cmluZykge1xuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGZvciBkYXRhTGlua1xuICAgIHRoaXMubG9nKCd1cGRhdGluZyBFbnRyeURhdGEgYXQgcGF0aCcsIHBhdGgsIGRhdGFMaW5rKVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLm15U2t5LnNldERhdGFMaW5rKHBhdGgsIGRhdGFMaW5rKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nKCcgRXJyb3IgaW4gc2V0RGF0YUxpbmsgJywgZSlcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZUZpbGUgbWVyZWx5IHdyYXBzIHNldEpTT04gYnV0IGlzIHR5cGVkIGluIGEgd2F5IHRoYXQgYXZvaWRzIHJlcGVhdGluZ1xuICAvLyB0aGUgYXdrd2FycyBcImFzIHVua25vd24gYXMgSnNvbkRhdGFcIiBldmVyeXdoZXJlXG4gIHByaXZhdGUgYXN5bmMgc2V0RW50cnlEYXRhKHBhdGg6IHN0cmluZywgZGF0YUxpbms6IHN0cmluZykge1xuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGZvciBkYXRhTGlua1xuICAgIHRoaXMubG9nKCd1cGRhdGluZyBFbnRyeURhdGEgYXQgcGF0aCcsIHBhdGgsIGRhdGFMaW5rKVxuICAgIGNvbnN0IHBhZGRlZERhdGFMaW5rID0gYCR7dHJpbVVyaVByZWZpeChkYXRhTGluaywgdXJpU2t5bmV0UHJlZml4KX09PWA7XG4gICAgdGhpcy5sb2coJyBwYWRkZWREYXRhTGluayAnLCBwYWRkZWREYXRhTGluaylcbiAgICBjb25zdCBlbnRyeWRhdGE6IFVpbnQ4QXJyYXkgPSBiYXNlNjRSYXdVcmxUb1VpbnQ4QXJyYXkocGFkZGVkRGF0YUxpbmspO1xuICAgIHRoaXMubG9nKCcgZW50cnlkYXRhICcsIEpTT04uc3RyaW5naWZ5KGVudHJ5ZGF0YSkpXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMubXlTa3kuc2V0RW50cnlEYXRhKHBhdGgsIGVudHJ5ZGF0YSwge30pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2coJyBFcnJvciBTZXR0aW5nIEVudHJ5IERhdGEgJywgZSlcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZUZpbGUgbWVyZWx5IHdyYXBzIHNldEpTT04gYnV0IGlzIHR5cGVkIGluIGEgd2F5IHRoYXQgYXZvaWRzIHJlcGVhdGluZ1xuICAvLyB0aGUgYXdrd2FycyBcImFzIHVua25vd24gYXMgSnNvbkRhdGFcIiBldmVyeXdoZXJlXG4gIHByaXZhdGUgYXN5bmMgZ2V0RW50cnlEYXRhKHBhdGg6IHN0cmluZywgZGF0YTogc3RyaW5nKSB7XG4gICAgdGhpcy5sb2coJ3JlYWRpbmcgRW50cnlEYXRhIGF0IHBhdGgnLCBwYXRoLCBkYXRhKVxuICAgIC8vbGV0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAvL2xldCBkYXRhSlNPTiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgLy90aGlzLmxvZygndXBkYXRpbmcgZmlsZSBhdCBwYXRoKGpzb25TdHJpbmcpJywgcGF0aCwganNvblN0cmluZylcbiAgICBhd2FpdCB0aGlzLm15U2t5LnNldEpTT04ocGF0aCwgZGF0YSBhcyB1bmtub3duIGFzIEpzb25EYXRhKVxuICB9XG4gIC8vIHVwZGF0ZUZpbGUgbWVyZWx5IHdyYXBzIHNldEpTT04gYnV0IGlzIHR5cGVkIGluIGEgd2F5IHRoYXQgYXZvaWRzIHJlcGVhdGluZ1xuICAvLyB0aGUgYXdrd2FycyBcImFzIHVua25vd24gYXMgSnNvbkRhdGFcIiBldmVyeXdoZXJlXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlRmlsZTxUPihwYXRoOiBzdHJpbmcsIGRhdGE6IFQpOiBQcm9taXNlPEpTT05SZXNwb25zZT4ge1xuICAgIHRoaXMubG9nKCd1cGRhdGluZyBmaWxlIGF0IHBhdGgnLCBwYXRoLCBkYXRhKVxuICAgIC8vbGV0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAvL2xldCBkYXRhSlNPTiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgLy90aGlzLmxvZygndXBkYXRpbmcgZmlsZSBhdCBwYXRoKGpzb25TdHJpbmcpJywgcGF0aCwganNvblN0cmluZylcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5teVNreS5zZXRKU09OKHBhdGgsIGRhdGEgYXMgdW5rbm93biBhcyBKc29uRGF0YSlcbiAgfVxuICAvLyAvLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgcHJvbWlzZVxuICAvLyBwcml2YXRlIGFzeW5jIHVwZGF0ZUZpbGU8VD4ocGF0aDogc3RyaW5nLCBkYXRhOiBUKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vICAgdGhpcy5sb2coJ3VwZGF0aW5nIGZpbGUgYXQgcGF0aCcsIHBhdGgsIGRhdGEpXG4gIC8vICAgYXdhaXQgdGhpcy5teVNreS5zZXRKU09OKHBhdGgsIGRhdGEgYXMgdW5rbm93biBhcyBKc29uRGF0YSlcbiAgLy8gfVxuICBwcml2YXRlIHdhaXRVbnRpbEZpbGVzQXJlUHJlc2VudCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZmlsZUhpZXJhcmNoeUVuc3VyZWQpIHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZmlsZUhpZXJhcmNoeUVuc3VyZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGlmIChlbGFwc2VkID4gNjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGB3YWl0VW50aWxGaWxlc0FyZVByZXNlbnQgdGltZWQgb3V0IGFmdGVyICR7ZWxhcHNlZH1tc2ApXG4gICAgICAgICAgICByZWplY3QoZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGxvZyBwcmludHMgdG8gc3Rkb3V0IG9ubHkgaWYgREVCVUdfRU5BQkxFRCBmbGFnIGlzIHNldFxuICBwcml2YXRlIGxvZyhtZXNzYWdlOiBzdHJpbmcsIC4uLm9wdGlvbmFsQ29udGV4dDogYW55W10pIHtcbiAgICBpZiAoREVCVUdfRU5BQkxFRCkge1xuICAgICAgY29uc29sZS5sb2coXCIjIyMgU0tBUFAtREFDIChERUJVRykgIyMjIyBcIiArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsQ29udGV4dClcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBmYWlsKGVycm9yOiBzdHJpbmcpOiBJREFDUmVzcG9uc2Uge1xuICAgIHRoaXMubG9nKGVycm9yKVxuICAgIHJldHVybiB7IHN1Ym1pdHRlZDogZmFsc2UsIGVycm9yIH1cbiAgfVxufVxuIiwiaW1wb3J0IFNrYXBwREFDIGZyb20gXCIuL2RhY1wiO1xuXG4oYXN5bmMgKCkgPT4ge1xuICBuZXcgU2thcHBEQUMoKTtcbn0pKCk7XG4iLCJleHBvcnQgY29uc3QgVkVSU0lPTiA9IDE7XG5cbi8vIE5PVEU6IHRoZSB2YWx1ZXMgY29udGFpbmVkIGJ5IHRoaXMgaW50ZXJmYWNlIGFyZSAnc3RhdGljJywgbWVhbmluZyB0aGV5IHdvbid0XG4vLyBjaGFuZ2UgYWZ0ZXIgdGhlIERBQyBoYXMgaW5pdGlhbGl6ZWQuIFRoYXQgaXMgd2h5IHRoZXkgYXJlIHVwcGVyY2FzZWQsXG4vLyBiZWNhdXNlIGRlc2N0cnVjdHVyZWQgdGhleSB3aWxsIGxvb2sgbGlrZSByZWd1bGFyIGNvbnN0YW50cy5cbi8vXG4vLyBlLmcuIGNvbnN0IHsgTkNfSU5ERVhfUEFUSCB9ID0gdGhpcy5wYXRocztcbmV4cG9ydCBpbnRlcmZhY2UgSUZpbGVQYXRocyB7XG5cbiAgLy8gRGVwbG95XG4gIEREX0RFUExPWUVEX0FQUFNfSU5ERVhfUEFUSDogc3RyaW5nOyAvLyBJRGVwbG95ZWRBcHBzRERJRFhcbiAgRERfREVQTE9ZRURfQVBQX1BBVEg6IHN0cmluZzsgLy9JRGVwbG95bWVudFJlY29yZFxuICBTRF9ERVBMT1lFRF9BUFBTX0lOREVYX1BBVEg6IHN0cmluZzsgLy8gSURlcGxveWVkQXBwc1NESURYXG4gIFNEX0RFUExPWUVEX0FQUF9QQVRIOiBzdHJpbmc7IC8vSURlcGxveW1lbnRSZWNvcmRcblxuICAvLyBQdWJsaXNoIEFwcFxuICBERF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIOiBzdHJpbmc7IC8vIElQdWJsaXNoZWRBcHBzRERJRFhcbiAgRERfUFVCTElTSEVEX0FQUF9QQVRIOiBzdHJpbmc7IC8vSVB1Ymxpc2hlZEFwcFJlY29yZFxuICBTRF9QVUJMSVNIRURfQVBQU19JTkRFWF9QQVRIOiBzdHJpbmc7IC8vIElQdWJsaXNoZWRBcHBzU0RJRFhcbiAgU0RfUFVCTElTSEVEX0FQUF9QQVRIOiBzdHJpbmc7IC8vSVB1Ymxpc2hlZEFwcFJlY29yZFxuXG4gIC8vIFB1Ymxpc2ggQXBwIDogVXNlciBBY3Rpb24gLT4gU3RhdHNcbiAgRERfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSDogc3RyaW5nOyAvLyBJUHVibGlzaGVkQXBwc0RESURYXG4gIEREX1BVQkxJU0hFRF9BUFBfU1RBVFNfUEFUSDogc3RyaW5nOyAvL0lQdWJsaXNoZWRBcHBSZWNvcmRcbiAgU0RfUFVCTElTSEVEX0FQUFNfU1RBVFNfSU5ERVhfUEFUSDogc3RyaW5nOyAvLyBJUHVibGlzaGVkQXBwc1NESURYXG4gIFNEX1BVQkxJU0hFRF9BUFBfU1RBVFNfUEFUSDogc3RyaW5nOyAvL0lQdWJsaXNoZWRBcHBSZWNvcmRcblxuICAvLyBQdWJsaXNoIEFwcCA6IFVzZXIgQWN0aW9uIC0+IENvbW1lbnRzXG4gIC8vIEREX1BVQkxJU0hFRF9BUFBTX0NPTU1FTlRTX01BU1RFUl9QQVRIOiBzdHJpbmcsLy8gSVB1Ymxpc2hlZEFwcHNDb21tZW50c1xuICAvLyBTRF9QVUJMSVNIRURfQVBQX0NPTU1FTlRTX0lOREVYX1BBVEg6IHN0cmluZywgLy8gSVNrYXBwUHVibGlzaGVkQXBwc0NvbW1lbnRzSW5kZXhcbiAgLy8gU0RfUFVCTElTSEVEX0FQUF9DT01NRU5UU19QQVRIOiBzdHJpbmcsIC8vSVNrYXBwUHVibGlzaGVkQXBwc0NvbW1lbnRzXG59XG5leHBvcnQgaW50ZXJmYWNlIElTa2FwcERBQyB7XG4gIC8vIERlcGxveSBBcHAgRnVuY3Rpb25hbGl0eVxuICBzZXREZXBsb3ltZW50KGRhdGE6IElEZXBsb3ltZW50UmVjb3JkKTogUHJvbWlzZTxJREFDUmVzcG9uc2U+O1xuICBnZXREZXBsb3ltZW50cyhhcHBJZHM/OiBzdHJpbmdbXSk6IFByb21pc2U8YW55PjsgLy8gSWYgbnVsbC9lbXB0eSB3aWxsIHJldHVybiBhbGwgZGVwbG95bWVudHNcbiAgLy8gTm8gR0VUIGhpc3RvcnkgbWV0aG9kIGZvciBkZXBsb3ltZW50IGFzIEl0IGlzIHN1cHBvc2UgdG8gYmUgcHJpdmF0ZSB0byBhcHAgZGV2ZWxvcGVyLlxuICAvLyBPbmNlIGhpZGRlbiBzdG9yYWdlIGZlYXR1cmUgaXMgcmVsZWFzZWQsIEkgd2lsbCBhZGQgbWV0aG9kIGhlcmUuXG5cbiAgLy8gUHVibGlzaCBBcHAgRnVuY3Rpb25hbGl0eVxuICBzZXRQdWJsaXNoZWRBcHAoZGF0YTogSVB1Ymxpc2hlZEFwcFJlY29yZCk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPjtcbiAgZ2V0UHVibGlzaGVkQXBwcyhhcHBJZHM/OiBzdHJpbmdbXSwgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxhbnk+Oy8vIElmIG51bGwvZW1wdHkgd2lsbCByZXR1cm4gYWxsIGFwcHNcbiAgZ2V0UHVibGlzaGVkQXBwSWRzKHVzZXJJZD86IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgLy9nZXRQdWJsaXNoZWRBcHBIaXN0b3J5KGFwcElkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZyk6IFByb21pc2U8YW55PjtcblxuICAvLyBJbnRlcmFjdGlvbnMgLyBzdGF0c1xuICBza2FwcEFjdGlvbihhY3Rpb246IHNrYXBwQWN0aW9uVHlwZSwgYXBwSWQ6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTxJREFDUmVzcG9uc2U+O1xuICBnZXRTdGF0cyhhcHBJZHM/OiBzdHJpbmdbXSwgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICBcbiAgLy8gc2V0UHVibGlzaGVkQXBwQ29tbWVudChkYXRhOiBJUHVibGlzaGVkQXBwQ29tbWVudFJlY29yZCk6IFByb21pc2U8SURBQ1Jlc3BvbnNlPjtcbiAgLy8gZ2V0UHVibGlzaGVkQXBwQ29tbWVudHMoYXBwSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAvLyBnZXRTa2FwcENvbW1lbnRzKGFwcElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG59XG5cbi8vICMjIERlcGxveW1lbnQgTW9kZWxzIFxuZXhwb3J0IGludGVyZmFjZSBJRGVwbG95ZWRBcHBzRERJRFgge1xuICB2ZXJzaW9uOiBudW1iZXIsXG4gIGFwcHNJbmRleDogSUtleVZhbHVlTWFwPElEZXBsb3llZEFwcHNERElEWFJlY29yZD4gfCBudWxsLFxuICB0aW1lc3RhbXA6IG51bWJlclxufVxuZXhwb3J0IGludGVyZmFjZSBJRGVwbG95ZWRBcHBzRERJRFhSZWNvcmQge1xuICBhcHBJZDogc3RyaW5nLFxuICBkZENvdW50ZXI6IG51bWJlcixcbiAgbGF0ZXN0RGF0YUxpbms6IHN0cmluZyxcbiAgbGFzdFVwZGF0ZWRCeTogc3RyaW5nLFxuICBza2FwcHM6IHN0cmluZ1tdXG59XG5leHBvcnQgaW50ZXJmYWNlIElEZXBsb3llZEFwcHNTRElEWCB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgYXBwc0luZGV4OiBJS2V5VmFsdWVNYXA8SURlcGxveWVkQXBwc1NESURYUmVjb3JkPiB8IG51bGwsXG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5leHBvcnQgaW50ZXJmYWNlIElEZXBsb3llZEFwcHNTRElEWFJlY29yZCB7XG4gIGFwcElkOiBzdHJpbmcsXG4gIHNkQ291bnRlcjogbnVtYmVyLFxuICBsYXRlc3REYXRhTGluazogc3RyaW5nLFxufVxuZXhwb3J0IGludGVyZmFjZSBJRGVwbG95bWVudFJlY29yZCB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgJHR5cGU6IHN0cmluZywvL3NrYXBwXG4gICRzdWJUeXBlOiBzdHJpbmcsLy9kZXBsb3ltZW50XG4gIGFwcElkOiBzdHJpbmcsXG4gIGNvbnRlbnQ6IElEZXBsb3ltZW50Q29udGVudCxcbiAgZGRDb3VudGVyPzogbnVtYmVyLC8vVGhpcyB2YWx1ZSB3aWxsIGJlIHNldCBieSBEQUNcbiAgdGltZXN0YW1wOiBudW1iZXIsIC8vVGhpcyB2YWx1ZSB3aWxsIGJlIHNldCBieSBEQUNcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURlcGxveW1lbnRDb250ZW50IHtcbiAgYXBwTmFtZTogc3RyaW5nLFxuICBhcHBMb2dvOiBJTWVkaWFbXSxcbiAgZG9tYWluTmFtZXM/OiBzdHJpbmdbXSxcbiAgZW50cnlQYXRoOiBzdHJpbmcsXG4gIGVudHJ5TGluazogc3RyaW5nLFxuICBkYXRhTGluazogc3RyaW5nLFxuICBza3luZXRQb3J0YWw6IHN0cmluZyxcbiAgZGVmYXVsdFBhdGg6IHN0cmluZyxcbiAgbm90ZXM/OiBzdHJpbmcsIC8vIHRvIHN0b3JlIGdpdCBjb21taXQgb3Igb3RoZXIgZGVwbG95bWVudCByZWxhdGVkIG5vdGVzLiBcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRERfREVQTE9ZRURfQVBQU19JTkRFWDogSURlcGxveWVkQXBwc0RESURYID0ge1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBhcHBzSW5kZXg6IG51bGwsIC8vIGxpc3Qgb2YgQXBwSWRzXG4gIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnZhbHVlT2YoKVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRF9ERVBMT1lFRF9BUFBTX0lOREVYOiBJRGVwbG95ZWRBcHBzU0RJRFggPSB7XG4gIHZlcnNpb246IFZFUlNJT04sXG4gIGFwcHNJbmRleDogbnVsbCwgLy8gbGlzdCBvZiBBcHBJZHNcbiAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudmFsdWVPZigpXG59XG5cbi8vIFB1Ymxpc2hlZCBBcHAgTW9kZWxcbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNERElEWCB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgYXBwc0luZGV4OiBJS2V5VmFsdWVNYXA8SVB1Ymxpc2hlZEFwcHNERElEWFJlY29yZD4gfCBudWxsLFxuICB0aW1lc3RhbXA6IG51bWJlclxufVxuZXhwb3J0IGludGVyZmFjZSBJUHVibGlzaGVkQXBwc0RESURYUmVjb3JkIHtcbiAgYXBwSWQ6IHN0cmluZyxcbiAgZGRDb3VudGVyOiBudW1iZXIsXG4gIGxhdGVzdERhdGFMaW5rOiBzdHJpbmcsXG4gIGxhc3RVcGRhdGVkQnk6IHN0cmluZyxcbiAgc2thcHBzOiBzdHJpbmdbXVxufVxuZXhwb3J0IGludGVyZmFjZSBJUHVibGlzaGVkQXBwc1NESURYIHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICBhcHBzSW5kZXg6IElLZXlWYWx1ZU1hcDxJUHVibGlzaGVkQXBwc1NESURYUmVjb3JkPiB8IG51bGwsXG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5leHBvcnQgaW50ZXJmYWNlIElQdWJsaXNoZWRBcHBzU0RJRFhSZWNvcmQge1xuICBhcHBJZDogc3RyaW5nLFxuICBzZENvdW50ZXI6IG51bWJlcixcbiAgbGF0ZXN0RGF0YUxpbms6IHN0cmluZyxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcFJlY29yZCB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgJHR5cGU6IHN0cmluZywvL3NrYXBwXG4gICRzdWJUeXBlOiBzdHJpbmcsLy9wdWJsaXNoZWRBcHBcbiAgYXBwSWQ6IHN0cmluZyxcbiAgY29udGVudDogSVB1Ymxpc2hlZEFwcENvbnRlbnQsXG4gIGRkQ291bnRlcj86IG51bWJlciwvL1RoaXMgdmFsdWUgd2lsbCBiZSBzZXQgYnkgREFDXG4gIHRpbWVzdGFtcDogbnVtYmVyLCAvL1RoaXMgdmFsdWUgd2lsbCBiZSBzZXQgYnkgREFDXG59XG5leHBvcnQgaW50ZXJmYWNlIElQdWJsaXNoZWRBcHBDb250ZW50IHtcbiAgYXBwTG9nbzogSU1lZGlhUmVjb3JkW10sXG4gIGFwcE5hbWU6IHN0cmluZyxcbiAgYXBwVXJsOiBzdHJpbmcsLy8gZG9tYWluIHVybCAoaG5lLCBlbnMuLmV0Yykgb3IgZW50cnlMaW5rVXJsIG9yIGRhdGFMaW5rVXJsIFxuICBhcHBWZXJzaW9uOiBzdHJpbmcsIC8vIHgueC54XG4gIGFwcFN0YXR1czogc3RyaW5nLCAvLyBBbHBoYSwgQmV0YSAsIExpdmVcbiAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgdGFncz86IHN0cmluZ1tdLFxuICBnaXRVcmw/OiBzdHJpbmcsXG4gIGRlbW9Vcmw/OiBzdHJpbmcsLy9cImRlbW9VcmxcIjogXCJbNDYgQ2hhcmFjdGVyIFNLWUxJTktdXCIsXG4gIGFnZTogc3RyaW5nOy8vXCJhZ2VcIjogXCJbMTgrfGdlbmVyYWxdXCIsXG4gIHByZXZpZXdNZWRpYT86IElNZWRpYVtdLFxuICBhcHBEZXNjcmlwdGlvbjogc3RyaW5nLFxuICByZWxlYXNlTm90ZXM/OiBzdHJpbmcsXG4gIGNvbm5lY3Rpb25zPzogSUtleVZhbHVlTWFwPHN0cmluZz4sXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0REX1BVQkxJU0hFRF9BUFBTX0lOREVYOiBJUHVibGlzaGVkQXBwc0RESURYID0ge1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBhcHBzSW5kZXg6IG51bGwsIC8vIGxpc3Qgb2YgQXBwSWRzXG4gIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnZhbHVlT2YoKVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRF9QVUJMSVNIRURfQVBQU19JTkRFWDogSVB1Ymxpc2hlZEFwcHNTRElEWCA9IHtcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgYXBwc0luZGV4OiBudWxsLCAvLyBsaXN0IG9mIEFwcElkc1xuICB0aW1lc3RhbXA6IChuZXcgRGF0ZSgpKS52YWx1ZU9mKClcbn1cbi8vIFB1Ymxpc2hlZCBBcHAgU3RhdHMgTW9kZWxcbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYIHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICBhcHBzSW5kZXg6IElLZXlWYWx1ZU1hcDxJUHVibGlzaGVkQXBwc1N0YXRzRERJRFhSZWNvcmQ+IHwgbnVsbCxcbiAgdGltZXN0YW1wOiBudW1iZXJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYUmVjb3JkIHtcbiAgYXBwSWQ6IHN0cmluZyxcbiAgZGRDb3VudGVyOiBudW1iZXIsXG4gIHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkOiBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgfCBudWxsLFxuICAvL2xhdGVzdERhdGFMaW5rIDogc3RyaW5nLFxuICBsYXN0VXBkYXRlZEJ5OiBzdHJpbmcsXG4gIHNrYXBwczogc3RyaW5nW11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYIHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICBhcHBzSW5kZXg6IElLZXlWYWx1ZU1hcDxJUHVibGlzaGVkQXBwc1N0YXRzU0RJRFhSZWNvcmQ+IHwgbnVsbCxcbiAgdGltZXN0YW1wOiBudW1iZXJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYUmVjb3JkIHtcbiAgYXBwSWQ6IHN0cmluZyxcbiAgc2RDb3VudGVyOiBudW1iZXIsXG4gIHB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkOiBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgfG51bGwsXG4gIC8vbGF0ZXN0RGF0YUxpbmsgOiBzdHJpbmcsXG59XG5leHBvcnQgaW50ZXJmYWNlIElQdWJsaXNoZWRBcHBTdGF0c1JlY29yZCB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgJHR5cGU6IHN0cmluZywvL3NrYXBwXG4gICRzdWJUeXBlOiBzdHJpbmcsLy9wdWJsaXNoZWRBcHBcbiAgYXBwSWQ6IHN0cmluZ3xudWxsLFxuICBjb250ZW50OiBJUHVibGlzaGVkQXBwU3RhdHNDb250ZW50LFxuICBkZENvdW50ZXI/OiBudW1iZXIsLy9UaGlzIHZhbHVlIHdpbGwgYmUgc2V0IGJ5IERBQ1xuICB0aW1lc3RhbXA6IG51bWJlciwgLy9UaGlzIHZhbHVlIHdpbGwgYmUgc2V0IGJ5IERBQ1xufVxuZXhwb3J0IGludGVyZmFjZSBJUHVibGlzaGVkQXBwU3RhdHNDb250ZW50IHtcbiAgZmF2b3JpdGU6IG51bWJlcixcbiAgbGlrZWQ6IG51bWJlcixcbiAgdmlld2VkOiBudW1iZXIsIC8vIGNvdW50ZXIgaW5jcmVtZW50cyBldmVyeXRpbWUgY2FyZCBpcyBjbGlja2VkIHRvIHZpZXcgZGV0YWlsc1xuICBhY2Nlc3NlZDogbnVtYmVyLCAvLyBjb3VudGVyIGluY3JlbWVudHMgZXZlcnl0aW1lIGFwcCBVUkwgaXMgY2xpY2tlZFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9ERF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWDogSVB1Ymxpc2hlZEFwcHNTdGF0c0RESURYID0ge1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBhcHBzSW5kZXg6IG51bGwsIC8vIGxpc3Qgb2YgQXBwSWRzXG4gIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnZhbHVlT2YoKVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRF9QVUJMSVNIRURfQVBQU19TVEFUU19JTkRFWDogSVB1Ymxpc2hlZEFwcHNTdGF0c1NESURYID0ge1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBhcHBzSW5kZXg6IG51bGwsIC8vIGxpc3Qgb2YgQXBwSWRzXG4gIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnZhbHVlT2YoKVxufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFVCTElTSEVEX0FQUFNfU1RBVFNfUkVDT1JEOiBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQgPSB7XG4gIHZlcnNpb246IFZFUlNJT04sXG4gICR0eXBlOiBcInNrYXBwXCIsXG4gICRzdWJUeXBlOiBcImludGVyYWN0aW9uc1wiLC8vcHVibGlzaGVkQXBwXG4gIGFwcElkOiBudWxsLFxuICBjb250ZW50OiB7XG4gICAgZmF2b3JpdGU6IDAsXG4gICAgbGlrZWQ6IDAsXG4gICAgdmlld2VkOiAwLFxuICAgIGFjY2Vzc2VkOiAwLFxuICB9LFxuICBkZENvdW50ZXI6IDAsLy9UaGlzIHZhbHVlIHdpbGwgYmUgc2V0IGJ5IERBQ1xuICB0aW1lc3RhbXA6IChuZXcgRGF0ZSgpKS52YWx1ZU9mKClcbn1cbi8vY29tbW9uIE1vZGVsc1xuZXhwb3J0IGludGVyZmFjZSBJS2V5VmFsdWVNYXA8VD4ge1xuICBba2V5OiBzdHJpbmddOiBULFxufVxuZXhwb3J0IGludGVyZmFjZSBJTWVkaWEge1xuICB0aHVtYm5haWw6IElNZWRpYVJlY29yZFtdLFxuICBvcmlnaW5hbENvbnRlbnQ6IElNZWRpYVJlY29yZFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1lZGlhUmVjb3JkIHsgLy8gSW1hZ2Ugb3IgVmlkZW9cbiAgZXh0OiBzdHJpbmcsXG4gIHc6IG51bWJlcixcbiAgaDogbnVtYmVyLFxuICB1cmw6IHN0cmluZywgLy9kYXRhIGxpbmsgc2lhOi8vXG59XG5cbi8vIFB1Ymxpc2hlZCBBcHAgU3RhdHMgTW9kZWxcbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcHNTdGF0cyB7XG4gIHZlcnNpb246IG51bWJlcixcbiAgcHVibGlzaGVkQXBwc1N0YXRzTWFwOiBJS2V5VmFsdWVNYXA8SVB1Ymxpc2hlZEFwcFN0YXRzPiB8IG51bGwsLy8gYXBwSWQgOiBJUHVibGlzaGVkQXBwU3RhdHNcbiAgdGltZXN0YW1wOiBudW1iZXIsXG59XG5leHBvcnQgaW50ZXJmYWNlIElQdWJsaXNoZWRBcHBTdGF0cyB7XG4gIGxhdGVzdFB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkOiBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmQsXG4gIGxhc3RVcGRhdGVkQnk6IHN0cmluZywgLy8gc2thcHAgbmFtZVxuICBza2FwcHM6IHN0cmluZ1tdIHwgbnVsbCxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcFN0YXRzUmVjb3JkIHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICAkdHlwZTogc3RyaW5nLC8vc2thcHBcbiAgJHN1YlR5cGU6IHN0cmluZywvL3N0YXRzXG4gIGFwcElkOiBzdHJpbmd8bnVsbCxcbiAgY29udGVudDogSVB1Ymxpc2hlZEFwcFN0YXRzQ29udGVudCxcbiAgdGltZXN0YW1wOiBudW1iZXJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcFN0YXRzQ29udGVudCB7XG4gIGZhdm9yaXRlOiBudW1iZXIsXG4gIHZpZXdlZDogbnVtYmVyLCAvLyBjb3VudGVyIGluY3JlbWVudHMgZXZlcnl0aW1lIGNhcmQgaXMgY2xpY2tlZCB0byB2aWV3IGRldGFpbHNcbiAgbGlrZWQ6IG51bWJlcixcbiAgYWNjZXNzZWQ6IG51bWJlciwgLy8gY291bnRlciBpbmNyZW1lbnRzIGV2ZXJ5dGltZSBhcHAgVVJMIGlzIGNsaWNrZWRcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVNrYXBwUHVibGlzaGVkQXBwc1N0YXRzIHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICBwdWJsaXNoZWRBcHBSZWNvcmRzOiBJUHVibGlzaGVkQXBwU3RhdHNSZWNvcmRbXSB8IG51bGwsIC8vIGxpc3Qgb2YgZGVwbG95bWVudFJlY29yZHNcbiAgdGltZXN0YW1wOiBudW1iZXIsXG59XG5leHBvcnQgaW50ZXJmYWNlIElTa2FwcFB1Ymxpc2hlZEFwcHNTdGF0c0luZGV4IHtcbiAgdmVyc2lvbjogbnVtYmVyLFxuICBwdWJsaXNoZWRBcHBJZHM6IHN0cmluZ1tdIHwgbnVsbCwvLyBsaXN0IG9mIEFwcElkcyBmb3Igd2hpY2ggc3RhdHMgYXJlIGF2YWlsYWJsZSAoVXNlciBoYXMgcGVyZm9ybWVkIHN0YXRzIGFjdGlvbilcbiAgdGltZXN0YW1wOiBudW1iZXIsXG59XG5cbmV4cG9ydCBlbnVtIHNrYXBwQWN0aW9uVHlwZSB7XG4gICdWSUVXRUQnLFxuICAnQUNDRVNTRUQnLFxuICAnRkFWT1JJVEUnLFxuICAnVU5GQVZPUklURScsXG4gICdMSUtFRCcsXG4gICdVTkxJS0VEJyxcbiAgJ0FERF9DT01NRU5UJyxcbiAgJ0VESVRfQ09NTUVOVCcsXG4gICdSRU1PVkVfQ09NTUVOVCdcbn1cblxuLy8gLy8gUHVibGlzaGVkIEFwcCBDb21tZW50cyBNb2RlbFxuLy8gZXhwb3J0IGludGVyZmFjZSBJUHVibGlzaGVkQXBwQ29tbWVudHMge1xuLy8gICB2ZXJzaW9uOiBudW1iZXIsXG4vLyAgIGNvdW50ZXI6IG51bWJlcixcbi8vICAgcHVibGlzaGVkQXBwQ29tbWVudHNNYXA6IElLZXlWYWx1ZU1hcDxJUHVibGlzaGVkQXBwQ29tbWVudFJlY29yZD4gfCBudWxsLCAvL2NvbW1lbnRJZCA6IElQdWJsaXNoZWRBcHBDb21tZW50XG4vLyAgIHNrYXBwczogc3RyaW5nW10gfCBudWxsLFxuLy8gICB0aW1lc3RhbXA6IG51bWJlcixcbi8vIH1cbi8vIGV4cG9ydCBpbnRlcmZhY2UgSVB1Ymxpc2hlZEFwcENvbW1lbnRSZWNvcmQge1xuLy8gICB2ZXJzaW9uOiBudW1iZXIsXG4vLyAgICR0eXBlOiBzdHJpbmcsLy9za2FwcFxuLy8gICAkc3ViVHlwZTogc3RyaW5nLC8vY29tbWVudHNcbi8vICAgYXBwSWQ6IHN0cmluZyxcbi8vICAgY29udGVudDogSVB1Ymxpc2hlZEFwcENvbW1lbnRDb250ZW50LFxuLy8gICB0aW1lc3RhbXA6IG51bWJlclxuLy8gfVxuLy8gZXhwb3J0IGludGVyZmFjZSBJUHVibGlzaGVkQXBwQ29tbWVudENvbnRlbnQge1xuLy8gICBjb21tZW50SWQ6IHN0cmluZyxcbi8vICAgY29tbWVudDogc3RyaW5nLFxuLy8gICBhdHRhY2htZW50cz86IElNZWRpYVtdLFxuLy8gICBjcmVhdGVkQnk6IHN0cmluZywgLy8gc2thcHAgbmFtZVxuLy8gfVxuLy8gZXhwb3J0IGludGVyZmFjZSBJU2thcHBQdWJsaXNoZWRBcHBzQ29tbWVudHNJbmRleCB7XG4vLyAgIHZlcnNpb246IG51bWJlcixcbi8vICAgcHVibGlzaGVkQXBwSWRzOiBzdHJpbmdbXSB8IG51bGwsLy8gbGlzdCBvZiBBcHBJZHMgZm9yIHdoaWNoIGNvbW1lbnRzIGFyZSBhdmFpbGFibGUgKFVzZXIgaGFzIHBlcmZvcm1lZCBwb3N0IGNvbW1lbnRzIGFjdGlvbilcbi8vICAgdGltZXN0YW1wOiBudW1iZXIsXG4vLyB9XG4vLyBleHBvcnQgaW50ZXJmYWNlIElTa2FwcFB1Ymxpc2hlZEFwcENvbW1lbnRzIHtcbi8vICAgdmVyc2lvbjogbnVtYmVyLFxuLy8gICBwdWJsaXNoZWRBcHBDb21tZW50UmVjb3JkczogSVB1Ymxpc2hlZEFwcENvbW1lbnRSZWNvcmRbXSB8IG51bGwsIC8vIGxpc3Qgb2YgZGVwbG95bWVudFJlY29yZHNcbi8vICAgdGltZXN0YW1wOiBudW1iZXIsXG4vLyB9XG5cbi8vICMjIyMjIERvbWFpbiBNb2RlbFxuZXhwb3J0IGludGVyZmFjZSBJRG9tYWluSW5kZXgge1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIGRvbWFpbnM6IE1hcDxzdHJpbmcsIElEb21haW4+IHwgbnVsbDsgLy8geyBza3lzcGFjZS5obnMgOiB7RG9tYWluIEpTT059LCBza3lmZWVkLmhucyA6IHtEb21haW4gSlNPTn0gfVxuICBsYXN0VXBkYXRlZEJ5OiBzdHJpbmc7XG59XG5leHBvcnQgaW50ZXJmYWNlIElEb21haW4ge1xuICB2ZXJzaW9uOiBudW1iZXI7IC8vIDEgZm9yIG5vd1xuICBkb21haW5UeXBlOiBzdHJpbmc7Ly9ITlMsIEVOUy4uZXRjXG4gIGRvbWFpbk5hbWU6IHN0cmluZzsvLyBza3lmZWVkLCBza3lzcGFjZXMuLi5ldGNcbiAgZG9tYWluUmVjb3JkczogSURvbWFpblJlY29yZFtdIHwgbnVsbDsgLy8gVFhUIGZvciBub3dcbiAgc3RhdHVzOiBzdHJpbmc7IC8vYWN0aXZlLCBpbmFjdGl2ZVxuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURvbWFpblJlY29yZCB7XG4gIHJlY29yZFR5cGU6IHN0cmluZzsgLy8gVFhUIGZvciBub3dcbiAgcmVjb3JkVmFsdWU6IHN0cmluZzsgLy8gc2lhOntza3lsaW5rdjJ9XG59XG5leHBvcnQgaW50ZXJmYWNlIElEb21haW5IaXN0b3J5TG9nIHtcbiAgdmVyc2lvbjogbnVtYmVyO1xuICBoaXN0b3J5UmVjb3JkOiBJRG9tYWluSGlzdG9yeVJlY29yZFtdO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRG9tYWluSGlzdG9yeVJlY29yZCB7XG4gIGRvbWFpblR5cGU6IHN0cmluZzsvL0hOUywgRU5TLi5ldGNcbiAgZG9tYWluTmFtZTogc3RyaW5nOy8vIHNreWZlZWQsIHNreXNwYWNlcy4uLmV0Y1xuICB1cGRhdGVkQnk6IHN0cmluZzsgLy9VcGRhdGVkIGJ5IHNrYXBwIG5hbWVcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbi8vIGRvbWFpbi1kYWMve3NrYXBwfS5obnMvZG9tYWluTmFtZS5kb21haW5UeXBlLmpzb25cbmV4cG9ydCBpbnRlcmZhY2UgSVNrYXBwRG9tYWluSW5kZXgge1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIGRvbWFpbnM6IElEb21haW5bXTtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIElPcHRpb25zIHtcbiAgc2thcHA/OiBzdHJpbmdcbn1cbi8vIERFRkFVTFRfVVNFUl9QUk9GSUxFIGRlZmluZXMgYWxsIHByb3BzIGFzIGl0IGlzIHVzZWQgaW4gdmFsaWRhdG9yXG5leHBvcnQgY29uc3QgREVGQVVMVF9ET01BSU5fSU5ERVg6IElEb21haW5JbmRleCA9IHtcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgZG9tYWluczogbnVsbCwgLy8geyBza3lzcGFjZS5obnMgOiB7RG9tYWluIEpTT059LCBza3lmZWVkLmhucyA6IHtEb21haW4gSlNPTn0gfVxuICBsYXN0VXBkYXRlZEJ5OiBcIlwiLFxufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRE9NQUlOOiBJRG9tYWluID0ge1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBkb21haW5UeXBlOiBcIkhOU1wiLC8vSE5TLCBFTlMuLmV0Y1xuICBkb21haW5OYW1lOiBcIlwiLC8vIHNreWZlZWQsIHNreXNwYWNlcy4uLmV0Y1xuICBkb21haW5SZWNvcmRzOiBbXSwgLy8gVFhUIGZvciBub3dcbiAgc3RhdHVzOiBcIkFjdGl2ZVwiLCAvL2FjdGl2ZSwgaW5hY3RpdmVcbiAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudmFsdWVPZigpXG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9ET01BSU5fUkVDT1JEOiBJRG9tYWluUmVjb3JkID0ge1xuICByZWNvcmRUeXBlOiBcIlRYVFwiLCAvLyBUWFQgZm9yIG5vd1xuICByZWNvcmRWYWx1ZTogXCJcIiwgLy8gc2lhOntza3lsaW5rdjJ9XG4gIC8vIGRhdGFMaW5rOiBcIlwiIC8vIFNreWxpbmtWMSBvZiB1cGxvYWRlZCBjb2RlL3NpdGVcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURvbWFpbkhpc3RvcnlMb2cge1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIGhpc3RvcnlSZWNvcmQ6IElEb21haW5IaXN0b3J5UmVjb3JkW107XG59XG5leHBvcnQgaW50ZXJmYWNlIElEb21haW5IaXN0b3J5UmVjb3JkIHtcbiAgZG9tYWluVHlwZTogc3RyaW5nOy8vSE5TLCBFTlMuLmV0Y1xuICBkb21haW5OYW1lOiBzdHJpbmc7Ly8gc2t5ZmVlZCwgc2t5c3BhY2VzLi4uZXRjXG4gIGRhdGFMaW5rOiBzdHJpbmc7IC8vIHNreWxpbmtWMSBvZiB1cGxvYWRlZCBkYXRhIFxuICB1cGRhdGVkQnk6IHN0cmluZzsgLy9VcGRhdGVkIGJ5IHNrYXBwIG5hbWVcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIElEQUNSZXNwb25zZSB7XG4gIHN1Ym1pdHRlZDogYm9vbGVhbjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG4iLCJpbXBvcnQgeyBmcm9tQnl0ZUFycmF5LCB0b0J5dGVBcnJheSB9IGZyb20gXCJiYXNlNjQtanNcIjtcbmV4cG9ydCBjb25zdCB1cmlTa3luZXRQcmVmaXggPSBcInNpYTovL1wiO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBieXRlcyB0byBhIHN0cmluZyBlbmNvZGVkIHVzaW5nIGJhc2U2NCByYXcgVVJMIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyAtIFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0Jhc2U2NFJhd1VybChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgbGV0IGJhc2U2NCA9IGZyb21CeXRlQXJyYXkoYnl0ZXMpO1xuICAgIC8vIENvbnZlcnQgdG8gVVJMIGVuY29kaW5nLlxuICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4gICAgcmV0dXJuIGJhc2U2NDtcbn1cbi8qKlxuICogRGVjb2RlcyB0aGUgc3RyaW5nIGVuY29kZWQgdXNpbmcgYmFzZTY0IHJhdyBVUkwgZW5jb2RpbmcgdG8gYnl0ZXMuXG4gKlxuICogQHBhcmFtIHMgLSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyAtIFRoZSBkZWNvZGVkIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0UmF3VXJsVG9VaW50OEFycmF5KHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIC8vIENvbnZlcnQgZnJvbSBVUkwgZW5jb2RpbmcuXG4gICAgcyA9IHMucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgYnl0ZXMgPSB0b0J5dGVBcnJheShzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyBUT0RPOiBNb3ZlIHRvIG15c2t5LXV0aWxzXG4vKipcbiAqIFJlbW92ZXMgYSBzdWZmaXggZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBzdWZmaXggLSBUaGUgc3VmZml4IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbbGltaXRdIC0gTWF4aW11bSBhbW91bnQgb2YgdGltZXMgdG8gdHJpbS4gTm8gbGltaXQgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIC0gVGhlIHByb2Nlc3NlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3VmZml4KHN0cjogc3RyaW5nLCBzdWZmaXg6IHN0cmluZywgbGltaXQ/OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHdoaWxlIChzdHIuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICBsaW1pdCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIFJlbW92ZXMgYSBVUkkgcHJlZml4IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gcHJlZml4IC0gVGhlIHByZWZpeCB0byByZW1vdmUuXG4gKiBAcmV0dXJucyAtIFRoZSBwcm9jZXNzZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVVyaVByZWZpeChzdHI6IHN0cmluZywgcHJlZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNob3J0UHJlZml4ID0gdHJpbVN1ZmZpeChwcmVmaXgsIFwiL1wiKTtcbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAvLyBsb25nUHJlZml4IGlzIGV4YWN0bHkgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICByZXR1cm4gc3RyLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoc2hvcnRQcmVmaXgpKSB7XG4gICAgICAgIC8vIGVsc2UgcHJlZml4IGlzIGV4YWN0bHkgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICByZXR1cm4gc3RyLnNsaWNlKHNob3J0UHJlZml4Lmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59IiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9